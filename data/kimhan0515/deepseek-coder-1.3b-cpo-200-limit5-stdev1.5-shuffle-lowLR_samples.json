{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # edge case\n        if len(matrix) == 0:\n            return []\n        \n        # initialize variables\n        m = len(matrix)\n        n = len(matrix[0])\n        visited = [[False for i in range(n)] for j in range(m)]\n        res = []\n        row = 0\n        col = 0\n        dir = 0\n        # direction: 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        # 0 -> right, 1 -> down, 2 -> left, 3 -> up\n        #"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] that equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        # dp[i][j] = dp[i-1][j] if s[i] != t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        # dp[i][j] = dp[i][j-1] if s["}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Check if the array contains any negative numbers\n        ## 2. Check if the array contains any zeroes\n        ## 3. Check if the array contains any numbers greater than the length of the array\n        ## 4. Check if the array contains any numbers less than the length of the array\n        ## 5. Check if the array contains any numbers greater than the length of the array\n        ## 6. Check if the array contains any numbers less than the length of the array\n        ## 7. Check if the array contains any numbers greater than the length of the array\n        ## 8. Check if the array contains any numbers less than the length of the array\n        ## 9. Check if the array contains any numbers greater than the length of the array\n        ## 10. Check if the array contains any numbers less than the length of the array\n        ## 11. Check if the array contains any numbers greater than the length of the array\n        ## 12. Check if the array contains any numbers less than the length of the array\n        ## 13. Check if the array contains any numbers greater than the length of the array\n        ## 14. Check if the array contains any numbers less than the length of the array\n        ## 15. Check if the array contains any numbers greater than the length of the array\n        ## 16. Check if the array contains any numbers less than the length of the array\n        ## 17. Check if the array contains any numbers greater than the length of the array\n        ## 18. Check if the array contains any numbers less than the length of the array\n        ## 19. Check if the array contains any numbers greater than the length of the array\n        ## 20. Check if the array contains any numbers less than the length of the array\n        ## 21. Check if the array contains any numbers greater than the length of the array\n        ## 22. Check if the array contains any numbers less than the length of the array\n        ## 23. Check if the array contains any numbers greater than the length of the array\n        ## 24. Check if the array contains any numbers less than the length of the array\n        ## 25. Check if the array contains any numbers greater than the length of the array\n        ## 26. Check if the array contains any numbers less than the length of the array\n        ## 27. Check if the array contains any numbers greater than the length of the array\n        ## 28. Check if the array contains any numbers less than the length of the array\n        ## 29. Check if the array contains any numbers greater than the length of the array\n        ## 30. Check if the array contains any numbers less than the length of the array\n        ## 31. Check if the array contains any numbers greater than the length of the array\n        ## 32. Check if the array contains any numbers less than the length of the array\n        ## 33. Check if the array contains any numbers greater than the length of the array\n        ## 34. Check if the array contains any numbers less than the length of the array\n        ## 35. Check if the array contains any numbers greater than the length of the array\n        ## 36. Check if the array contains any numbers less than the length of the array\n        ## 37. Check if the array contains any numbers greater than the length of the array\n        ## 38. Check if the array contains any numbers less than the length of the array\n        ## 39. Check if the array contains any numbers greater than the length of the array\n        ## 40. Check if the array contains any numbers less than the length of the array\n        ## 41. Check if the array contains any numbers greater than the length of the array\n        ## 42. Check if the array contains any numbers less than the length of the array\n        ## 43. Check if the array contains any numbers greater than the length of the array\n        ## 44. Check if the array contains any numbers less than the length of the array\n        ## 45. Check if the array contains any numbers greater than the length of the array\n        ## 46. Check if the array contains any numbers less than the length of the array\n        ## 47. Check if the array contains any numbers greater than the length of the array\n        ## 48. Check if the array"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # left = 0\n        # right = len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary Search\n        # Time Complexity: O(nlogn)\n        # Space Complexity: O(1)\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     left = i + 1\n        #     right = len(numbers) - 1\n        #     while left <= right:\n        #         mid = left + (right - left) // 2\n        #         if numbers[mid] == complement:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < complement:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Hash Table\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # hashmap = {}\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in hashmap:\n        #         return [hashmap[complement]+1, i+1]\n        #     hashmap[numbers[i]] = i\n        \n        # 5. Hash Table (optimized)\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        hashmap = {}\n        for i in range(len(numbers)):\n            complement = target - numbers[i]\n            if complement in hashmap:\n                return [hashmap[complement]+1, i+1]\n            hashmap[numbers[i]] = i\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, res, curr, prev, pos):\n            if pos == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            \n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the current number is 0, then we can only use the previous number\n            # if the"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## Recursive Solution\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## where n is the number of nodes in the tree\n        \n        ## Approach:\n        ## 1. Traverse the tree in preorder fashion\n        ## 2. For each node, calculate the sum of the path from root to the node\n        ## 3. Add the sum to the total sum\n        \n        ## Base Case:\n        ## If the root is None, return 0\n        ## If the root is a leaf node, return the value of the node\n        \n        ## Recursive Case:\n        ## Calculate the sum of the left subtree\n        ## Calculate the sum of the right subtree\n        ## Add the sum of the left subtree to the sum of the right subtree\n        ## Add the sum of the left subtree and the sum of the right subtree to the total sum\n        \n        ## Base Case:\n        ## If the root is None, return 0\n        ## If the root is a leaf node, return the value of the node\n        \n        ## Recursive Case:\n        ## Calculate the sum of the left subtree\n        ## Calculate the sum of the right subtree\n        ## Add the sum of the left subtree to the sum of the right subtree\n        ## Add the sum of the left subtree and the sum of the right subtree to the total sum\n        \n        ## Base Case:\n        ## If the root is None, return 0\n        ## If the root is a leaf node, return the value of the node\n        \n        ## Recursive Case:\n        ## Calculate the sum of the left subtree\n        ## Calculate the sum of the right subtree\n        ## Add the sum of the left subtree to the sum of the right subtree\n        ## Add the sum of the left subtree and the sum of the right subtree to the total sum\n        \n        ## Base Case:\n        ## If the root is None, return 0\n        ## If the root is a leaf node, return the value of the node\n        \n        ## Recursive Case:\n        ## Calculate the sum of the left subtree\n        ## Calculate the sum of the right subtree\n        ## Add the sum of the left subtree to the sum of the right subtree\n        ## Add the sum of the left subtree and the sum of the right subtree to the total sum\n        \n        ## Base Case:\n        ## If the root is None, return 0\n        ## If the root is a leaf node, return the value of the node\n        \n        ## Recursive Case:\n        ## Calculate the sum of the left subtree\n        ## Calculate the sum of the right subtree\n        ## Add the sum of the left subtree to the sum of the right subtree\n        ## Add the sum of the left subtree and the sum of the right subtree to the total sum\n        \n        ## Base Case:\n        ## If the root is None, return 0\n        ## If the root is a leaf node, return the value of the node\n        \n        ## Recursive Case:\n        ## Calculate the sum of the left subtree\n        ## Calculate the sum of the right subtree\n        ## Add the sum of the left subtree to the sum of the right subtree\n        ## Add the sum of the left subtree and the sum of the right subtree to the total sum\n        \n        ## Base Case:\n        ## If the root is None, return 0\n        ## If the root is a leaf node, return the value of the node\n        \n        ## Recursive Case:\n        ## Calculate the sum of the left subtree\n        ## Calculate the sum of the right subtree\n        ## Add the sum of the left subtree to the sum of the right subtree\n        ## Add the sum of the left subtree and the sum of the right subtree to the total sum\n        \n        ## Base Case:\n        ## If the root is None, return 0\n        ## If the root is a leaf node, return the value of the node\n        \n        ## Recursive Case:\n        ## Calculate the sum of the left subtree\n        ## Calcul"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Convert all uppercase letters to lowercase letters\n        ## 2. Count the number of dashes\n        ## 3. If the number of dashes is greater than or equal to k, then add a dash\n        ## 4. If the number of dashes is less than k, then add a dash\n        ## 5. Reverse the string\n        ## 6. Convert the first k characters to uppercase letters\n        ## 7. Convert the remaining characters to uppercase letters\n        ## 8. Reverse the string\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Base Case:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Base Case:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Base Case:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Base Case:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Base Case:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Base Case:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a dash, return the string\n        ## 3. If the string is only a dash and k is 1, return the string\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, return an empty string\n        ## 2. If the string is only a"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Calculate the total gas and cost\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        ## 2. If total gas is less than total cost, then no solution\n        if total_gas < total_cost:\n            return -1\n        \n        ## 3. Calculate the total gas and cost\n        total_gas = 0\n        total_cost = 0\n        start_index = 0\n        for i in range(len(gas)):\n            total_gas += gas[i]\n            total_cost += cost[i]\n            \n            ## 4. If total gas is less than total cost, then no solution\n            if total_gas < total_cost:\n                start_index = i + 1\n                total_gas = 0\n                total_cost = 0\n                \n        return start_index"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the pattern is empty, then the string must be empty as well\n        if not p:\n            return not s\n        \n        # if the pattern is not empty, then the string must not be empty\n        if not s:\n            return False\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[1] == '*':\n            return self.isMatch(s, p[2:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] == '.' and p[1] == '*':\n            return self.isMatch(s[1:], p[2:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] == '.' and p[1] != '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] != '.' and p[1] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] != '.' and p[1] != '*':\n            return False\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] == '.' and p[1] == '.':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] == '.' and p[1] == '.' and p[2] == '*':\n            return self.isMatch(s[1:], p[2:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] == '.' and p[1] == '.' and p[2] != '*':\n            return self.isMatch(s[1:], p[2:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] != '.' and p[1] == '.' and p[2] == '*':\n            return self.isMatch(s[1:], p[2:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] != '.' and p[1] == '.' and p[2] != '*':\n            return False\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] != '.' and p[1] != '.' and p[2] == '*':\n            return self.isMatch(s[1:], p[2:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] != '.' and p[1] != '.' and p[2] != '*':\n            return False\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] == '.' and p[1] == '.' and p[2] == '*':\n            return self.isMatch(s[1:], p[2:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] == '.' and p[1] == '.' and p[2] != '*':\n            return self.isMatch(s[1:], p[2:])\n        \n        # if the pattern is not empty, then the string must not be empty\n        if p[0] != '.' and p[1] == '.' and p[2] == '*':\n            return self.isMatch(s[1:], p[2:])\n        \n        # if the pattern is not empty,"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if k is larger than the sum of the lengths of nums1 and nums2, return nums2\n        if k > len(nums1) + len(nums2):\n            return nums2\n        \n        # if k is 0, return an empty list\n        if k == 0:\n            return []\n        \n        # if k is larger than the length of nums1, return nums1\n        if k > len(nums1):\n            return nums1\n        \n        # if k is larger than the length of nums2, return nums2\n        if k > len(nums2):\n            return nums2\n        \n        # initialize an empty list to store the maximum number of digits\n        max_num = []\n        \n        # loop through the digits of nums1\n        for i in range(len(nums1)):\n            # initialize a list to store the digits of nums2 that are smaller than the current digit of nums1\n            smaller_nums2 = []\n            \n            # loop through the digits of nums2\n            for j in range(len(nums2)):\n                # if the current digit of nums2 is smaller than the current digit of nums1, add it to the list\n                if nums2[j] < nums1[i]:\n                    smaller_nums2.append(nums2[j])\n                    \n            # if the length of the list smaller_nums2 is larger than k, remove the last digit of the list\n            if len(smaller_nums2) > k:\n                smaller_nums2.pop()\n                \n            # if the length of the list smaller_nums2 is equal to k, return the list\n            if len(smaller_nums2) == k:\n                return smaller_nums2\n            \n            # if the length of the list smaller_nums2 is less than k, add the current digit of nums1 to the list\n            smaller_nums2.append(nums1[i])\n            \n            # if the length of the list smaller_nums2 is larger than k, remove the last digit of the list\n            if len(smaller_nums2) > k:\n                smaller_nums2.pop()\n                \n            # if the length of the list smaller_nums2 is equal to k, return the list\n            if len(smaller_nums2) == k:\n                return smaller_nums2\n            \n            # if the length of the list smaller_nums2 is less than k, add the current digit of nums2 to the list\n            smaller_nums2.append(nums2[i])\n            \n            # if the length of the list smaller_nums2 is larger than k, remove the last digit of the list\n            if len(smaller_nums2) > k:\n                smaller_nums2.pop()\n                \n            # if the length of the list smaller_nums2 is equal to k, return the list\n            if len(smaller_nums2) == k:\n                return smaller_nums2\n            \n            # if the length of the list smaller_nums2 is less than k, add the current digit of nums1 to the list\n            smaller_nums2.append(nums1[i])\n            \n            # if the length of the list smaller_nums2 is larger than k, remove the last digit of the list\n            if len(smaller_nums2) > k:\n                smaller_nums2.pop()\n                \n            # if the length of the list smaller_nums2 is equal to k, return the list\n            if len(smaller_nums2) == k:\n                return smaller_nums2\n            \n            # if the length of the list smaller_nums2 is less than k, add the current digit of nums2 to the list\n            smaller_nums2.append(nums2[i])\n            \n            # if the length of the list smaller_nums2 is larger than k, remove the last digit of the list\n            if len(smaller_nums2) > k:\n                smaller_nums2.pop()\n                \n            # if the length of the list smaller_nums2 is equal to k, return the list\n            if len(smaller_nums2) == k:\n                return smaller_nums2\n            \n            # if the"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                if i**2 == num:\n                    sum += i\n                else:\n                    sum += i + num//i\n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        # 0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9237455,15939352,26171021,42091364,68252985,109334346,177687021,296114368,483900499,780114874,1264914361,2049129136,3314943497,5463071722,8880114219\n        \n        # 0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9237455,15939352,26171021,42091364,68252985,109334346,177687021,296114368,483900499,780114874,1264914361,2049129136,3314943497,5463071722,8880114219\n        \n        # 0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9237455,15939352,26171021,42091364,68252985,109334346,177687021,296114368,483900499,780114874,1264914361,2049129136,3314943497,5463071722,8880114219\n        \n        # 0,1,1,2,3,5,8,13,21,34,55,89,144,23"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the left and right pointers\n        left = 0\n        right = nums[-1] - nums[0]\n        \n        # binary search\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            left_pointer = 0\n            right_pointer = 0\n            \n            # find the number of pairs with distance <= mid\n            while right_pointer < len(nums):\n                while right_pointer < len(nums) and nums[right_pointer] - nums[left_pointer] <= mid:\n                    right_pointer += 1\n                count += right_pointer - left_pointer - 1\n                left_pointer += 1\n            \n            # if the number of pairs with distance <= mid is less than k,\n            # update the left pointer to the right\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \" and s[i-4] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \" and s[i-4] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \" and s[i-4] != \" \" and s[i-5] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] != \" \" and s[i-2] != \" \" and s[i-3] != \" \" and s[i-4] != \" \" and s[i-5] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        #"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list) - 1\n        while left < right:\n            if s_list[left] in vowels and s_list[right] in vowels:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n            elif s_list[left] not in vowels:\n                left += 1\n            elif s_list[right] not in vowels:\n                right -= 1\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Edge Case:\n        if len(nums) == 0:\n            return 0\n        \n        # Create a hashmap to store the number and its index\n        num_map = {}\n        \n        # Iterate through the array\n        for i in range(len(nums)):\n            \n            # If the number is not in the hashmap, add it to the hashmap\n            if nums[i] not in num_map:\n                num_map[nums[i]] = i\n                \n        # Initialize the longest consecutive sequence to 1\n        longest_seq = 1\n        \n        # Iterate through the hashmap\n        for num in num_map:\n            \n            # If the number is not in the hashmap, continue to the next number\n            if num not in num_map:\n                continue\n            \n            # Initialize the current number to the number\n            curr_num = num\n            \n            # Initialize the current sequence to 1\n            curr_seq = 1\n            \n            # Initialize the left neighbor to the number - 1\n            left_neighbor = curr_num - 1\n            \n            # Initialize the right neighbor to the number + 1\n            right_neighbor = curr_num + 1\n            \n            # While the left neighbor is in the hashmap\n            while left_neighbor in num_map:\n                \n                # Increment the current sequence by 1\n                curr_seq += 1\n                \n                # Update the current number to the left neighbor\n                curr_num = left_neighbor\n                \n                # Update the left neighbor to the left neighbor - 1\n                left_neighbor = left_neighbor - 1\n                \n            # While the right neighbor is in the hashmap\n            while right_neighbor in num_map:\n                \n                # Increment the current sequence by 1\n                curr_seq += 1\n                \n                # Update the current number to the right neighbor\n                curr_num = right_neighbor\n                \n                # Update the right neighbor to the right neighbor + 1\n                right_neighbor = right_neighbor + 1\n                \n            # If the current sequence is greater than the longest sequence, update the longest sequence\n            if curr_seq > longest_seq:\n                longest_seq = curr_seq\n                \n        # Return the longest sequence\n        return longest_seq"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. We can use the property of XOR to solve this problem.\n        ## 2. XOR of a number with itself is 0.\n        ## 3. XOR of a number with 0 is the number itself.\n        ## 4. XOR of a number with a number is 0.\n        ## 5. XOR of a number with itself is the number itself.\n        ## 6. XOR of a number with 0 is the number itself.\n        ## 7. XOR of a number with a number is 0.\n        ## 8. XOR of a number with itself is the number itself.\n        ## 9. XOR of a number with 0 is the number itself.\n        ## 10. XOR of a number with a number is 0.\n        ## 11. XOR of a number with itself is the number itself.\n        ## 12. XOR of a number with 0 is the number itself.\n        ## 13. XOR of a number with a number is 0.\n        ## 14. XOR of a number with itself is the number itself.\n        ## 15. XOR of a number with 0 is the number itself.\n        ## 16. XOR of a number with a number is 0.\n        ## 17. XOR of a number with itself is the number itself.\n        ## 18. XOR of a number with 0 is the number itself.\n        ## 19. XOR of a number with a number is 0.\n        ## 20. XOR of a number with itself is the number itself.\n        ## 21. XOR of a number with 0 is the number itself.\n        ## 22. XOR of a number with a number is 0.\n        ## 23. XOR of a number with itself is the number itself.\n        ## 24. XOR of a number with 0 is the number itself.\n        ## 25. XOR of a number with a number is 0.\n        ## 26. XOR of a number with itself is the number itself.\n        ## 27. XOR of a number with 0 is the number itself.\n        ## 28. XOR of a number with a number is 0.\n        ## 29. XOR of a number with itself is the number itself.\n        ## 30. XOR of a number with 0 is the number itself.\n        ## 31. XOR of a number with a number is 0.\n        ## 32. XOR of a number with itself is the number itself.\n        ## 33. XOR of a number with 0 is the number itself.\n        ## 34. XOR of a number with a number is 0.\n        ## 35. XOR of a number with itself is the number itself.\n        ## 36. XOR of a number with 0 is the number itself.\n        ## 37. XOR of a number with a number is 0.\n        ## 38. XOR of a number with itself is the number itself.\n        ## 39. XOR of a number with 0 is the number itself.\n        ## 40. XOR of a number with a number is 0.\n        ## 41. XOR of a number with itself is the number itself.\n        ## 42. XOR of a number with 0 is the number itself.\n        ## 43. XOR of a number with a number is 0.\n        ## 44. XOR of a number with itself is the number itself.\n        ## 45. XOR of a number with 0 is the number itself.\n        ## 46. XOR of a number with a number is 0.\n        ## 47. XOR of a number with itself is the number itself.\n        ## 48. XOR of a number with 0 is the number itself.\n        ## 49. XOR of a number with"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        ## BFS\n        ## Time Complexity: O(N * M)\n        ## Space Complexity: O(N * M)\n        \n        ## Create a graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ## For each word in wordList, add it to the graph\n        ##"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # if len(a) < len(b):\n        #     a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     # a, b = b, a\n        #     #"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        # find the leftmost index of target\n        # find the rightmost index of target\n        # return [leftmost index, rightmost index]\n        \n        # edge case\n        if len(nums) == 0:\n            return [-1, -1]\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        leftmost = -1\n        rightmost = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                leftmost = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                rightmost = mid\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return [leftmost, rightmost]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 0:\n        #     return 0\n        \n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        \n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        \n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        \n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        \n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        \n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        \n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        \n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## TLE\n        ## 2. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 3. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Accepted\n        ## 4. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 5. Two Pointers\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 6. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 7. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 8. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 9. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 10. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 11. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 12. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 13. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 14. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 15. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 16. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 17. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 18. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 19. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 20. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 21. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 22. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted\n        ## 23. Binary Search\n        ## Time Complexity: O(logn)\n        ## Space Complexity: O(1)\n        ## Accepted"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if k > len(prices) / 2:\n        #     return self.maxProfit_k_inf(prices)\n        \n        # if k == 0:\n        #     return 0\n        \n        # if len(prices) == 1:\n        #     return 0\n        \n        # if len(prices) == 2:\n        #     return max(prices[1] - prices[0], 0)\n        \n        # buy_price = [float('inf')] * k\n        # sell_price = [float('inf')] * k\n        \n        # for i in range(len(prices)):\n        #     for j in range(k):\n        #         buy_price[j] = min(buy_price[j], prices[i] - (i - j))\n        #         sell_price[j] = max(sell_price[j], prices[i] - buy_price[j])\n        \n        # return sum(sell_price)\n        \n        # if k > len(prices) / 2:\n        #     return self.maxProfit_k_inf(prices)\n        \n        # if k == 0:\n        #     return 0\n        \n        # if len(prices) == 1:\n        #     return 0\n        \n        # if len(prices) == 2:\n        #     return max(prices[1] - prices[0], 0)\n        \n        # buy_price = [float('inf')] * k\n        # sell_price = [float('inf')] * k\n        \n        # for i in range(len(prices)):\n        #     for j in range(k):\n        #         buy_price[j] = min(buy_price[j], prices[i] - (i - j))\n        #         sell_price[j] = max(sell_price[j], prices[i] - buy_price[j])\n        \n        # return sum(sell_price)\n        \n        # if k > len(prices) / 2:\n        #     return self.maxProfit_k_inf(prices)\n        \n        # if k == 0:\n        #     return 0\n        \n        # if len(prices) == 1:\n        #     return 0\n        \n        # if len(prices) == 2:\n        #     return max(prices[1] - prices[0], 0)\n        \n        # buy_price = [float('inf')] * k\n        # sell_price = [float('inf')] * k\n        \n        # for i in range(len(prices)):\n        #     for j in range(k):\n        #         buy_price[j] = min(buy_price[j], prices[i] - (i - j))\n        #         sell_price[j] = max(sell_price[j], prices[i] - buy_price[j])\n        \n        # return sum(sell_price)\n        \n        # if k > len(prices) / 2:\n        #     return self.maxProfit_k_inf(prices)\n        \n        # if k == 0:\n        #     return 0\n        \n        # if len(prices) == 1:\n        #     return 0\n        \n        # if len(prices) == 2:\n        #     return max(prices[1] - prices[0], 0)\n        \n        # buy_price = [float('inf')] * k\n        # sell_price = [float('inf')] * k\n        \n        # for i in range(len(prices)):\n        #     for j in range(k):\n        #         buy_price[j] = min(buy_price[j], prices[i] - (i - j))\n        #         sell_price[j] = max(sell_price[j], prices[i] - buy_price[j])\n        \n        # return sum(sell_price)\n        \n        # if k > len(prices) / 2:\n        #     return self.maxProfit_k_inf(prices)\n        \n        # if k == 0:\n        #     return 0\n        \n        # if len(prices) == 1:"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {\n            0:\"0\",\n            1:\"1\",\n            2:\"2\",\n            3:\"3\",\n            4:\"4\",\n            5:\"5\",\n            6:\"6\",\n            7:\"7\",\n            8:\"8\",\n            9:\"9\",\n            10:\"a\",\n            11:\"b\",\n            12:\"c\",\n            13:\"d\",\n            14:\"e\",\n            15:\"f\"\n        }\n        \n        hex_str = \"\"\n        \n        while num > 0:\n            remainder = num % 16\n            hex_str = hex_dict[remainder] + hex_str\n            num = num // 16\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap with key as character and value as index\n        ## 2. Iterate over the string and check if the character is already present in the hashmap\n        ## 3. If character is already present, then update the value of the character in the hashmap\n        ## 4. If character is not present, then add the character in the hashmap with value as -1\n        ## 5. Iterate over the string again and check if the value of the character is -1\n        ## 6. If value is -1, then return the index of the character\n        ## 7. If value is not -1, then return -1\n        \n        ## Edge Cases:\n        ## 1. If string is empty, then return -1\n        ## 2. If string has only one character, then return 0\n        \n        ## Initialization\n        hashmap = {}\n        \n        ## Edge Cases\n        if len(s) == 0:\n            return -1\n        if len(s) == 1:\n            return 0\n        \n        ## Iterate over the string and add the character in the hashmap with value as -1\n        for i in range(len(s)):\n            if s[i] not in hashmap:\n                hashmap[s[i]] = -1\n        \n        ## Iterate over the string again and check if the value of the character is -1\n        for i in range(len(s)):\n            if hashmap[s[i]] == -1:\n                return i\n        \n        ## If no character is repeated, then return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # if indexDiff < 0:\n        #     return False\n        \n        # if valueDiff < 0:\n        #     return False\n        \n        # if indexDiff >= len(nums):\n        #     return False\n        \n        # if valueDiff >= len(nums):\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff >"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        \n        left = 0\n        right = len(nums) - 1\n        i = 0\n        \n        while i <= right:\n            if nums[i] == 0:\n                nums[left], nums[i] = nums[i], nums[left]\n                left += 1\n                i += 1\n            elif nums[i] == 2:\n                nums[right], nums[i] = nums[i], nums[right]\n                right -= 1\n            else:\n                i += 1\n        \n        return nums"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Initialize max_count = 0\n        ## 2. Initialize count = 0\n        ## 3. Iterate through the array\n        ## 4. If nums[i] == 1, increment count\n        ## 5. If nums[i] == 0, reset count to 0\n        ## 6. Update max_count with max(max_count, count)\n        ## 7. Return max_count\n        \n        max_count = 0\n        count = 0\n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        \n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        \n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        \n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        \n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        \n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        \n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        \n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        \n        # return 1 + self.countNodes(root.left"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 2. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 3. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 4. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 5. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 6. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 7. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 8. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 9. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 10. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 11. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 12. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 13. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 14. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 15. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 16. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 17. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 18. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 19. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 20. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 21. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 22. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 23. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 24. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 25. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 26. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 27. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 28. \uc5f0\uc0b0\uc790 \uc6b0\uc120\uc21c\uc704 \uc815\uc758\n        # 29. \uc5f0\uc0b0\uc790 \uc6b0\uc120\ufffd"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we can't do this project"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     '(': ')',\n        #     '[': ']',\n        #     '{': '}'\n        # }\n        \n        # for char in s:\n        #     if char in brackets:\n        #         stack.append(char)\n        #     else:\n        #         if stack and brackets[stack[-1]] == char:\n        #             stack.pop()\n        #         else:\n        #             return False\n        \n        # return len(stack) == 0\n        \n        # stack = []\n        # brackets = {\n        #     '(': ')',\n        #     '[': ']',\n        #     '{': '}'\n        # }\n        \n        # for char in s:\n        #     if char in brackets:\n        #         stack.append(char)\n        #     else:\n        #         if stack and brackets[stack[-1]] == char:\n        #             stack.pop()\n        #         else:\n        #             return False\n        \n        # return len(stack) == 0\n        \n        stack = []\n        brackets = {\n            '(': ')',\n            '[': ']',\n            '{': '}'\n        }\n        \n        for char in s:\n            if char in brackets:\n                stack.append(char)\n            else:\n                if stack and brackets[stack[-1]] == char:\n                    stack.pop()\n                else:\n                    return False\n        \n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right\n        # find the number that is larger than the number to its right\n        # swap the two numbers\n        # reverse the numbers to the right of the number that was swapped\n        \n        # find the first number that is smaller than the number to its right"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the array and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is in the dictionary, return True\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the array and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is in the dictionary, return True\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the array and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is in the dictionary, return True\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the array and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is in the dictionary, return True\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the array and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is in the dictionary, return True\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the array and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is in the dictionary, return True\n        # If the number is not in the dictionary, return False\n        \n        # Create a dictionary with key as the number and value as the index\n        # Iterate through the array and check if the number is already in the dictionary\n        # If the number is already in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, check if the difference between the index and the value of the number is less than or equal to k\n        # If the number is in the dictionary, return True\n        # If the number is not in the dictionary, return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) < 2:\n            return 0\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize max_gap\n        max_gap = 0\n        \n        # initialize min_num and max_num\n        min_num = nums[0]\n        max_num = nums[-1]\n        \n        # initialize gap\n        gap = 0\n        \n        # iterate through the array\n        for i in range(len(nums)):\n            \n            # if the current number is greater than the previous number\n            if nums[i] > min_num:\n                \n                # update min_num\n                min_num = nums[i]\n                \n            # if the current number is less than the previous number\n            elif nums[i] < max_num:\n                \n                # update max_num\n                max_num = nums[i]\n                \n            # if the current number is equal to the previous number\n            else:\n                \n                # update gap\n                gap = max(gap, nums[i] - min_num)\n                \n        # return the max_gap\n        return gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the number of couples\n        n = len(row) // 2\n        \n        # 2. Find the number of couples\n        couples = [0] * n\n        for i in range(n):\n            couples[row[2*i]//2] += 1\n            couples[row[2*i+1]//2] += 1\n        \n        # 3. Find the number of swaps\n        swaps = 0\n        for i in range(n):\n            if couples[i] == 1:\n                swaps += i\n            elif couples[i] == 2:\n                swaps += couples[i]-1\n            elif couples[i] == 3:\n                swaps += couples[i]-2\n            else:\n                swaps += couples[i]-3\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the length of s1 + s2 is not equal to s3, return False\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        # if s1 is empty, return True if s2 is equal to s3\n        if not s1:\n            return s2 == s3\n        \n        # if s2 is empty, return True if s1 is equal to s3\n        if not s2:\n            return s1 == s3\n        \n        # if s1 is not empty and s2 is not empty, create a 2D array with the length of s1 + 1 and s2 + 1\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty\n        # initialize the first row and column with False\n        # the first row is for the case where s1 is empty\n        # the first column is for the case where s2 is empty\n        # the rest of the cells are for the case where s1 and s2 are not empty"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the greed factors and sizes\n        g.sort()\n        s.sort()\n        \n        # initialize the number of children and cookies\n        num_children = len(g)\n        num_cookies = len(s)\n        \n        # initialize the number of cookies that can be given to children\n        num_cookies_given = 0\n        \n        # iterate through the greed factors and sizes\n        for i in range(num_children):\n            # iterate through the sizes\n            for j in range(num_cookies):\n                # if the size is greater than or equal to the greed factor, increment the number of cookies that can be given to children\n                if s[j] >= g[i]:\n                    num_cookies_given += 1\n                    break\n        \n        # return the number of cookies that can be given to children\n        return num_cookies_given"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Create a dictionary with the letters of the alphabet\n        # 2. Create a list of the rows\n        # 3. Iterate through the words\n        # 4. Check if the word is in the same row as the first letter\n        # 5. If it is, add it to the list\n        # 6. Return the list\n        \n        # 1. Create a dictionary with the letters of the alphabet\n        alphabet = {\n            'q': 1,\n            'w': 1,\n            'e': 1,\n            'r': 1,\n            't': 1,\n            'y': 1,\n            'u': 1,\n            'i': 1,\n            'o': 1,\n            'p': 1,\n            'a': 2,\n            's': 2,\n            'd': 2,\n            'f': 2,\n            'g': 2,\n            'h': 2,\n            'j': 2,\n            'k': 2,\n            'l': 2,\n            'z': 3,\n            'x': 3,\n            'c': 3,\n            'v': 3,\n            'b': 3,\n            'n': 3,\n            'm': 3\n        }\n        \n        # 2. Create a list of the rows\n        rows = [\n            'qwertyuiop',\n            'asdfghjkl',\n            'zxcvbnm'\n        ]\n        \n        # 3. Iterate through the words\n        res = []\n        for word in words:\n            # 4. Check if the word is in the same row as the first letter\n            # 5. If it is, add it to the list\n            # 6. Return the list\n            if alphabet[word[0].lower()] == alphabet[word[0].lower()] and alphabet[word[0].lower()] == alphabet[word[0].lower()]:\n                res.append(word)\n            elif alphabet[word[0].lower()] == alphabet[word[0].lower()] and alphabet[word[0].lower()] != alphabet[word[0].lower()]:\n                for letter in word:\n                    if alphabet[letter.lower()] == alphabet[letter.lower()]:\n                        res.append(word)\n                        break\n            else:\n                for letter in word:\n                    if alphabet[letter.lower()] == alphabet[letter.lower()]:\n                        break\n                    else:\n                        res.append(word)\n                        break\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the left node\n        leftNode = head\n        for i in range(left - 1):\n            leftNode = leftNode.next\n        \n        # 2. Find the right node\n        rightNode = head\n        for i in range(right):\n            rightNode = rightNode.next\n        \n        # 3. Reverse the nodes\n        prev = None\n        curr = leftNode\n        nextNode = curr.next\n        while curr != rightNode:\n            nextNode = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nextNode\n        \n        # 4. Update the left node\n        leftNode.next = curr\n        \n        # 5. Update the right node\n        rightNode.next = nextNode\n        \n        # 6. Return the head\n        return head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # concatenate the reverse string with the original string\n        # return the concatenated string\n        \n        # find the longest palindrome substring"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Edge case\n        if len(s) < len(t):\n            return \"\"\n        \n        # Initialize the hashmap\n        hashmap = {}\n        for char in t:\n            hashmap[char] = 0\n        \n        # Initialize the window\n        left = 0\n        right = 0\n        min_window = \"\"\n        min_window_len = len(s) + 1\n        \n        # Iterate through the string\n        while right < len(s):\n            # If the character is in the hashmap, increment the count\n            if s[right] in hashmap:\n                hashmap[s[right]] += 1\n            right += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] -= 1\n            left += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the character is in the hashmap, increment the count\n            if s[left] in hashmap:\n                hashmap[s[left]] += 1\n            \n            # If the"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 1st case: \n        # 2. 2nd case: \n        # 3. 3rd case: \n        # 4. 4th case: \n        # 5. 5th case: \n        # 6. 6th case: \n        # 7. 7th case: \n        # 8. 8th case: \n        # 9. 9th case: \n        # 10. 10th case: \n        # 11. 11th case: \n        # 12. 12th case: \n        # 13. 13th case: \n        # 14. 14th case: \n        # 15. 15th case: \n        # 16. 16th case: \n        # 17. 17th case: \n        # 18. 18th case: \n        # 19. 19th case: \n        # 20. 20th case: \n        # 21. 21st case: \n        # 22. 22nd case: \n        # 23. 23rd case: \n        # 24. 24th case: \n        # 25. 25th case: \n        # 26. 26th case: \n        # 27. 27th case: \n        # 28. 28th case: \n        # 29. 29th case: \n        # 30. 30th case: \n        # 31. 31st case: \n        # 32. 32nd case: \n        # 33. 33rd case: \n        # 34. 34th case: \n        # 35. 35th case: \n        # 36. 36th case: \n        # 37. 37th case: \n        # 38. 38th case: \n        # 39. 39th case: \n        # 40. 40th case: \n        # 41. 41st case: \n        # 42. 42nd case: \n        # 43. 43rd case: \n        # 44. 44th case: \n        # 45. 45th case: \n        # 46. 46th case: \n        # 47. 47th case: \n        # 48. 48th case: \n        # 49. 49th case: \n        # 50. 50th case: \n        # 51. 51st case: \n        # 52. 52nd case: \n        # 53. 53rd case: \n        # 54. 54th case: \n        # 55. 55th case: \n        # 56. 56th case: \n        # 57. 57th case: \n        # 58. 58th case: \n        # 59. 59th case: \n        # 60. 60th case: \n        # 61. 61st case: \n        # 62. 62nd case: \n        # 63. 63rd case: \n        # 64. 64th case: \n        # 65. 65th case: \n        # 66. 66th case: \n        # 67. 67th case: \n        # 68. 68th case: \n        # 69. 69th case: \n        # 70. 70th case: \n        # 71. 71st case: \n        # 72. 72nd case: \n        # 73. 73rd case: \n        # 74. 74th case: \n        # 75."}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the frequency of each letter\n        # 2. if the frequency is odd, add 1 to the result\n        # 3. if the frequency is even, add it to the result\n        # 4. if the frequency is 1, add 1 to the result\n        # 5. return the result\n        \n        # 1.\n        freq = {}\n        for letter in s:\n            if letter not in freq:\n                freq[letter] = 1\n            else:\n                freq[letter] += 1\n        \n        # 2.\n        result = 0\n        for letter in freq:\n            if freq[letter] % 2 == 0:\n                result += freq[letter]\n            else:\n                result += freq[letter] - 1\n        \n        # 3.\n        if result < len(s):\n            result += 1\n        \n        # 4.\n        return result"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index + 1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index + 1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index + 1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index + 1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(root.val)\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index + 1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find all the trees in the forest\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((i, j))\n        \n        # 2. Sort the trees by height\n        trees.sort(key=lambda x: forest[x[0]][x[1]])\n        \n        # 3. Find the shortest path from the starting point to each tree\n        start = (0, 0)\n        steps = 0\n        for tree in trees:\n            steps += self.bfs(forest, start, tree)\n            if steps == -1:\n                return -1\n            start = tree\n        \n        return steps\n    \n    def bfs(self, forest, start, end):\n        # BFS to find the shortest path from start to end\n        visited = set()\n        queue = collections.deque([(start, 0)])\n        while queue:\n            node, steps = queue.popleft()\n            if node == end:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in self.get_neighbors(forest, node):\n                queue.append((neighbor, steps + 1))\n        return -1\n    \n    def get_neighbors(self, forest, node):\n        # Get the neighbors of a node in the forest\n        i, j = node\n        neighbors = []\n        if i > 0:\n            neighbors.append((i - 1, j))\n        if i < len(forest) - 1:\n            neighbors.append((i + 1, j))\n        if j > 0:\n            neighbors.append((i, j - 1))\n        if j < len(forest[0]) - 1:\n            neighbors.append((i, j + 1))\n        return neighbors"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 2:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 3:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 4:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 5:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 6:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 7:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 8:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 9:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 10:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 11:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 12:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 13:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 14:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 15:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 16:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 17:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 18:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 19:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 20:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 21:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 22:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 23:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 24:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 25:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 26:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 27:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 28:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 29:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 30:\n        # Time Complexity: O("}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))\n        \n        # if a == b:\n        #     return -1\n        # else:\n        #     return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # BFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # DFS\n        # Time Comple"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        # if x < 0:\n        #     return False\n        # if x < 10:\n        #     return True\n        # if x % 10 == 0:\n        #     return False\n        # if x < 100:\n        #     return True\n        # if x < 1000:\n        #     return True\n        # if x < 10000:\n        #     return True\n        # if x < 100000:\n        #     return True\n        # if x < 1000000:\n        #     return True\n        # if x < 10000000:\n        #     return True\n        # if x < 100000000:\n        #     return True\n        # if x < 1000000000:\n        #     return True\n        # if x < 10000000000:\n        #     return True\n        # if x < 100000000000:\n        #     return True\n        # if x < 1000000000000:\n        #     return True\n        # if x < 10000000000000:\n        #     return True\n        # if x < 100000000000000:\n        #     return True\n        # if x < 1000000000000000:\n        #     return True\n        # if x < 10000000000000000:\n        #     return True\n        # if x < 100000000000000000:\n        #     return True\n        # if x < 1000000000000000000:\n        #     return True\n        # if x < 10000000000000000000:\n        #     return True\n        # if x < 100000000000000000000:\n        #     return True\n        # if x < 1000000000000000000000:\n        #     return True\n        # if x < 10000000000000000000000:\n        #     return True\n        # if x < 100000000000000000000000:\n        #     return True\n        # if x < 1000000000000000000000000:\n        #     return True\n        # if x < 10000000000000000000000000:\n        #     return True\n        # if x < 100000000000000000000000000:\n        #     return True\n        # if x < 1000000000000000000000000000:\n        #     return True\n        # if x < 10000000000000000000000000000:\n        #     return True\n        # if x < 100000000000000000000000000000:\n        #     return True\n        # if x < 1000000000000000000000000000000:\n        #     return True\n        # if x < 10000000000000000000000000000000:\n        #     return True\n        # if x < 100000000000000000000000000000000:\n        #     return True\n        # if x < 10000000000"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if the first digit is 0, return 0\n        if s[0] == '0':\n            return 0\n        \n        # if the string is empty, return 0\n        if not s:\n            return 0\n        \n        # if the string has only one digit, return 1\n        if len(s) == 1:\n            return 1\n        \n        # initialize the number of ways to decode the string\n        num_ways = 0\n        \n        # initialize the number of ways to decode the string\n        num_ways_prev = 1\n        \n        # initialize the number of ways to decode the string\n        num_ways_prev_prev = 1\n        \n        # loop through the string\n        for i in range(1, len(s)):\n            \n            # if the current digit is 0, return 0\n            if s[i] == '0':\n                return 0\n            \n            # if the current digit is 0, return 0\n            if s[i] == '0':\n                return 0\n            \n            # calculate the number of ways to decode the string\n            num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current digit is 0, return 0\n            if s[i] == '0':\n                return 0\n            \n            # if the current digit is 0, return 0\n            if s[i] == '0':\n                return 0\n            \n            # calculate the number of ways to decode the string\n            num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # update the number of ways to decode the string\n            num_ways_prev_prev = num_ways_prev\n            \n            # update the number of ways to decode the string\n            num_ways_prev = num_ways\n            \n        # return the number of ways to decode the string\n        return num_ways"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) == 1:\n        #     return t.find(s) != -1\n        # if len(t) == 1:\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) == 1:\n        #     return t.find(s) != -1\n        # if len(t) == 1:\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) == 1:\n        #     return t.find(s) != -1\n        # if len(t) == 1:\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) == 1:\n        #     return t.find(s) != -1\n        # if len(t) == 1:\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) == 1:\n        #     return t.find(s) != -1\n        # if len(t) == 1:\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) == 1:\n        #     return t.find(s) != -1\n        # if len(t) == 1:\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) == 1:\n        #     return t.find(s) != -1\n        # if len(t) == 1:\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) == 1:"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the max number that can be represented by n bits\n        # 2. 2^n - 1 - 2^(n-1) is the min number that can be represented by n bits\n        # 3. 2^n - 1 - 2^(n-1) + 1 is the max number that can be represented by n bits\n        # 4. 2^n - 1 - 2^(n-1) + 2 is the min number that can be represented by n bits\n        # 5. 2^n - 1 - 2^(n-1) + 3 is the max number that can be represented by n bits\n        # 6. 2^n - 1 - 2^(n-1) + 4 is the min number that can be represented by n bits\n        # 7. 2^n - 1 - 2^(n-1) + 5 is the max number that can be represented by n bits\n        # 8. 2^n - 1 - 2^(n-1) + 6 is the min number that can be represented by n bits\n        # 9. 2^n - 1 - 2^(n-1) + 7 is the max number that can be represented by n bits\n        # 10. 2^n - 1 - 2^(n-1) + 8 is the min number that can be represented by n bits\n        # 11. 2^n - 1 - 2^(n-1) + 9 is the max number that can be represented by n bits\n        # 12. 2^n - 1 - 2^(n-1) + 10 is the min number that can be represented by n bits\n        # 13. 2^n - 1 - 2^(n-1) + 11 is the max number that can be represented by n bits\n        # 14. 2^n - 1 - 2^(n-1) + 12 is the min number that can be represented by n bits\n        # 15. 2^n - 1 - 2^(n-1) + 13 is the max number that can be represented by n bits\n        # 16. 2^n - 1 - 2^(n-1) + 14 is the min number that can be represented by n bits\n        # 17. 2^n - 1 - 2^(n-1) + 15 is the max number that can be represented by n bits\n        # 18. 2^n - 1 - 2^(n-1) + 16 is the min number that can be represented by n bits\n        # 19. 2^n - 1 - 2^(n-1) + 17 is the max number that can be represented by n bits\n        # 20. 2^n - 1 - 2^(n-1) + 18 is the min number that can be represented by n bits\n        # 21. 2^n - 1 - 2^(n-1) + 19 is the max number that can be represented by n bits\n        # 22. 2^n - 1 - 2^(n-1) + 20 is the min number that can be represented by n bits\n        # 23. 2^n - 1 - 2^(n-1) + 21 is the max number that can be represented by n bits\n        # 24. 2^n - 1 - 2^(n-1) + 22 is the min number that can be represented by n bits\n        # 25. 2^n - 1 - 2^(n-1) + 23 is the max number that can be represented by n bits\n        # 26. 2^n - 1 - 2^(n-1) + 24 is the min number that can be represented by n bits\n        # 27. 2^n - 1 - 2^(n-1) + 25 is the max number that can be represented by n bits\n        # 28. 2^n - 1 - 2^(n-1) + 26 is the min number that can be represented by n bits\n        # 29. 2^n - 1 - 2^(n-1"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # return self.climbStairs(n-1) + self.climbStairs(n-2)\n        \n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 5\n        # if n == 5:\n        #     return 8\n        # if n == 6:\n        #     return 13\n        # if n == 7:\n        #     return 21\n        # if n == 8:\n        #     return 34\n        # if n == 9:\n        #     return 55\n        # if n == 10:\n        #     return 89\n        # if n == 11:\n        #     return 144\n        # if n == 12:\n        #     return 233\n        # if n == 13:\n        #     return 377\n        # if n == 14:\n        #     return 610\n        # if n == 15:\n        #     return 987\n        # if n == 16:\n        #     return 1597\n        # if n == 17:\n        #     return 2584\n        # if n == 18:\n        #     return 4181\n        # if n == 19:\n        #     return 6765\n        # if n == 20:\n        #     return 10946\n        # if n == 21:\n        #     return 17711\n        # if n == 22:\n        #     return 28657\n        # if n == 23:\n        #     return 46368\n        # if n == 24:\n        #     return 75025\n        # if n == 25:\n        #     return 121393\n        # if n == 26:\n        #     return 196418\n        # if n == 27:\n        #     return 317811\n        # if n == 28:\n        #     return 514229\n        # if n == 29:\n        #     return 832040\n        # if n == 30:\n        #     return 1346269\n        # if n == 31:\n        #     return 2178309\n        # if n == 32:\n        #     return 3524578\n        # if n == 33:\n        #     return 5702887\n        # if n == 34:\n        #     return 9237416\n        # if n == 35:\n        #     return 14930352\n        # if n == 36:\n        #     return 24157817\n        # if n == 37:\n        #     return 39088169\n        # if n == 38:\n        #     return 63245986\n        # if n == 39:\n        #     return 102334155\n        # if n == 40:\n        #     return 165580141\n        # if n == 41:\n        #     return 267914296\n        # if n == 42:\n        #     return 433494437\n        # if n == 43:\n        #     return 701408733\n        # if n == 44:\n        #     return 1134903170\n        # if n == 45:\n        #     return 1836311903\n        # if n == 46:\n        #     return 2971215073\n        # if n == 47:\n        #     return 4807526976\n        # if n == 48:\n        #     return"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap to store the wordDict\n        ## Create a hashmap"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return isValidBSTUtil(root.left, min_val, root.val) and isValidBSTUtil(root.right, root.val, max_val)\n        \n        return isValidBSTUtil(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # edge case\n        if len(intervals) == 0:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] > intervals[-1][1]:\n            return [newInterval] + intervals\n        \n        # edge case\n        if newInterval[1] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [intervals[0]] + intervals[1:]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals["}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\uc544\uc57c \ud55c\ub2e4.\n        # 16. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574\uc11c \ucd5c\ub300\ufffd"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # BFS\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2)\n        # Space Complexity: O"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. Permutation"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # if num1 == \"0\" or num2 == \"0\":\n        #     return \"0\"\n        \n        # if num1 == \"1\":\n        #     return num2\n        \n        # if num2 == \"1\":\n        #     return num1\n        \n        # if num1 == \"2\":\n        #     return num2 + num2\n        \n        # if num2 == \"2\":\n        #     return num1 + num1\n        \n        # if num1 == \"3\":\n        #     return num2 + num2 + num2\n        \n        # if num2 == \"3\":\n        #     return num1 + num1 + num1\n        \n        # if num1 == \"4\":\n        #     return num2 + num2 + num2 + num2\n        \n        # if num2 == \"4\":\n        #     return num1 + num1 + num1 + num1\n        \n        # if num1 == \"5\":\n        #     return num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"5\":\n        #     return num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"6\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"6\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"7\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"7\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"8\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"8\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"9\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"9\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"10\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"10\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"11\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"11\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"12\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"12\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"13\":\n        #     return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        # if num2 == \"13\":\n        #     return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # if num1 == \"14\":\n        #     return num2 + num2 + num2 + num2 +"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the max profit from left to right\n        ## 2. Find the max profit from right to left\n        ## 3. Add the two profits\n        \n        ## 1. Find the max profit from left to right\n        max_profit_left = 0\n        min_price_left = prices[0]\n        for price in prices:\n            min_price_left = min(min_price_left, price)\n            max_profit_left = max(max_profit_left, price - min_price_left)\n        \n        ## 2. Find the max profit from right to left\n        max_profit_right = 0\n        max_price_right = prices[-1]\n        for price in prices[::-1]:\n            max_price_right = max(max_price_right, price)\n            max_profit_right = max(max_profit_right, max_price_right - price)\n        \n        ## 3. Add the two profits\n        return max_profit_left + max_profit_right"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()\n        \n        # initialize the result array\n        result = []\n        \n        # initialize the current combination\n        current_combination = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # loop through the array\n        while index < len(candidates):\n            \n            # if the current sum is less than the target\n            if current_sum < target:\n                \n                # add the current number to the current combination\n                current_combination.append(candidates[index])\n                \n                # add the current number to the current sum\n                current_sum += candidates[index]\n                \n                # recursively call the function with the next index\n                self.combinationSum2(candidates, target, index + 1, current_combination, current_sum, result)\n                \n                # remove the current number from the current combination\n                current_combination.pop()\n                \n                # remove the current number from the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is equal to the target\n            elif current_sum == target:\n                \n                # add the current combination to the result array\n                result.append(current_combination.copy())\n                \n                # remove the current number from the current combination\n                current_combination.pop()\n                \n                # remove the current number from the current sum\n                current_sum -= candidates[index]\n                \n                # recursively call the function with the next index\n                self.combinationSum2(candidates, target, index + 1, current_combination, current_sum, result)\n                \n                # remove the current number from the current combination\n                current_combination.pop()\n                \n                # remove the current number from the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is greater than the target\n            else:\n                \n                # remove the current number from the current combination\n                current_combination.pop()\n                \n                # remove the current number from the current sum\n                current_sum -= candidates[index]\n                \n                # recursively call the function with the next index\n                self.combinationSum2(candidates, target, index + 1, current_combination, current_sum, result)\n                \n                # remove the current number from the current combination\n                current_combination.pop()\n                \n                # remove the current number from the current sum\n                current_sum -= candidates[index]\n                \n            # increment the index\n            index += 1\n            \n        return result\n    \n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()\n        \n        # initialize the result array\n        result = []\n        \n        # initialize the current combination\n        current_combination = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # loop through the array\n        while index < len(candidates):\n            \n            # if the current sum is less than the target\n            if current_sum < target:\n                \n                # add the current number to the current combination\n                current_combination.append(candidates[index])\n                \n                # add the current number to the current sum\n                current_sum += candidates[index]\n                \n                # recursively call the function with the next index\n                self.combinationSum2(candidates, target, index + 1, current_combination, current_sum, result)\n                \n                # remove the current number from the current combination\n                current_combination.pop()\n                \n                # remove the current number from the current sum\n                current_sum -= candidates[index]\n                \n            # if the current sum is equal to the target\n            elif current_sum == target:\n                \n                # add the current combination to the result array\n                result.append(current_combination.copy())\n                \n                # remove the current number from the current combination\n                current_combination.pop()\n                \n                # remove the current number from the current sum\n                current_sum -= candidates[index]\n                \n                # recursively call"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the word is all capital letters\n        if word.isupper():\n            return True\n        \n        # if the word is all lowercase letters\n        if word.islower():\n            return True\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return True\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].islower() and word[1:].islower():\n            return True\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].islower() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].isupper():\n            return False\n        \n        # if the word is all lowercase letters except the first letter\n        if word[0].isupper() and word[1:].islower():\n            return False\n        \n        # if the word is all lowercase letters except the first letter"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach:\n        ## We can use two pointers, one for buying and one for selling.\n        ## We can keep track of the minimum price and the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and the minimum price.\n        ## If the difference is greater than the maximum profit, we can update the maximum profit.\n        ## If the difference is less than the maximum profit, we can update the minimum price.\n        ## We can keep track of the maximum profit.\n        ## We can keep track of the difference between the current price and"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Initialize stack and result\n        stack = []\n        result = []\n        \n        # Initialize current node and move to root\n        curr = root\n        \n        # While current node is not None\n        while curr != None:\n            \n            # Push current node to stack\n            stack.append(curr)\n            \n            # Move to left child\n            curr = curr.left\n        \n        # While stack is not empty\n        while len(stack) > 0:\n            \n            # Pop node from stack\n            node = stack.pop()\n            \n            # Add node value to result\n            result.append(node.val)\n            \n            # If node has right child, move to right child\n            if node.right != None:\n                curr = node.right\n                while curr != None:\n                    stack.append(curr)\n                    curr = curr.left\n        \n        # Return result\n        return result\n        \n        # Recursive solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Initialize result\n        result = []\n        \n        # If root is not None\n        if root != None:\n            \n            # Recursively call inorderTraversal on left child\n            result = self.inorderTraversal(root.left)\n            \n            # Add root value to result\n            result.append(root.val)\n            \n            # Recursively call inorderTraversal on right child\n            result = result + self.inorderTraversal(root.right)\n        \n        # Return result\n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Find the number of left and right parentheses\n        # 2. Find the number of left and right parentheses that are not removed\n        # 3. Find the number of left and right parentheses that are removed\n        # 4. Find the number of left and right parentheses that are removed\n        # 5. Find the number of left and right parentheses that are removed\n        # 6. Find the number of left and right parentheses that are removed\n        # 7. Find the number of left and right parentheses that are removed\n        # 8. Find the number of left and right parentheses that are removed\n        # 9. Find the number of left and right parentheses that are removed\n        # 10. Find the number of left and right parentheses that are removed\n        # 11. Find the number of left and right parentheses that are removed\n        # 12. Find the number of left and right parentheses that are removed\n        # 13. Find the number of left and right parentheses that are removed\n        # 14. Find the number of left and right parentheses that are removed\n        # 15. Find the number of left and right parentheses that are removed\n        # 16. Find the number of left and right parentheses that are removed\n        # 17. Find the number of left and right parentheses that are removed\n        # 18. Find the number of left and right parentheses that are removed\n        # 19. Find the number of left and right parentheses that are removed\n        # 20. Find the number of left and right parentheses that are removed\n        # 21. Find the number of left and right parentheses that are removed\n        # 22. Find the number of left and right parentheses that are removed\n        # 23. Find the number of left and right parentheses that are removed\n        # 24. Find the number of left and right parentheses that are removed\n        # 25. Find the number of left and right parentheses that are removed\n        # 26. Find the number of left and right parentheses that are removed\n        # 27. Find the number of left and right parentheses that are removed\n        # 28. Find the number of left and right parentheses that are removed\n        # 29. Find the number of left and right parentheses that are removed\n        # 30. Find the number of left and right parentheses that are removed\n        # 31. Find the number of left and right parentheses that are removed\n        # 32. Find the number of left and right parentheses that are removed\n        # 33. Find the number of left and right parentheses that are removed\n        # 34. Find the number of left and right parentheses that are removed\n        # 35. Find the number of left and right parentheses that are removed\n        # 36. Find the number of left and right parentheses that are removed\n        # 37. Find the number of left and right parentheses that are removed\n        # 38. Find the number of left and right parentheses that are removed\n        # 39. Find the number of left and right parentheses that are removed\n        # 40. Find the number of left and right parentheses that are removed\n        # 41. Find the number of left and right parentheses that are removed\n        # 42. Find the number of left and right parentheses that are removed\n        # 43. Find the number of left and right parentheses that are removed\n        # 44. Find the number of left and right parentheses that are removed\n        # 45. Find the number of left and right parentheses that are removed\n        # 46. Find the number of left and right parentheses that are removed\n        # 47. Find the number of left and right parentheses that are removed\n        # 48. Find the number of left and right parentheses that are removed\n        # 49. Find the number of left and right parentheses that are removed\n        # 50. Find the number of left and right parentheses that are removed\n        # 51. Find the number of left and right parentheses that are removed\n        # 52. Find the number of left and right parenthes"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Time Complexity: O(nlogk)\n        # Space Complexity: O(1)\n        \n        # Edge Case:\n        # If the list is empty, return None\n        if not lists:\n            return None\n        \n        # If the list has only one element, return that element\n        if len(lists) == 1:\n            return lists[0]\n        \n        # If the list has more than one element, merge them\n        # Using the merge function\n        return self.merge(lists)\n        \n    def merge(self, lists):\n        # Base Case:\n        # If the list is empty, return None\n        if not lists:\n            return None\n        \n        # If the list has only one element, return that element\n        if len(lists) == 1:\n            return lists[0]\n        \n        # If the list has more than one element, merge them\n        # Using the merge function\n        mid = len(lists) // 2\n        left = self.merge(lists[:mid])\n        right = self.merge(lists[mid:])\n        return self.merge_two_lists(left, right)\n        \n    def merge_two_lists(self, l1, l2):\n        # Base Case:\n        # If either list is empty, return the other list\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        \n        # If both lists are not empty, merge them\n        # Using the merge function\n        if l1.val < l2.val:\n            l1.next = self.merge_two_lists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.merge_two_lists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^5 = 10^4 * 5 + 1\n        # 2. 10^4 = 10^3 * 4 + 1\n        # 3. 10^3 = 10^2 * 3 + 1\n        # 4. 10^2 = 10^1 * 2 + 1\n        # 5. 10^1 = 10^0 * 1 + 1\n        # 6. 10^0 = 1 + 1\n        # 7. 1 = 0 + 1\n        # 8. 0 = 0 + 0\n        # 9. 0 = 0 + 0\n        # 10. 0 = 0 + 0\n        # 11. 0 = 0 + 0\n        # 12. 0 = 0 + 0\n        # 13. 0 = 0 + 0\n        # 14. 0 = 0 + 0\n        # 15. 0 = 0 + 0\n        # 16. 0 = 0 + 0\n        # 17. 0 = 0 + 0\n        # 18. 0 = 0 + 0\n        # 19. 0 = 0 + 0\n        # 20. 0 = 0 + 0\n        # 21. 0 = 0 + 0\n        # 22. 0 = 0 + 0\n        # 23. 0 = 0 + 0\n        # 24. 0 = 0 + 0\n        # 25. 0 = 0 + 0\n        # 26. 0 = 0 + 0\n        # 27. 0 = 0 + 0\n        # 28. 0 = 0 + 0\n        # 29. 0 = 0 + 0\n        # 30. 0 = 0 + 0\n        # 31. 0 = 0 + 0\n        # 32. 0 = 0 + 0\n        # 33. 0 = 0 + 0\n        # 34. 0 = 0 + 0\n        # 35. 0 = 0 + 0\n        # 36. 0 = 0 + 0\n        # 37. 0 = 0 + 0\n        # 38. 0 = 0 + 0\n        # 39. 0 = 0 + 0\n        # 40. 0 = 0 + 0\n        # 41. 0 = 0 + 0\n        # 42. 0 = 0 + 0\n        # 43. 0 = 0 + 0\n        # 44. 0 = 0 + 0\n        # 45. 0 = 0 + 0\n        # 46. 0 = 0 + 0\n        # 47. 0 = 0 + 0\n        # 48. 0 = 0 + 0\n        # 49. 0 = 0 + 0\n        # 50. 0 = 0 + 0\n        # 51. 0 = 0 + 0\n        # 52. 0 = 0 + 0\n        # 53. 0 = 0 + 0\n        # 54. 0 = 0 + 0\n        # 55. 0 = 0 + 0\n        # 56. 0 = 0 + 0\n        # 57. 0 = 0 + 0\n        # 58. 0 = 0 + 0\n        # 59. 0 = 0 + 0\n        # 60. 0 = 0 + 0\n        # 61. 0 = 0 + 0\n        # 62. 0 = 0 + 0\n        # 63. 0 = 0 + 0\n        # 64. 0 = 0 + 0\n        # 65. 0 = 0 + 0\n        # 66. 0 = 0 + 0\n        # 67. 0 = 0 + 0\n        # 68. 0 = 0 + 0\n        # 69. 0 = 0 + 0\n        # 70. 0 = 0 + 0\n        # 71. 0 = 0 + 0\n        # 72. 0 = 0 + 0\n        # 73. 0 = 0 + 0\n        # 74. 0 = 0 + 0\n        # 75. 0 = 0 + 0\n        # 76. 0 = 0"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. Build a hashmap of words and their indices\n        word_to_index = {word: i for i, word in enumerate(words)}\n        \n        ## 2. Build a hashmap of reversed words and their indices\n        reversed_words = {word[::-1]: i for i, word in enumerate(words)}\n        \n        ## 3. Build a hashmap of reversed words and their indices\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list\n        ##    - if the reversed word is not a palindrome, then we can add the index of the original word to the list"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums["}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u51fa\u6240\u6709\u611f\u67d3\u7684\u533a\u57df\n        # 2. \u627e\u51fa\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\n        # 3. \u5c06\u8fb9\u754c\u4e0a\u7684\u611f\u67d3\u533a\u57df\u611f\u67d3\n        # 4. \u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df\uff0c\u5219\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\u4e0a\u6ca1\u6709\u611f\u67d3\u533a\u57df"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            max_len = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    max_len = max(max_len, 1 + dfs(x, y))\n            \n            dp[i][j] = max_len\n            return max_len\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # level = 0\n        # while queue:\n        #     level += 1\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     if level % 2 == 0:\n        #         result.append(temp[::-1])\n        #     else:\n        #         result.append(temp)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # level = 0\n        # while queue:\n        #     level += 1\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     result.append(temp[::-1] if level % 2 == 0 else temp)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # level = 0\n        # while queue:\n        #     level += 1\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     result.append(temp[::-1] if level % 2 == 0 else temp)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # level = 0\n        # while queue:\n        #     level += 1\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     result.append(temp[::-1] if level % 2 == 0 else temp)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # level = 0\n        # while queue:\n        #     level += 1\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     result.append(temp[::-1] if level % 2 == 0 else temp)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # level = 0\n        # while queue:\n        #     level += 1\n        #     temp = []\n        #     for node in queue:\n        #         temp.append(node.val)\n        #         if node.left:\n        #             temp.append(node.left)\n        #         if node.right:\n        #             temp.append(node.right)\n        #     queue = temp\n        #     result.append(temp[::-1] if level % 2 == 0 else temp)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # level = 0\n        # while queue:\n        #     level += 1\n        #     temp = []\n        #     for node in queue:"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if numRows == 0:\n        #     return []\n        # if numRows == 1:\n        #     return [[1]]\n        # if numRows == 2:\n        #     return [[1], [1,1]]\n        \n        # res = [[1], [1,1]]\n        # for i in range(2, numRows):\n        #     temp = [1]\n        #     for j in range(1, i):\n        #         temp.append(res[i-1][j-1] + res[i-1][j])\n        #     temp.append(1)\n        #     res.append(temp)\n        # return res\n        \n        # if numRows == 0:\n        #     return []\n        # if numRows == 1:\n        #     return [[1]]\n        # if numRows == 2:\n        #     return [[1], [1,1]]\n        \n        # res = [[1], [1,1]]\n        # for i in range(2, numRows):\n        #     temp = [1]\n        #     for j in range(1, i):\n        #         temp.append(res[i-1][j-1] + res[i-1][j])\n        #     temp.append(1)\n        #     res.append(temp)\n        # return res\n        \n        # if numRows == 0:\n        #     return []\n        # if numRows == 1:\n        #     return [[1]]\n        # if numRows == 2:\n        #     return [[1], [1,1]]\n        \n        # res = [[1], [1,1]]\n        # for i in range(2, numRows):\n        #     temp = [1]\n        #     for j in range(1, i):\n        #         temp.append(res[i-1][j-1] + res[i-1][j])\n        #     temp.append(1)\n        #     res.append(temp)\n        # return res\n        \n        # if numRows == 0:\n        #     return []\n        # if numRows == 1:\n        #     return [[1]]\n        # if numRows == 2:\n        #     return [[1], [1,1]]\n        \n        # res = [[1], [1,1]]\n        # for i in range(2, numRows):\n        #     temp = [1]\n        #     for j in range(1, i):\n        #         temp.append(res[i-1][j-1] + res[i-1][j])\n        #     temp.append(1)\n        #     res.append(temp)\n        # return res\n        \n        # if numRows == 0:\n        #     return []\n        # if numRows == 1:\n        #     return [[1]]\n        # if numRows == 2:\n        #     return [[1], [1,1]]\n        \n        # res = [[1], [1,1]]\n        # for i in range(2, numRows):\n        #     temp = [1]\n        #     for j in range(1, i):\n        #         temp.append(res[i-1][j-1] + res[i-1][j])\n        #     temp.append(1)\n        #     res.append(temp)\n        # return res\n        \n        # if numRows == 0:\n        #     return []\n        # if numRows == 1:\n        #     return [[1]]\n        # if numRows == 2:\n        #     return [[1], [1,1]]\n        \n        # res = [[1], [1,1]]\n        # for i in range(2, numRows):\n        #     temp = [1]\n        #     for j in range(1, i):\n        #         temp.append(res[i-1][j-1] + res[i-1][j])\n        #     temp.append(1)\n        #     res.append(temp)\n        # return res\n        \n        # if numRows == 0:\n        #     return []\n        # if numRows == 1:\n        #     return [[1]]\n        # if numRows == 2:\n        #     return [[1], [1,1]]\n        \n        # res = [[1], [1,1]]\n        # for i in range("}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## Approach 1: Recursive\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 2: Iterative\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 3: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 4: BFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 5: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 6: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 7: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 8: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 9: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 10: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 11: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 12: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 13: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 14: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 15: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 16: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 17: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 18: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 19: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 20: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 21: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 22: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 23: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 24: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 25: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 26: DFS\n        ## Time Complexity: O(n)\n        ## Space Complexity"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc804\uccb4 \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\n        # 2. \ucd5c\uc18c \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\n        # 3. \ucd5c\uc18c \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\n        # 4. \ucd5c\uc18c \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\n        # 5. \ucd5c\uc18c \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\n        # 6. \ucd5c\uc18c \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\n        # 7. \ucd5c\uc18c \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\n        # 8. \ucd5c\uc18c \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\uce58\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\n        # 9. \ucd5c\uc18c \ub192\uc774\ub97c \uc800\uc7a5\ud558\ub294 \ubc30\uc5f4\uc758 \uc704\ufffd"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # remove non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # sliding window\n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of the middle two numbers\n        \n        # 1. create a list of k numbers\n        # 2. sort the list\n        # 3. if k is odd, return the middle number\n        # 4. if k is even, return the mean of"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the list, we can just return the head\n        if k >= length:\n            return head\n        \n        # find the new head and the new tail\n        new_head = head\n        new_tail = head\n        for i in range(length - k - 1):\n            new_tail = new_tail.next\n            new_head = new_head.next\n        \n        # set the new tail's next to None\n        new_tail.next = None\n        \n        # set the new head to the original head\n        new_head = head\n        \n        # find the new tail\n        while new_head.next:\n            new_head = new_head.next\n        \n        # set the new tail's next to the original head\n        new_head.next = head\n        \n        # return the new head\n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n == 1:\n            return True\n        \n        if n % 2 == 0:\n            return self.isUgly(n // 2)\n        \n        if n % 3 == 0:\n            return self.isUgly(n // 3)\n        \n        if n % 5 == 0:\n            return self.isUgly(n // 5)\n        \n        return False"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root.left is None:\n        #     return self.sumOfLeftLeaves(root.right)\n        # if root.right is None:\n        #     return root.left.val\n        # return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 0\n        # if root."}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the max sum of a submatrix with sum <= k\n        ## 2. Find the min sum of a submatrix with sum >= k\n        ## 3. Find the max sum of a submatrix with sum between k and 2k\n        ## 4. Find the min sum of a submatrix with sum between k and 2k\n        ## 5. Find the max sum of a submatrix with sum between k and 3k\n        ## 6. Find the min sum of a submatrix with sum between k and 3k\n        ## 7. Find the max sum of a submatrix with sum between k and 4k\n        ## 8. Find the min sum of a submatrix with sum between k and 4k\n        ## 9. Find the max sum of a submatrix with sum between k and 5k\n        ## 10. Find the min sum of a submatrix with sum between k and 5k\n        ## 11. Find the max sum of a submatrix with sum between k and 6k\n        ## 12. Find the min sum of a submatrix with sum between k and 6k\n        ## 13. Find the max sum of a submatrix with sum between k and 7k\n        ## 14. Find the min sum of a submatrix with sum between k and 7k\n        ## 15. Find the max sum of a submatrix with sum between k and 8k\n        ## 16. Find the min sum of a submatrix with sum between k and 8k\n        ## 17. Find the max sum of a submatrix with sum between k and 9k\n        ## 18. Find the min sum of a submatrix with sum between k and 9k\n        ## 19. Find the max sum of a submatrix with sum between k and 10k\n        ## 20. Find the min sum of a submatrix with sum between k and 10k\n        ## 21. Find the max sum of a submatrix with sum between k and 11k\n        ## 22. Find the min sum of a submatrix with sum between k and 11k\n        ## 23. Find the max sum of a submatrix with sum between k and 12k\n        ## 24. Find the min sum of a submatrix with sum between k and 12k\n        ## 25. Find the max sum of a submatrix with sum between k and 13k\n        ## 26. Find the min sum of a submatrix with sum between k and 13k\n        ## 27. Find the max sum of a submatrix with sum between k and 14k\n        ## 28. Find the min sum of a submatrix with sum between k and 14k\n        ## 29. Find the max sum of a submatrix with sum between k and 15k\n        ## 30. Find the min sum of a submatrix with sum between k and 15k\n        ## 31. Find the max sum of a submatrix with sum between k and 16k\n        ## 32. Find the min sum of a submatrix with sum between k and 16k\n        ## 33. Find the max sum of a submatrix with sum between k and 17k\n        ## 34. Find the min sum of a submatrix with sum between k and 17k\n        ## 35. Find the max sum of a submatrix with sum between k and 18k\n        ## 36. Find the min sum of a submatrix with sum between k and 18k\n        ## 37. Find the max sum of a submatrix with sum between k and 19k\n        ## 38. Find the min sum of a submatrix with sum between k and 19k\n        ## 39. Find the max sum of a submatrix with sum between k and 20k\n        ## 40. Find the min sum of a submatrix with sum between k and 20k\n        ## 41. Find the max sum of a submatrix with sum between k and 21k\n        ## 42. Find the min sum of a submatrix with sum between k and 21k\n        ## 43. Find the"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if dividend == 0:\n            return 0\n        \n        # edge case\n        if divisor == 1:\n            return dividend\n        \n        # edge case\n        if divisor == -1:\n            if dividend == -2147483648:\n                return 2147483647\n            else:\n                return -dividend\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == 1:\n                return -2147483648\n            elif divisor == -1:\n                return 2147483647\n            else:\n                return 0\n        \n        # edge case\n        if divisor == -2147483648:\n            if dividend == 1:\n                return 1\n            elif dividend == -1:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == 2147483647 and divisor == -1:\n            return 2147483647\n        \n        # edge case\n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        # edge case\n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        # edge case\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        # edge case\n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        # edge case\n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        # edge case\n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        # edge case\n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        # edge case\n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        # edge case\n        if dividend == -2147483648 and divisor == 2147483647:\n            return -1\n        \n        # edge case\n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        # edge case\n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        # edge case\n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        # edge case\n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        # edge case\n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        # edge case\n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        # edge case\n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        # edge case\n        if dividend == -2147483648 and divisor == -21474"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O's on the border\n        # 2. Flip all the 'O's on the border with '1's\n        # 3. Flip all the '1's with '0's\n        # 4. Flip all the '0's with '1's\n        \n        # 1. Find all the 'O"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force solution\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ##\n        ## for i in range(len(nums)):\n        ##     for j in range(i+1, len(nums)):\n        ##         if nums[i] + nums[j] == target:\n        ##             return [i, j]\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    new_cards = [a, b] + [x for x in cards if x not in [a, b]]\n                    if dfs(new_cards, target):\n                        return True\n                    new_cards = [b, a] + [x for x in cards if x not in [a, b]]\n                    if dfs(new_cards, target):\n                        return True\n                    \n            return False\n        \n        return dfs(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then it means it can be anything\n        if not p:\n            return not s\n        \n        # if s is empty, then it means it can be anything\n        if not s:\n            return False\n        \n        # if p is '?' then it means it can be anything\n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is '*' then it means it can be anything\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p[0] is not '?' or '*' then it means it can be anything\n        if s[0] != p[0]:\n            return False\n        \n        # if p[0] is not '?' or '*' then it means it can be anything\n        return self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        # build a hashmap\n        # build a stack\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a queue\n        # build a hashmap\n        # build a result\n        # build a visited set\n        # build a"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        # print(nums)\n        # print(target)\n        # print(nums[0])\n        # print(nums[-1])\n        # print(nums[0] + nums[-1])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8] + nums[8] + nums[-9])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8] + nums[8] + nums[-9] + nums[9] + nums[-10])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8] + nums[8] + nums[-9] + nums[9] + nums[-10] + nums[10] + nums[-11])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8] + nums[8] + nums[-9] + nums[9] + nums[-10] + nums[10] + nums[-1"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize result list\n        result = []\n        \n        # initialize max height\n        max_height = 0\n        \n        # initialize current height\n        curr_height = 0\n        \n        # initialize current building\n        curr_building = None\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building left edge\n        building_left_edge = 0\n        \n        # initialize building right edge\n        building_right_edge = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize building height\n        building_height = 0\n        \n        # initialize building index\n        building_index = 0\n        \n        # initialize"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()\n        \n        # reverse the string again\n        s.reverse()"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Iterative solution\n        # prev = None\n        # curr = head\n        # while curr:\n        #     next = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = next\n        # return prev\n        \n        # Recursive solution\n        if not head:\n            return None\n        if not head.next:\n            return head\n        new_head = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return new_head"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # We can use DP to solve this problem.\n        # We can use a 2D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each row.\n        # We can use a 1D array to store the minimum sum of each"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        # 1000 - 999\n        # 1000000 - 999999\n        # 1000000000 - 9223372036854775807\n        # 1000000000000 - 9223372036854775807\n        # 1000000000000000 - 9223372036854775807\n        # 1000000000000000000 - 9223372036854775807\n        # 1000000000000000000000 - 9223372036854775807\n        # 1000000000000000000000000 - 9223372036854775807\n        # 1000000000000000000000000000 - 9223372036854775807\n        # 1000000000000000000000000000000 - 9223372036854775807\n        # 1000000000000000000000000000000000 - 9223372036854775807\n        # 1000000000000000000000000000000000000 - 9223372036854775807\n        # 1000000000000000000000000000000000000000 - 9223372036854775807\n        # 100000000000000000000000000000000000000000 - 9223372036854775807\n        # 100000000000000000000000000000000000000000000 - 9223372036854775807\n        # 100000000000000000000000000000000000000000000000 - 9223372036854775807\n        # 100000000000000000000000000000000000000000000000000 - 9223372036854775807\n        # 100000000000000000000000000000000000000000000000000000 - 9223372036854775807\n        # 100000000000000000000000000000000000000000000000000000000 -"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # edge case\n        if not head or not head.next:\n            return head\n        \n        # initialize the dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # initialize the current node\n        curr = dummy\n        \n        # loop through the list\n        while curr.next and curr.next.next:\n            # initialize the first node\n            first = curr.next\n            \n            # initialize the second node\n            second = curr.next.next\n            \n            # swap the nodes\n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            # move the current node to the next node\n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # edge 1: (1,2)\n        # edge 2: (2,3)\n        # edge 3: (3,4)\n        # edge 4: (4,1)\n        # edge 5: (1,5)\n        \n        # edge 1: (1,2)\n        # edge 2: (2,3)\n        # edge 3: (3,4)\n        # edge 4: (4,1)\n        # edge 5: (1,5)\n        # edge 6: (5,6)\n        # edge 7: (6,7)\n        # edge 8: (7,8)\n        # edge 9: (8,9)\n        # edge 10: (9,10)\n        # edge 11: (10,11)\n        # edge 12: (11,12)\n        # edge 13: (12,13)\n        # edge 14: (13,14)\n        # edge 15: (14,15)\n        # edge 16: (15,16)\n        # edge 17: (16,17)\n        # edge 18: (17,18)\n        # edge 19: (18,19)\n        # edge 20: (19,20)\n        # edge 21: (20,21)\n        # edge 22: (21,22)\n        # edge 23: (22,23)\n        # edge 24: (23,24)\n        # edge 25: (24,25)\n        # edge 26: (25,26)\n        # edge 27: (26,27)\n        # edge 28: (27,28)\n        # edge 29: (28,29)\n        # edge 30: (29,30)\n        # edge 31: (30,31)\n        # edge 32: (31,32)\n        # edge 33: (32,33)\n        # edge 34: (33,34)\n        # edge 35: (34,35)\n        # edge 36: (35,36)\n        # edge 37: (36,37)\n        # edge 38: (37,38)\n        # edge 39: (38,39)\n        # edge 40: (39,40)\n        # edge 41: (40,41)\n        # edge 42: (41,42)\n        # edge 43: (42,43)\n        # edge 44: (43,44)\n        # edge 45: (44,45)\n        # edge 46: (45,46)\n        # edge 47: (46,47)\n        # edge 48: (47,48)\n        # edge 49: (48,49)\n        # edge 50: (49,50)\n        # edge 51: (50,51)\n        # edge 52: (51,52)\n        # edge 53: (52,53)\n        # edge 54: (53,54)\n        # edge 55: (54,55)\n        # edge 56: (55,56)\n        # edge 57: (56,57)\n        # edge 58: (57,58)\n        # edge 59: (58,59)\n        # edge 60: (59,60)\n        # edge 61: (60,61)\n        # edge 62: (61,62)\n        # edge 63: (62,63)\n        # edge 64: (63,64)\n        # edge 65: (64,65)\n        # edge 66: (65,66)"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the list\n        nums.sort()\n        \n        # create a list of lists to store the permutations\n        permutations = []\n        \n        # create a set to store the unique permutations\n        unique_permutations = set()\n        \n        # create a list to store the current permutation\n        current_permutation = []\n        \n        # create a list to store the current permutation\n        current_permutation_index = []\n        \n        # create a list to store the current permutation\n        current_permutation_index_set = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique = set()\n        \n        # create a list to store the current permutation\n        current_permutation_index_set_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique_unique"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        #"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. XOR all the elements in the array\n        ## 2. XOR of a number with itself is 0\n        ## 3. XOR of a number with 0 is the number itself\n        ## 4. XOR of a number with 0 is the number itself\n        ## 5. XOR of a number with itself is 0\n        ## 6. XOR of a number with itself is the number itself\n        ## 7. XOR of a number with 0 is the number itself\n        ## 8. XOR of a number with 0 is the number itself\n        ## 9. XOR of a number with itself is the number itself\n        ## 10. XOR of a number with itself is the number itself\n        ## 11. XOR of a number with itself is the number itself\n        ## 12. XOR of a number with itself is the number itself\n        ## 13. XOR of a number with itself is the number itself\n        ## 14. XOR of a number with itself is the number itself\n        ## 15. XOR of a number with itself is the number itself\n        ## 16. XOR of a number with itself is the number itself\n        ## 17. XOR of a number with itself is the number itself\n        ## 18. XOR of a number with itself is the number itself\n        ## 19. XOR of a number with itself is the number itself\n        ## 20. XOR of a number with itself is the number itself\n        ## 21. XOR of a number with itself is the number itself\n        ## 22. XOR of a number with itself is the number itself\n        ## 23. XOR of a number with itself is the number itself\n        ## 24. XOR of a number with itself is the number itself\n        ## 25. XOR of a number with itself is the number itself\n        ## 26. XOR of a number with itself is the number itself\n        ## 27. XOR of a number with itself is the number itself\n        ## 28. XOR of a number with itself is the number itself\n        ## 29. XOR of a number with itself is the number itself\n        ## 30. XOR of a number with itself is the number itself\n        ## 31. XOR of a number with itself is the number itself\n        ## 32. XOR of a number with itself is the number itself\n        ## 33. XOR of a number with itself is the number itself\n        ## 34. XOR of a number with itself is the number itself\n        ## 35. XOR of a number with itself is the number itself\n        ## 36. XOR of a number with itself is the number itself\n        ## 37. XOR of a number with itself is the number itself\n        ## 38. XOR of a number with itself is the number itself\n        ## 39. XOR of a number with itself is the number itself\n        ## 40. XOR of a number with itself is the number itself\n        ## 41. XOR of a number with itself is the number itself\n        ## 42. XOR of a number with itself is the number itself\n        ## 43. XOR of a number with itself is the number itself\n        ## 44. XOR of a number with itself is the number itself\n        ## 45. XOR of a number with itself is the number itself\n        ## 46. XOR of a number with itself is the number itself\n        ## 47. XOR of a number with itself is the number itself\n        ## 48. XOR of a number with itself is the number itself\n        ## 49. XOR of a number with itself is the number itself\n        ## 50. XOR of a number with itself is the number itself\n        ## 51. XOR of a number with itself is the number itself\n        ## 52. XOR of a number with itself is the number itself\n        ##"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 1st approach is to use hashmap\n        # 3. 2nd approach is to use floyd's cycle detection algorithm\n        \n        # 1. 2 pointer approach\n        slow = n\n        fast = n\n        \n        while True:\n            slow = self.squareSum(slow)\n            fast = self.squareSum(self.squareSum(fast))\n            \n            if slow == fast:\n                break\n        \n        return slow == 1\n        \n    def squareSum(self, n):\n        sum = 0\n        while n > 0:\n            digit = n % 10\n            sum += digit * digit\n            n = n // 10\n        return sum\n        \n        # 2. 1st approach is to use hashmap\n        # 3. 2nd approach is to use floyd's cycle detection algorithm\n        # 1. 2 pointer approach\n        # slow = n\n        # fast = n\n        # seen = set()\n        # while True:\n        #     slow = self.squareSum(slow)\n        #     if slow in seen:\n        #         return False\n        #     seen.add(slow)\n        #     slow = self.squareSum(slow)\n        #     if slow == 1:\n        #         return True\n        #     fast = self.squareSum(self.squareSum(fast))\n        #     if fast == 1:\n        #         return True\n        #     if slow == fast:\n        #         return False\n        \n        # 2. 1st approach is to use hashmap\n        # 3. 2nd approach is to use floyd's cycle detection algorithm\n        # slow = n\n        # fast = n\n        # seen = set()\n        # while True:\n        #     slow = self.squareSum(slow)\n        #     if slow in seen:\n        #         return False\n        #     seen.add(slow)\n        #     slow = self.squareSum(slow)\n        #     if slow == 1:\n        #         return True\n        #     fast = self.squareSum(self.squareSum(fast))\n        #     if fast == 1:\n        #         return True\n        #     if slow == fast:\n        #         return False\n        \n        # 3. 3rd approach is to use tortoise and hare algorithm\n        # slow = n\n        # fast = n\n        # while True:\n        #     slow = self.squareSum(slow)\n        #     fast = self.squareSum(self.squareSum(fast))\n        #     if slow == fast:\n        #         break\n        #     if slow == 1:\n        #         return True\n        #     if fast == 1:\n        #         return True\n        # return False"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # left = 0\n        # right = len(nums) - 1\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] == target:\n        #         return mid\n        #     elif nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return left\n        \n        # linear search\n        for i in range(len(nums)):\n            if nums[i] >= target:\n                return i\n        return len(nums)\n        \n        # if target in nums:\n        #     return nums.index(target)\n        # else:\n        #     return nums.index(min(nums))"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1st approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2nd approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 3rd approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 4th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 5th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 6th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 7th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 8th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 9th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 10th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 11th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 12th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 13th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 14th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 15th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 16th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 17th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 18th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 19th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 20th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 21st approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 22nd approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 23rd approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 24th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 25th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 26th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 27th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 28th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(m*n)\n        # Space Complexity: O(m*n)\n        \n        # Approach: Dynamic Programming\n        # We can solve this problem using Dynamic Programming.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array to store the minimum sum of each cell.\n        # We can use a 2D array"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"311311222123213211211131221\"\n        \n        if n == 13:\n            return \"1321132132111231131221123113112221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 15:\n            return \"3113112221231132132112311312211211131221\"\n        \n        if n == 16:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 17:\n            return \"1113122113121321123113122112311322211211131221\"\n        \n        if n == 18:\n            return \"31131122212311321321123113222112311312211211131221\"\n        \n        if n == 19:\n            return \"13211321321123113222112311312211211131221\"\n        \n        if n == 20:\n            return \"111312211312132112311322211231132122211211131221\"\n        \n        if n == 21:\n            return \"3113112221231132132112311321222112311312211211131221\"\n        \n        if n == 22:\n            return \"132113213211231132122211231132122211211131221\"\n        \n        if n == 23:\n            return \"11131221131213211231132122211231132122211231131221\"\n        \n        if n == 24:\n            return \"311311222123113213211231132122211231132122211211131221\"\n        \n        if n == 25:\n            return \"13"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max element in the array\n        # find the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the array\n        # binary search the min element in the array\n        # binary search the max element in the"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the pivot\n        # if target is in the left part of the pivot, search in the left part\n        # if target is in the right part of the pivot, search in the right part\n        # if target is not in the left part of the pivot, search in the right part\n        # if target is not in the right part of the pivot, search in the left part\n        \n        # find the pivot\n        left = 0\n        right = len(nums) - 1\n        pivot = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                pivot = mid + 1\n                break\n            elif nums[mid] < nums[mid - 1]:\n                pivot = mid\n                break\n            else:\n                if nums[mid] > nums[left]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        # if target is not in the left part of the pivot, search in the right part\n        if target < nums[0]:\n            left = pivot\n            right = len(nums) - 1\n        else:\n            left = 0\n            right = pivot - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        # 2 -> 3\n        # 3 -> 4\n        # 4 -> 5\n        # 5 -> 6\n        # 6 -> 7\n        # 7 -> 8\n        # 8 -> 9\n        # 9 -> 9\n        \n        # 2 -> abc\n        # 3 -> def\n        # 4 -> ghi\n        # 5 -> jkl\n        # 6 -> mno\n        # 7 -> pqrs\n        # 8 -> tuv\n        # 9 -> wxyz\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        # 6 -> m, n, o\n        # 7 -> p, q, r, s\n        # 8 -> t, u, v\n        # 9 -> w, x, y, z\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        # 6 -> m, n, o\n        # 7 -> p, q, r, s\n        # 8 -> t, u, v\n        # 9 -> w, x, y, z\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        # 6 -> m, n, o\n        # 7 -> p, q, r, s\n        # 8 -> t, u, v\n        # 9 -> w, x, y, z\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        # 6 -> m, n, o\n        # 7 -> p, q, r, s\n        # 8 -> t, u, v\n        # 9 -> w, x, y, z\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        # 6 -> m, n, o\n        # 7 -> p, q, r, s\n        # 8 -> t, u, v\n        # 9 -> w, x, y, z\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        # 6 -> m, n, o\n        # 7 -> p, q, r, s\n        # 8 -> t, u, v\n        # 9 -> w, x, y, z\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        # 6 -> m, n, o\n        # 7 -> p, q, r, s\n        # 8 -> t, u, v\n        # 9 -> w, x, y, z\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        # 6 -> m, n, o\n        # 7 -> p, q, r, s\n        # 8 -> t, u, v\n        # 9 -> w, x, y, z\n        \n        # 2 -> a, b, c\n        # 3 -> d, e, f\n        # 4 -> g, h, i\n        # 5 -> j, k, l\n        #"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()\n        \n        # initialize the result array\n        result = []\n        \n        # initialize the current combination\n        current = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # loop through the candidates\n        while index < len(candidates):\n            \n            # if the current sum is less than the target\n            if current_sum < target:\n                \n                # add the current candidate to the current combination\n                current.append(candidates[index])\n                \n                # add the current candidate to the result array\n                result.append(current.copy())\n                \n                # add the current candidate to the current sum\n                current_sum += candidates[index]\n                \n                # increment the index\n                index += 1\n                \n            # if the current sum is equal to the target\n            elif current_sum == target:\n                \n                # add the current combination to the result array\n                result.append(current.copy())\n                \n                # add the current candidate to the current sum\n                current_sum += candidates[index]\n                \n                # increment the index\n                index += 1\n                \n            # if the current sum is greater than the target\n            else:\n                \n                # decrement the index\n                index -= 1\n                \n                # remove the last element from the current combination\n                current.pop()\n                \n                # remove the last element from the current sum\n                current_sum -= candidates[index]\n                \n                # increment the index\n                index += 1\n                \n        return result"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest palindrome is the largest palindrome, return the largest palindrome\n        # 4. If the nearest palindrome is the smallest palindrome, return the smallest palindrome\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is the same as the input, return the smaller palindrome\n        # 3. If the nearest"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Initialize the matrix with zeros\n        matrix = [[0] * n for _ in range(n)]\n        \n        # 2. Initialize the direction and the current position\n        direction = 0\n        row = 0\n        col = 0\n        \n        # 3. Initialize the counter for the matrix\n        count = 1\n        \n        # 4. Loop until the matrix is filled\n        while count <= n * n:\n            # 4.1 Move in the direction\n            if direction == 0:\n                # Move right\n                matrix[row][col] = count\n                col += 1\n                count += 1\n            elif direction == 1:\n                # Move down\n                matrix[row][col] = count\n                row += 1\n                count += 1\n            elif direction == 2:\n                # Move left\n                matrix[row][col] = count\n                col -= 1\n                count += 1\n            else:\n                # Move up\n                matrix[row][col] = count\n                row -= 1\n                count += 1\n            \n            # 4.2 Check if the matrix is filled\n            if count > n * n:\n                break\n            \n            # 4.3 Update the direction\n            if col == n - 1:\n                direction = 1\n            elif row == n - 1:\n                direction = 2\n            elif col == 0:\n                direction = 3\n            elif row == 0:\n                direction = 0\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2. Reverse each row\n        ## 3. Swap the rows\n        \n        ## 1. Transpose the matrix\n        ## 2"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it can be crossed\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is 0, then it can't be crossed\n        if stones[-1] == 0:\n            return False\n        \n        # if the"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score array\n        sorted_score = sorted(score, reverse=True)\n        \n        # create a hashmap to store the index of each score\n        score_index = {}\n        for i in range(len(sorted_score)):\n            score_index[sorted_score[i]] = i\n        \n        # create a hashmap to store the rank of each score\n        rank_map = {}\n        for i in range(len(sorted_score)):\n            rank_map[sorted_score[i]] = i + 1\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):\n            if score[i] in rank_map:\n                rank_list.append(rank_map[score[i]])\n            else:\n                rank_list.append(score_index[score[i]] + 1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for i in range(len(score)):"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # 1. set up a window\n        # 2. iterate through the string\n        # 3. if the character is not in the window, add it\n        # 4. if the character is in the window, move the window to the right until the character is not in the window\n        # 5. update the max length\n        \n        # set up a window\n        window = set()\n        max_length = 0\n        left = 0\n        \n        # iterate through the string\n        for right in range(len(s)):\n            # if the character is not in the window, add it\n            if s[right] not in window:\n                window.add(s[right])\n            # if the character is in the window, move the window to the right until the character is not in the window\n            else:\n                while s[right] in window:\n                    window.remove(s[left])\n                    left += 1\n                window.add(s[right])\n            # update the max length\n            max_length = max(max_length, right - left + 1)\n        \n        return max_length"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Edge case\n        if len(words) == 0:\n            return []\n        \n        # Edge case\n        if len(s) == 0:\n            return []\n        \n        # Edge case\n        if len(words) * len(words[0]) > len(s):\n            return []\n        \n        # Edge case\n        if len(words) * len(words[0]) == len(s):\n            return [0]\n        \n        # Edge case\n        if len(words) == 1:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0]]\n        \n        # Edge case\n        if len(words) == 2:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1]]\n        \n        # Edge case\n        if len(words) == 3:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2]]\n        \n        # Edge case\n        if len(words) == 4:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2] and s[i+3*len(words[0]):i+4*len(words[0])] == words[3]]\n        \n        # Edge case\n        if len(words) == 5:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2] and s[i+3*len(words[0]):i+4*len(words[0])] == words[3] and s[i+4*len(words[0]):i+5*len(words[0])] == words[4]]\n        \n        # Edge case\n        if len(words) == 6:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2] and s[i+3*len(words[0]):i+4*len(words[0])] == words[3] and s[i+4*len(words[0]):i+5*len(words[0])] == words[4] and s[i+5*len(words[0]):i+6*len(words[0])] == words[5]]\n        \n        # Edge case\n        if len(words) == 7:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2] and s[i+3*len(words[0]):i+4*len(words[0])] == words[3] and s[i+4*len(words[0]):i+5*len(words[0])] == words[4] and s[i+5*len(words[0]):i"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the max element in the array\n        # 2. Find the index of the max element\n        # 3. Find the max element in the array from the index of the max element\n        # 4. Find the index of the max element from the index of the max element\n        # 5. Repeat steps 2 and 3 until the max element is the last element in the array\n        # 6. Return the number of chunks\n        \n        # 1. Find the max element in the array\n        max_element = max(arr)\n        \n        # 2. Find the index of the max element\n        max_element_index = arr.index(max_element)\n        \n        # 3. Find the max element in the array from the index of the max element\n        max_element_from_max_element_index = max(arr[max_element_index:])\n        \n        # 4. Find the index of the max element from the index of the max element\n        max_element_from_max_element_index_index = arr[max_element_index:].index(max_element_from_max_element_index)\n        \n        # 5. Repeat steps 2 and 3 until the max element is the last element in the array\n        max_element_index += max_element_from_max_element_index_index\n        \n        # 6. Return the number of chunks\n        return (max_element_index + 1) // len(arr)"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         if curr == head:\n        #             head = temp\n        #         else:\n        #             prev.next = temp\n        #         curr = dummy.next\n        # return head\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         if curr == head:\n        #             head = temp\n        #         else:\n        #             prev.next = temp\n        #         curr = dummy.next\n        # return head\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         if curr == head:\n        #             head = temp\n        #         else:\n        #             prev.next = temp\n        #         curr = dummy.next\n        # return head\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         if curr == head:\n        #             head = temp\n        #         else:\n        #             prev.next = temp\n        #         curr = dummy.next\n        # return head\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # prev = dummy\n        # curr = head\n        \n        # while curr:\n        #     if curr.next and curr.val == curr.next.val:\n        #         while curr.next and curr.val == curr.next.val:\n        #             curr = curr.next\n        #         prev.next = curr.next\n        #         curr = curr.next\n        #     else:\n        #         prev = curr\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # prev = dummy\n        # curr = head\n        \n        # while curr:\n        #     if curr.next and curr.val == curr.next.val:\n        #         while curr.next and curr.val == curr.next.val:\n        #             curr = curr.next\n        #         prev.next = curr.next\n        #         curr = curr.next\n        #     else:\n        #         prev = curr\n        #         curr = curr.next\n        # return dummy.next\n        \n        if head is None or head.next is None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n                curr = curr.next\n            else:\n                prev = curr\n                curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        # print(nums)\n        # print(nums[0])\n        # print(nums[1])\n        # print(nums[2])\n        # print(nums[3])\n        # print(nums[4])\n        # print(nums[5])\n        # print(nums[6])\n        # print(nums[7])\n        # print(nums[8])\n        # print(nums[9])\n        # print(nums[10])\n        # print(nums[11])\n        # print(nums[12])\n        # print(nums[13])\n        # print(nums[14])\n        # print(nums[15])\n        # print(nums[16])\n        # print(nums[17])\n        # print(nums[18])\n        # print(nums[19])\n        # print(nums[20])\n        # print(nums[21])\n        # print(nums[22])\n        # print(nums[23])\n        # print(nums[24])\n        # print(nums[25])\n        # print(nums[26])\n        # print(nums[27])\n        # print(nums[28])\n        # print(nums[29])\n        # print(nums[30])\n        # print(nums[31])\n        # print(nums[32])\n        # print(nums[33])\n        # print(nums[34])\n        # print(nums[35])\n        # print(nums[36])\n        # print(nums[37])\n        # print(nums[38])\n        # print(nums[39])\n        # print(nums[40])\n        # print(nums[41])\n        # print(nums[42])\n        # print(nums[43])\n        # print(nums[44])\n        # print(nums[45])\n        # print(nums[46])\n        # print(nums[47])\n        # print(nums[48])\n        # print(nums[49])\n        # print(nums[50])\n        # print(nums[51])\n        # print(nums[52])\n        # print(nums[53])\n        # print(nums[54])\n        # print(nums[55])\n        # print(nums[56])\n        # print(nums[57])\n        # print(nums[58])\n        # print(nums[59])\n        # print(nums[60])\n        # print(nums[61])\n        # print(nums[62])\n        # print(nums[63])\n        # print(nums[64])\n        # print(nums[65])\n        # print(nums[66])\n        # print(nums[67])\n        # print(nums[68])\n        # print(nums[69])\n        # print(nums[70])\n        # print(nums[71])\n        # print(nums[72])\n        # print(nums[73])\n        # print(nums[74])\n        # print(nums[75])\n        # print(nums[76])\n        # print(nums[77])\n        # print(nums[78])\n        # print(nums[79])\n        # print(nums[80])\n        # print(nums[81])\n        # print(nums[82])\n        # print(nums[83])\n        # print(nums[84])\n        # print(nums[85])\n        # print(nums[86])\n        # print(nums[87])\n        # print(nums[88])\n        # print(nums[89])\n        # print(nums[90])\n        # print(nums[91])"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        if len(word1) == 0:\n            return len(word2)\n        \n        # if word2 is empty, then we need to delete all the characters of word1\n        if len(word2) == 0:\n            return len(word1)\n        \n        # if both words are empty, then we need to insert all the characters of word2\n        if len(word1) == 0 and len(word2) == 0:\n            return 0\n        \n        # if the last characters of both words are same, then we don'\n        # need to delete the last character of word1\n        if word1[-1] == word2[-1]:\n            return self.minDistance(word1[:-1], word2[:-1])\n        \n        # if the last characters of both words are not same, then we need to\n        # insert the last character of word1\n        return 1 + min(self.minDistance(word1[:-1], word2),\n                       self.minDistance(word1, word2[:-1]),\n                       self.minDistance(word1[:-1], word2[:-1]))"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                if ty > sy:\n                    tx = tx % ty\n                else:\n                    tx = tx % sy\n            else:\n                if tx > sx:\n                    ty = ty % tx\n                else:\n                    ty = ty % sx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        if len(v1) > len(v2):\n            v2.extend(['0'] * (len(v1) - len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend(['0'] * (len(v2) - len(v1)))\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # loop through courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total time\n            total += course[0]\n            \n            # if total time exceeds course duration\n            if total > course[1]:\n                # pop from priority queue\n                total -= heapq.heappop(pq)\n                \n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Edge case\n        if not head:\n            return None\n        \n        # Initialize the dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # Initialize the current node and the previous node\n        curr = dummy\n        prev = dummy\n        \n        # Initialize the count\n        count = 0\n        \n        # Loop through the list\n        while curr:\n            # Increment the count\n            count += 1\n            \n            # If the count is divisible by k\n            if count % k == 0:\n                # Initialize the next node\n                next_node = curr.next\n                \n                # Reverse the nodes\n                prev = self.reverse(prev, curr)\n                \n                # Update the current node\n                curr = next_node\n                \n            # Otherwise, move to the next node\n            else:\n                curr = curr.next\n                \n        # Return the dummy node\n        return dummy.next\n    \n    def reverse(self, prev, curr):\n        # Initialize the previous node\n        prev_node = prev.next\n        \n        # Initialize the current node\n        curr_node = curr.next\n        \n        # Loop through the list\n        while curr_node:\n            # Initialize the next node\n            next_node = curr_node.next\n            \n            # Reverse the nodes\n            curr_node.next = prev_node\n            \n            # Update the previous node\n            prev_node = curr_node\n            \n            # Update the current node\n            curr_node = next_node\n            \n        # Return the previous node\n        return prev_node"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # if len(s) == 2:\n        #     return False\n        \n        # if len(s) == 1:\n        #     return False\n        \n        # if len(s) == 3:\n        #     return False\n        \n        # if len(s) == 4:\n        #     return False\n        \n        # if len(s) == 5:\n        #     return False\n        \n        # if len(s) == 6:\n        #     return False\n        \n        # if len(s) == 7:\n        #     return False\n        \n        # if len(s) == 8:\n        #     return False\n        \n        # if len(s) == 9:\n        #     return False\n        \n        # if len(s) == 10:\n        #     return False\n        \n        # if len(s) == 11:\n        #     return False\n        \n        # if len(s) == 12:\n        #     return False\n        \n        # if len(s) == 13:\n        #     return False\n        \n        # if len(s) == 14:\n        #     return False\n        \n        # if len(s) == 15:\n        #     return False\n        \n        # if len(s) == 16:\n        #     return False\n        \n        # if len(s) == 17:\n        #     return False\n        \n        # if len(s) == 18:\n        #     return False\n        \n        # if len(s) == 19:\n        #     return False\n        \n        # if len(s) == 20:\n        #     return False\n        \n        # if len(s) == 21:\n        #     return False\n        \n        # if len(s) == 22:\n        #     return False\n        \n        # if len(s) == 23:\n        #     return False\n        \n        # if len(s) == 24:\n        #     return False\n        \n        # if len(s) == 25:\n        #     return False\n        \n        # if len(s) == 26:\n        #     return False\n        \n        # if len(s) == 27:\n        #     return False\n        \n        # if len(s) == 28:\n        #     return False\n        \n        # if len(s) == 29:\n        #     return False\n        \n        # if len(s) == 30:\n        #     return False\n        \n        # if len(s) == 31:\n        #     return False\n        \n        # if len(s) == 32:\n        #     return False\n        \n        # if len(s) == 33:\n        #     return False\n        \n        # if len(s) == 34:\n        #     return False\n        \n        # if len(s) == 35:\n        #     return False\n        \n        # if len(s) == 36:\n        #     return False\n        \n        # if len(s) == 37:\n        #     return False\n        \n        # if len(s) == 38:\n        #     return False\n        \n        # if len(s) == 39:\n        #     return False\n        \n        # if len(s) == 40:\n        #     return False\n        \n        # if len(s) == 41:\n        #     return False\n        \n        # if len(s) == 42:\n        #     return False\n        \n        # if len(s) == 43:\n        #     return False\n        \n        # if len(s) == 44:\n        #     return False\n        \n        # if len(s) == 45:\n        #     return False\n        \n        # if len(s) == 46:\n        #     return False\n        \n        # if len(s) == 47:\n        #     return False\n        \n        # if len(s) == 48:\n        #     return False\n        \n        # if len(s) == 49:\n        #     return False\n        \n        # if len(s) == 50:\n        #     return False\n        \n        # if len(s) == 51"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[0]*2 + dp[i-1]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[0]*2 + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + ... + dp[i"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1st approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Build a map of the target letters and their frequencies\n        target_map = {}\n        for letter in target:\n            target_map[letter] = target_map.get(letter, 0) + 1\n        \n        # 2. Build a map of the sticker letters and their frequencies\n        sticker_map = {}\n        for sticker in stickers:\n            sticker_map[sticker] = sticker_map.get(sticker, 0) + 1\n        \n        # 3. Build a map of the sticker letters and their frequencies\n        sticker_map_copy = sticker_map.copy()\n        \n        # 4. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_2 = sticker_map_copy.copy()\n        \n        # 5. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_3 = sticker_map_copy.copy()\n        \n        # 6. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_4 = sticker_map_copy.copy()\n        \n        # 7. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_5 = sticker_map_copy.copy()\n        \n        # 8. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_6 = sticker_map_copy.copy()\n        \n        # 9. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_7 = sticker_map_copy.copy()\n        \n        # 10. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_8 = sticker_map_copy.copy()\n        \n        # 11. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_9 = sticker_map_copy.copy()\n        \n        # 12. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_10 = sticker_map_copy.copy()\n        \n        # 13. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_11 = sticker_map_copy.copy()\n        \n        # 14. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_12 = sticker_map_copy.copy()\n        \n        # 15. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_13 = sticker_map_copy.copy()\n        \n        # 16. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_14 = sticker_map_copy.copy()\n        \n        # 17. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_15 = sticker_map_copy.copy()\n        \n        # 18. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_16 = sticker_map_copy.copy()\n        \n        # 19. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_17 = sticker_map_copy.copy()\n        \n        # 20. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_18 = sticker_map_copy.copy()\n        \n        # 21. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_19 = sticker_map_copy.copy()\n        \n        # 22. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_20 = sticker_map_copy.copy()\n        \n        # 23. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_21 = sticker_map_copy.copy()\n        \n        # 24. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_22 = sticker_map_copy.copy()\n        \n        # 25. Build a map of the sticker letters and their frequencies\n        sticker_map_copy_"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] ="}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3. if the square of the square root is less than x, then the square root is the answer\n        # 4. else, the square root is the answer\n        \n        # 1. find the square root of x\n        # 2. find the square of the square root\n        # 3"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Create a dictionary with the roman numerals and their values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # 2. Initialize the result variable\n        result = 0\n        \n        # 3. Iterate over the string\n        for i in range(len(s)):\n            # 4. If the current character is the last character, add its value to the result\n            if i == len(s) - 1:\n                result += roman_dict[s[i]]\n            # 5. If the current character is not the last character, check if the current character is less than the next character\n            elif roman_dict[s[i]] < roman_dict[s[i+1]]:\n                # 6. If the current character is less than the next character, subtract the value of the current character from the result\n                result -= roman_dict[s[i]]\n            # 7. If the current character is not less than the next character, add the value of the current character to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # 8. Return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Create a hashmap\n        # Iterate through the array\n        # If the element is already in the hashmap, return True\n        # Otherwise, add the element to the hashmap\n        # Return False if the loop completes\n        \n        # Create a hashmap\n        hashmap = {}\n        \n        # Iterate through the array\n        for num in nums:\n            # If the element is already in the hashmap, return True\n            if num in hashmap:\n                return True\n            # Otherwise, add the element to the hashmap\n            hashmap[num] = 1\n        \n        # Return False if the loop completes\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # sliding window\n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the deque is empty, add the first element to it\n        # 4. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 5. if the element at the front of the deque is greater than the element at the back of the deque, add the element at the back of the deque to the deque\n        # 6. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 7. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 8. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 9. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 10. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 11. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 12. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 13. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 14. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 15. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 16. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 17. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 18. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 19. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 20. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 21. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 22. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 23. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of the deque\n        # 24. if the deque is not empty, and the element at the front of the deque is greater than the element at the back of the deque, pop the front of the deque\n        # 25. if the deque is not empty, and the element at the front of the deque is less than the element at the back of the deque, pop the front of"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1,"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # if rowIndex == 2:\n        #     return [1,2,1]\n        # if rowIndex == 3:\n        #     return [1,3,3,1]\n        # if rowIndex == 4:\n        #     return [1,4,6,4,1]\n        # if rowIndex == 5:\n        #     return [1,5,10,10,5,1]\n        # if rowIndex == 6:\n        #     return [1,6,15,20,15,6,1]\n        # if rowIndex == 7:\n        #     return [1,7,21,35,35,21,7,1]\n        # if rowIndex == 8:\n        #     return [1,8,28,56,70,56,28,8,1]\n        # if rowIndex == 9:\n        #     return [1,9,36,84,126,126,84,36,9,1]\n        # if rowIndex == 10:\n        #     return [1,10,45,120,210,252,210,120,45,10,1]\n        # if rowIndex == 11:\n        #     return [1,11,55,165,320,435,435,320,165,55,11,1]\n        # if rowIndex == 12:\n        #     return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        # if rowIndex == 13:\n        #     return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        # if rowIndex == 14:\n        #     return [1,14,88,343,864,1650,2435,2800,2435,1650,864,343,88,14,1]\n        # if rowIndex == 15:\n        #     return [1,15,99,414,1001,2002,3003,3430,3003,2002,1001,414,99,15,1]\n        # if rowIndex == 16:\n        #     return [1,16,100,455,1200,2500,4142,5660,5660,4142,2500,1200,455,100,16,1]\n        # if rowIndex == 17:\n        #     return [1,17,111,514,1560,3500,5605,7007,6603,5605,3500,1560,514,111,17,1]\n        # if rowIndex == 18:\n        #     return [1,18,122,615,2002,4862,9245,12375,12375,9245,4862,2002,615,122,18,1]\n        # if rowIndex == 19:\n        #     return [1,19,133,666,2640,7152,12316,16728,18240,16728,12316,7152,2640,666,133,19,1]\n        # if rowIndex == 20:\n        #     return [1,2"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        \n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        \n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        \n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        \n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        \n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        \n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        \n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        \n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        \n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        \n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        \n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        \n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        \n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        \n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        \n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        \n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        \n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        \n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        \n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        \n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        \n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        \n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        \n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        \n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == endWord:\n                    res.append([])\n                    break\n                for i in range(len(curr)):\n                    for j in range(26):\n                        neighbor = curr[:i] + chr(ord(\"a\") + j) + curr[i+1:]\n                        if neighbor in graph:\n                            for word in graph[neighbor]:\n                                if word not in visited:\n                                    visited.add(word)\n                                    queue.append(word)\n            if len(queue) == 0:\n                break\n        \n        # Build the result\n        if len(res) == 0:\n            return []\n        res = res[::-1]\n        res = [list(reversed(r)) for r in res]\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if root is None:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the result array\n        result = [[]]\n        \n        # initialize the current subset\n        current_subset = []\n        \n        # initialize the index\n        i = 0\n        \n        # loop through the array\n        while i < len(nums):\n            \n            # if the current subset is empty\n            if not current_subset:\n                \n                # add the current element to the current subset\n                current_subset.append(nums[i])\n                \n                # add the current subset to the result array\n                result.append(current_subset)\n                \n                # increment the index\n                i += 1\n                \n            # if the current element is not the same as the previous element\n            elif nums[i] != nums[i-1]:\n                \n                # add the current element to the current subset\n                current_subset.append(nums[i])\n                \n                # add the current subset to the result array\n                result.append(current_subset)\n                \n                # reset the current subset\n                current_subset = []\n                \n                # increment the index\n                i += 1\n                \n            # if the current element is the same as the previous element\n            else:\n                \n                # increment the index\n                i += 1\n                \n        # return the result array\n        return result"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. Find the four corners of the rectangle\n        ## 2. Find the area of the rectangle\n        ## 3. Find the area of the rectangle minus the area of the corners\n        ## 4. If the area of the rectangle minus the area of the corners is not equal to the area of the rectangle, return False\n        ## 5. If the area of the rectangle minus the area of the corners is equal to the area of the rectangle, return True\n        \n        ## 1. Find the four corners of the rectangle\n        x1, y1, x2, y2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n        for rect in rectangles:\n            x1 = min(x1, rect[0])\n            y1 = min(y1, rect[1])\n            x2 = max(x2, rect[2])\n            y2 = max(y2, rect[3])\n        \n        ## 2. Find the area of the rectangle\n        area = (x2 - x1) * (y2 - y1)\n        \n        ## 3. Find the area of the rectangle minus the area of the corners\n        corners = set()\n        for rect in rectangles:\n            corners.add((rect[0], rect[1]))\n            corners.add((rect[2], rect[1]))\n            corners.add((rect[0], rect[3]))\n            corners.add((rect[2], rect[3]))\n        \n        ## 4. If the area of the rectangle minus the area of the corners is not equal to the area of the rectangle, return False\n        if area - len(corners) != (x2 - x1) * (y2 - y1):\n            return False\n        \n        ## 5. If the area of the rectangle minus the area of the corners is equal to the area of the rectangle, return True\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # max_sum = nums[0]\n        # for i in range(len(nums)):\n        #     curr_sum = nums[i]\n        #     for j in range(i+1, len(nums)):\n        #         curr_sum += nums[j]\n        #         max_sum = max(max_sum, curr_sum)\n        # return max_sum\n        \n        # 2. Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        max_sum = nums[0]\n        curr_sum = nums[0]\n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n        return max_sum\n        \n        # 3. Dynamic Programming\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # max_sum = nums[0]\n        # curr_sum = nums[0]\n        # for i in range(1, len(nums)):\n        #     curr_sum = max(nums[i], curr_sum + nums[i])\n        #     max_sum = max(max_sum, curr_sum)\n        # return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the empty square\n        ## 2. Find the 5 numbers\n        ## 3. Find the 5 numbers in the correct order\n        ## 4. Find the 5 numbers in the correct order\n        ## 5. Find the 5 numbers in the correct order\n        ## 6. Find the 5 numbers in the correct order\n        ## 7. Find the 5 numbers in the correct order\n        ## 8. Find the 5 numbers in the correct order\n        ## 9. Find the 5 numbers in the correct order\n        ## 10. Find the 5 numbers in the correct order\n        ## 11. Find the 5 numbers in the correct order\n        ## 12. Find the 5 numbers in the correct order\n        ## 13. Find the 5 numbers in the correct order\n        ## 14. Find the 5 numbers in the correct order\n        ## 15. Find the 5 numbers in the correct order\n        ## 16. Find the 5 numbers in the correct order\n        ## 17. Find the 5 numbers in the correct order\n        ## 18. Find the 5 numbers in the correct order\n        ## 19. Find the 5 numbers in the correct order\n        ## 20. Find the 5 numbers in the correct order\n        ## 21. Find the 5 numbers in the correct order\n        ## 22. Find the 5 numbers in the correct order\n        ## 23. Find the 5 numbers in the correct order\n        ## 24. Find the 5 numbers in the correct order\n        ## 25. Find the 5 numbers in the correct order\n        ## 26. Find the 5 numbers in the correct order\n        ## 27. Find the 5 numbers in the correct order\n        ## 28. Find the 5 numbers in the correct order\n        ## 29. Find the 5 numbers in the correct order\n        ## 30. Find the 5 numbers in the correct order\n        ## 31. Find the 5 numbers in the correct order\n        ## 32. Find the 5 numbers in the correct order\n        ## 33. Find the 5 numbers in the correct order\n        ## 34. Find the 5 numbers in the correct order\n        ## 35. Find the 5 numbers in the correct order\n        ## 36. Find the 5 numbers in the correct order\n        ## 37. Find the 5 numbers in the correct order\n        ## 38. Find the 5 numbers in the correct order\n        ## 39. Find the 5 numbers in the correct order\n        ## 40. Find the 5 numbers in the correct order\n        ## 41. Find the 5 numbers in the correct order\n        ## 42. Find the 5 numbers in the correct order\n        ## 43. Find the 5 numbers in the correct order\n        ## 44. Find the 5 numbers in the correct order\n        ## 45. Find the 5 numbers in the correct order\n        ## 46. Find the 5 numbers in the correct order\n        ## 47. Find the 5 numbers in the correct order\n        ## 48. Find the 5 numbers in the correct order\n        ## 49. Find the 5 numbers in the correct order\n        ## 50. Find the 5 numbers in the correct order\n        ## 51. Find the 5 numbers in the correct order\n        ## 52. Find the 5 numbers in the correct order\n        ## 53. Find the 5 numbers in the correct order\n        ## 54. Find the 5 numbers in the correct order\n        ## 55. Find the 5 numbers in the correct order\n        ## 56. Find the 5 numbers in the correct order\n        ## 57. Find the 5 numbers in the correct order\n        ## 58. Find the 5 numbers in the correct order\n        ## 59. Find the 5 numbers in the correct order\n        ## 60. Find the 5 numbers in the correct order\n        ## 61. Find the 5 numbers in the correct order\n        ## 6"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary search in the right part\n        # if target is not in the left part and right part, then do binary search in the left part\n        \n        # find the pivot\n        # if target is in the left part, then do binary search in the left part\n        # if target is in the right part, then do binary"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        # for i in range(1, len(obstacleGrid)):\n        #     if obstacleGrid[i][0] == 1:\n        #         obstacleGrid[i][0] = 0\n        #     else:\n        #         obstacleGrid[i][0] = obstacleGrid[i-1][0]\n        # for i in range(1, len(obstacleGrid[0])):\n        #     if obstacleGrid[0][i] == 1:\n        #         obstacleGrid[0][i] = 0\n        #     else:\n        #         obstacleGrid[0][i] = obstacleGrid[0][i-1]\n        # for i in range(1, len(obstacleGrid)):\n        #     for j in range(1, len(obstacleGrid[0])):\n        #         if obstacleGrid[i][j] == 1:\n        #             obstacleGrid[i][j] = 0\n        #         else:\n        #             obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n        # return obstacleGrid[-1][-1]\n        \n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        # for i in range(1, len(obstacleGrid)):\n        #     if obstacleGrid[i][0] == 1:\n        #         obstacleGrid[i][0] = 0\n        #     else:\n        #         obstacleGrid[i][0] = obstacleGrid[i-1][0]\n        # for i in range(1, len(obstacleGrid[0])):\n        #     if obstacleGrid[0][i] == 1:\n        #         obstacleGrid[0][i] = 0\n        #     else:\n        #         obstacleGrid[0][i] = obstacleGrid[0][i-1]\n        # for i in range(1, len(obstacleGrid)):\n        #     for j in range(1, len(obstacleGrid[0])):\n        #         if obstacleGrid[i][j] == 1:\n        #             obstacleGrid[i][j] = 0\n        #         else:\n        #             obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n        # return obstacleGrid[-1][-1]\n        \n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        # for i in range(1, len(obstacleGrid)):\n        #     if obstacleGrid[i][0] == 1:\n        #         obstacleGrid[i][0] = 0\n        #     else:\n        #         obstacleGrid[i][0] = obstacleGrid[i-1][0]\n        # for i in range(1, len(obstacleGrid[0])):\n        #     if obstacleGrid[0][i] == 1:\n        #         obstacleGrid[0][i] = 0\n        #     else:\n        #         obstacleGrid[0][i] = obstacleGrid[0][i-1]\n        # for i in range(1, len(obstacleGrid)):\n        #     for j in range(1, len(obstacleGrid[0])):\n        #         if obstacleGrid[i][j] == 1:\n        #             obstacleGrid[i][j] = 0\n        #         else:\n        #             obstacleGrid[i][j] = obstacleGrid[i-1][j] +"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if the first character is 0, return 0\n        if s[0] == '0':\n            return 0\n        \n        # if the string is empty, return 0\n        if not s:\n            return 0\n        \n        # if the string has only one character, return 1\n        if len(s) == 1:\n            return 1\n        \n        # initialize the number of ways to decode the string\n        num_ways = 0\n        \n        # initialize the number of ways to decode the string\n        num_ways_prev = 1\n        \n        # initialize the number of ways to decode the string\n        num_ways_prev_prev = 0\n        \n        # loop through the string\n        for i in range(len(s)):\n            \n            # if the current character is 0, return 0\n            if s[i] == '0':\n                return 0\n            \n            # if the current character is 1, return the number of ways to decode the string\n            if s[i] == '1':\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current character is 2, return the number of ways to decode the string\n            if s[i] == '2' and i + 1 < len(s) and s[i + 1] in ['0', '1', '2']:\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current character is 3, return the number of ways to decode the string\n            if s[i] == '3' and i + 1 < len(s) and s[i + 1] in ['0', '1', '2']:\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current character is 4, return the number of ways to decode the string\n            if s[i] == '4' and i + 1 < len(s) and s[i + 1] in ['0', '1', '2', '3']:\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current character is 5, return the number of ways to decode the string\n            if s[i] == '5' and i + 1 < len(s) and s[i + 1] in ['0', '1', '2', '3', '4']:\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current character is 6, return the number of ways to decode the string\n            if s[i] == '6' and i + 1 < len(s) and s[i + 1] in ['0', '1', '2', '3', '4', '5']:\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current character is 7, return the number of ways to decode the string\n            if s[i] == '7' and i + 1 < len(s) and s[i + 1] in ['0', '1', '2', '3', '4', '5', '6']:\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current character is 8, return the number of ways to decode the string\n            if s[i] == '8' and i + 1 < len(s) and s[i + 1] in ['0', '1', '2', '3', '4', '5', '6', '7']:\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # if the current character is 9, return the number of ways to decode the string\n            if s[i] == '9' and i + 1 < len(s) and s[i + 1] in ['0', '1', '2', '3', '4', '5', '6', '7', '8']:\n                num_ways = num_ways_prev + num_ways_prev_prev\n            \n            # update the number of ways to decode the string\n            num_ways_prev_prev = num_ways_prev\n            num_ways_prev = num_ways\n            \n        # return the number of ways to decode the string"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the closest sum\n        closest_sum = nums[0] + nums[1] + nums[2]\n        \n        # initialize the closest difference\n        closest_diff = abs(target - closest_sum)\n        \n        # loop through the array\n        for i in range(len(nums) - 2):\n            \n            # initialize the left and right pointers\n            left = i + 1\n            right = len(nums) - 1\n            \n            # loop through the array\n            while left < right:\n                \n                # calculate the sum\n                sum = nums[i] + nums[left] + nums[right]\n                \n                # calculate the difference\n                diff = abs(target - sum)\n                \n                # if the difference is less than the closest difference\n                if diff < closest_diff:\n                    \n                    # update the closest sum\n                    closest_sum = sum\n                    \n                    # update the closest difference\n                    closest_diff = diff\n                    \n                # if the sum is less than the target\n                if sum < target:\n                    \n                    # increment the left pointer\n                    left += 1\n                    \n                # if the sum is greater than the target\n                else:\n                    \n                    # decrement the right pointer\n                    right -= 1\n                    \n        # return the closest sum\n        return closest_sum"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        # else:\n        #     return"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     return self.intersect(nums2, nums1)\n        \n        # if len(nums1) == 0 or len(nums2) == 0:\n        #     return []\n        \n        # if len(nums1) == 1 and len(nums2) == 1:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 1:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums2) == 1:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 2 and len(nums2) == 2:\n        #     if nums1[0] == nums2[0] and nums1[1] == nums2[1]:\n        #         return [nums1[0], nums1[1]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 2 and len(nums2) == 3:\n        #     if nums1[0] == nums2[0] or nums1[0] == nums2[1] or nums1[0] == nums2[2]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 3 and len(nums2) == 2:\n        #     if nums1[0] == nums2[0] or nums1[0] == nums2[1] or nums1[0] == nums2[2]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 3 and len(nums2) == 3:\n        #     if nums1[0] == nums2[0] or nums1[0] == nums2[1] or nums1[0] == nums2[2] or nums1[1] == nums2[0] or nums1[1] == nums2[1] or nums1[1] == nums2[2] or nums1[2] == nums2[0] or nums1[2] == nums2[1] or nums1[2] == nums2[2]:\n        #         return [nums1[0], nums1[1], nums1[2]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 4 and len(nums2) == 2:\n        #     if nums1[0] == nums2[0] or nums1[0] == nums2[1] or nums1[1] == nums2[0] or nums1[1] == nums2[1]:\n        #         return [nums1[0], nums1[1]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 4 and len(nums2) == 3:\n        #     if nums1[0] == nums2[0] or nums1[0] == nums2[1] or nums1[0] == nums2[2] or nums1[1] == nums2[0] or nums1[1] == nums2[1] or nums1[1] == nums2[2] or nums1[2] == nums2[0] or nums1[2] == nums2[1] or nums1[2] == nums2[2] or nums1[3] == nums2[0] or nums1[3] == nums2[1] or nums1[3] == nums2[2]:\n        #         return ["}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # return the min difference\n        \n        # inorder traversal"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Approach 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 12:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 13:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 14:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 15:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 16:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 17:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 18:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 19:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 20:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 21:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 22:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 23:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 24:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 25:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 26:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 27:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 2"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is equal to haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Check if password is at least 6 characters long\n        if len(password) < 6:\n            return max(6 - len(password), 3)\n        \n        # 2. Check if password is at most 20 characters long\n        if len(password) > 20:\n            return max(20 - len(password), 3)\n        \n        # 3. Check if password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        lowercase_count = 0\n        uppercase_count = 0\n        digit_count = 0\n        for char in password:\n            if char.islower():\n                lowercase_count += 1\n            elif char.isupper():\n                uppercase_count += 1\n            elif char.isdigit():\n                digit_count += 1\n        \n        if lowercase_count == 0 or uppercase_count == 0 or digit_count == 0:\n            return max(3 - lowercase_count - uppercase_count - digit_count, 3)\n        \n        # 4. Check if password contains three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong)\n        # 4.1 Find the number of repeating characters in a row\n        repeating_characters_count = 0\n        prev_char = None\n        for char in password:\n            if char == prev_char:\n                repeating_characters_count += 1\n            else:\n                prev_char = char\n        \n        # 4.2 Check if the number of repeating characters in a row is greater than 2\n        if repeating_characters_count > 2:\n            return max(repeating_characters_count - 2, 3)\n        \n        # 5. Check if password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        # 5.1 Find the number of repeating characters in a row\n        repeating_characters_count = 0\n        prev_char = None\n        for char in password:\n            if char == prev_char:\n                repeating_characters_count += 1\n            else:\n                prev_char = char\n        \n        # 5.2 Check if the number of repeating characters in a row is greater than 2\n        if repeating_characters_count > 2:\n            return max(repeating_characters_count - 2, 3)\n        \n        # 6. Check if password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        # 6.1 Find the number of repeating characters in a row\n        repeating_characters_count = 0\n        prev_char = None\n        for char in password:\n            if char == prev_char:\n                repeating_characters_count += 1\n            else:\n                prev_char = char\n        \n        # 6.2 Check if the number of repeating characters in a row is greater than 2\n        if repeating_characters_count > 2:\n            return max(repeating_characters_count - 2, 3)\n        \n        # 7. Check if password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        # 7.1 Find the number of repeating characters in a row\n        repeating_characters_count = 0\n        prev_char = None\n        for char in password:\n            if char == prev_char:\n                repeating_characters_count += 1\n            else:\n                prev_char = char\n        \n        # 7.2 Check if the number of repeating characters in a row is greater than 2\n        if repeating_characters_count > 2:\n            return max(repeating_characters_count - 2, 3)\n        \n        # 8. Check if password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        # 8.1 Find the number of repeating characters in a row\n        repeating_characters_count = 0\n        prev_char = None\n        for char in password:\n            if char == prev_char:\n                repeating_characters_count += 1\n            else:\n                prev_char = char\n        \n        # 8.2 Check if the number of repeating characters in a row is greater than 2\n        if repeating_characters_count > 2:\n            return max("}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 10 = 2 * 5\n        # 2 = 2 * 2\n        # 5 = 5 * 5\n        # 25 = 5 * 5\n        # 125 = 5 * 5 * 5\n        # 625 = 5 * 5 * 5 * 5\n        # 3125 = 5 * 5 * 5 * 5 * 5\n        # 15625 = 5 * 5 * 5 * 5 * 5 * 5\n        # 78125 = 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 390625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 1953125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 9765625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 48828125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 244140625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 1220703125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 6103017578125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 305175781250 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 152587890625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 762939453125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 3814697265625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 19073486328125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 95367431640625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 476837158203125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 2384185791015625 = 5 * 5 * 5 * 5 * 5 * 5 * 5"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        # if numRows is 2, then we can just return the string\n        if numRows == 2:\n            return s\n        \n        # if numRows is greater than 2, then we need to create a dictionary\n        # where the key is the index of the string and the value is the character\n        # we are going to add to the string\n        # we also need to keep track of the index of the string\n        # we also need to keep track of the direction of the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string\n        # we also need to keep track of the number of characters in the string"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Approach 1: Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 2: Two Pointers\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 3: Monotonic Stack\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 4: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 5: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 6: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 7: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 8: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 9: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 10: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 11: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 12: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 13: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach 14: Two Pointers (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Approach 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 12:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 13:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 14:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 15:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 16:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 17:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 18:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 19:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 20:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 21:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 22:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 23:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 24:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 25:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 26:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 27:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 28:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 29:\n        ## Time Complexity: O(n)\n        #"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start and end\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        # initialize the result and the last interval\n        result = 0\n        last_interval = None\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the last interval is None, set it to the current interval\n            if last_interval is None:\n                last_interval = interval\n                result += 2\n            # if the current interval is not None and the current interval is greater than the last interval, set the last interval to the current interval\n            elif interval[0] > last_interval[1]:\n                last_interval = interval\n                result += 2\n            # if the current interval is not None and the current interval is less than the last interval, set the last interval to the current interval\n            else:\n                last_interval = interval\n                result += 1\n        \n        # return the result\n        return result"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # Recursive solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # if root is None:\n        #     return True\n        # return self.isMirror(root.left, root.right)\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        if root is None:\n            return True\n        \n        queue = [root.left, root.right]\n        while queue:\n            left = queue.pop(0)\n            right = queue.pop(0)\n            if left is None and right is None:\n                continue\n            if left is None or right is None:\n                return False\n            if left.val != right.val:\n                return False\n            queue.append(left.left)\n            queue.append(right.right)\n            queue.append(left.right)\n            queue.append(right.left)\n        return True\n        \n    def isMirror(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n // 4)"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root\n        \n        # if root is None:\n        #     return None\n        \n        # temp = root.left\n        # root.left = root.right\n        # root.right = temp\n        \n        # self.invertTree(root.left)\n        # self.invertTree(root.right)\n        \n        # return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # Base case\n        if n == 0:\n            return []\n        \n        # Recursive case\n        if n == 1:\n            return ['()']\n        \n        # Recursive call\n        res = []\n        for i in range(n):\n            # Recursive call\n            left = self.generateParenthesis(i)\n            right = self.generateParenthesis(n - i - 1)\n            \n            # Generate combinations\n            for l in left:\n                for r in right:\n                    res.append('(' + l + ')' + r)\n        \n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[0] == 1:\n            return 1\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 0\n        \n        # edge case\n        if nums[-1] == n - 1:\n            return 1\n        \n        # edge case\n        if nums[-1] == n - 2:\n            return 2\n        \n        # edge case\n        if nums[-1] == n - 3:\n            return 3\n        \n        # edge case\n        if nums[-1] == n - 4:\n            return 4\n        \n        # edge case\n        if nums[-1] == n - 5:\n            return 5\n        \n        # edge case\n        if nums[-1] == n - 6:\n            return 6\n        \n        # edge case\n        if nums[-1] == n - 7:\n            return 7\n        \n        # edge case\n        if nums[-1] == n - 8:\n            return 8\n        \n        # edge case\n        if nums[-1] == n - 9:\n            return 9\n        \n        # edge case\n        if nums[-1] == n - 10:\n            return 10\n        \n        # edge case\n        if nums[-1] == n - 11:\n            return 11\n        \n        # edge case\n        if nums[-1] == n - 12:\n            return 12\n        \n        # edge case\n        if nums[-1] == n - 13:\n            return 13\n        \n        # edge case\n        if nums[-1] == n - 14:\n            return 14\n        \n        # edge case\n        if nums[-1] == n - 15:\n            return 15\n        \n        # edge case\n        if nums[-1] == n - 16:\n            return 16\n        \n        # edge case\n        if nums[-1] == n - 17:\n            return 17\n        \n        # edge case\n        if nums[-1] == n - 18:\n            return 18\n        \n        # edge case\n        if nums[-1] == n - 19:\n            return 19\n        \n        # edge case\n        if nums[-1] == n - 20:\n            return 20\n        \n        # edge case\n        if nums[-1] == n - 21:\n            return 21\n        \n        # edge case\n        if nums[-1] == n - 22:\n            return 22\n        \n        # edge case\n        if nums[-1] == n - 23:\n            return 23\n        \n        # edge case\n        if nums[-1] == n - 24:\n            return 24\n        \n        # edge case\n        if nums[-1] == n - 25:\n            return 25\n        \n        # edge case\n        if nums[-1] == n - 26:\n            return 26\n        \n        # edge case\n        if nums[-1] == n - 27:\n            return 27\n        \n        # edge case\n        if nums[-1] == n - 28:\n            return 28\n        \n        # edge case\n        if nums[-1] == n - 29:\n            return 29\n        \n        # edge case\n        if nums[-1] == n - 30:\n            return 30\n        \n        # edge case\n        if nums[-1] == n - 31:\n            return 31\n        \n        # edge case\n        if nums[-1] == n - 32:\n            return 32\n        \n        # edge case\n        if nums[-1] == n - 33:\n            return 33\n        \n        # edge"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        # edge case\n        if denominator == 0:\n            return \"NaN\"\n        \n        # edge case\n        if numerator == 0:\n            return \"0\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == -1:\n            return \"2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == -1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-2147483648\"\n        \n        # edge case\n        if numerator == -2147483648 and denominator == 1:\n            return \"-214"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Edge case: if the list is empty, return None\n        if not head:\n            return None\n        \n        # Edge case: if the list has only one node, return that node\n        if not head.next:\n            return head\n        \n        # Edge case: if the list has two nodes, return the second node if the first node is greater than the second node\n        if head.val > head.next.val:\n            head.next, head = head.next, head.next\n            return head\n        \n        # Edge case: if the list has three nodes, return the third node if the first node is greater than the second node and the second node is greater than the third node\n        if head.val > head.next.val and head.val > head.next.next.val:\n            head.next.next, head.next = head.next.next, head.next\n            return head.next\n        \n        # Edge case: if the list has four nodes, return the fourth node if the first node is greater than the second node and the second node is greater than the third node and the third node is greater than the fourth node\n        if head.val > head.next.val and head.val > head.next.next.val and head.val > head.next.next.next.val:\n            head.next.next.next.next, head.next.next.next = head.next.next.next.next, head.next.next.next\n            return head.next.next.next\n        \n        # Edge case: if the list has five nodes, return the fifth node if the first node is greater than the second node and the second node is greater than the third node and the third node is greater than the fourth node and the fourth node is greater than the fifth node\n        if head.val > head.next.val and head.val > head.next.next.val and head.val > head.next.next.next.val and head.val > head.next.next.next.next.val:\n            head.next.next.next.next.next, head.next.next.next.next = head.next.next.next.next.next, head.next.next.next.next\n            return head.next.next.next.next\n        \n        # Edge case: if the list has six nodes, return the sixth node if the first node is greater than the second node and the second node is greater than the third node and the third node is greater than the fourth node and the fourth node is greater than the fifth node and the fifth node is greater than the sixth node\n        if head.val > head.next.val and head.val > head.next.next.val and head.val > head.next.next.next.val and head.val > head.next.next.next.next.val and head.val > head.next.next.next.next.next.val:\n            head.next.next.next.next.next.next, head.next.next.next.next.next = head.next.next.next.next.next.next, head.next.next.next.next.next\n            return head.next.next.next.next.next\n        \n        # Edge case: if the list has seven nodes, return the seventh node if the first node is greater than the second node and the second node is greater than the third node and the third node is greater than the fourth node and the fourth node is greater than the fifth node and the fifth node is greater than the sixth node and the sixth node is greater than the seventh node\n        if head.val > head.next.val and head.val > head.next.next.val and head.val > head.next.next.next.val and head.val > head.next.next.next.next.val and head.val > head.next.next.next.next.next.val and head.val > head.next.next.next.next.next.next.val:\n            head.next.next.next.next.next.next.next, head.next.next.next.next.next.next = head.next.next.next.next.next.next.next, head.next.next.next.next.next.next\n            return head.next.next.next.next.next.next\n        \n        # Edge case: if the list has eight nodes, return the eighth node if the first node is greater than the second node and the second node is greater than the third node and the third node is greater than the fourth node and the fourth node"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Initialize the maximum number of envelopes\n        max_envelopes = 0\n        \n        # Initialize the maximum number of envelopes with the current envelope\n        max_envelopes_with_current_envelope = 0\n        \n        # Iterate over the envelopes\n        for envelope in envelopes:\n            # If the current envelope is larger than the maximum number of envelopes with the current envelope\n            if envelope[1] > max_envelopes_with_current_envelope:\n                # Update the maximum number of envelopes with the current envelope\n                max_envelopes_with_current_envelope = envelope[1]\n                # Increment the maximum number of envelopes\n                max_envelopes += 1\n        \n        return max_envelopes"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Optimized\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        \n        #"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end\n        ## 3. If the length of the linked list is less than n, return the head\n        ## 4. If the length of the linked list is greater than n, remove the nth node from the end\n        ## 5. Return the head\n        \n        ## Edge Cases:\n        ## 1. If the head is None, return None\n        ## 2. If the head is not None, but the length of the linked list is 1, return None\n        \n        ## Initialization:\n        ## 1. Initialize the length of the linked list to 0\n        ## 2. Initialize the current node to the head\n        ## 3. Initialize the previous node to None\n        \n        ## Traversal:\n        ## 1. Traverse the linked list until the current node is None\n        ## 2. If the length of the linked list is less than n, return the head\n        ## 3. If the length of the linked list is greater than n, remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Edge Cases:\n        ## 1. If the head is None, return None\n        ## 2. If the head is not None, but the length of the linked list is 1, return None\n        \n        ## Initialization:\n        ## 1. Initialize the length of the linked list to 0\n        ## 2. Initialize the current node to the head\n        ## 3. Initialize the previous node to None\n        \n        ## Traversal:\n        ## 1. Traverse the linked list until the current node is None\n        ## 2. If the length of the linked list is less than n, return the head\n        ## 3. If the length of the linked list is greater than n, remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Edge Cases:\n        ## 1. If the head is None, return None\n        ## 2. If the head is not None, but the length of the linked list is 1, return None\n        \n        ## Initialization:\n        ## 1. Initialize the length of the linked list to 0\n        ## 2. Initialize the current node to the head\n        ## 3. Initialize the previous node to None\n        \n        ## Traversal:\n        ## 1. Traverse the linked list until the current node is None\n        ## 2. If the length of the linked list is less than n, return the head\n        ## 3. If the length of the linked list is greater than n, remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Edge Cases:\n        ## 1. If the head is None, return None\n        ## 2. If the head is not None, but the length of the linked list is 1, return None\n        \n        ## Initialization:\n        ## 1. Initialize the length of the linked list to 0\n        ## 2. Initialize the current node to the head\n        ## 3. Initialize the previous node to None\n        \n        ## Traversal:\n        ## 1. Traverse the linked list until the current node is None\n        ## 2. If the length of the linked list is less than n, return the head\n        ## 3. If the length of the linked list is greater than n, remove the nth node from the end\n        ## 4. Return the head\n        \n        ## Edge Cases:\n        ## 1. If the head is None, return None\n        ## 2. If the head is not None, but the length of the linked list is 1, return None\n        \n        ## Initialization:\n        ## 1. Initialize the length of the linked list to 0\n        ## 2. Initialize the current node to the head\n        ## 3. Initialize the previous node to None\n        \n        #"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set\n        ## 3. If nums2[i] is in set, add it to the result set\n        ## 4. Return the result set\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set\n        ## 3. If nums2[i] is in set, add it to the result set\n        ## 4. Return the result set\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set\n        ## 3. If nums2[i] is in set, add it to the result set\n        ## 4. Return the result set\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set\n        ## 3. If nums2[i] is in set, add it to the result set\n        ## 4. Return the result set\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set\n        ## 3. If nums2[i] is in set, add it to the result set\n        ## 4. Return the result set\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set\n        ## 3. If nums2[i] is in set, add it to the result set\n        ## 4. Return the result set\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set\n        ## 3. If nums2[i] is in set, add it to the result set\n        ## 4. Return the result set\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set\n        ## 3. If nums2[i] is in set, add it to the result set\n        ## 4. Return the result set\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach:\n        ## 1. Create a set from nums1\n        ## 2. Iterate through nums2 and check if nums2[i] is in set"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # max_moves = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     max_moves = max(max_moves, abs(left_sum - right_sum))\n        #     machines[i] = avg\n        #     left_sum -= avg\n        #     right_sum += avg\n        \n        # return max_moves\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # max_moves = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     max_moves = max(max_moves, abs(left_sum - right_sum))\n        #     machines[i] = avg\n        #     left_sum -= avg\n        #     right_sum += avg\n        \n        # return max_moves\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # max_moves = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     max_moves = max(max_moves, abs(left_sum - right_sum))\n        #     machines[i] = avg\n        #     left_sum -= avg\n        #     right_sum += avg\n        \n        # return max_moves\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # max_moves = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     max_moves = max(max_moves, abs(left_sum - right_sum))\n        #     machines[i] = avg\n        #     left_sum -= avg\n        #     right_sum += avg\n        \n        # return max_moves\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # max_moves = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        # find the middle of the linked list\n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the linked list into left and right\n        left = head\n        right = slow.next\n        slow.next = None\n        \n        # recursively build the tree\n        if left == right:\n            return None\n        return self.sortedListToBST(left)\n        \n        # if left == right:\n        #     return None\n        # mid = left\n        # while mid.next != right:\n        #     mid = mid.next\n        # return TreeNode(mid.val, self.sortedListToBST(left), self.sortedListToBST(right))"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     temp = list1\n        #     list1 = list2\n        #     list2 = temp\n        \n        # head = list1\n        \n        # while list1.next is not None:\n        #     if list1.next.val < list2.val:\n        #         temp = list1.next\n        #         list1.next = list2\n        #         list2 = temp\n        #         list1 = list1.next\n        #     else:\n        #         list1 = list1.next\n        \n        # list1.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     temp = list1\n        #     list1 = list2\n        #     list2 = temp\n        \n        # head = list1\n        \n        # while list1.next is not None:\n        #     if list1.next.val < list2.val:\n        #         temp = list1.next\n        #         list1.next = list2\n        #         list2 = temp\n        #         list1 = list1.next\n        #     else:\n        #         list1 = list1.next\n        \n        # list1.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     temp = list1\n        #     list1 = list2\n        #     list2 = temp\n        \n        # head = list1\n        \n        # while list1.next is not None:\n        #     if list1.next.val < list2.val:\n        #         temp = list1.next\n        #         list1.next = list2\n        #         list2 = temp\n        #         list1 = list1.next\n        #     else:\n        #         list1 = list1.next\n        \n        # list1.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     temp = list1\n        #     list1 = list2\n        #     list2 = temp\n        \n        # head = list1\n        \n        # while list1.next is not None:\n        #     if list1.next.val < list2.val:\n        #         temp = list1.next\n        #         list1.next = list2\n        #         list2 = temp\n        #         list1 = list1.next\n        #     else:\n        #         list1 = list1.next\n        \n        # list1.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     temp = list1\n        #     list1 = list2\n        #     list2 = temp\n        \n        # head = list1\n        \n        # while list1.next is not None:\n        #     if list1.next.val < list2.val:\n        #         temp = list1.next\n        #         list1.next = list2\n        #         list2 = temp\n        #         list1 = list1.next\n        #     else:\n        #         list1 = list1.next\n        \n        # list1.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     temp = list1\n        #     list1 = list2\n        #     list"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. Bit manipulation\n        ## 3. DP\n        ## 4. Backtracking\n        ## 5. Combinatorics\n        ## 6. Math\n        ## 7. Bit manipulation\n        ## 8. Bit manipulation\n        ## 9. Bit manipulation\n        ## 10. Bit manipulation\n        ## 11. Bit manipulation\n        ## 12. Bit manipulation\n        ## 13. Bit manipulation\n        ## 14. Bit manipulation\n        ## 15. Bit manipulation\n        ## 16. Bit manipulation\n        ## 17. Bit manipulation\n        ## 18. Bit manipulation\n        ## 19. Bit manipulation\n        ## 20. Bit manipulation\n        ## 21. Bit manipulation\n        ## 22. Bit manipulation\n        ## 23. Bit manipulation\n        ## 24. Bit manipulation\n        ## 25. Bit manipulation\n        ## 26. Bit manipulation\n        ## 27. Bit manipulation\n        ## 28. Bit manipulation\n        ## 29. Bit manipulation\n        ## 30. Bit manipulation\n        ## 31. Bit manipulation\n        ## 32. Bit manipulation\n        ## 33. Bit manipulation\n        ## 34. Bit manipulation\n        ## 35. Bit manipulation\n        ## 36. Bit manipulation\n        ## 37. Bit manipulation\n        ## 38. Bit manipulation\n        ## 39. Bit manipulation\n        ## 40. Bit manipulation\n        ## 41. Bit manipulation\n        ## 42. Bit manipulation\n        ## 43. Bit manipulation\n        ## 44. Bit manipulation\n        ## 45. Bit manipulation\n        ## 46. Bit manipulation\n        ## 47. Bit manipulation\n        ## 48. Bit manipulation\n        ## 49. Bit manipulation\n        ## 50. Bit manipulation\n        ## 51. Bit manipulation\n        ## 52. Bit manipulation\n        ## 53. Bit manipulation\n        ## 54. Bit manipulation\n        ## 55. Bit manipulation\n        ## 56. Bit manipulation\n        ## 57. Bit manipulation\n        ## 58. Bit manipulation\n        ## 59. Bit manipulation\n        ## 60. Bit manipulation\n        ## 61. Bit manipulation\n        ## 62. Bit manipulation\n        ## 63. Bit manipulation\n        ## 64. Bit manipulation\n        ## 65. Bit manipulation\n        ## 66. Bit manipulation\n        ## 67. Bit manipulation\n        ## 68. Bit manipulation\n        ## 69. Bit manipulation\n        ## 70. Bit manipulation\n        ## 71. Bit manipulation\n        ## 72. Bit manipulation\n        ## 73. Bit manipulation\n        ## 74. Bit manipulation\n        ## 75. Bit manipulation\n        ## 76. Bit manipulation\n        ## 77. Bit manipulation\n        ## 78. Bit manipulation\n        ## 79. Bit manipulation\n        ## 80. Bit manipulation\n        ## 81. Bit manipulation\n        ## 82. Bit manipulation\n        ## 83. Bit manipulation\n        ## 84. Bit manipulation\n        ## 85. Bit manipulation\n        ## 86. Bit manipulation\n        ## 87. Bit manipulation\n        ## 88. Bit manipulation\n        ## 89. Bit manipulation\n        ## 90. Bit manipulation\n        ## 91. Bit manipulation\n        ## 92. Bit manipulation\n        ## 93. Bit manipulation\n        ## 94. Bit manipulation"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        # return nums[left]\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            elif nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right -= 1\n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        # Symbol       Value\n        # I             1\n        # V             5\n        # X             10\n        # L             50\n        # C             100\n        # D             500\n        # M             1000\n        \n        # Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9. \n        # X can be placed before L (50) and C (100) to make 40 and 90. \n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # Example 1:\n        # Input: num = 3\n        # Output: \"III\"\n        # Explanation: 3 is represented as 3 ones.\n        \n        # Example 2:\n        # Input: num = 58\n        # Output: \"LVIII\"\n        # Explanation: L = 50, V = 5, III = 3.\n        \n        # Example 3:\n        # Input: num = 1994\n        # Output: \"MCMXCIV\"\n        # Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \n        # Example 4:\n        # Input: num = 3999\n        # Output: \"MMMCMXCIX\"\n        \n        # Example 5:\n        # Input: num = 1\n        # Output: \"I\"\n        \n        # Example 6:\n        # Input: num = 2\n        # Output: \"II\"\n        \n        # Example 7:\n        # Input: num = 3\n        # Output: \"III\"\n        \n        # Example 8:\n        # Input: num = 4\n        # Output: \"IV\"\n        \n        # Example 9:\n        # Input: num = 5\n        # Output: \"V\"\n        \n        # Example 10:\n        # Input: num = 6\n        # Output: \"VI\"\n        \n        # Example 11:\n        # Input: num = 7\n        # Output: \"VII\"\n        \n        # Example 12:\n        # Input: num = 8\n        # Output: \"VIII\"\n        \n        # Example 13:\n        # Input: num = 9\n        # Output: \"IX\"\n        \n        # Example 14:\n        # Input: num = 10\n        # Output: \"X\"\n        \n        # Example 15:\n        # Input: num = 11\n        # Output: \"XI\"\n        \n        # Example 16:\n        # Input: num = 12\n        # Output: \"XII\"\n        \n        # Example 17:\n        # Input: num = 13\n        # Output: \"XIII\"\n        \n        # Example 18:\n        # Input: num = 14\n        # Output: \"XIV\"\n        \n        # Example 19:\n        # Input: num = 15\n        # Output: \"XV\"\n        \n        # Example 20:\n        # Input: num = 16\n        # Output: \"XVI\"\n        \n        # Example 21:\n        # Input: num = 17\n        # Output: \"XVII\"\n        \n        # Example 22:\n        # Input: num = 18\n        # Output: \"XVIII\"\n        \n        # Example 23:\n        # Input: num = 19\n        # Output: \"XIX\"\n        \n        # Example 24:\n        # Input: num = 20\n        # Output: \"XX\"\n        \n        # Example 25:\n        # Input: num = 21\n        # Output: \"XXI\"\n        \n        # Example 26:\n        # Input: num = 2"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. We can use XOR to find the difference between the two strings.\n        ## 2. We can use a hashmap to store the frequency of each character in the string.\n        ## 3. We can iterate through the string s and increment the frequency of each character in the hashmap.\n        ## 4. We can iterate through the string t and decrement the frequency of each character in the hashmap.\n        ## 5. We can find the character that has a frequency of 1 in the hashmap.\n        \n        ## Code:\n        \n        ## Step 1:\n        ## Initialize a hashmap to store the frequency of each character in the string.\n        ## Set the frequency of the character 'a' to 0.\n        ## Set the frequency of the character 'b' to 0.\n        ## Set the frequency of the character 'c' to 0.\n        ## Set the frequency of the character 'd' to 0.\n        ## Set the frequency of the character 'e' to 0.\n        ## Set the frequency of the character 'f' to 0.\n        ## Set the frequency of the character 'g' to 0.\n        ## Set the frequency of the character 'h' to 0.\n        ## Set the frequency of the character 'i' to 0.\n        ## Set the frequency of the character 'j' to 0.\n        ## Set the frequency of the character 'k' to 0.\n        ## Set the frequency of the character 'l' to 0.\n        ## Set the frequency of the character 'm' to 0.\n        ## Set the frequency of the character 'n' to 0.\n        ## Set the frequency of the character 'o' to 0.\n        ## Set the frequency of the character 'p' to 0.\n        ## Set the frequency of the character 'q' to 0.\n        ## Set the frequency of the character 'r' to 0.\n        ## Set the frequency of the character 's' to 0.\n        ## Set the frequency of the character 't' to 0.\n        ## Set the frequency of the character 'u' to 0.\n        ## Set the frequency of the character 'v' to 0.\n        ## Set the frequency of the character 'w' to 0.\n        ## Set the frequency of the character 'x' to 0.\n        ## Set the frequency of the character 'y' to 0.\n        ## Set the frequency of the character 'z' to 0.\n        \n        ## Step 2:\n        ## Iterate through the string s and increment the frequency of each character in the hashmap.\n        ## Iterate through the string t and decrement the frequency of each character in the hashmap.\n        \n        ## Step 3:\n        ## Iterate through the hashmap and find the character that has a frequency of 1 in the hashmap.\n        \n        ## Step 4:\n        ## Return the character that has a frequency of 1 in the hashmap.\n        \n        ## Code:\n        \n        ## Step 1:\n        ## Initialize a hashmap to store the frequency of each character in the string.\n        ## Set the frequency of the character 'a' to 0.\n        ## Set the frequency of the character 'b' to 0.\n        ## Set the frequency of the character 'c' to 0.\n        ## Set the frequency of the character 'd' to 0.\n        ## Set the frequency of the character 'e' to 0.\n        ## Set the frequency of the character 'f' to 0.\n        ## Set the frequency of the character 'g' to 0.\n        ## Set the frequency of the character 'h' to 0.\n        ## Set the frequency of the character 'i' to 0.\n        ## Set the frequency of the character 'j' to 0.\n        ## Set the frequency of the character 'k' to 0.\n        ## Set the frequency of the character 'l' to 0.\n        ## Set the frequency of the character 'm' to"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. Find the empty cells\n        # 2. Fill the empty cells with numbers from 1 to 9\n        # 3. Check if the number is valid for the row, col, and 3x3 box\n        # 4. Recursively fill the rest of the cells with numbers from 1 to 9\n        # 5. If the number is valid for the row, col, and 3x3 box, return True\n        # 6. If the number is not valid for the row, col, or 3x3 box, backtrack and try a different number\n        # 7. If all numbers are tried, return False\n        \n        # 1. Find the empty cells\n        empty_cells = []\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    empty_cells.append((i, j))\n        \n        # 2. Fill the empty cells with numbers from 1 to 9\n        for i, j in empty_cells:\n            for num in range(1, 10):\n                if self.is_valid(board, i, j, num):\n                    board[i][j] = str(num)\n                    if self.solve_sudoku(board):\n                        return True\n                    board[i][j] = '.'\n            return False\n        \n    def is_valid(self, board, i, j, num):\n        # Check if the number is valid for the row\n        for k in range(9):\n            if board[i][k] == str(num) and k != j:\n                return False\n        \n        # Check if the number is valid for the column\n        for k in range(9):\n            if board[k][j] == str(num) and k != i:\n                return False\n        \n        # Check if the number is valid for the 3x3 box\n        box_i = i // 3 * 3\n        box_j = j // 3 * 3\n        for k in range(3):\n            for l in range(3):\n                if board[box_i + k][box_j + l] == str(num) and (box_i + k, box_j + l) != (i, j):\n                    return False\n        \n        return True\n    \n    def solve_sudoku(self, board):\n        # Recursively fill the rest of the cells with numbers from 1 to 9\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    for num in range(1, 10):\n                        if self.is_valid(board, i, j, num):\n                            board[i][j] = str(num)\n                            if self.solve_sudoku(board):\n                                return True\n                            board[i][j] = '.'\n                    return False\n        \n        return True"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Swap the values of the two nodes\n        ## 3. Recursively traverse the left subtree\n        ## 4. Recursively traverse the right subtree"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # 1. find the midpoint\n        # 2. square the midpoint\n        # 3. if square is less than num, then move left\n        # 4. if square is greater than num, then move right\n        # 5. if square is equal to num, then return true\n        # 6. if left pointer is greater than right pointer, then return false\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            square = mid * mid\n            \n            if square == num:\n                return True\n            \n            if square < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if n == 0:\n        #     return [0]\n        # if n == 1:\n        #     return [0,1]\n        # if n == 2:\n        #     return [0,1,1]\n        # if n == 3:\n        #     return [0,1,1,2]\n        # if n == 4:\n        #     return [0,1,1,2,2]\n        # if n == 5:\n        #     return [0,1,1,2,2,3]\n        # if n == 6:\n        #     return [0,1,1,2,2,3,3]\n        # if n == 7:\n        #     return [0,1,1,2,2,3,3,4]\n        # if n == 8:\n        #     return [0,1,1,2,2,3,3,4,4]\n        # if n == 9:\n        #     return [0,1,1,2,2,3,3,4,4,5]\n        # if n == 10:\n        #     return [0,1,1,2,2,3,3,4,4,5,5]\n        # if n == 11:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6]\n        # if n == 12:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        # if n == 13:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        # if n == 14:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        # if n == 15:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        # if n == 16:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        # if n == 17:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        # if n == 18:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10]\n        # if n == 19:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10]\n        # if n == 20:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11]\n        # if n == 21:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11]\n        # if n == 22:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11,12]\n        # if n == 23:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11,12,12]\n        # if n == 24:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the length of the string is 1, stop.\n        if len(s1) == 1 and len(s2) == 1:\n            return s1 == s2\n        \n        # if the length of the string is > 1, do the following:\n        else:\n            # split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\n            x = s1[:len(s1)//2]\n            y = s1[len(s1)//2:]\n            z = s2[:len(s2)//2]\n            t = s2[len(s2)//2:]\n            \n            # Randomly\u00a0decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\n            if x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True\n            elif x == z and y == t:\n                return True\n            elif x == t and y == z:\n                return True\n            elif x == y and z == t:\n                return True"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of strings\n        path_list = path.split('/')\n        \n        # initialize a stack to store the directory names\n        stack = []\n        \n        # loop through the list of strings\n        for i in range(len(path_list)):\n            # if the string is not empty and not a dot\n            if path_list[i] != '' and path_list[i] != '.':\n                # if the string is a dot\n                if path_list[i] == '.':\n                    # if the stack is empty, do nothing\n                    if len(stack) == 0:\n                        continue\n                    # if the stack is not empty, pop the last element\n                    else:\n                        stack.pop()\n                # if the string is not a dot\n                else:\n                    # if the stack is empty, push the string to the stack\n                    if len(stack) == 0:\n                        stack.append(path_list[i])\n                    # if the stack is not empty, push the string to the stack\n                    else:\n                        stack.append(path_list[i])\n        \n        # initialize a string to store the simplified path\n        simplified_path = ''\n        \n        # loop through the stack\n        for i in range(len(stack)):\n            # if the stack is not empty\n            if len(stack) > 0:\n                # if the stack is not the last element\n                if i != len(stack) - 1:\n                    # if the stack is not the last element\n                    simplified_path += stack[i] + '/'\n                # if the stack is the last element\n                else:\n                    simplified_path += stack[i]\n        \n        # if the simplified path is empty, return a slash\n        if len(simplified_path) == 0:\n            return '/'\n        # if the simplified path is not empty, return the simplified path\n        else:\n            return simplified_path"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the result array\n        result = []\n        \n        # Initialize the trie\n        trie = {}\n        \n        # Build the trie\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node[\"*\"] = True\n        \n        # Initialize the visited array\n        visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n        \n        # Initialize the directions array\n        directions = [(1,0), (-1,0), (0,1), (0,-1)]\n        \n        # Initialize the word array\n        word = []\n        \n        # Initialize the word index\n        word_index = 0\n        \n        # Initialize the word length\n        word_length = 0\n        \n        # Initialize the word direction\n        word_direction = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction_length = 0\n        \n        # Initialize the word direction index\n        word_direction_index = 0\n        \n        # Initialize the word direction length\n        word_direction"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        \n        # for i in range(len(t)):\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict or t[i] not in t_dict:\n        #         return False\n        #     elif s_dict[s[i]] != t_dict[t[i]]:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        \n        # for i in range(len(t)):\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict or t[i] not in t_dict:\n        #         return False\n        #     elif s_dict[s[i]] != t_dict[t[i]]:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        \n        # for i in range(len(t)):\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict or t[i] not in t_dict:\n        #         return False\n        #     elif s_dict[s[i]] != t_dict[t[i]]:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        \n        # for i in range(len(t)):\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict or t[i] not in t_dict:\n        #         return False\n        #     elif s_dict[s[i]] != t_dict[t[i]]:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 2. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 3. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 4. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 5. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 6. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 7. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 8. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 9. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 10. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 11. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 12. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 13. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 14. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 15. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 16. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 17. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 18. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 19. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 20. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 21. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 22. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 23. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 24. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 25. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 26. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 27. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 28. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 29. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 30. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 31. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 32. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 33. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 34. 3 sets of 9 rows, 9 columns, and 9 3x3 sub-boxes\n        # 35. 3 sets of 9 rows"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 25600\n        # 26^4 = 1440000\n        # 26^5 = 73720000\n        # 26^6 = 3689600000\n        # 26^7 = 195312500000\n        # 26^8 = 10737418240000\n        # 26^9 = 536870912000000\n        # 26^10 = 26843545600000000\n        # 26^11 = 1342177280000000000\n        # 26^12 = 67108864000000000000\n        # 26^13 = 3355443200000000000000\n        # 26^14 = 167772160000000000000000\n        # 26^15 = 8388608000000000000000000\n        # 26^16 = 414745600000000000000000000\n        # 26^17 = 20971520000000000000000000000\n        # 26^18 = 1048576000000000000000000000000\n        # 26^19 = 52428800000000000000000000000000\n        # 26^20 = 2621440000000000000000000000000000\n        # 26^21 = 131072000000000000000000000000000000\n        # 26^22 = 6553600000000000000000000000000000000\n        # 26^23 = 327680000000000000000000000000000000000\n        # 26^24 = 16384000000000000000000000000000000000000\n        # 26^25 = 819200000000000000000000000000000000000000\n        # 26^26 = 40960000000000000000000000000000000000000000\n        # 26^27 = 2048000000000000000000000000000000000000000000\n        # 26^28 = 10240000000000000000000000000000000000000000000\n        # 26^29 = 5120000000000000000000000000000000000000000000"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # Base case\n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        \n        # Recursive case\n        if p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Merge the first and second halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern is not equal to the length of the words, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the pattern and words\n        pattern_to_word = {}\n        word_to_pattern = {}\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern is not in the dictionary, add it to the dictionary\n            if pattern[i] not in pattern_to_word:\n                pattern_to_word[pattern[i]] = words[i]\n            # if the word is not in the dictionary, add it to the dictionary\n            if words[i] not in word_to_pattern:\n                word_to_pattern[words[i]] = pattern[i]\n            # if the pattern and word are not the same, return False\n            if pattern_to_word[pattern[i]] != words[i] or word_to_pattern[words[i]] != pattern[i]:\n                return False\n        \n        # if the pattern and word are the same, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return [nums]\n        \n        # if len(nums) == 2:\n        #     return [[nums[0], nums[1]], [nums[1], nums[0]]]\n        \n        # if len(nums) == 3:\n        #     return [[nums[0], nums[1], nums[2]], [nums[0], nums[2], nums[1]], [nums[1], nums[0], nums[2]], [nums[1], nums[2], nums[0]], [nums[2], nums[0], nums[1]], [nums[2], nums[1], nums[0]]]\n        \n        # if len(nums) == 4:\n        #     return [[nums[0], nums[1], nums[2], nums[3]], [nums[0], nums[1], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3]], [nums[0], nums[2], nums[3], nums[1]], [nums[1], nums[0], nums[2], nums[3]], [nums[1], nums[0], nums[3], nums[2]], [nums[1], nums[2], nums[0], nums[3]], [nums[1], nums[2], nums[3], nums[0]], [nums[2], nums[0], nums[1], nums[3]], [nums[2], nums[0], nums[3], nums[1]], [nums[2], nums[1], nums[0], nums[3]], [nums[2], nums[1], nums[3], nums[0]], [nums[3], nums[0], nums[1], nums[2]], [nums[3], nums[0], nums[2], nums[1]], [nums[3], nums[1], nums[0], nums[2]], [nums[3], nums[1], nums[2], nums[0]], [nums[0], nums[1], nums[2], nums[3]], [nums[0], nums[1], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3]], [nums[0], nums[2], nums[3], nums[1]], [nums[1], nums[2], nums[3], nums[0]], [nums[1], nums[3], nums[0], nums[2]], [nums[1], nums[3], nums[2], nums[0]], [nums[2], nums[3], nums[0], nums[1]], [nums[2], nums[3], nums[1], nums[0]], [nums[3], nums[2], nums[0], nums[1]], [nums[3], nums[2], nums[1], nums[0]]]\n        \n        # if len(nums) == 5:\n        #     return [[nums[0], nums[1], nums[2], nums[3], nums[4]], [nums[0], nums[1], nums[3], nums[4], nums[2]], [nums[0], nums[1], nums[4], nums[2], nums[3]], [nums[0], nums[1], nums[4], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3], nums[4]], [nums[0], nums[2], nums[1], nums[4], nums[3]], [nums[0], nums[2], nums[3], nums[1], nums[4]], [nums[0], nums[2], nums[3], nums["}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # time complexity: O(log(m*n))\n        # space complexity: O(1)\n        \n        # edge cases\n        if not matrix:\n            return False\n        \n        # variables\n        m = len(matrix)\n        n = len(matrix[0])\n        low = 0\n        high = m*n - 1\n        \n        # binary search\n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid // n][mid % n] == target:\n                return True\n            elif matrix[mid // n][mid % n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result list\n        result = ListNode()\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Loop through the lists until one of the lists is empty\n        while l1 or l2:\n            # If the first list is empty, set the value to 0\n            if not l1:\n                l1 = ListNode(0)\n            # If the second list is empty, set the value to 0\n            if not l2:\n                l2 = ListNode(0)\n            # Add the values of the nodes\n            sum = l1.val + l2.val + carry\n            # Set the value of the current node to the sum modulo 10\n            current.val = sum % 10\n            # Set the carry to the sum divided by 10\n            carry = sum // 10\n            # If the next node is not empty, set the next node to the next node\n            if l1.next or l2.next:\n                # If the next node is empty, set the next node to a new node\n                if not l1.next:\n                    l1.next = ListNode()\n                if not l2.next:\n                    l2.next = ListNode()\n                # Set the next node to the next node\n                current.next = ListNode()\n                # Set the next node to the next node\n                current = current.next\n            # Move to the next node\n            l1 = l1.next\n            l2 = l2.next\n        # If the carry is greater than 0, add a new node to the result list\n        if carry > 0:\n            current.next = ListNode(carry)\n        # Return the result list\n        return result"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert num to binary\n        ## 2. reverse the binary\n        ## 3. convert the binary to decimal\n        ## 4. return the decimal\n        \n        ## 1. convert num to binary\n        binary = \"\"\n        while num > 0:\n            binary = str(num % 2) + binary\n            num = num // 2\n        \n        ## 2. reverse the binary\n        binary = binary[::-1]\n        \n        ## 3. convert the binary to decimal\n        decimal = 0\n        for i in range(len(binary)):\n            decimal += int(binary[i]) * (2 ** i)\n        \n        ## 4. return the decimal\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums)-1:\n        #     j = i+1\n        #     while j < len(nums):\n        #         if nums[j]-nums[i] == nums[1]-nums[0]:\n        #             count += 1\n        #             i += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums)-1:\n        #     j = i+1\n        #     while j < len(nums):\n        #         if nums[j]-nums[i] == nums[1]-nums[0]:\n        #             count += 1\n        #             i += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums)-1:\n        #     j = i+1\n        #     while j < len(nums):\n        #         if nums[j]-nums[i] == nums[1]-nums[0]:\n        #             count += 1\n        #             i += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums)-1:\n        #     j = i+1\n        #     while j < len(nums):\n        #         if nums[j]-nums[i] == nums[1]-nums[0]:\n        #             count += 1\n        #             i += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums)-1:\n        #     j = i+1\n        #     while j < len(nums):\n        #         if nums[j]-nums[i] == nums[1]-nums[0]:\n        #             count += 1\n        #             i += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums)-1:\n        #     j = i+1\n        #     while j < len(nums):\n        #         if nums[j]-nums[i] == nums[1]-nums[0]:\n        #             count += 1\n        #             i += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums)-1:\n        #     j = i+1\n        #     while j < len(nums):\n        #         if nums[j]-nums[i] == nums[1]-nums[0]:\n        #             count += 1\n        #             i += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums)-1:\n        #     j = i+1\n        #     while j < len(nums):\n        #         if nums[j]-nums[i] == nums[1]-nums[0]:\n        #             count += 1"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Iterative"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach:\n        ## 1. We can use two pointers, one at the start and one at the end.\n        ## 2. We will keep track of the maximum area.\n        ## 3. We will compare the height of the two pointers and update the maximum area accordingly.\n        ## 4. We will move the pointer with the shorter height.\n        ## 5. We will update the maximum area accordingly.\n        ## 6. We will repeat the steps 3 and 4 until the two pointers meet.\n        \n        ## Code:\n        ## 1. Initialize two pointers, one at the start and one at the end.\n        ## 2. Initialize a variable maxArea to 0.\n        ## 3. While the two pointers are not equal:\n        ## 4. Calculate the area between the two pointers.\n        ## 5. Update the maximum area if the area is greater.\n        ## 6. If the height of the left pointer is smaller, move the left pointer to the right.\n        ## 7. If the height of the right pointer is smaller, move the right pointer to the left.\n        ## 8. Return the maximum area.\n        \n        ## 1. Initialize two pointers, one at the start and one at the end.\n        ## 2. Initialize a variable maxArea to 0.\n        ## 3. While the two pointers are not equal:\n        ## 4. Calculate the area between the two pointers.\n        ## 5. Update the maximum area if the area is greater.\n        ## 6. If the height of the left pointer is smaller, move the left pointer to the right.\n        ## 7. If the height of the right pointer is smaller, move the right pointer to the left.\n        ## 8. Return the maximum area.\n        \n        left = 0\n        right = len(height) - 1\n        maxArea = 0\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            maxArea = max(maxArea, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return maxArea"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(N * L)\n        # Space Complexity: O(N)\n        \n        # Create a set of words\n        word_set = set(words)\n        \n        # Create a dictionary to store the longest word that can be formed from the words in the set\n        longest_word_dict = {}\n        \n        # Iterate through the words in the set\n        for word in word_set:\n            \n            # Initialize the longest word that can be formed from the word\n            longest_word = \"\"\n            \n            # Iterate through the word\n            for i in range(len(word)):\n                \n                # If the word is not in the dictionary, add it to the dictionary\n                if word[:i] not in longest_word_dict:\n                    longest_word_dict[word[:i]] = word\n                \n                # If the word is in the dictionary, check if the word can be formed from the word\n                elif word[:i] in longest_word_dict:\n                    \n                    # If the word can be formed from the word, add it to the longest word\n                    if word[i:] in longest_word_dict:\n                        longest_word = word\n                        break\n                    \n                    # If the word cannot be formed from the word, add it to the longest word\n                    else:\n                        longest_word = word\n                        break\n                    \n            # If the longest word is not empty, add it to the list of concatenated words\n            if longest_word:\n                longest_word_dict[word] = longest_word\n        \n        # Initialize the list of concatenated words\n        concatenated_words = []\n        \n        # Iterate through the words in the set\n        for word in words:\n            \n            # If the word is in the dictionary, check if it can be formed from the words in the set\n            if word in longest_word_dict:\n                \n                # If the word can be formed from the words in the set, add it to the list of concatenated words\n                if longest_word_dict[word] == word:\n                    concatenated_words.append(word)\n                \n                # If the word cannot be formed from the words in the set, add it to the list of concatenated words\n                else:\n                    concatenated_words.append(word)\n        \n        # Return the list of concatenated words\n        return concatenated_words"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 queen\n        # 2. 2 queens\n        # 3. 3 queens\n        # 4. 4 queens\n        # 5. 5 queens\n        # 6. 6 queens\n        # 7. 7 queens\n        # 8. 8 queens\n        # 9. 9 queens\n        # 10. 10 queens\n        # 11. 11 queens\n        # 12. 12 queens\n        # 13. 13 queens\n        # 14. 14 queens\n        # 15. 15 queens\n        # 16. 16 queens\n        # 17. 17 queens\n        # 18. 18 queens\n        # 19. 19 queens\n        # 20. 20 queens\n        # 21. 21 queens\n        # 22. 22 queens\n        # 23. 23 queens\n        # 24. 24 queens\n        # 25. 25 queens\n        # 26. 26 queens\n        # 27. 27 queens\n        # 28. 28 queens\n        # 29. 29 queens\n        # 30. 30 queens\n        # 31. 31 queens\n        # 32. 32 queens\n        # 33. 33 queens\n        # 34. 34 queens\n        # 35. 35 queens\n        # 36. 36 queens\n        # 37. 37 queens\n        # 38. 38 queens\n        # 39. 39 queens\n        # 40. 40 queens\n        # 41. 41 queens\n        # 42. 42 queens\n        # 43. 43 queens\n        # 44. 44 queens\n        # 45. 45 queens\n        # 46. 46 queens\n        # 47. 47 queens\n        # 48. 48 queens\n        # 49. 49 queens\n        # 50. 50 queens\n        # 51. 51 queens\n        # 52. 52 queens\n        # 53. 53 queens\n        # 54. 54 queens\n        # 55. 55 queens\n        # 56. 56 queens\n        # 57. 57 queens\n        # 58. 58 queens\n        # 59. 59 queens\n        # 60. 60 queens\n        # 61. 61 queens\n        # 62. 62 queens\n        # 63. 63 queens\n        # 64. 64 queens\n        # 65. 65 queens\n        # 66. 66 queens\n        # 67. 67 queens\n        # 68. 68 queens\n        # 69. 69 queens\n        # 70. 70 queens\n        # 71. 71 queens\n        # 72. 72 queens\n        # 73. 73 queens\n        # 74. 74 queens\n        # 75. 75 queens\n        # 76. 76 queens\n        # 77. 77 queens\n        # 78. 78 queens\n        # 79. 79 queens\n        # 80. 80 queens\n        # 81. 81 queens\n        # 82. 82 queens\n        # 83. 83 queens\n        # 84. 84 queens\n        # 85. 85 queens\n        # 86. 86 queens\n        # 87. 87 queens"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\n        # 2. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 3. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 4. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 5. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 6. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 7. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 8. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 9. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 10. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 11. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 12. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \uc6d0\uc18c\ub97c \uc804\uccb4 \uc88c\ud45c\ub85c \ucd08\uae30\ud654\n        # 13. \uc804\uccb4 \uc88c\ud45c\ub97c \ub2f4\uc744 \ubc30\uc5f4\uc758 \uccab\ubc88\uc9f8 \ufffd"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. Check if the word is empty\n        if len(word) == 0:\n            return True\n        \n        ## 2. Check if the board is empty\n        if len(board) == 0:\n            return False\n        \n        ## 3. Check if the word is longer than the board\n        if len(word) > len(board) * len(board[0]):\n            return False\n        \n        ## 4. Check if the word is shorter than the board\n        if len(word) < len(board) * len(board[0]):\n            return False\n        \n        ## 5. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]):\n            return True\n        \n        ## 6. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) - 1:\n            return True\n        \n        ## 7. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 1:\n            return True\n        \n        ## 8. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 2:\n            return True\n        \n        ## 9. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 3:\n            return True\n        \n        ## 10. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 4:\n            return True\n        \n        ## 11. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 5:\n            return True\n        \n        ## 12. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 6:\n            return True\n        \n        ## 13. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 7:\n            return True\n        \n        ## 14. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 8:\n            return True\n        \n        ## 15. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 9:\n            return True\n        \n        ## 16. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 10:\n            return True\n        \n        ## 17. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 11:\n            return True\n        \n        ## 18. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 12:\n            return True\n        \n        ## 19. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 13:\n            return True\n        \n        ## 20. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 14:\n            return True\n        \n        ## 21. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 15:\n            return True\n        \n        ## 22. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 16:\n            return True\n        \n        ## 23. Check if the word is the same as the board\n        if len(word) == len(board) * len(board[0]) + 17:\n            return True\n        \n        ## 24"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array in descending order\n        # 2. If the array has less than 3 elements, return the largest element\n        # 3. If the array has 3 elements, return the third element\n        # 4. If the array has 4 elements, return the third element\n        # 5. If the array has 5 elements, return the third element\n        # 6. If the array has 6 elements, return the third element\n        # 7. If the array has 7 elements, return the third element\n        # 8. If the array has 8 elements, return the third element\n        # 9. If the array has 9 elements, return the third element\n        # 10. If the array has 10 elements, return the third element\n        # 11. If the array has 11 elements, return the third element\n        # 12. If the array has 12 elements, return the third element\n        # 13. If the array has 13 elements, return the third element\n        # 14. If the array has 14 elements, return the third element\n        # 15. If the array has 15 elements, return the third element\n        # 16. If the array has 16 elements, return the third element\n        # 17. If the array has 17 elements, return the third element\n        # 18. If the array has 18 elements, return the third element\n        # 19. If the array has 19 elements, return the third element\n        # 20. If the array has 20 elements, return the third element\n        # 21. If the array has 21 elements, return the third element\n        # 22. If the array has 22 elements, return the third element\n        # 23. If the array has 23 elements, return the third element\n        # 24. If the array has 24 elements, return the third element\n        # 25. If the array has 25 elements, return the third element\n        # 26. If the array has 26 elements, return the third element\n        # 27. If the array has 27 elements, return the third element\n        # 28. If the array has 28 elements, return the third element\n        # 29. If the array has 29 elements, return the third element\n        # 30. If the array has 30 elements, return the third element\n        # 31. If the array has 31 elements, return the third element\n        # 32. If the array has 32 elements, return the third element\n        # 33. If the array has 33 elements, return the third element\n        # 34. If the array has 34 elements, return the third element\n        # 35. If the array has 35 elements, return the third element\n        # 36. If the array has 36 elements, return the third element\n        # 37. If the array has 37 elements, return the third element\n        # 38. If the array has 38 elements, return the third element\n        # 39. If the array has 39 elements, return the third element\n        # 40. If the array has 40 elements, return the third element\n        # 41. If the array has 41 elements, return the third element\n        # 42. If the array has 42 elements, return the third element\n        # 43. If the array has 43 elements, return the third element\n        # 44. If the array has 44 elements, return the third element\n        # 45. If the array has 45 elements, return the third element\n        # 46. If the array has 46 elements, return the third element\n        # 47. If the array has 47 elements, return the third element\n        # 48. If the array has 48 elements, return the third element\n        # 49. If the array has 49 elements, return the third element\n        # 50. If the array has 50 elements, return the third element\n        # 51. If the array has 51 elements, return the third element\n        # 52. If the array has 52 elements, return the third element\n        # 53"}]}