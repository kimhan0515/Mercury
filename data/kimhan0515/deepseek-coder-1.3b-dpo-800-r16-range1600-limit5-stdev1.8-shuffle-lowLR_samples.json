{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            if top > bottom:\n                break\n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            if right < left:\n                break\n            for i in range(right, left-1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n            if bottom < top:\n                break\n            for i in range(bottom, top-1, -1):\n                res.append(matrix[i][left])\n            left += 1\n            \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end += 1\n            else:\n                if end > start:\n                    res.append(str(start) + \"->\" + str(end))\n                else:\n                    res.append(str(start))\n                start = nums[i]\n                end = nums[i]\n        \n        if end > start:\n            res.append(str(start) + \"->\" + str(end))\n        else:\n            res.append(str(start))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) < len(t):\n            return 0\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] == t[count]:\n                count += 1\n            if count > 0:\n                dp[count] += dp[count - 1]\n        \n        return dp[count] if count > 0 else 0"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers as 0\n        # 2. mark all numbers in the range [1,n] as 1\n        # 3. iterate through the array and mark the numbers as negative if they are in the range [1,n]\n        # 4. iterate through the array again and find the first number that is not negative\n        # 5. if all numbers are negative, return n+1\n        # 6. if the first positive number is 1, return 2\n        # 7. if the first positive number is greater than 1, return 1\n        \n        n = len(nums)\n        if n == 0:\n            return 1\n        \n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            if abs(nums[i]) <= n and nums[abs(nums[i]) - 1] > 0:\n                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1]\n        \n        for i in range(1, n):\n            if nums[i] > 0:\n                return i\n        \n        if nums[0] > 0:\n            return n\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        ans = \"\"\n        digits = [i for i in range(1, n+1)]\n        for i in range(n-1, -1, -1):\n            # calculate the number of digits in the current permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the number of digits in the next permutation\n            # (n-1-i) because we need to subtract 1 from the current digit\n            # to get the"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] > target:\n                right -= 1\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                return [left + 1, right + 1]\n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if not num:\n            return []\n        \n        n = len(num)\n        res = []\n        last_num = 0\n        cur_num = 0\n        cur_val = 0\n        op = '+'\n        for i in range(n):\n            cur_num = cur_num * 10 + int(num[i])\n            if i > 0:\n                cur_val = cur_val * 10 + int(num[i-1])\n            if i > 0 and num[0] == '0' or i == 0:\n                if i == 0:\n                    cur_val = cur_num\n                else:\n                    cur_val = cur_val * 10 + cur_num\n            if i < n - 1:\n                next_num = cur_num * 10 + int(num[i+1])\n                cur_val = cur_val * 10 + int(num[i])\n                if i > 0:\n                    cur_val = cur_val * 10 + int(num[i-1])\n            if i < n - 1 or i == n - 1:\n                if op == '+':\n                    cur_val = cur_val + next_num\n                elif op == '-':\n                    cur_val = next_num - cur_val\n                elif op == '*':\n                    cur_val = cur_val * next_num\n                if cur_val > target:\n                    break\n                if cur_val == target and cur_num == 0:\n                    res.append(str(cur_val))\n                if cur_num > 0:\n                    cur_val = cur_val - next_num + next_num\n                    if op == '+':\n                        cur_val = cur_val + next_num\n                    elif op == '-':\n                        cur_val = -cur_val + next_num\n                    elif op == '*':\n                        cur_val = cur_val - last_num + last_num * next_num\n                    if cur_val > target:\n                        break\n                    if cur_val == target and cur_num == 0:\n                        res.append(str(cur_val))\n                    last_num = cur_num\n                    cur_num = next_num\n                    op = '+'\n                    if i < n - 2:\n                        cur_val = cur_val * 10 + int(num[i+1])\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        stack = [(root, root.val)]\n        sum = 0\n        \n        while stack:\n            node, val = stack.pop()\n            if node.left:\n                node.left.val = val * 10 + node.left.val\n                stack.append((node.left, node.left.val))\n            if node.right:\n                node.right.val = val * 10 + node.right.val\n                stack.append((node.right, node.right.val))\n            if not node.left and not node.right:\n                sum += val\n                \n        return sum"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()[::-1]\n        n = len(s) % k\n        if n == 0:\n            n = k\n        ans = s[:n]\n        ans += '-' * (len(s) - n)\n        i = n\n        while i < len(s):\n            ans += s[i:i+k]\n            if i < len(s) - 1:\n                ans += '-'\n            i += k\n        if ans.endswith('-'):\n            ans = ans[:-1]\n        return ans[::-1]"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank, curr_sum, start = 0, 0, 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n            curr_sum += gas[i] - cost[i]\n            \n        return start if tank >= curr_sum else -1"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [0] * n\n        for i in range(n-2):\n            dp[i+1] = max(dp[i+1], dp[i])\n            j = i + nums[i+1] - 1\n            if j < n-1:\n                dp[j] = max(dp[j], dp[i])\n                nums[i] *= nums[j]\n            else:\n                nums[i] *= 1\n        return dp[-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if digits[-1] < 9:\n            digits[-1] += 1\n            return digits\n        else:\n            carry = 1\n            for i in range(len(digits)-1,-1,-1):\n                if digits[i] < 9:\n                    digits[i] += 1\n                    carry = 0\n                    break\n                else:\n                    digits[i] = 0\n            if carry:\n                digits.insert(0,1)\n            return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return false if s is not empty\n        if not p:\n            return not s\n        \n        # if p has a star, check if there is a previous character\n        # if there is no previous character, return false\n        # if there is a previous character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character, check if it is a . or a character\n        # if it is a ., then check if there is a next character\n        # if there is no next character, return false\n        # if there is a next character"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) < k or len(nums2) < k:\n            return []\n        \n        if k == 0:\n            return []\n        \n        if k == len(nums1):\n            return nums2[:k]\n        \n        if k == len(nums2):\n            return nums1[:k]\n        \n        if nums1[k-1] > nums2[k-1]:\n            return nums1[:k]\n        else:\n            return nums2[:k]\n        \n        # if len(nums1) < k or len(nums2) < k:\n        #     return []\n        \n        # if k == 0:\n        #     return []\n        \n        # if k == len(nums1):\n        #     return nums2[:k]\n        \n        # if k == len(nums2):\n        #     return nums1[:k]\n        \n        # if nums1[k-1] > nums2[k-1]:\n        #     return nums1[:k]\n        # else:\n        #     return nums2[:k]\n        \n        # if len(nums1) < k or len(nums2) < k:\n        #     return []\n        \n        # if k == 0:\n        #     return []\n        \n        # if k == len(nums1):\n        #     return nums2[:k]\n        \n        # if k == len(nums2):\n        #     return nums1[:k]\n        \n        # if nums1[k-1] > nums2[k-1]:\n        #     return nums1[:k]\n        # else:\n        #     return nums2[:k]\n        \n        # if len(nums1) < k or len(nums2) < k:\n        #     return []\n        \n        # if k == 0:\n        #     return []\n        \n        # if k == len(nums1):\n        #     return nums2[:k]\n        \n        # if k == len(nums2):\n        #     return nums1[:k]\n        \n        # if nums1[k-1] > nums2[k-1]:\n        #     return nums1[:k]\n        # else:\n        #     return nums2[:k]\n        \n        # if len(nums1) < k or len(nums2) < k:\n        #     return []\n        \n        # if k == 0:\n        #     return []\n        \n        # if k == len(nums1):\n        #     return nums2[:k]\n        \n        # if k == len(nums2):\n        #     return nums1[:k]\n        \n        # if nums1[k-1] > nums2[k-1]:\n        #     return nums1[:k]\n        # else:\n        #     return nums2[:k]\n        \n        # if len(nums1) < k or len(nums2) < k:\n        #     return []\n        \n        # if k == 0:\n        #     return []\n        \n        # if k == len(nums1):\n        #     return nums2[:k]\n        \n        # if k == len(nums2):\n        #     return nums1[:k]\n        \n        # if nums1[k-1] > nums2[k-1]:\n        #     return nums1[:k]\n        # else:\n        #     return nums2[:k]\n        \n        # if len(nums1) < k or len(nums2) < k:\n        #     return []\n        \n        # if k == 0:\n        #     return []\n        \n        # if k == len(nums1):\n        #     return nums2[:k]\n        \n        # if k == len(nums2):\n        #     return nums1[:k]\n        \n        # if nums1[k-1] > nums2[k-1]:\n        #     return nums1[:k]\n        # else:\n        #     return nums2[:k]\n        \n        # if len(nums1) < k or len(nums2) < k"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 1:\n            return False\n        # 2 is the only even perfect number\n        # 6 is the only perfect number divisible by 3\n        # 49 is the only perfect number divisible by 7\n        # 33550336 is the only perfect number divisible by 8\n        # 81388003 is the only perfect number divisible by 9\n        # 1373662976 is the only perfect number divisible by 10\n        # 285311670617 is the only perfect number divisible by 11\n        # 5625142528329 is the only perfect number divisible by 12\n        # 11867069767450413 is the only perfect number divisible by 13\n        # 23571142912370641 is the only perfect number divisible by 14\n        # 47591255472250529 is the only perfect number divisible by 15\n        # 1124005699337224125 is the only perfect number divisible by 16\n        # 2772631578947006641 is the only perfect number divisible by 17\n        # 5585059400226134513 is the only perfect number divisible by 18\n        # 1258291227411664389 is the only perfect number divisible by 19\n        # 2972134793646708913 is the only perfect number divisible by 20\n        # 5948550150125262961 is the only perfect number divisible by 21\n        # 13463364050000000000 is the only perfect number divisible by 22\n        # 29524516400000000000 is the only perfect number divisible by 23\n        # 62772528000000000000 is the only perfect number divisible by 24\n        # 137274680000000000000 is the only perfect number divisible by 25\n        # 303700416000000000000 is the only perfect number divisible by 26\n        # 647200832000000000000 is the only perfect number divisible by 27\n        # 1392401664000000000000 is the only perfect number divisible by 28\n        # 3037004160000000000000 is the only perfect number divisible by 29\n        # 6472008320000000000000 is the only perfect number divisible by 30\n        # 13924016640000000000000 is the only perfect number divisible by 31\n        # 30370041600000000000000 is the only perfect number divisible by 32\n        # 64720083200000000000000 is the only perfect number divisible by 33\n        # 139240166400000000000000 is the only perfect number divisible by 34\n        # 303700416000000000000000 is the only perfect number divisible by 35\n        # 647"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b % (10**9 + 7)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[m - 1][n] = max(1, 1 - dungeon[m - 1][n])\n        dp[m][n - 1] = max(1, 1 - dungeon[m][n - 1])\n        for i in range(m - 1, -1, -1):\n            dp[i][n] = max(dp[i + 1][n] - dungeon[i][n], 1)\n        for j in range(n - 1, -1, -1):\n            dp[m][j] = max(dp[m][j + 1] - dungeon[m][j], 1)\n        for i in range(m - 1, 0, -1):\n            for j in range(n - 1, 0, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        return dp[0][1]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            j = 0\n            cnt = 0\n            for i in range(n):\n                if nums[i] - nums[j] > mid:\n                    j += 1\n                cnt += i - j\n            if cnt >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n        l, r = 0, len(s) - 1\n        s = list(s)\n        while l < r:\n            if s[l] not in vowels:\n                l += 1\n            elif s[r] not in vowels:\n                r -= 1\n            else:\n                s[l], s[r] = s[r], s[l]\n                l += 1\n                r -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## XOR all the numbers from 0 to n\n        ## XOR all the numbers in the array\n        ## XOR the two numbers\n        ## return the XOR\n        ## if n is 0, return 0\n        ## if n is 1, return 1\n        ## if n is 2, return 2\n        ## if n is 3, return 3\n        ## if n is 4, return 4\n        ## if n is 5, return 5\n        ## if n is 6, return 6\n        ## if n is 7, return 7\n        ## if n is 8, return 8\n        ## if n is 9, return 9\n        ## if n is 10, return 10\n        ## if n is 11, return 11\n        ## if n is 12, return 12\n        ## if n is 13, return 13\n        ## if n is 14, return 14\n        ## if n is 15, return 15\n        ## if n is 16, return 16\n        ## if n is 17, return 17\n        ## if n is 18, return 18\n        ## if n is 19, return 19\n        ## if n is 20, return 20\n        ## if n is 21, return 21\n        ## if n is 22, return 22\n        ## if n is 23, return 23\n        ## if n is 24, return 24\n        ## if n is 25, return 25\n        ## if n is 26, return 26\n        ## if n is 27, return 27\n        ## if n is 28, return 28\n        ## if n is 29, return 29\n        ## if n is 30, return 30\n        ## if n is 31, return 31\n        ## if n is 32, return 32\n        ## if n is 33, return 33\n        ## if n is 34, return 34\n        ## if n is 35, return 35\n        ## if n is 36, return 36\n        ## if n is 37, return 37\n        ## if n is 38, return 38\n        ## if n is 39, return 39\n        ## if n is 40, return 40\n        ## if n is 41, return 41\n        ## if n is 42, return 42\n        ## if n is 43, return 43\n        ## if n is 44, return 44\n        ## if n is 45, return 45\n        ## if n is 46, return 46\n        ## if n is 47, return 47\n        ## if n is 48, return 48\n        ## if n is 49, return 49\n        ## if n is 50, return 50\n        ## if n is 51, return 51\n        ## if n is 52, return 52\n        ## if n is 53, return 53\n        ## if n is 54, return 54\n        ## if n is 55, return 55\n        ## if n is 56, return 56\n        ## if n is 57, return 57\n        ## if n is 58, return 58\n        ## if n is 59, return 59\n        ## if n is 60, return 60\n        ## if n is 61, return 61\n        ## if n is 62, return 62\n        ## if n is 63, return 63\n        ## if n is 64, return 64\n        ## if n"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        q = collections.deque([beginWord])\n        distance = 1\n        while q:\n            for i in range(len(q)):\n                word = q.popleft()\n                for j in range(len(word)):\n                    new_word = word[:j] + \"*\" + word[j+1:]\n                    for w in wordList:\n                        if w == new_word:\n                            q.append(w)\n                            wordList.remove(w)\n                    new_word = word[:j] + \"*\" + word[j+1:]\n            distance += 1\n            if endWord in wordList:\n                return distance\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        a = list(a)[::-1]\n        b = list(b)[::-1]\n        carry = 0\n        res = []\n        for i in range(len(a)):\n            if i < len(b):\n                val = int(a[i]) + int(b[i]) + carry\n            else:\n                val = int(a[i]) + carry\n            carry = val // 2\n            res.append(val % 2)\n        if carry:\n            res.append(carry)\n        return ''.join(map(str, res[::-1]))"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return [-1, -1]\n        \n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] != target:\n            left += 1\n        if left == right and nums[left] != target:\n            return [-1, -1]\n        left += 1\n        right = len(nums) - 1\n        while left < right and nums[right] != target:\n            right -= 1\n        if left == right and nums[right] != target:\n            return [-1, -1]\n        right += 1\n        return [left, right - 1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return len(nums)\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        cur_reach = 0\n        \n        for i in range(1, len(nums)):\n            if i > cur_reach:\n                jumps += 1\n                cur_reach = max_reach\n            max_reach = max(max_reach, nums[i] + i)\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            profit = 0\n            for i in range(1, len(prices)):\n                if prices[i] > prices[i-1]:\n                    profit += prices[i] - prices[i-1]\n            return profit\n        \n        if k == 0:\n            return 0\n        \n        buy = [float('-inf')] * k\n        sell = [0] * k\n        \n        for price in prices:\n            for i in range(k-1):\n                buy[i] = max(buy[i], sell[i] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n        \n        return sell[-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        hex_map = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        res = ''\n        while num > 0:\n            rem = num % 16\n            if rem < 10:\n                res = str(rem) + res\n            else:\n                res = hex_map[rem] + res\n            num = num // 16\n        return res if res else '0'"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of the character\n        # if the value is 0, then it is the first occurence of the character\n        # return the value of the hashmap\n        \n        # create a hashmap with character as key and index as value\n        # iterate over the string and update the value of the hashmap\n        # if the value is 1, then it is the first occurence of the character\n        # if the value is -1, then it is the second occurence of"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if indexDiff < 1 or valueDiff < 0:\n            return False\n        \n        # use a set to store the values in the sliding window\n        # if the set contains a value that is within valueDiff of the current value,\n        # then we have found a match\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to find the closest value in the set to the current value\n        # if the set does not contain a value that is within valueDiff of the current value,\n        # then we need to"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_ones = 0\n        ones = 0\n        for n in nums:\n            if n == 1:\n                ones += 1\n            else:\n                ones = 0\n            max_ones = max(max_ones, ones)\n        return max_ones"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = root\n        right = root\n        level = 0\n        while right.left:\n            left = left.left\n            right = right.right\n            level += 1\n        \n        if not left:\n            return (1 << level) - 1\n        \n        # right now left and right are at the same level\n        # we need to find the number of nodes in the left subtree\n        # and the number of nodes in the right subtree\n        # we can do this by counting the number of nodes in the left subtree\n        # and subtracting 1 (since the last node is counted twice)\n        # and then right shifting the number of nodes in the left subtree\n        # by 1\n        # we can do this because the left subtree is a complete binary tree\n        # and the right subtree is a full binary tree\n        # so the number of nodes in the left subtree is 2^level - 1\n        # and the number of nodes in the right subtree is 2^(level - 1) - 1\n        # and the number of nodes in the left subtree is 2^(level - 1) - 1\n        # and the number of nodes in the right subtree is 2^(level - 2) - 1\n        # and the number of nodes in the left subtree is 2^(level - 2) - 1\n        # and the number of nodes in the right subtree is 2^(level - 3) - 1\n        # and the number of nodes in the left subtree is 2^(level - 3) - 1\n        # and the number of nodes in the right subtree is 2^(level - 4) - 1\n        # and the number of nodes in the left subtree is 2^(level - 4) - 1\n        # and the number of nodes in the right subtree is 2^(level - 5) - 1\n        # and the number of nodes in the left subtree is 2^(level - 5) - 1\n        # and the number of nodes in the right subtree is 2^(level - 6) - 1\n        # and the number of nodes in the left subtree is 2^(level - 6) - 1\n        # and the number of nodes in the right subtree is 2^(level - 7) - 1\n        # and the number of nodes in the left subtree is 2^(level - 7) - 1\n        # and the number of nodes in the right subtree is 2^(level - 8) - 1\n        # and the number of nodes in the left subtree is 2^(level - 8) - 1\n        # and the number of nodes in the right subtree is 2^(level - 9) - 1\n        # and the number of nodes in the left subtree is 2^(level - 9) - 1\n        # and the number of nodes in the right subtree is 2^(level - 10) - 1\n        # and the number of nodes in the left subtree is 2^(level - 10) - 1\n        # and the number of nodes in the right subtree is 2^(level - 11) - 1\n        # and the number of nodes in the left subtree is 2^(level - 11) - 1\n        # and the number of nodes in the right subtree is 2^(level - 12) - 1\n        # and the number of nodes in the left subtree is 2^(level - 12) - 1\n        # and the number of nodes in the right subtree is 2^(level - 13) - 1\n        # and the number of nodes in the left subtree is 2^(level - 13) - 1\n        # and the number of nodes in the right subtree is 2^(level - 14) - 1\n        # and the number of nodes in the left subtree is 2^(level - 14) - 1\n        # and the number of nodes in the right subtree is 2^(level - 15) - 1\n        # and the number of nodes in the left subtree is 2^(level - 15) - 1\n        # and the number of nodes"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        carry = 0\n        res = []\n        for i in range(len(num1)):\n            val = int(num1[i]) + int(num2[i]) + carry\n            carry = val // 10\n            res.append(str(val % 10))\n        for i in range(len(num1), len(num2)):\n            val = int(num2[i]) + carry\n            carry = val // 10\n            res.append(str(val % 10))\n        if carry:\n            res.append(str(carry))\n        return ''.join(res[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the stack and the result\n        stack = [1]\n        sign = 1\n        num = 0\n        \n        # 2. Iterate over the string\n        for i in range(len(s)):\n            if s[i] == ' ' and num > 0:\n                stack.append(num)\n                num = 0\n            elif s[i] == '+':\n                sign = stack[-1]\n                num = 0\n            elif s[i] == '-':\n                sign = -stack[-1]\n                num = 0\n            elif s[i] == '(':\n                stack.append(sign)\n                sign = 1\n            elif s[i] == ')':\n                sign = stack.pop()\n                num = 0\n            else:\n                num = num * 10 + int(s[i])\n                \n        # 3. Add the last number to the result\n        if num > 0:\n            stack.append(num)\n        # 4. Add the numbers in the stack\n        for n in stack:\n            num += n\n        return num"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # if capital[i] > w, then we can't do anything\n        # if capital[i] <= w, then we can do i\n        # if i < k, then we can do i\n        # if i > k, then we can't do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we can't do i\n        # if i > k, then we can't do i\n        # if i < k, then we can do i\n        # if i == k, then we"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) % 2 != 0:\n            return False\n        \n        stack = []\n        d = {')':'(', ']':'[', '}':'{'}\n        \n        for c in s:\n            if c not in d:\n                stack.append(c)\n            elif not stack or d[c] != stack.pop():\n                return False\n        \n        return not stack"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first element from the right which is smaller than its next element\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        # if all elements are in descending order, then we need to reverse the whole array\n        if i == -1:\n            nums.reverse()\n            return\n        # find the element just greater than nums[i]\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        # swap the elements\n        nums[i], nums[j] = nums[j], nums[i]\n        # reverse the elements from i+1 to end\n        nums[i+1:] = nums[i+1:][::-1]\n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if k < 1:\n            return False\n        \n        d = {}\n        for i, n in enumerate(nums):\n            if n not in d:\n                d[n] = i\n            else:\n                if i - d[n] <= k:\n                    return True\n                d[n] = i\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        prev = nums[0]\n        \n        for num in nums[1:]:\n            max_diff = max(max_diff, num - prev)\n            prev = num\n            \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        while q:\n            level = []\n            for i in range(len(q)):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row) // 2\n        couples = [(row[i] // 2, i) for i in range(0, n)]\n        couples.sort()\n        ans = 0\n        for i in range(n):\n            if couples[i][1] % 2 == 1:\n                if couples[i] > couples[i - 1]:\n                    ans += 1\n                else:\n                    couples[i - 1] += 1\n            else:\n                if couples[i] > couples[i - 1]:\n                    ans += 1\n                else:\n                    couples[i - 1] += 1\n        return ans"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if s1 == s2:\n            return s3.count('a') % 2 == 1\n        \n        if s1[0] == s2[0] == s3[0]:\n            return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\n        \n        if s1[0] == s3[0]:\n            return self.isInterleave(s1[1:], s2, s3[1:])\n        if s2[0] == s3[0]:\n            return self.isInterleave(s1, s2[1:], s3[1:])\n        \n        return False"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        \n        ans = []\n        for word in words:\n            row = None\n            if word[0] in row1:\n                row = 1\n            elif word[0] in row2:\n                row = 2\n            else:\n                row = 3\n            if all(word[i] in row1 if row == 1 else word[i] in row2 if row == 2 else word[i] in row3 for i in range(1, len(word))):\n                ans.append(word)\n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        # reverse the nodes from left to right\n        prev_rev = None\n        curr_rev = curr\n        for i in range(right - left):\n            next_rev = curr_rev.next\n            curr_rev.next = prev_rev\n            prev_rev = curr_rev\n            curr_rev = next_rev\n        \n        # connect the reversed nodes to the original list\n        prev.next = prev_rev\n        curr.next = curr_rev\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the current index\n        # if the current index is 0, then the longest palindrome is itself\n        # if the current index is not 0, then the longest palindrome is the longest palindrome that can be centered at the current index - 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is itself\n        # if the current index is not n-1, then the longest palindrome is the longest palindrome that can be centered at the current index + 1\n        # if the current index is n-1, then the longest palindrome is"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        # create a hashmap of all the characters in t\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we need to find in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters\n        # we have found in s\n        # and their frequencies\n        # we will use this to keep track of the characters"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) <= 2:\n            return False\n        \n        if distance[3] >= distance[1] and distance[2] >= distance[0]:\n            return True\n        \n        if distance[1] >= distance[3] and distance[4] >= distance[0]:\n            return True\n        \n        if distance[2] >= distance[0] and distance[5] >= distance[1]:\n            return True\n        \n        if distance[4] >= distance[2] and distance[3] >= distance[5]:\n            return True\n        \n        if distance[1] >= distance[5] and distance[0] >= distance[3]:\n            return True\n        \n        if distance[3] >= distance[1] and distance[0] >= distance[2]:\n            return True\n        \n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        curr = head\n        while curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # if the frequency is odd, add 1 to the count\n        # if the frequency is even, add 2 to the count\n        # if the count is greater than 1, add 1 to the count\n        # if the count is 1, add 1 to the count\n        # return the count\n        \n        count = 0\n        freq = {}\n        for c in s:\n            if c not in freq:\n                freq[c] = 1\n            else:\n                freq[c] += 1\n                if freq[c] == 2:\n                    count += 1\n                elif freq[c] == 1:\n                    count += 1\n        if count > 0:\n            count += 1\n        return count"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        # find the root value\n        root_val = postorder[-1]\n        root_idx = inorder.index(root_val)\n        \n        # create the root node\n        root = TreeNode(root_val)\n        \n        # create the left subtree\n        root.left = self.buildTree(inorder[:root_idx], postorder[:root_idx])\n        \n        # create the right subtree\n        root.right = self.buildTree(inorder[root_idx+1:], postorder[root_idx:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        trees = []\n        m, n = len(forest), len(forest[0])\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        if not trees:\n            return -1\n        ans = 0\n        curr = 0\n        for h, i, j in trees:\n            d = abs(i - curr[0]) + abs(j - curr[1])\n            if d == 0:\n                curr = (i, j)\n                continue\n            if d > curr[0] + curr[1]:\n                return -1\n            curr = (i, j)\n            ans += d\n        return ans"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and root.right:\n            return 1 + min(self.minDepth(root.left), self.minDepth(root.right))\n        \n        if root.left:\n            return 1 + self.minDepth(root.left)\n        \n        if root.right:\n            return 1 + self.minDepth(root.right)\n        \n        return 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Use two pointers to find the sum of the subarray\n        # 3. Use a hashmap to store the frequency of the sum\n        # 4. Iterate over the array and update the frequency of the sum\n        # 5. If the sum is in the hashmap, add the frequency to the answer\n        # 6. If the sum is greater than upper, decrement the frequency\n        # 7. If the sum is less than lower, increment the frequency\n        # 8. Add the frequency to the hashmap\n        # 9. Return the answer\n        \n        # 1. Sort the array\n        nums = sorted(nums)\n        \n        # 2. Use two pointers to find the sum of the subarray\n        # 3. Use a hashmap to store the frequency of the sum\n        # 4. Iterate over the array and update the frequency of the sum\n        # 5. If the sum is in the hashmap, add the frequency to the answer\n        # 6. If the sum is greater than upper, decrement the frequency\n        # 7. If the sum is less than lower, increment the frequency\n        # 8. Add the frequency to the hashmap\n        # 9. Return the answer\n        \n        # 1. Sort the array\n        nums = sorted(nums)\n        \n        # 2. Use two pointers to find the sum of the subarray\n        # 3. Use a hashmap to store the frequency of the sum\n        # 4. Iterate over the array and update the frequency of the sum\n        # 5. If the sum is in the hashmap, add the frequency to the answer\n        # 6. If the sum is greater than upper, decrement the frequency\n        # 7. If the sum is less than lower, increment the frequency\n        # 8. Add the frequency to the hashmap\n        # 9. Return the answer\n        \n        # 1. Sort the array\n        nums = sorted(nums)\n        \n        # 2. Use two pointers to find the sum of the subarray\n        # 3. Use a hashmap to store the frequency of the sum\n        # 4. Iterate over the array and update the frequency of the sum\n        # 5. If the sum is in the hashmap, add the frequency to the answer\n        # 6. If the sum is greater than upper, decrement the frequency\n        # 7. If the sum is less than lower, increment the frequency\n        # 8. Add the frequency to the hashmap\n        # 9. Return the answer\n        \n        # 1. Sort the array\n        nums = sorted(nums)\n        \n        # 2. Use two pointers to find the sum of the subarray\n        # 3. Use a hashmap to store the frequency of the sum\n        # 4. Iterate over the array and update the frequency of the sum\n        # 5. If the sum is in the hashmap, add the frequency to the answer\n        # 6. If the sum is greater than upper, decrement the frequency\n        # 7. If the sum is less than lower, increment the frequency\n        # 8. Add the frequency to the hashmap\n        # 9. Return the answer\n        \n        # 1. Sort the array\n        nums = sorted(nums)\n        \n        # 2. Use two pointers to find the sum of the subarray\n        # 3. Use a hashmap to store the frequency of the sum\n        # 4. Iterate over the array and update the frequency of the sum\n        # 5. If the sum is in the hashmap, add the frequency to the answer\n        # 6. If the sum is greater than upper, decrement the frequency\n        # 7. If the sum is less than lower, increment the frequency\n        # 8. Add the frequency to the hashmap\n        # 9. Return the answer\n        \n        # 1. Sort the array\n        nums = sorted(nums)\n        \n        # 2. Use two pointers to find the sum of the subarray\n        # 3. Use a hashmap to store the frequency of the sum\n        # 4. Iterate over the array and update the frequency of the sum\n        # 5. If the sum is in the hashmap, add the frequency to the answer\n        # 6. If the sum is greater"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if n is 1, return 1\n        if n == 1:\n            return 1\n        \n        # if n is 2, return 2\n        if n == 2:\n            return 2\n        \n        # if n is 3, return 3\n        if n == 3:\n            return 3\n        \n        # if n is 4, return 4\n        if n == 4:\n            return 4\n        \n        # if n is 5, return 5\n        if n == 5:\n            return 5\n        \n        # if n is 6, return 6\n        if n == 6:\n            return 6\n        \n        # if n is 7, return 7\n        if n == 7:\n            return 7\n        \n        # if n is 8, return 8\n        if n == 8:\n            return 8\n        \n        # if n is 9, return 9\n        if n == 9:\n            return 9\n        \n        # if n is 10, return 10\n        if n == 10:\n            return 10\n        \n        # if n is 11, return 11\n        if n == 11:\n            return 11\n        \n        # if n is 12, return 12\n        if n == 12:\n            return 12\n        \n        # if n is 13, return 13\n        if n == 13:\n            return 13\n        \n        # if n is 14, return 14\n        if n == 14:\n            return 14\n        \n        # if n is 15, return 15\n        if n == 15:\n            return 15\n        \n        # if n is 16, return 16\n        if n == 16:\n            return 16\n        \n        # if n is 17, return 17\n        if n == 17:\n            return 17\n        \n        # if n is 18, return 18\n        if n == 18:\n            return 18\n        \n        # if n is 19, return 19\n        if n == 19:\n            return 19\n        \n        # if n is 20, return 20\n        if n == 20:\n            return 20\n        \n        # if n is 21, return 21\n        if n == 21:\n            return 21\n        \n        # if n is 22, return 22\n        if n == 22:\n            return 22\n        \n        # if n is 23, return 23\n        if n == 23:\n            return 23\n        \n        # if n is 24, return 24\n        if n == 24:\n            return 24\n        \n        # if n is 25, return 25\n        if n == 25:\n            return 25\n        \n        # if n is 26, return 26\n        if n == 26:\n            return 26\n        \n        # if n is 27, return 27\n        if n == 27:\n            return 27\n        \n        # if n is 28, return 28\n        if n == 28:\n            return 28\n        \n        # if n is 29, return 29\n        if n == 29:\n            return 29\n        \n        # if n is 30, return 30\n        if n == 30:\n            return 30\n        \n        # if n is 31, return 31\n        if n == 31:\n            return 31\n        \n        # if n is 32, return 32\n        if n == 32:\n            return 32\n        \n        # if n is 33, return 33\n        if n == 33:\n            return 33\n        \n        # if n is 34, return 34\n        if n == 34:\n            return 34\n        \n        # if n is 35, return 35\n        if n == 35:\n            return 35\n        \n        # if n is 36, return"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        while q:\n            temp = []\n            for node in q:\n                temp.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            q = temp\n            res.append(temp)\n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0 or (x % 10 == 0 and x != 0):\n            return False\n        \n        rev = 0\n        y = x\n        \n        while y > rev:\n            rev = rev * 10 + y % 10\n            y = y // 10\n            \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        one, two = 1, 1\n        for i in range(1, len(s)):\n            curr = 0\n            if s[i] != '0':\n                curr += two\n            if s[i-1] != '0' and int(s[i-1:i+1]) <= 26:\n                curr += one\n            one, two = two, curr\n        return two"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) > len(t):\n            return False\n        if len(s) == 0:\n            return True\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0]\n        for i in range(1, n):\n            res.append(res[-1] ^ (1 << (i - 1)))\n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 2:\n            return n\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = dp[j] and s[j:i] in wordDict\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j in range(i)\n        # O(n^2) time and O(n) space\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # inorder traversal\n        # if the inorder traversal is sorted, it is a BST\n        # if not, it is not a BST\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and lower bound\n        # if the inorder traversal is sorted, we can use the last element as the upper bound\n        # if not, we can use the min and max value as the upper and"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not intervals:\n            return [newInterval]\n        \n        start, end = newInterval\n        i = 0\n        res = []\n        \n        # find the index of the interval that needs to be merged with the new interval\n        while i < len(intervals) and start > intervals[i][1]:\n            res.append(intervals[i])\n            i += 1\n        \n        # merge with the new interval if it overlaps\n        while i < len(intervals) and end >= intervals[i][0]:\n            start = min(start, intervals[i][0])\n            end = max(end, intervals[i][1])\n            i += 1\n        \n        res.append([start, end])\n        \n        # add the rest of the intervals to the result without any overlap\n        while i < len(intervals):\n            res.append(intervals[i])\n            i += 1\n        \n        return res"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        if not s:\n            return [[]]\n        \n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n            if i > 0:\n                dp[i][i-1] = s[i] == s[i-1]\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i+1][j-1] and s[i] == s[j]\n        \n        ans = []\n        cur = [0]\n        for i in range(n):\n            if dp[cur[-1]][i]:\n                cur.append(i+1)\n            if i == n-1 or not dp[cur[-1]][i]:\n                ans.append(cur[:])\n                cur = [i+1]\n        return ans"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # min_val = float('inf')\n        # max_val = float('-inf')\n        # for l in nums:\n        #     min_val = min(min_val, l[0])\n        #     max_val = max(max_val, l[-1])\n        # min_val = min_val\n        # max_val = max_val\n        # if max_val - min_val <= 0:\n        #     return [min_val, max_val]\n        # min_val = nums[0][0]\n        # max_val = nums[0][0]\n        # for l in nums[1:]:\n        #     min_val = min(min_val, l[0])\n        #     max_val = max(max_val, l[-1])\n        # min_val = min_val\n        # max_val = max_val\n        # if max_val - min_val <= 0:\n        #     return [min_val, max_val]\n        # min_val = nums[0][0]\n        # max_val = nums[0][0]\n        # for l in nums[1:]:\n        #     min_val = min(min_val, l[0])\n        #     max_val = max(max_val, l[-1])\n        # min_val = min_val\n        # max_val = max_val\n        # if max_val - min_val <= 0:\n        #     return [min_val, max_val]\n        # min_val = nums[0][0]\n        # max_val = nums[0][0]\n        # for l in nums[1:]:\n        #     min_val = min(min_val, l[0])\n        #     max_val = max(max_val, l[-1])\n        # min_val = min_val\n        # max_val = max_val\n        # if max_val - min_val <= 0:\n        #     return [min_val, max_val]\n        # min_val = nums[0][0]\n        # max_val = nums[0][0]\n        # for l in nums[1:]:\n        #     min_val = min(min_val, l[0])\n        #     max_val = max(max_val, l[-1])\n        # min_val = min_val\n        # max_val = max_val\n        # if max_val - min_val <= 0:\n        #     return [min_val, max_val]\n        # min_val = nums[0][0]\n        # max_val = nums[0][0]\n        # for l in nums[1:]:\n        #     min_val = min(min_val, l[0])\n        #     max_val = max(max_val, l[-1])\n        # min_val = min_val\n        # max_val = max_val\n        # if max_val - min_val <= 0:\n        #     return [min_val, max_val]\n        # min_val = nums[0][0]\n        # max_val = nums[0][0]\n        # for l in nums[1:]:\n        #     min_val = min(min_val, l[0])\n        #     max_val = max(max_val, l[-1])\n        # min_val = min_val\n        # max_val = max_val\n        # if max_val - min_val <= 0:\n        #     return [min_val, max_val]\n        # min_val = nums[0][0]\n        # max_val = nums[0][0]\n        # for l in nums[1:]:\n        #     min_val = min(min_val, l[0])\n        #     max_val = max(max_val, l[-1])\n        # min_val = min_val\n        # max_val = max_val\n        # if max_val - min_val <= 0:\n        #     return [min_val, max_val]\n        # min_val = nums[0][0]\n        # max_val = nums[0][0]\n        # for l in nums[1:]:"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        if buckets == 1:\n            return 0\n        if buckets <= minutesToTest / minutesToDie + 1:\n            return 1\n        return ceil(log(minutesToTest / minutesToDie + 1, buckets)) + 1"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        q = [(grid[0][0], 0, 0)]\n        seen = set((0, 0))\n        ans = 0\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        while q:\n            t, r, c = heapq.heappop(q)\n            ans = max(ans, t)\n            if r == c == n - 1:\n                return ans\n            for dr, dc in dirs:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in seen:\n                    seen.add((nr, nc))\n                    heapq.heappush(q, (grid[nr][nc], nr, nc))\n        return ans"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[-1]\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     dp[0] = 1\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        res = 0\n        n1 = len(num1)\n        n2 = len(num2)\n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        for i in range(n1):\n            carry = 0\n            for j in range(n2):\n                curr = (num1[i] - '0') * (num2[j] - '0') + carry\n                curr += res * 10\n                res = curr % 10\n                carry = curr / 10\n            if carry > 0:\n                res += carry\n            num1[i] = res % 10 + '0'\n            res /= 10\n        if res > 0:\n            num1.append(res % 10 + '0')\n        if num1[0] == '0':\n            return num1[1:]\n        return num1[::-1]"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        # buy1, buy2 = prices[0], prices[0]\n        # profit = 0\n        # for p in prices:\n        #     buy1 = min(buy1, p)\n        #     profit = max(profit, p - buy1)\n        # return profit\n        \n        # buy1, sell1 = prices[0], 0\n        # buy2 = buy1\n        # for p in prices:\n        #     buy1 = min(buy1, p - buy2)\n        #     sell1 = max(sell1, p - buy1)\n        #     buy2 = buy1\n        # return sell1\n        \n        # buy1, sell1 = prices[0], 0\n        # profit = 0\n        # for p in prices:\n        #     if buy1 > p:\n        #         buy1 = p\n        #     else:\n        #         profit = max(profit, p - buy1)\n        # return profit\n        \n        buy1, sell1 = prices[0], 0\n        profit = 0\n        for p in prices:\n            if buy1 > p:\n                buy1 = p\n            else:\n                profit = max(profit, p - buy1)\n            sell1 = max(sell1, p - buy1)\n        return sell1"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        i = 0\n        while i < len(candidates) and candidates[i] <= target:\n            if candidates[i] == candidates[i-1]:\n                i += 1\n                continue\n            l, r = i+1, len(candidates)-1\n            while l < r:\n                if candidates[l] + candidates[r] > target:\n                    r -= 1\n                elif candidates[l] + candidates[r] < target:\n                    l += 1\n                else:\n                    res.append([candidates[l], candidates[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and candidates[l] == candidates[l-1]:\n                        l += 1\n            i += 1\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or (word[0] >= 'A' and word[0] <= 'Z' and word[1:] == word[1:].lower()):\n            return True\n        return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr or stack:\n            if curr:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        # find the root value in inorder\n        root_val = preorder[0]\n        root_idx = inorder.index(root_val)\n        \n        # create left subtree\n        left_subtree = self.buildTree(preorder[1:root_idx+1], inorder[:root_idx])\n        \n        # create right subtree\n        right_subtree = self.buildTree(preorder[root_idx+1:], inorder[root_idx+1:])\n        \n        # create root node\n        root = TreeNode(root_val)\n        root.left = left_subtree\n        root.right = right_subtree\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # find the number of left and right parentheses\n        left, right = 0, 0\n        for c in s:\n            if c == '(':\n                left += 1\n            elif c == ')':\n                if left > 0:\n                    left -= 1\n                else:\n                    right += 1\n        # add left parentheses to the string\n        # add right parentheses to the string\n        # reverse the string if left > right\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result\n        # add the string to the result"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists or len(lists) == 0:\n            return None\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        curr = dummy\n        # find the smallest node\n        smallest = min(lists, key = lambda x: x.val if x else float('inf'))\n        if not smallest:\n            return None\n        \n        # add the smallest node to the list\n        lists[lists.index(smallest)] = smallest.next\n        # if the smallest node is empty, remove it from the list\n        if not smallest.next:\n            lists.remove(smallest)\n        \n        # add the smallest node to the dummy node\n        curr.next = smallest\n        \n        # find the next smallest node\n        smallest = min(lists, key = lambda x: x.val if x else float('inf'))\n        \n        # if the smallest node is empty, remove it from the list\n        if not smallest:\n            return dummy.next\n        \n        # add the smallest node to the dummy node\n        curr.next = smallest\n        curr = curr.next\n        smallest = smallest.next\n        \n        # add the next smallest node to the list\n        lists[lists.index(smallest)] = smallest.next\n        if not smallest.next:\n            lists.remove(smallest)\n        \n        # find the next smallest node\n        smallest = min(lists, key = lambda x: x.val if x else float('inf'))\n        \n        # if the smallest node is empty, remove it from the list\n        if not smallest:\n            return dummy.next\n        \n        # add the smallest node to the dummy node\n        curr.next = smallest\n        curr = curr.next\n        smallest = smallest.next\n        \n        # add the next smallest node to the list\n        lists[lists.index(smallest)] = smallest.next\n        if not smallest.next:\n            lists.remove(smallest)\n        \n        # find the next smallest node\n        smallest = min(lists, key = lambda x: x.val if x else float('inf'))\n        \n        # if the smallest node is empty, remove it from the list\n        if not smallest:\n            return dummy.next\n        \n        # add the smallest node to the dummy node\n        curr.next = smallest\n        curr = curr.next\n        smallest = smallest.next\n        \n        # add the next smallest node to the list\n        lists[lists.index(smallest)] = smallest.next\n        if not smallest.next:\n            lists.remove(smallest)\n        \n        # find the next smallest node\n        smallest = min(lists, key = lambda x: x.val if x else float('inf'))\n        \n        # if the smallest node is empty, remove it from the list\n        if not smallest:\n            return dummy.next\n        \n        # add the smallest node to the dummy node\n        curr.next = smallest\n        curr = curr.next\n        smallest = smallest.next\n        \n        # add the next smallest node to the list\n        lists[lists.index(smallest)] = smallest.next\n        if not smallest.next:\n            lists.remove(smallest)\n        \n        # find the next smallest node\n        smallest = min(lists, key = lambda x: x.val if x else float('inf'))\n        \n        # if the smallest node is empty, remove it from the list\n        if not smallest:\n            return dummy.next\n        \n        # add the smallest node to the dummy node\n        curr.next = smallest\n        curr = curr.next\n        smallest = smallest.next\n        \n        # add the next smallest node to the list\n        lists[lists.index(smallest)] = smallest.next\n        if not smallest.next:\n            lists.remove(smallest)\n        \n        # find the next smallest node\n        smallest = min(lists, key = lambda x: x.val if x else float('inf'))\n        \n        # if the smallest node is empty, remove it from the list\n        if not smallest:\n            return dummy.next\n        \n        # add the smallest node to the dummy node\n        curr.next = smallest\n        curr = curr.next\n        smallest = smallest.next\n        \n        # add the next smallest node to the list\n        lists[lists.index(small"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5224\u65ad\u662f\u5426\u4e3a\u56de\u6587\n        # 2. \u52a8\u6001\u89c4\u5212\n        # 3. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 4. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 5. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 6. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 7. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 8. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 9. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 10. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 11. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 12. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 13. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 14. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 15. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 16. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 17. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 18. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 19. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 20. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 21. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 22. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 23. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 24. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 25. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 26. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 27. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 28. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 29. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 30. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 31. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 32. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 33. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 34. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 35. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 36. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 37. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 38. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 39. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 40. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 41. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 42. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 43. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 44. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 45. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 46. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 47. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 48. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 49. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 50. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 51. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 52. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 53. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 54. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 55. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 56. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 57. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 58. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 59. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 60. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 61. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 62. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 63. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 64. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 65. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 66. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 67. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 68. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 69. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 70. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 71. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 72. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 73. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 74. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 75. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 76. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 77. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 78. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 79. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 80. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 81. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 82. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 83. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 84. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 85. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        # 86. \u4e2d\u5fc3\u6269\u5c55\u6cd5\n        #"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^10 = 10^9 * 2 + 1\n        # 2. 10^9 = 10^8 * 5 + 4\n        # 3. 10^8 = 10^7 * 9 + 1\n        # 4. 10^7 = 10^6 * 4 + 2\n        # 5. 10^6 = 10^5 * 9 + 3\n        # 6. 10^5 = 10^4 * 4 + 4\n        # 7. 10^4 = 10^3 * 9 + 5\n        # 8. 10^3 = 10^2 * 4 + 9\n        # 9. 10^2 = 10^1 * 9 + 10\n        # 10. 10^1 = 10^0 * 4 + 10\n        # 11. 10^0 = 1\n        # 12. 1 = 0\n        # 13. 0 = 0\n        # 14. 0 = 0\n        # 15. 0 = 0\n        # 16. 0 = 0\n        # 17. 0 = 0\n        # 18. 0 = 0\n        # 19. 0 = 0\n        # 20. 0 = 0\n        # 21. 0 = 0\n        # 22. 0 = 0\n        # 23. 0 = 0\n        # 24. 0 = 0\n        # 25. 0 = 0\n        # 26. 0 = 0\n        # 27. 0 = 0\n        # 28. 0 = 0\n        # 29. 0 = 0\n        # 30. 0 = 0\n        # 31. 0 = 0\n        # 32. 0 = 0\n        # 33. 0 = 0\n        # 34. 0 = 0\n        # 35. 0 = 0\n        # 36. 0 = 0\n        # 37. 0 = 0\n        # 38. 0 = 0\n        # 39. 0 = 0\n        # 40. 0 = 0\n        # 41. 0 = 0\n        # 42. 0 = 0\n        # 43. 0 = 0\n        # 44. 0 = 0\n        # 45. 0 = 0\n        # 46. 0 = 0\n        # 47. 0 = 0\n        # 48. 0 = 0\n        # 49. 0 = 0\n        # 50. 0 = 0\n        # 51. 0 = 0\n        # 52. 0 = 0\n        # 53. 0 = 0\n        # 54. 0 = 0\n        # 55. 0 = 0\n        # 56. 0 = 0\n        # 57. 0 = 0\n        # 58. 0 = 0\n        # 59. 0 = 0\n        # 60. 0 = 0\n        # 61. 0 = 0\n        # 62. 0 = 0\n        # 63. 0 = 0\n        # 64. 0 = 0\n        # 65. 0 = 0\n        # 66. 0 = 0\n        # 67. 0 = 0\n        # 68. 0 = 0\n        # 69. 0 = 0\n        # 70. 0 = 0\n        # 71. 0 = 0\n        # 72. 0 = 0\n        # 73. 0 = 0\n        # 74. 0 = 0\n        # 75. 0 = 0\n        # 76. 0 = 0\n        # 77. 0 = 0\n        # 78. 0 = 0\n        # 79. 0 = 0\n        # 80. 0 = 0\n        # 81. 0 = 0\n        # 82. 0 = 0\n        # 83. 0 = 0\n        # 8"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        d = {w: i for i, w in en\n            enumerate(words)}\n        ans = []\n        for i, w in enumerate(words):\n            rw = w[::-1]\n            if rw in d:\n                j = d[rw]\n                if j != i:\n                    ans.append([i, j])\n                    ans.append([j, i])\n            for k in range(len(rw) + 1):\n                if rw[:k] in d:\n                    j = d[rw[:k]]\n                    if j != i and rw[k:] == rw[k:][::-1]:\n                        ans.append([i, j])\n        return ans"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        infected = 0\n        for i in range(m):\n            for j in range(n):\n                if isInfected[i][j] == 1:\n                    infected += 1\n        if infected == 0:\n            return 0\n        left, right = 0, infected\n        while left < right:\n            mid = (left + right) // 2\n            if self.can_spread(isInfected, mid) >= infected - mid:\n                right = mid\n            else:\n                left = mid + 1\n        return infected - left\n        \n    def can_spread(self, isInfected, infected):\n        m, n = len(isInfected), len(isInfected[0])\n        infected = 0\n        for i in range(m):\n            j = 0\n            while j < n and isInfected[i][j] == 0:\n                j += 1\n            if j == n:\n                continue\n            k = j\n            while j < n and isInfected[i][j] == 1:\n                j += 1\n            if j == n:\n                infected += (j - k) // 2\n            else:\n                infected += (j - k) // 2 - 1\n        return infected"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_path = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if dp[i][j]:\n                    max_path = max(max_path, dp[i][j])\n                    continue\n                path = 1\n                if i and matrix[i][j] > matrix[i-1][j]:\n                    path = dp[i-1][j] + 1\n                if i < m-1 and matrix[i][j] > matrix[i+1][j]:\n                    path = max(path, dp[i+1][j] + 1)\n                if j and matrix[i][j] > matrix[i][j-1]:\n                    path = max(path, dp[i][j-1] + 1)\n                if j < n-1 and matrix[i][j] > matrix[i][j+1]:\n                    path = max(path, dp[i][j+1] + 1)\n                dp[i][j] = path\n                max_path = max(max_path, path)\n        \n        return max_path"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 1:\n            return 0\n        if n < 10:\n            return 1\n        if n < 100:\n            return 10\n        if n < 1000:\n            return 100\n        if n < 10000:\n            return 1000\n        if n < 100000:\n            return 10000\n        if n < 1000000:\n            return 100000\n        if n < 10000000:\n            return 1000000\n        if n < 100000000:\n            return 10000000\n        if n < 1000000000:\n            return 100000000\n        if n < 10000000000:\n            return 1000000000\n        if n < 100000000000:\n            return 10000000000\n        if n < 1000000000000:\n            return 100000000000\n        if n < 10000000000000:\n            return 1000000000000\n        if n < 100000000000000:\n            return 10000000000000\n        if n < 1000000000000000:\n            return 100000000000000\n        if n < 10000000000000000:\n            return 1000000000000000\n        if n < 100000000000000000:\n            return 10000000000000000\n        if n < 1000000000000000000:\n            return 100000000000000000\n        if n < 10000000000000000000:\n            return 1000000000000000000\n        if n < 100000000000000000000:\n            return 10000000000000000000\n        if n < 1000000000000000000000:\n            return 100000000000000000000\n        if n < 10000000000000000000000:\n            return 1000000000000000000000\n        if n < 100000000000000000000000:\n            return 10000000000000000000000\n        if n < 1000000000000000000000000:\n            return 100000000000000000000000\n        if n < 10000000000000000000000000:\n            return 1000000000000000000000000\n        if n < 100000000000000000000000000:\n            return 10000000000000000000000000\n        if n < 10000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # Otherwise, dp[i] = False.\n        # Time: O(n^2)\n        # Space: O(n)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n                    break\n        if not dp[-1]:\n            return []\n        # If dp[i] is true, then s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # Add each word to a list of strings.\n        # Otherwise, add a \" \" to each position corresponding to the last set of dictionary words.\n        # The last element in the list will be the complete sentence.\n        # Time: O(n)\n        # Space: O(n)\n        res = []\n        word = \"\"\n        for i, d in enumerate(dp):\n            if d:\n                if word:\n                    word += \" \"\n                word += s[i]\n            elif word:\n                res.append(word)\n                word = \"\"\n        if word:\n            res.append(word)\n        return res"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        leftToRight = True\n        \n        while queue:\n            level = []\n            size = len(queue)\n            for i in range(size):\n                node = queue.pop(0)\n                if leftToRight:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            leftToRight = not leftToRight\n            result.append(level)\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if turnedOn == 0:\n            return ['0:00']\n        \n        res = []\n        for h in range(12):\n            if h*6 + turnedOn > turnedOn:\n                m = max(1, (turnedOn - (h*6)) // 2)\n                if m < 6:\n                    res.append('%d:%02d' % (h, m))\n                elif m == 6:\n                    res.append('%d:0%d' % (h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1,1],[1,2,1]]\n        \n        res = [[1] * i for i in range(1,numRows)]\n        for i in range(2,numRows):\n            for j in range(1,i):\n                res[i][j] = res[i-1][j-1] + res[i-1][j]\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        if n == 1:\n            return True\n        if n % 3 != 0:\n            return False\n        return self.isPowerOfThree(n // 3)"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left_gain + right_gain + node.val)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum if self.max_sum != float('-inf') else max(root.val, max_gain(root.left), max_gain(root.right))"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        n, m = len(heightMap), len(heightMap[0])\n        max_h = [heightMap[0][0]] + [max(max_h[-1], heightMap[i][0]) for i in range(1, m)]\n        min_h = [heightMap[-1][0]] + [min(min_h[-1], heightMap[-i - 1][0]) for i in range(1, m)]\n        for i in range(1, m):\n            max_h[i] = max(max_h[i], max_h[i - 1])\n            min_h[i] = min(min_h[i], min_h[i - 1])\n        \n        max_r, min_r = 0, m - 1\n        max_c, min_c = 0, n - 1\n        ans = 0\n        while max_r < min_r and max_c < min_c:\n            if max_h[max_c] > min_h[min_c]:\n                ans += min_h[min_c] - heightMap[min_c][min_r]\n                min_r -= 1\n            else:\n                ans += max_h[max_c] - heightMap[max_c][max_r]\n                max_r += 1\n            max_h[max_c] = max(max_h[max_c], heightMap[max_c][max_r])\n            min_h[min_c] = min(min_h[min_c], heightMap[min_c][min_r])\n        max_c += 1\n        min_c -= 1\n        while max_c < min_c:\n            ans += min_h[min_c] - heightMap[min_c][max_r]\n            min_c -= 1\n        max_r += 1\n        min_r -= 1\n        while max_r < min_r:\n            ans += max_h[max_r] - heightMap[max_r][min_c]\n            max_r += 1\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # remove all non-alphanumeric characters\n        s = re.sub('[^a-z0-9]', '', s)\n        \n        # check if the string is empty\n        if not s:\n            return True\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        if k == 1:\n            return [nums[i] for i in range(len(nums))]\n        \n        # create a max heap of the first k elements\n        max_heap = [-nums[i] for i in range(k)]\n        heapq.heapify(max_heap)\n        \n        # create a min heap of the first k/2 elements\n        min_heap = [max_heap[i] for i in range(k//2)]\n        if k % 2 == 1:\n            min_heap.append(max_heap[k//2])\n        heapq.heapify(min_heap)\n        \n        # add the first median to the output\n        medians = [-min_heap[0]]\n        \n        # iterate over the rest of the array\n        for i in range(k, len(nums)):\n            # add the new element to the max heap\n            heapq.heappush(max_heap, -nums[i])\n            # if the max heap has an odd number of elements,\n            # add the next element to the min heap\n            if len(max_heap) > k//2:\n                heapq.heappush(min_heap, -max_heap[k//2])\n            # if the max heap has an even number of elements,\n            # add the next element to the min heap\n            elif len(max_heap) == k//2:\n                heapq.heappush(min_heap, -max_heap[k//2])\n            # compute the median\n            if len(min_heap) > 0:\n                medians.append(-min_heap[0])\n            # if the min heap has an odd number of elements,\n            # add the next element to the max heap\n            elif len(min_heap) == k//2:\n                heapq.heappush(max_heap, -min_heap[k//2])\n            # if the min heap has an even number of elements,\n            # add the next element to the max heap\n            elif len(min_heap) > 0:\n                heapq.heappush(max_heap, -min_heap[k//2])\n        \n        # compute the median for the last window\n        if len(max_heap) > k//2:\n            medians.append(-max_heap[k//2])\n        elif len(max_heap) == k//2:\n            medians.append(-max_heap[k//2])\n        elif len(min_heap) > 0:\n            medians.append(-min_heap[0])\n        elif len(min_heap) == k//2:\n            medians.append(-min_heap[k//2])\n        \n        # divide the medians by k\n        for i in range(len(medians)-1):\n            medians[i] /= k\n        \n        return medians"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the new head\n        new_head = head\n        if k % length == 0:\n            return head\n        k = k % length\n        for i in range(length - k - 1):\n            new_head = new_head.next\n        new_tail = new_head\n        new_tail.next = None\n        \n        # find the new tail\n        curr = head\n        while curr.next:\n            curr = curr.next\n        curr.next = new_head\n        \n        return new_tail.next"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n == 1:\n            return True\n        \n        if n % 2 == 0:\n            n = n // 2\n        elif n % 3 == 0:\n            n = n // 3\n        elif n % 5 == 0:\n            n = n // 5\n        \n        if n == 1:\n            return True\n        \n        if n > 1 and n % 2 == 0:\n            return self.isUgly(n // 2)\n        elif n > 1 and n % 3 == 0:\n            return self.isUgly(n // 3)\n        elif n > 1 and n % 5 == 0:\n            return self.isUgly(n // 5)\n        \n        return False"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left coordinate\n        # 2. use a monotonic stack to keep track of the max height\n        # 3. use a hashmap to keep track of the max height at each position\n        # 4. use a variable to keep track of the max height\n        # 5. for each position, check if it is in the hashmap, if it is, update the max height\n        # 6. if it is not, add it to the hashmap\n        # 7. update the max height\n        # 8. return the list of max heights\n        \n        max_height = 0\n        max_height_map = {}\n        max_height_map[0] = 0\n        max_height_list = [0]\n        for left, side_length in positions:\n            max_height = max_height_map.get(left, 0)\n            max_height += side_length\n            max_height_map[left] = max_height\n            max_height_map[left + side_length] = max_height\n            max_height_list.append(max_height)\n        max_height_list.pop()\n        max_height_list.sort()\n        ans = []\n        for i in max_height_list:\n            ans.append(i)\n        return ans"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]: return 0\n        m, n = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        prefix_sum = [0] * n\n        if matrix[0][0] > k:\n            max_sum = matrix[0][0]\n        if n == 1:\n            for i in matrix:\n                max_sum = max(max_sum, i[0])\n            return max_sum if max_sum <= k else k\n        if m == 1:\n            for i in prefix_sum:\n                max_sum = max(max_sum, i)\n            return max_sum if max_sum <= k else k\n        for i in range(n):\n            prefix_sum[i] = matrix[0][i] if i > 0 else matrix[0][i]\n        for i in range(1, m):\n            curr_sum = prefix_sum[0]\n            for j in range(1, n):\n                prefix_sum[j] += matrix[i][j]\n            left, right = 0, n - 1\n            while left <= right:\n                mid = (left + right) // 2\n                curr_sum += prefix_sum[mid]\n                if curr_sum <= k:\n                    max_sum = max(max_sum, curr_sum)\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            curr_sum -= prefix_sum[0]\n            if curr_sum <= k:\n                max_sum = max(max_sum, curr_sum)\n            if max_sum == k:\n                return k\n            if prefix_sum[0] > k:\n                curr_sum -= prefix_sum[0]\n                prefix_sum[0] = matrix[0][0]\n            else:\n                prefix_sum[0] += matrix[0][0]\n        return max_sum if max_sum != float('-inf') else k"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        if dividend == -2**31 and divisor == 1:\n            return -2**31\n        if dividend > 0 and divisor > 0:\n            sign = 1\n        elif dividend < 0 and divisor > 0:\n            sign = -1\n        elif dividend > 0 and divisor < 0:\n            sign = -1\n        elif dividend < 0 and divisor < 0:\n            sign = 1\n        dividend = abs(dividend)\n        divisor = abs(divisor)\n        quotient = 0\n        while dividend >= divisor:\n            temp = divisor\n            power = 1\n            while dividend >= temp:\n                dividend -= temp\n                quotient += power\n                temp <<= 1\n                power <<= 1\n        if sign == 1:\n            if quotient > 2**31 - 1:\n                return 2**31 - 1\n            else:\n                return quotient\n        else:\n            if quotient < -2**31:\n                return -2**31\n            else:\n                return -quotient"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        # mark all the border 'O's with 'T's\n        for i in range(m):\n            for j in range(n):\n                if (i == 0 or j == 0 or i == m-1 or j == n-1) and board[i][j] == 'O':\n                    board[i][j] = 'T'\n        \n        # mark all the 'O's that are not on the border with 'F's\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'T' if i == 0 or j == 0 else 'F'\n        \n        # change all 'T's to 'O's and all 'F's to 'X's\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'T':\n                    board[i][j] = 'O' if board[i][j] == 'F' else 'X'\n        \n        return board"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a hashmap\n        hashmap = {}\n        \n        # iterate through the list\n        for i, num in en\n            # check if the complement is in the hashmap\n            if num in hashmap:\n                return [hashmap[num], i]\n            # if not, add it to the hashmap\n            hashmap[target - num] = i\n\n# Time Complexity: O(n)\n# Space Complexity: O(n)"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(cards) == 1:\n            return False\n        \n        if len(cards) == 2:\n            return abs(cards[0] - cards[1]) == 1\n        \n        if len(cards) == 3:\n            if cards[0] * 4 == cards[1] * 3:\n                return True\n            if cards[1] * 3 == cards[0] * 4:\n                return True\n            return False\n        \n        seen = set()\n        for i in range(len(cards) - 1):\n            for j in seen:\n                a, b = cards[i], cards[j]\n                if a * 4 == b * 3:\n                    return True\n                if b * 3 == a * 4:\n                    return True\n                seen.add(a + b)\n                seen.add(a - b)\n                if b != 0:\n                    seen.add(a / b)\n                if a != 0:\n                    seen.add(b / a)\n        return False"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if not p:\n            return not s\n        \n        # if p is not empty, then s must not be empty\n        if not s:\n            return not p.startswith('*')\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s:\n            return self.isMatch(s[:-1], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and not s:\n            return True\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return self.isMatch(s[:-1], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p starts with '*', then s can be empty\n        if p[0] == '*' and s[0] != '*':\n            return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/104088/Python-O(n)-Boyer-Moore-Voting-Algorithm\n        # https://leetcode.com/problems/majority-element/discuss/10408"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a hashmap of the airports to the list of airports that are connected to it\n        # if the airport is not in the hashmap, create a new list and add the airport to it\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to the itinerary\n        # if the airport is not in the hashmap, add it to the hashmap\n        # if the airport is in the hashmap, add the airport to the list\n        # then sort the list of airports\n        # then add the airport to"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        if n < 4:\n            return []\n        res = []\n        if nums[0] + nums[1] + nums[2] + nums[3] > target:\n            return res\n        if nums[n-1] + nums[n-2] + nums[n-3] + nums[n-4] < target:\n            return res\n        if nums[0] == nums[n-1] == nums[n-2] == nums[n-3]:\n            return [[nums[0],nums[1],nums[2],nums[3]]]\n        if nums[0] == nums[n-1] == nums[n-2] == nums[n-3] == nums[n-4]:\n            return [[nums[0],nums[1],nums[2],nums[3]]]\n        d = {}\n        for i in range(n-1):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]] + 1\n        for i in range(n-3):\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target:\n                break\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] < target:\n                continue\n            if nums[i] == nums[i+1] == nums[i+2] == nums[i+3]:\n                res.append([nums[i],nums[i],nums[i],nums[i]])\n                continue\n            if nums[i] == nums[i+1] == nums[i+2] == nums[i+3] == nums[i]:\n                res.append([nums[i],nums[i],nums[i],nums[i]])\n                continue\n            if nums[i] == nums[i+1] == nums[i+2] == nums[i+3] == nums[i] == nums[i]:\n                res.append([nums[i],nums[i],nums[i],nums[i]])\n                continue\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] == target:\n                res.append([nums[i],nums[i+1],nums[i+2],nums[i+3]])\n                continue\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] == target - nums[i]:\n                res.append([nums[i],nums[i+1],nums[i+2],nums[i+3]])\n                continue\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] == target + nums[i]:\n                res.append([nums[i],nums[i+1],nums[i+2],nums[i+3]])\n                continue\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] == target - nums[i] - nums[i]:\n                res.append([nums[i],nums[i+1],nums[i+2],nums[i+3]])\n                continue\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] == target + nums[i] - nums[i]:\n                res.append([nums[i],nums[i+1],nums[i+2],nums[i+3]])\n                continue\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] == target - nums[i] - nums[i] - nums[i]:\n                res.append"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        # if left edge is same, sort by right edge\n        # if right edge is same, sort by height\n        # if left edge is different, sort by height\n        # if right edge is different, sort by left edge\n        # if left edge is different, sort by right edge\n        # if right edge is different, sort by left edge\n        # if left edge is different, sort by right edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if right edge is different, sort by left edge\n        # if"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n\n# Time Complexity: O(n)\n# Space Complexity: O(1)"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not triangle:\n            return 0\n        \n        dp = triangle[-1]\n        \n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(len(triangle[i])):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j+1])\n        \n        return dp[0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        res = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                curr = num % 1000\n                if curr > 0:\n                    if res:\n                        res = ones[curr] + \" \" + thousands[i] + \" \" + res\n                    else:\n                        res = ones[curr] + \" \" + thousands[i]\n                if num % 1000000 > 0:\n                    res = ones[num % 1000000 // 1000] + \" \" + \"Hundred\" + \" \" + res\n                num //= 1000\n                i += 1\n            else:\n                num //= 1000\n        return res.strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if k == 0:\n            return 1\n        if k == 1:\n            return n\n        if n == 1:\n            return k\n        if k > n * (n - 1) / 2:\n            return (k - n % 2) % 1000000007\n        # dp[i] = dp[i - 1] + dp[i - 2]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7] + dp[i - 8]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7] + dp[i - 8] + dp[i - 9]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7] + dp[i - 8] + dp[i - 9] + dp[i - 10]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7] + dp[i - 8] + dp[i - 9] + dp[i - 10] + dp[i - 11]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7] + dp[i - 8] + dp[i - 9] + dp[i - 10] + dp[i - 11] + dp[i - 12]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7] + dp[i - 8] + dp[i - 9] + dp[i - 10] + dp[i - 11] + dp[i - 12] + dp[i - 13]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp[i - 4] + dp[i - 5] + dp[i - 6] + dp[i - 7] + dp[i - 8] + dp[i - 9] + dp[i - 10] + dp[i - 11] + dp[i - 12] + dp[i - 13] + dp[i - 14]\n        # dp[i] = dp[i - 1] + dp[i - 3] - dp["}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            first = prev.next\n            second = prev.next.next\n            \n            prev.next = second\n            first.next = second.next\n            second.next = first\n            \n            prev = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        small = ListNode(0)\n        large = ListNode(0)\n        small_tail = small\n        large_tail = large\n        \n        curr = head\n        \n        while curr:\n            if curr.val < x:\n                small_tail.next = curr\n                small_tail = small_tail.next\n            else:\n                large_tail.next = curr\n                large_tail = large_tail.next\n            curr = curr.next\n        \n        small_tail.next = large.next\n        large_tail.next = None\n        \n        return small.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent = [0] * (len(edges) + 1)\n        # find the node with more than one parent\n        child = [0] * (len(edges) + 1)\n        # find the node with more than one child\n        more_than_one_child = 0\n        # find the node with more than one parent\n        more_than_one_parent = 0\n        for u, v in edges:\n            if parent[u] > 0:\n                if child[u] > 0:\n                    more_than_one_child = u\n                    more_than_one_parent = parent[u]\n                child[u] = v\n            else:\n                parent[u] = v\n        if more_than_one_child:\n            return [more_than_one_child, more_than_one_parent]\n        # find the node with more than one child\n        for i in range(1, len(parent)):\n            if parent[i] > 0:\n                child[parent[i]] = i\n        # find the node with two parents\n        for i in range(1, len(parent)):\n            if child[i] == 0:\n                continue\n            if parent[child[i]] > 0:\n                return [child[i], parent[child[i]]]\n        return [0, 0]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        ans = [nums[0]]\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1]:\n                ans.append(nums[i])\n        ans = [x * (len(ans) - 1) + ans[len(ans) - 1] for x in ans]\n        ans.append(ans[-1] * (len(ans) - 1) + ans[len(ans) - 2])\n        ans = [x // (len(ans) - 1) for x in ans]\n        ans.append(ans[-1] // (len(ans) - 1))\n        ans = [x + 1 for x in ans]\n        ans.append(ans[-1] + 1)\n        ans = [x * (len(ans) - 1) + ans[len(ans) - 1] for x in ans]\n        ans.append(ans[-1] * (len(ans) - 1) + ans[len(ans) - 2])\n        ans = [x // (len(ans) - 1) for x in ans]\n        ans.append(ans[-1] // (len(ans) - 1))\n        ans = [x + 1 for x in ans]\n        ans.append(ans[-1] + 1)\n        ans = [x * (len(ans) - 1) + ans[len(ans) - 1] for x in ans]\n        ans.append(ans[-1] * (len(ans) - 1) + ans[len(ans) - 2])\n        ans = [x // (len(ans) - 1) for x in ans]\n        ans.append(ans[-1] // (len(ans) - 1))\n        ans = [x + 1 for x in ans]\n        ans.append(ans[-1] + 1)\n        ans = [x * (len(ans) - 1) + ans[len(ans) - 1] for x in ans]\n        ans.append(ans[-1] * (len(ans) - 1) + ans[len(ans) - 2])\n        ans = [x // (len(ans) - 1) for x in ans]\n        ans.append(ans[-1] // (len(ans) - 1))\n        ans = [x + 1 for x in ans]\n        ans.append(ans[-1] + 1)\n        ans = [x * (len(ans) - 1) + ans[len(ans) - 1] for x in ans]\n        ans.append(ans[-1] * (len(ans) - 1) + ans[len(ans) - 2])\n        ans = [x // (len(ans) - 1) for x in ans]\n        ans.append(ans[-1] // (len(ans) - 1))\n        ans = [x + 1 for x in ans]\n        ans.append(ans[-1] + 1)\n        ans = [x * (len(ans) - 1) + ans[len(ans) - 1] for x in ans]\n        ans.append(ans[-1] * (len(ans) - 1) + ans[len(ans) - 2])\n        ans = [x // (len(ans) - 1) for x in ans]\n        ans.append(ans[-1] // (len(ans) - 1))\n        ans = [x + 1 for x in ans]\n        ans.append(ans[-1] + 1)\n        ans = [x * (len(ans) - 1) + ans[len(ans) - 1] for x in ans]\n        ans.append(ans[-1] * (len(ans) - 1) + ans[len(ans) - 2])\n        ans = [x // (len(ans) - 1) for x in ans]\n        ans.append(ans[-1] // (len(ans) - 1))\n        ans ="}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR\n        # 0 ^ 1 = 1\n        # 0 ^ 0 = 0\n        # 1 ^ 1 = 0\n        # 1 ^ 0 = 1\n        # 0 ^ 1 ^ 1 = 0\n        # 0 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 1 = 0\n        # 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 = 0\n        # 0 ^ 1 ^ 1 ^ 0 = 1\n        # 0 ^ 0 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 1 ^ 0 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 ^"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) == 0:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)-1,-1,-1):\n        #     if s[i] == ' ':\n        #         if count > 0:\n        #             return count\n        #     else:\n        #         count += 1\n        # return count\n        \n        # if len(s) == 0:\n        #     return 0\n        # words = s.split()\n        # return len(words[-1])\n        \n        # if len(s) == 0:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)-1,-1,-1):\n        #     if s[i] == ' ':\n        #         if count > 0:\n        #             return count\n        #     else:\n        #         count += 1\n        # return count\n        \n        # if len(s) == 0:\n        #     return 0\n        # words = s.split()\n        # return len(words[-1])\n        \n        # if len(s) == 0:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)-1,-1,-1):\n        #     if s[i] == ' ':\n        #         if count > 0:\n        #             return count\n        #     else:\n        #         count += 1\n        # return count\n        \n        # if len(s) == 0:\n        #     return 0\n        # words = s.split()\n        # return len(words[-1])\n        \n        # if len(s) == 0:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)-1,-1,-1):\n        #     if s[i] == ' ':\n        #         if count > 0:\n        #             return count\n        #     else:\n        #         count += 1\n        # return count\n        \n        # if len(s) == 0:\n        #     return 0\n        # words = s.split()\n        # return len(words[-1])\n        \n        # if len(s) == 0:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)-1,-1,-1):\n        #     if s[i] == ' ':\n        #         if count > 0:\n        #             return count\n        #     else:\n        #         count += 1\n        # return count\n        \n        # if len(s) == 0:\n        #     return 0\n        # words = s.split()\n        # return len(words[-1])\n        \n        # if len(s) == 0:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)-1,-1,-1):\n        #     if s[i] == ' ':\n        #         if count > 0:\n        #             return count\n        #     else:\n        #         count += 1\n        # return count\n        \n        # if len(s) == 0:\n        #     return 0\n        # words = s.split()\n        # return len(words[-1])\n        \n        # if len(s) == 0:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)-1,-1,-1):\n        #     if s[i] == ' ':\n        #         if count > 0:\n        #             return count\n        #     else:\n        #         count += 1\n        # return count\n        \n        # if len(s) == 0:\n        #     return 0\n        # words = s.split()\n        # return len(words[-1])\n        \n        # if len(s) == 0:\n        #     return 0\n        # count = 0\n        # for i in range(len(s)-1,-1,-1):\n        #     if s[i] == ' ':\n        #         if count > 0:\n        #             return count\n        #     else:\n        #         count += 1\n        # return count\n        \n        # if len(s) == 0:\n        #     return 0\n        # words = s.split()\n        # return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[float('inf')] * n for _ in range(n)]\n        dp[0][0] = grid[0][0] if grid[0][0] > 0 else 0\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1] + grid[i][0] if grid[i][0] > 0 else float('inf')\n        for i in range(1, n):\n            dp[0][i] = dp[0][i - 1] + grid[0][i] if grid[0][i] > 0 else float('inf')\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i][j - 1] + grid[i][j], dp[i - 1][j] + grid[i][j]) if grid[i][j] > 0 else float('inf')\n        ans = 0\n        i, j = 0, n - 1\n        while i < n and j >= 0:\n            if grid[i][j] > 0:\n                ans += grid[i][j]\n                j -= 1\n            else:\n                i += 1\n        return ans if ans < float('inf') else ans - 1"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        a, l, p = 1, 2, 4\n        if n < 3:\n            return n\n        n -= 2\n        a = (a * p) % MOD\n        l = (l * p + l * (p - 1) // 2) % MOD\n        p = (p * p) % MOD\n        for i in range(n):\n            a, l, p = (a * 2 + l) % MOD, (l * 3 - a) % MOD, (p * 2) % MOD\n        return a % MOD"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        seen = set()\n        while n not in seen:\n            seen.add(n)\n            n = sum(int(d)**2 for d in str(n))\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        low = 0\n        high = len(nums) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return low"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i, n in en\n            if max_reach < i:\n                return False\n            max_reach = max(max_reach, i + n)\n        return max_reach >= len(nums) - 1"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,m):\n            grid[i][0] += grid[i-1][0]\n        for i in range(1,n):\n            grid[0][i] += grid[0][i-1]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        prev = '1'\n        curr = ''\n        count = 1\n        \n        for i in range(2, n+1):\n            count = 1\n            curr = ''\n            for j in range(1, len(prev)):\n                if prev[j] == prev[j-1]:\n                    count += 1\n                else:\n                    curr += str(count) + prev[j-1]\n                    count = 1\n            curr += str(count) + prev[-1]\n            prev = curr\n            \n        return prev"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search on the range of the max element in the array\n        # we are trying to find the max element in the array\n        # so we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        # we can use binary search to find the max element in the array\n        #"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return -1\n        \n        low = 0\n        high = len(nums) - 1\n        \n        while low <= high:\n            mid = low + (high - low) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < nums[high]:\n                if nums[mid] < target and nums[high] >= target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            else:\n                if nums[mid] > target and nums[low] <= target:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}\n        res = [''] if digits else []\n        for d in digits:\n            tmp = []\n            for c in phone[d]:\n                tmp += res\n            res = tmp\n            res = [r+c for r in res]\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        i = 0\n        while i < len(candidates) and candidates[i] <= target:\n            if candidates[i] == target:\n                res.append([target])\n            elif candidates[i] < target:\n                tmp = self.combinationSum(candidates[i:], target - candidates[i])\n                if tmp:\n                    for t in tmp:\n                        res.append([candidates[i]] + t)\n            i += 1\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if n[0] == '9':\n            return str(int(n) + 1)\n        \n        if n[0] == '1':\n            return '9' if n[1] == '9' else '10'\n        \n        if n[0] == '0':\n            return '9' if n[1] == '9' else '0'\n        \n        if n[0] == '5':\n            return '4' if n[1] == '9' else '5'\n        \n        half = int(n) // 2\n        left = str(half)\n        right = left[::-1]\n        \n        if n[0] == '1':\n            left = '0'\n            right = '9'\n        elif n[0] == '9':\n            left = '8'\n            right = '9'\n        else:\n            left = str(int(left) + 1)\n            right = right[::-1]\n        \n        candidates = [int(left), int(right), int(left) - 1, int(left) + 1]\n        \n        if n[0] != '9':\n            candidates.append(int(right) + 1)\n        \n        diff = abs(int(n) - candidates[0])\n        closest = candidates[0]\n        \n        for cand in candidates[1:]:\n            if abs(cand - int(n)) < diff:\n                diff = abs(cand - int(n))\n                closest = cand\n            elif abs(cand - int(n)) == diff:\n                closest = min(closest, cand)\n        \n        return str(closest)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        \n        matrix = [[0]*n for _ in range(n)]\n        left, right = 0, n-1\n        top, bottom = 0, n-1\n        num = 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        # transpose\n        for i in range(n):\n            for j in range(i):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(n):\n            matrix[i] = matrix[i][::-1]\n\n# Time: O(n^2)\n# Space: O(1)"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        max_prod_so_far = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max_prod * nums[i]\n            curr_min = min_prod * nums[i]\n            \n            max_prod = max(curr_max, curr_min, nums[i])\n            min_prod = min(curr_max, curr_min, nums[i])\n            \n            max_prod_so_far = max(max_prod, max_prod_so_far)\n            \n        return max_prod_so_far"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        d = {stones[0]: 1}\n        \n        for s in stones[1:]:\n            if s in d:\n                d[s] = d[s] - 1\n            if d[s] < 0:\n                return False\n            if s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 0:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 0 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 1 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 2 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 3 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 4 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 5 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 6 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 7 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 8 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 9 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 10 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 11 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 12 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 13 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 14 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 15 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 16 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 17 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 18 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 19 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 20 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 21 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 22 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 23 and s not in d:\n                d[s] = d.get(s-1, 0) + 1\n            if d[s] > 24 and s not in d:\n                d[s] = d.get(s-1, 0) + 1"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        # then assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign the rank to the score\n        # and assign"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) <= 1:\n        #     return len(s)\n        \n        # max_len = 0\n        # seen = set()\n        # left = 0\n        # for right in range(len(s)):\n        #     while s[right] in seen:\n        #         seen.remove(s[left])\n        #         left += 1\n        #     seen.add(s[right])\n        #     max_len = max(max_len, right - left + 1)\n        # return max_len\n        \n        # if len(s) <= 1:\n        #     return len(s)\n        \n        # max_len = 0\n        # seen = {}\n        # left = 0\n        # for right in range(len(s)):\n        #     if s[right] in seen:\n        #         left = max(left, seen[s[right]] + 1)\n        #     seen[s[right]] = right\n        #     max_len = max(max_len, right - left + 1)\n        # return max_len\n        \n        if len(s) <= 1:\n            return len(s)\n        \n        max_len = 0\n        seen = {}\n        left = 0\n        for right in range(len(s)):\n            if s[right] in seen:\n                left = max(left, seen[s[right]] + 1)\n            seen[s[right]] = right\n            max_len = max(max_len, right - left + 1)\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_dict = collections.Counter(words)\n        num_words = len(word_dict)\n        window_len = num_words * word_len\n        \n        # sliding window\n        left = 0\n        right = 0\n        word_count = collections.defaultdict(int)\n        for word in words:\n            word_count[word] += 1\n        \n        res = []\n        for c in s[:window_len]:\n            word_count[c] -= 1\n            if word_count[c] == 0:\n                num_words -= 1\n            right += 1\n            if num_words == 0:\n                word_count[s[left]] += 1\n                if word_count[s[left]] == 1:\n                    num_words += 1\n                left += 1\n        if num_words == 0:\n            res.append(left)\n        \n        # slide window\n        for word in words:\n            word_count[word] += 1\n        \n        for right in range(window_len, len(s)):\n            word_count[s[right - window_len]] -= 1\n            if word_count[s[right - window_len]] == 0:\n                num_words += 1\n            word_count[s[right]] += 1\n            if word_count[s[right]] == 1:\n                num_words -= 1\n            if num_words == 0:\n                word_count[s[left]] += 1\n                if word_count[s[left]] == 1:\n                    num_words += 1\n                left += 1\n            if num_words == 0:\n                res.append(left)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        res = 1\n        for i in range(1, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if max_val == i:\n                res += 1\n        return res"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = None\n            prev = dummy\n            while prev.next and prev.next.val < curr.val:\n                prev = prev.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = temp\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                val = curr.val\n                while curr and curr.val == val:\n                    curr = curr.next\n                prev.next = curr\n            else:\n                prev = curr\n                curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if nums[i] > 0:\n                break\n            if i == 0 or nums[i] != nums[i-1]:\n                l, r = i+1, len(nums)-1\n                while l < r:\n                    if nums[l] + nums[r] + nums[i] == 0:\n                        res.append([nums[i], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[l] + nums[r] + nums[i] < 0:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        if m > n:\n            return self.minDistance(word2, word1)\n        \n        if m == 0:\n            return n\n        \n        prev = 0\n        curr = 1\n        for i in range(1, n + 1):\n            temp = curr\n            if word1[prev] == word2[i - 1]:\n                curr = prev + 1\n            else:\n                curr = prev + 1\n            prev = temp\n        return n - curr + (m - curr)"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        if left:\n            for l in left:\n                root_path = str(root.val) + '->' + l\n                left.append(root_path)\n        if right:\n            for r in right:\n                root_path = str(root.val) + '->' + r\n                right.append(root_path)\n        return left or right"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of reverse pairs\n        # 2. use binary search to find the number of elements that are greater than nums[i]/2\n        # 3. add the number of reverse pairs to the answer\n        # 4. use binary search to find the number of elements that are greater than nums[i]/2\n        # 5. add the number of reverse pairs to the answer\n        # 6. use binary search to find the number of elements that are greater than nums[i]/2\n        # 7. add the number of reverse pairs to the answer\n        # 8. use binary search to find the number of elements that are greater than nums[i]/2\n        # 9. add the number of reverse pairs to the answer\n        # 10. use binary search to find the number of elements that are greater than nums[i]/2\n        # 11. add the number of reverse pairs to the answer\n        # 12. use binary search to find the number of elements that are greater than nums[i]/2\n        # 13. add the number of reverse pairs to the answer\n        # 14. use binary search to find the number of elements that are greater than nums[i]/2\n        # 15. add the number of reverse pairs to the answer\n        # 16. use binary search to find the number of elements that are greater than nums[i]/2\n        # 17. add the number of reverse pairs to the answer\n        # 18. use binary search to find the number of elements that are greater than nums[i]/2\n        # 19. add the number of reverse pairs to the answer\n        # 20. use binary search to find the number of elements that are greater than nums[i]/2\n        # 21. add the number of reverse pairs to the answer\n        # 22. use binary search to find the number of elements that are greater than nums[i]/2\n        # 23. add the number of reverse pairs to the answer\n        # 24. use binary search to find the number of elements that are greater than nums[i]/2\n        # 25. add the number of reverse pairs to the answer\n        # 26. use binary search to find the number of elements that are greater than nums[i]/2\n        # 27. add the number of reverse pairs to the answer\n        # 28. use binary search to find the number of elements that are greater than nums[i]/2\n        # 29. add the number of reverse pairs to the answer\n        # 30. use binary search to find the number of elements that are greater than nums[i]/2\n        # 31. add the number of reverse pairs to the answer\n        # 32. use binary search to find the number of elements that are greater than nums[i]/2\n        # 33. add the number of reverse pairs to the answer\n        # 34. use binary search to find the number of elements that are greater than nums[i]/2\n        # 35. add the number of reverse pairs to the answer\n        # 36. use binary search to find the number of elements that are greater than nums[i]/2\n        # 37. add the number of reverse pairs to the answer\n        # 38. use binary search to find the number of elements that are greater than nums[i]/2\n        # 39. add the number of reverse pairs to the answer\n        # 40. use binary search to find the number of elements that are greater than nums[i]/2\n        # 41. add the number of reverse pairs to the answer\n        # 42. use binary search to find the number of elements that are greater than nums[i]/2\n        # 43. add the number of reverse pairs to the answer\n        # 44. use binary search to find the number of elements that are greater than nums[i]/2\n        # 45. add the number of reverse pairs to the answer\n        # 46. use binary search to find the number of elements that are greater than nums[i]/2\n        # 47. add the number of reverse pairs to the answer\n        # 48. use binary search to find the number of elements that are greater than nums[i]/2\n        # 4"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        if tx < sx or ty < sy:\n            return False\n        if sx == tx and sy <= ty:\n            return (ty - sy) % sy == 0\n        if sy == ty and sx <= tx:\n            return (tx - sx) % sx == 0\n        if sy < tx and sx < ty:\n            return self.reachingPoints(sx, sy, tx % ty, ty)\n        if sy < tx and sx > ty:\n            return self.reachingPoints(sx, sy, tx % ty, ty)\n        if sy > tx and sx < ty:\n            return self.reachingPoints(sx, sy, tx % ty, ty)\n        return sx > ty and self.reachingPoints(sx, sy, tx % ty, ty)"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        l1 = len(v1)\n        l2 = len(v2)\n        i1 = 0\n        i2 = 0\n        while i1 < l1 or i2 < l2:\n            v1i = int(v1[i1] or 0)\n            v2i = int(v2[i2] or 0)\n            if v1i > v2i:\n                return 1\n            elif v1i < v2i:\n                return -1\n            i1 += 1\n            i2 += 1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # profit = 0\n        # buy = prices[0]\n        # for i in range(1, len(prices)):\n        #     if prices[i] < buy:\n        #         buy = prices[i]\n        #     else:\n        #         profit = max(profit, prices[i] - buy)\n        # return profit\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # profit = 0\n        # buy = prices[0]\n        # for i in range(1, len(prices)):\n        #     if prices[i] < buy:\n        #         buy = prices[i]\n        #     else:\n        #         profit = max(profit, prices[i] - buy)\n        # return profit\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # profit = 0\n        # buy = prices[0]\n        # for i in range(1, len(prices)):\n        #     if prices[i] < buy:\n        #         buy = prices[i]\n        #     else:\n        #         profit = max(profit, prices[i] - buy)\n        # return profit\n        \n        if len(prices) < 2:\n            return 0\n        \n        profit = 0\n        buy = prices[0]\n        for i in range(1, len(prices)):\n            if prices[i] < buy:\n                buy = prices[i]\n            else:\n                profit = max(profit, prices[i] - buy)\n        return profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end time\n        courses.sort(key=lambda x: x[1])\n        # max heap\n        q = []\n        # sum of durations\n        curr = 0\n        # iterate over courses\n        for d, end in courses:\n            # add to max heap\n            heapq.heappush(q, d)\n            # update sum\n            curr += d\n            # if sum exceeds end time, remove from max heap\n            if curr > end:\n                curr -= heapq.heappop(q)\n        # return length of max heap\n        return len(q)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr.next)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, end):\n        curr = prev.next\n        prev.next = None\n        while curr != end:\n            nxt = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = nxt\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) <= 1:\n            return False\n        \n        n = len(s)\n        for i in range(1, n//2 + 1):\n            if n % i == 0:\n                if s[:i] * (n//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i\n        # dp[i] = dp[i-1] * 2 * dp[i-1] + dp[i-1] * dp[i-2]\n        # dp[i] = dp[i-1] * dp[i-1] + dp[i-1] * dp[i-2] * 2\n        # dp[i] = dp[i-1] * dp[i-1] * 2 + dp[i-1] * dp[i-2] * 3 + ... + dp[i-1] * dp[i-2] * 2\n        # dp[i] = dp[i-1] * dp[i-1] * 2 + dp[i-1] * dp[i-2] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2\n        # dp[i] = dp[i-1] * dp[i-1] * 2 + dp[i-1] * dp[i-2] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1] * dp[i-2] * 2 + dp[i-1] * dp[i-3] * 3 + ... + dp[i-1"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the numbers\n        # a ^ a = 0\n        # a ^ 0 = a\n        # a ^ b ^ a = b\n        # a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b = a\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a = b\n        # a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a ^ b ^ a"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # convert target to a set of 0s and 1s\n        # 0s are the ones that are not in the stickers\n        # 1s are the ones that are in the stickers\n        # we can use a set to keep track of the ones we have seen\n        # if we see a 1, we add it to the set\n        # if we see a 0, we subtract it from the set\n        # if the set is empty, we return -1\n        # if the set has a negative number, we return -1\n        # if the set has a positive number, we add it to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        # we add the number to the set\n        #"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        if n <= 1:\n            return n\n        \n        dp = [1] * n\n        prev = s[0]\n        for i in range(1, n):\n            if s[i] == prev:\n                dp[i] = dp[i-1] + 1\n            else:\n                dp[i] = dp[i-1]\n                prev = s[i]\n        return dp[-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        low = 1\n        high = x // 2\n        while low <= high:\n            mid = low + (high - low) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return high"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        prev = 0\n        ans = 0\n        for i in range(len(s)-1,-1,-1):\n            curr = roman_dict[s[i]]\n            if curr < prev:\n                ans -= curr\n            else:\n                ans += curr\n            prev = curr\n        return ans"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # use set to store the values\n        # if the length of the set is less than the length of the list, then there is a duplicate\n        return len(set(nums)) != len(nums)"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        q = []\n        res = []\n        for i in range(len(nums)):\n            if q and q[0] <= i - k:\n                q.pop(0)\n            while q and nums[q[-1]] <= nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                res.append(nums[q[0]])\n        return res"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        m, n = len(nums1), len(nums2)\n        lo, hi = 0, m\n        half_len = (m + n + 1) // 2\n        \n        while lo <= hi:\n            mid2 = (lo + hi) // 2\n            mid1 = half_len - mid2\n            \n            if nums1[mid1 - 1] > nums2[mid2]:\n                hi = mid1 - 1\n            elif nums1[mid1] < nums2[mid2 - 1]:\n                lo = mid1 + 1\n            else:\n                if mid1 == 0:\n                    max_left = nums2[mid2 - 1]\n                elif mid2 == 0:\n                    max_left = nums1[mid1 - 1]\n                else:\n                    max_left = max(nums1[mid1 - 1], nums2[mid2 - 1])\n                \n                if (m + n) % 2 == 1:\n                    return max_left\n                \n                if mid1 == m:\n                    min_right = nums2[mid2]\n                elif mid2 == n:\n                    min_right = nums1[mid1]\n                else:\n                    min_right = min(nums1[mid1], nums2[mid2])\n                \n                return (max_left + min_right) / 2.0\n        \n        return 0.0"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            elif nums[mid] < nums[r]:\n                r = mid\n            else:\n                r -= 1\n        return nums[l]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        res = [1,1]\n        for i in range(2, rowIndex+1):\n            res = [1] + [res[j] + res[j+1] for j in range(len(res)-1)] + [1]\n        return res"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        stack = [(root, root.val)]\n        \n        while stack:\n            node, val = stack[-1]\n            if node.left:\n                stack.append((node.left, val + node.left.val))\n                node.left = None\n            elif node.right:\n                stack.append((node.right, val + node.right.val))\n                node.right = None\n            else:\n                if val == targetSum:\n                    res.append(list(reversed(stack)))\n                stack.pop()\n        return res"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * L >= area, L = sqrt(area)\n        # 2. L <= area / L, L = area / L\n        L = int(area ** 0.5)\n        return [area // L, L] if L * L == area else [area, L]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList = set(wordList)\n        q = collections.deque([beginWord])\n        seen = {beginWord: 0}\n        found = False\n        res = []\n        \n        while q and not found:\n            size = len(q)\n            seen_copy = seen.copy()\n            for _ in range(size):\n                cur = q.popleft()\n                for i in range(len(cur)):\n                    for c in string.ascii_lowercase:\n                        new_word = cur[:i] + c + cur[i+1:]\n                        if new_word in seen_copy:\n                            if seen_copy[new_word] == seen[cur]:\n                                q.append(new_word)\n                            elif seen_copy[new_word] + 1 == seen[cur]:\n                                q.append(new_word)\n                                seen[new_word] = seen[cur] + 1\n                            else:\n                                seen[new_word] = seen[cur] + 1\n            if cur in seen:\n                if found:\n                    res.append(seen[cur] * [beginWord])\n                else:\n                    found = True\n        \n        if not found:\n            return []\n        \n        if len(res) == 1:\n            return res[0]\n        \n        res[-1][-1] = endWord\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        i = 0\n        for n in nums:\n            if n != nums[i]:\n                l = len(res)\n                res += res[l-1] + [n]*(l-1)\n                i = l\n            else:\n                l = len(res)\n                res += res[l-1] + [n]*(l-1)\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # stack of indices of heights\n        stack = []\n        max_area = 0\n        # iterate over heights\n        for i, h in en\n            if not stack or h >= heights[stack[-1]]:\n                stack.append(i)\n            else:\n                # pop until we find a smaller height\n                while stack and h < heights[stack[-1]]:\n                    top = stack.pop()\n                    # calculate area\n                    area = heights[top] * (i - stack[-1] - 1) if stack else heights[top] * i\n                    max_area = max(max_area, area)\n                stack.append(i)\n        # pop remaining elements\n        while stack:\n            top = stack.pop()\n            area = heights[top] * (len(heights) - stack[-1] - 1) if stack else heights[top] * len(heights)\n            max_area = max(max_area, area)\n        return max_area"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    if first < 0 and second > 0:\n                        stack.append(first // second)\n                    elif first > 0 and second < 0:\n                        stack.append(first // second)\n                    else:\n                        stack.append(first // second)\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        xmin,ymin,xmax,ymax = float('inf'),float('inf'),-float('inf'),-float('inf')\n        area = 0\n        seen = set()\n        for x1,y1,x2,y2 in rectangles:\n            xmin = min(xmin,x1)\n            ymin = min(ymin,y1)\n            xmax = max(xmax,x2)\n            ymax = max(ymax,y2)\n            area += (x2-x1)*(y2-y1)\n            if (x1,y1) in seen or (x1,y2) in seen or (x2,y1) in seen or (x2,y2) in seen:\n                seen.remove((x1,y1) if (x1,y1) in seen else (x2,y1))\n                seen.remove((x1,y2) if (x1,y2) in seen else (x2,y2))\n                seen.remove((x2,y1) if (x2,y1) in seen else (x2,y2))\n                seen.remove((x2,y2) if (x2,y2) in seen else (x2,y2))\n            else:\n                seen.add((x1,y1))\n                seen.add((x1,y2))\n                seen.add((x2,y1))\n                seen.add((x2,y2))\n        if (xmin,ymin) in seen or (xmin,ymax) in seen or (xmax,ymin) in seen or (xmax,ymax) in seen:\n            seen.remove((xmin,ymin) if (xmin,ymin) in seen else (xmin,ymax))\n            seen.remove((xmin,ymax) if (xmin,ymax) in seen else (xmin,ymax))\n            seen.remove((xmax,ymin) if (xmax,ymin) in seen else (xmax,ymax))\n            seen.remove((xmax,ymax) if (xmax,ymax) in seen else (xmax,ymax))\n        return area == (xmax-xmin)*(ymax-ymin) and len(seen) == 4"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + ord('A')) + ans\n            columnNumber //= 26\n        return ans"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = num\n            else:\n                curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a number\n        num = 0\n        for i in range(2):\n            for j in range(3):\n                num = num * 10 + board[i][j]\n                if board[i][j] == 0:\n                    zero_i = i\n                    zero_j = j\n        \n        # convert to a list of 4 numbers\n        nums = [num & 1, num >> 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        if nums[1] == 0:\n            nums[1] = 1\n        \n        # convert to a list of 3 numbers\n        nums = [nums[0] & 1, nums[0] >> 1, nums[1] & 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        if nums[1] == 0:\n            nums[1] = 1\n        \n        # convert to a list of 2 numbers\n        nums = [nums[0] & 1, nums[0] >> 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        \n        # convert to a number\n        num = nums[0] * 10 + nums[1]\n        \n        # convert to a list of 4 numbers\n        nums = [num & 1, num >> 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        if nums[1] == 0:\n            nums[1] = 1\n        \n        # convert to a list of 3 numbers\n        nums = [nums[0] & 1, nums[0] >> 1, nums[1] & 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        if nums[1] == 0:\n            nums[1] = 1\n        \n        # convert to a list of 2 numbers\n        nums = [nums[0] & 1, nums[0] >> 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        \n        # convert to a number\n        num = nums[0] * 10 + nums[1]\n        \n        # convert to a list of 4 numbers\n        nums = [num & 1, num >> 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        if nums[1] == 0:\n            nums[1] = 1\n        \n        # convert to a list of 3 numbers\n        nums = [nums[0] & 1, nums[0] >> 1, nums[1] & 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        if nums[1] == 0:\n            nums[1] = 1\n        \n        # convert to a list of 2 numbers\n        nums = [nums[0] & 1, nums[0] >> 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        \n        # convert to a number\n        num = nums[0] * 10 + nums[1]\n        \n        # convert to a list of 4 numbers\n        nums = [num & 1, num >> 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        if nums[1] == 0:\n            nums[1] = 1\n        \n        # convert to a list of 3 numbers\n        nums = [nums[0] & 1, nums[0] >> 1, nums[1] & 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        if nums[1] == 0:\n            nums[1] = 1\n        \n        # convert to a list of 2 numbers\n        nums = [nums[0] & 1, nums[0] >> 1]\n        if nums[0] == 0:\n            nums[0] = 1\n        \n        # convert to a number\n        num = nums[0] *"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t and t[i] != s_to_t[s[i]]:\n                return False\n            if t[i] in t_to_s and s[i] != t_to_s[t[i]]:\n                return False\n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return True\n            if nums[m] < nums[r]:\n                if nums[m] < target and target <= nums[r]:\n                    l = m + 1\n                else:\n                    r = m - 1\n            elif nums[m] > nums[r]:\n                if nums[l] <= target and target < nums[m]:\n                    r = m - 1\n                else:\n                    l = m + 1\n            else:\n                r -= 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        if obstacleGrid[0][n-1] == 1:\n            for i in range(m):\n                obstacleGrid[i][n-1] = 0\n        else:\n            obstacleGrid[0][n-1] = 1\n        if obstacleGrid[m-1][0] == 1:\n            for i in range(n):\n                obstacleGrid[m-1][i] = 0\n        else:\n            obstacleGrid[m-1][0] = 1\n        for i in range(1,m):\n            for j in range(1,n):\n                if obstacleGrid[i][j] == 1:\n                    obstacleGrid[i][j] = 0\n                else:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n        return obstacleGrid[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        one, two = 1, 1\n        for i in range(1, len(s)):\n            if s[i] == '0':\n                one = 0\n            if int(s[i-1:i+1]) <= 26:\n                one, two = two, one + two\n            else:\n                one = two\n        return one % (10**9 + 7)"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        n = len(nums)\n        if n < 3:\n            return closest\n        \n        i = 0\n        j = n - 1\n        while i < j and nums[i] <= 0 and nums[j] >= 0:\n            closest_sum = nums[i] + nums[j]\n            if closest_sum == target:\n                return closest_sum\n            if abs(closest_sum - target) < abs(closest - target):\n                closest = closest_sum\n            if closest_sum > target:\n                j -= 1\n            else:\n                i += 1\n        if closest == nums[0] + nums[1] + nums[2]:\n            return closest\n        if closest < target:\n            i = 0\n            j = n - 1\n            while i < j:\n                closest_sum = nums[i] + nums[j]\n                if closest_sum == target:\n                    return closest_sum\n                if abs(closest_sum - target) < abs(closest - target):\n                    closest = closest_sum\n                if closest_sum > target:\n                    j -= 1\n                else:\n                    i += 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        d = {}\n        res = []\n        for num in nums1:\n            if num not in d:\n                d[num] = 1\n            else:\n                d[num] += 1\n        \n        for num in nums2:\n            if num in d and d[num] > 0:\n                res.append(num)\n                d[num] -= 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        prev = None\n        min_diff = float('inf')\n        curr = root\n        \n        while curr:\n            if curr.left:\n                nxt = curr.left\n                while nxt.right and nxt.right != curr:\n                    nxt = nxt.right\n                if nxt.right:\n                    nxt.right = curr\n                    curr = curr.left\n                else:\n                    nxt.right = curr\n                    curr = curr.left\n            else:\n                if prev:\n                    min_diff = min(min_diff, curr.val - prev.val)\n                prev = curr\n                curr = curr.right\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        count = {}\n        max_count = 0\n        max_val = root.val\n        curr = root\n        while curr:\n            if curr.val in count:\n                count[curr.val] += 1\n            else:\n                count[curr.val] = 1\n            if count[curr.val] > max_count:\n                max_count = count[curr.val]\n                max_val = curr.val\n            curr = curr.left\n        ans = []\n        if max_count > 1:\n            for key, val in count.items():\n                if val == max_count:\n                    ans.append(key)\n        return ans"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        if needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of lower, upper, and digit\n        lower, digit, upper = 0, 0, 0\n        for c in password:\n            if c.islower():\n                lower += 1\n            elif c.isdigit():\n                digit += 1\n            else:\n                upper += 1\n        # 2. if the length is less than 6, add 6 - length\n        if lower + upper + digit < 6:\n            to_add = 6 - lower - upper - digit\n        # 3. if the length is more than 20, remove 20 - length\n        elif lower + upper + digit > 20:\n            to_remove = 20 - lower - upper - digit\n        else:\n            to_remove = 0\n        # 4. count the number of repeating characters\n        prev_repeat = 0\n        repeat = 0\n        for i in range(2, len(password) + 1):\n            if password[i - 2] == password[i - 1]:\n                repeat += 1\n            else:\n                if repeat > 0:\n                    prev_repeat = max(repeat, prev_repeat)\n                    repeat = 0\n        if repeat > 0:\n            prev_repeat = max(repeat, prev_repeat)\n        # 5. add the extra characters\n        extra = max(prev_repeat - 2, 0)\n        # 6. return the result\n        return max(3, to_add + extra + to_remove)"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 3:\n            return 0\n        count = 0\n        i = 5\n        while n // i > 0:\n            count += n // i\n            i *= 5\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [''] * numRows\n        currRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[currRow] += c\n            if currRow == 0:\n                goingDown = True\n            elif currRow == numRows - 1:\n                goingDown = False\n            currRow += 1 if goingDown else -1\n        \n        return ''.join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = 0, 0\n        ans = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                if height[left] > left_max:\n                    left_max = height[left]\n                else:\n                    ans += left_max - height[left]\n                left += 1\n            else:\n                if height[right] > right_max:\n                    right_max = height[right]\n                else:\n                    ans += right_max - height[right]\n                right -= 1\n        return ans"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## use the array as a hashmap\n        ## iterate through the array and mark the index of the number as negative\n        ## iterate through the array again and add the positive numbers to the result\n        ## if the number is already negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means it was not added\n        ## if the number is 0, it means it was not added\n        ## if the number is negative, it means it was already added\n        ## if the number is positive, it means"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. use a list to store the index of the number in the sorted array\n        # 2. use a dict to store the number and its index\n        # 3. use a list to store the number of smaller numbers to the right\n        # 4. use a dict to store the number and its index\n        # 5. use a list to store the number of smaller numbers to the right\n        # 6. use a dict to store the number and its index\n        # 7. use a list to store the number of smaller numbers to the right\n        # 8. use a dict to store the number and its index\n        # 9. use a list to store the number of smaller numbers to the right\n        # 10. use a dict to store the number and its index\n        # 11. use a list to store the number of smaller numbers to the right\n        # 12. use a dict to store the number and its index\n        # 13. use a list to store the number of smaller numbers to the right\n        # 14. use a dict to store the number and its index\n        # 15. use a list to store the number of smaller numbers to the right\n        # 16. use a dict to store the number and its index\n        # 17. use a list to store the number of smaller numbers to the right\n        # 18. use a dict to store the number and its index\n        # 19. use a list to store the number of smaller numbers to the right\n        # 20. use a dict to store the number and its index\n        # 21. use a list to store the number of smaller numbers to the right\n        # 22. use a dict to store the number and its index\n        # 23. use a list to store the number of smaller numbers to the right\n        # 24. use a dict to store the number and its index\n        # 25. use a list to store the number of smaller numbers to the right\n        # 26. use a dict to store the number and its index\n        # 27. use a list to store the number of smaller numbers to the right\n        # 28. use a dict to store the number and its index\n        # 29. use a list to store the number of smaller numbers to the right\n        # 30. use a dict to store the number and its index\n        # 31. use a list to store the number of smaller numbers to the right\n        # 32. use a dict to store the number and its index\n        # 33. use a list to store the number of smaller numbers to the right\n        # 34. use a dict to store the number and its index\n        # 35. use a list to store the number of smaller numbers to the right\n        # 36. use a dict to store the number and its index\n        # 37. use a list to store the number of smaller numbers to the right\n        # 38. use a dict to store the number and its index\n        # 39. use a list to store the number of smaller numbers to the right\n        # 40. use a dict to store the number and its index\n        # 41. use a list to store the number of smaller numbers to the right\n        # 42. use a dict to store the number and its index\n        # 43. use a list to store the number of smaller numbers to the right\n        # 44. use a dict to store the number and its index\n        # 45. use a list to store the number of smaller numbers to the right\n        # 46. use a dict to store the number and its index\n        # 47. use a list to store the number of smaller numbers to the right\n        # 48. use a dict to store the number and its index\n        # 49. use a list to store the number of smaller numbers to the right\n        # 50. use a dict to store the number and its index\n        # 51. use a list to store the number of smaller numbers to the right\n        # 52. use a dict to store the number and its index\n        # 53. use a list to store the number of smaller numbers to the right\n        # 54. use a dict to store the number and its index\n        # 55. use a list to store the number of smaller numbers to the right\n        # 56. use a dict to store the number"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        # initialize the result to 2, since we have at least 2 elements\n        res = 2\n        # the first element of the interval is the second element of the next interval\n        prev = intervals[0][1]\n        # iterate over the rest of the intervals\n        for interval in intervals[1:]:\n            # if the current interval starts before the previous interval ends,\n            # we can use the current interval as a starting point for the next interval\n            if interval[0] > prev:\n                prev = interval[1]\n                res += 1\n            # otherwise, we need to use the previous interval as a starting point for the next interval\n            else:\n                prev = interval[1]\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right or left.val != right.val:\n            return False\n        \n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. use a dict to store the count of each element\n        # 2. use a stack to store the count of the previous element\n        # 3. use a counter to store the count of the current element\n        # 4. use a variable to store the current element\n        # 5. use a variable to store the previous element\n        # 6. use a variable to store the count of the current element\n        # 7. use a variable to store the count of the previous element\n        # 8. use a variable to store the count of the current element\n        # 9. use a variable to store the count of the previous element\n        # 10. use a variable to store the count of the current element\n        # 11. use a variable to store the count of the previous element\n        # 12. use a variable to store the count of the current element\n        # 13. use a variable to store the count of the previous element\n        # 14. use a variable to store the count of the current element\n        # 15. use a variable to store the count of the previous element\n        # 16. use a variable to store the count of the current element\n        # 17. use a variable to store the count of the previous element\n        # 18. use a variable to store the count of the current element\n        # 19. use a variable to store the count of the previous element\n        # 20. use a variable to store the count of the current element\n        # 21. use a variable to store the count of the previous element\n        # 22. use a variable to store the count of the current element\n        # 23. use a variable to store the count of the previous element\n        # 24. use a variable to store the count of the current element\n        # 25. use a variable to store the count of the previous element\n        # 26. use a variable to store the count of the current element\n        # 27. use a variable to store the count of the previous element\n        # 28. use a variable to store the count of the current element\n        # 29. use a variable to store the count of the previous element\n        # 30. use a variable to store the count of the current element\n        # 31. use a variable to store the count of the previous element\n        # 32. use a variable to store the count of the current element\n        # 33. use a variable to store the count of the previous element\n        # 34. use a variable to store the count of the current element\n        # 35. use a variable to store the count of the previous element\n        # 36. use a variable to store the count of the current element\n        # 37. use a variable to store the count of the previous element\n        # 38. use a variable to store the count of the current element\n        # 39. use a variable to store the count of the previous element\n        # 40. use a variable to store the count of the current element\n        # 41. use a variable to store the count of the previous element\n        # 42. use a variable to store the count of the current element\n        # 43. use a variable to store the count of the previous element\n        # 44. use a variable to store the count of the current element\n        # 45. use a variable to store the count of the previous element\n        # 46. use a variable to store the count of the current element\n        # 47. use a variable to store the count of the previous element\n        # 48. use a variable to store the count of the current element\n        # 49. use a variable to store the count of the previous element\n        # 50. use a variable to store the count of the current element\n        # 51. use a variable to store the count of the previous element\n        # 52. use a variable to store the count of the current element\n        # 53. use a variable to store the count of the previous element\n        # 54. use a variable to store the count of the current element\n        # 55. use a variable to store the count of the previous element\n        # 56. use a variable to store the count of the current element\n        # 57. use a variable to store the count of the previous element\n        # 58. use a variable to store the count of"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            res.append(node.val)\n            \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        if n == 1:\n            return True\n        if n % 4 != 0:\n            return False\n        return self.isPowerOfFour(n // 4)"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = ['()']\n        for i in range(1, n*2, 2):\n            tmp = []\n            for j in res:\n                tmp.append('(' + j + ')')\n                tmp.append(j + '()')\n            res = tmp\n        return res[:n]"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if nums[0] > 1:\n            return 1\n        \n        # initialize the patch count to 0\n        patch_count = 0\n        # initialize the pointer to the nums array\n        i = 0\n        # initialize the max_val to 1\n        max_val = 1\n        \n        # while the max_val is less than n\n        while max_val <= n:\n            # if the pointer is less than the length of nums\n            if i < len(nums) and nums[i] <= max_val:\n                # add the nums[i] to max_val\n                max_val += nums[i]\n                # increment the pointer\n                i += 1\n            else:\n                # add the max_val to the patch count\n                patch_count += 1\n                # add max_val * 2 to max_val\n                max_val += max_val\n        # return the patch count\n        return patch_count"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) < 2:\n        #     return 0\n        # stack = [-1]\n        # max_len = 0\n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         stack.append(i)\n        #     else:\n        #         stack.pop()\n        #         if stack:\n        #             max_len = max(max_len, i - stack[-1])\n        #         else:\n        #             stack.append(i)\n        # return max_len\n        \n        # if len(s) < 2:\n        #     return 0\n        # left = 0\n        # right = 0\n        # max_len = 0\n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         left += 1\n        #     else:\n        #         right += 1\n        #         if right > left:\n        #             left = 0\n        #             right = 0\n        #         else:\n        #             left += 1\n        #     max_len = max(max_len, left)\n        # return max_len\n        \n        # if len(s) < 2:\n        #     return 0\n        # left = 0\n        # right = 0\n        # max_len = 0\n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         left += 1\n        #     else:\n        #         right += 1\n        #         if right > left:\n        #             left = 0\n        #             right = 0\n        #         else:\n        #             left += 1\n        #     max_len = max(max_len, left)\n        # return max_len\n        \n        if len(s) < 2:\n            return 0\n        left = 0\n        right = 0\n        max_len = 0\n        stack = [-1]\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if stack:\n                    max_len = max(max_len, i - stack[-1])\n                else:\n                    stack.append(i)\n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        # integer part\n        integer = numerator // denominator\n        remainder = numerator % denominator\n        if remainder == 0:\n            return str(sign * integer)\n        \n        # fractional part\n        seen = {}\n        fraction = remainder * 10\n        res = str(sign * integer) + \".\"\n        seen[fraction] = 0\n        while fraction != 0:\n            fraction *= 10\n            integer = fraction // denominator\n            if fraction in seen:\n                res += \"(\" + str(integer) + \")\"\n                break\n            seen[fraction] = 1\n            res += str(integer)\n            fraction %= denominator\n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the two sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        if left:\n            curr.next = left\n        # add any remaining nodes from the right half\n        if right:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: x[0])\n        nums = []\n        for e in envelopes:\n            if not nums or nums[-1] < e[1]:\n                nums.append(e[1])\n            else:\n                left, right = 0, len(nums) - 1\n                while left <= right:\n                    mid = left + (right - left) // 2\n                    if nums[mid] < e[1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                nums[left] = e[1]\n        return len(nums)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        # row_zero = False\n        # col_zero = False\n        # m = len(matrix)\n        # n = len(matrix[0])\n        # for i in range(m):\n        #     if matrix[i][0] == 0:\n        #         col_zero = True\n        # for j in range(n):\n        #     if matrix[0][j] == 0:\n        #         row_zero = True\n        # for i in range(1,m):\n        #     for j in range(1,n):\n        #         if matrix[i][j] == 0:\n        #             matrix[i][0] = 0\n        #             matrix[0][j] = 0\n        # for i in range(1,m):\n        #     if matrix[i][0] == 0:\n        #         for j in range(1,n):\n        #             matrix[i][j] = 0\n        # for j in range(1,n):\n        #     if matrix[0][j] == 0:\n        #         for i in range(1,m):\n        #             matrix[i][j] = 0\n        # if row_zero:\n        #     for i in range(m):\n        #         matrix[i][0] = 0\n        # if col_zero:\n        #     for j in range(n):\n        #         matrix[0][j] = 0\n        \n        # O(1) space\n        m = len(matrix)\n        n = len(matrix[0])\n        row_zero = False\n        col_zero = False\n        for i in range(m):\n            if matrix[i][0] == 0:\n                col_zero = True\n        for j in range(n):\n            if matrix[0][j] == 0:\n                row_zero = True\n        for i in range(1,m):\n            for j in range(1,n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        for i in range(1,m):\n            if matrix[i][0] == 0:\n                for j in range(1,n):\n                    matrix[i][j] = 0\n        if row_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n        if col_zero:\n            for j in range(n):\n                matrix[0][j] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0, head)\n        # create a slow and fast pointer\n        slow = dummy\n        fast = head\n        # move fast pointer n steps\n        for i in range(n):\n            fast = fast.next\n        # move slow and fast pointers until fast pointer reaches the end\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        # if the node to be removed is the first node, return the next node\n        if slow == dummy:\n            return head.next\n        # remove the node\n        slow.next = slow.next.next\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersection(nums2, nums1)\n        \n        nums1 = set(nums1)\n        return [x for x in nums1 if x in nums2]"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines)%n:\n            return -1\n        avg = sum(machines)//n\n        ans = 0\n        cur = 0\n        for m in machines:\n            cur += m - avg\n            ans = max(ans, abs(cur))\n        return ans\n        # if sum(machines)%n:\n        #     return -1\n        # avg = sum(machines)//n\n        # ans = 0\n        # cur = 0\n        # for m in machines:\n        #     cur += m - avg\n        #     ans = max(ans, abs(cur))\n        # return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if m > n:\n            m, n = n, m\n        if k == 1:\n            return 1\n        if k == m * n:\n            return m * n\n        curr = 1\n        count = m\n        while count > 1:\n            if curr + (n - 1) // count < k:\n                curr += (n - 1) // count * count\n                count = (n - 1) // count + (n - 1) % count\n            else:\n                curr += count\n                count = count - (n - 1) // count\n        return curr"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = slow\n        root.next = None\n        left = self.sortedListToBST(head)\n        right = self.sortedListToBST(slow)\n        root.left = left\n        root.right = right\n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1 = list1.next\n        else:\n            list2 = list2.next\n        \n        head = list1 if list1.val < list2.val else list2\n        \n        curr = head\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1:\n            curr.next = list1\n        elif list2:\n            curr.next = list2\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = [-1]\n        max_area = 0\n        for i in range(len(heights)):\n            while heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        while stack[-1] != -1:\n            h = heights[stack.pop()]\n            w = len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not nums:\n            return [[]]\n        \n        res = [[]]\n        for num in nums:\n            res += [item + [num] for item in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        if nums[left] < nums[right]:\n            return nums[0]\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            if nums[mid] < nums[mid - 1]:\n                return nums[mid]\n            if nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        # 2. check if it is a valid number\n        # 3. if it is a valid number, check if it is a float or int\n        # 4. if it is a float, check if it is a valid float\n        # 5. if it is a int, check if it is a valid int\n        # 6. if it is a valid int, check if it is a valid int\n        # 7. if it is a valid int, check if it is a valid int\n        # 8. if it is a valid int, check if it is a valid int\n        # 9. if it is a valid int, check if it is a valid int\n        # 10. if it is a valid int, check if it is a valid int\n        # 11. if it is a valid int, check if it is a valid int\n        # 12. if it is a valid int, check if it is a valid int\n        # 13. if it is a valid int, check if it is a valid int\n        # 14. if it is a valid int, check if it is a valid int\n        # 15. if it is a valid int, check if it is a valid int\n        # 16. if it is a valid int, check if it is a valid int\n        # 17. if it is a valid int, check if it is a valid int\n        # 18. if it is a valid int, check if it is a valid int\n        # 19. if it is a valid int, check if it is a valid int\n        # 20. if it is a valid int, check if it is a valid int\n        # 21. if it is a valid int, check if it is a valid int\n        # 22. if it is a valid int, check if it is a valid int\n        # 23. if it is a valid int, check if it is a valid int\n        # 24. if it is a valid int, check if it is a valid int\n        # 25. if it is a valid int, check if it is a valid int\n        # 26. if it is a valid int, check if it is a valid int\n        # 27. if it is a valid int, check if it is a valid int\n        # 28. if it is a valid int, check if it is a valid int\n        # 29. if it is a valid int, check if it is a valid int\n        # 30. if it is a valid int, check if it is a valid int\n        # 31. if it is a valid int, check if it is a valid int\n        # 32. if it is a valid int, check if it is a valid int\n        # 33. if it is a valid int, check if it is a valid int\n        # 34. if it is a valid int, check if it is a valid int\n        # 35. if it is a valid int, check if it is a valid int\n        # 36. if it is a valid int, check if it is a valid int\n        # 37. if it is a valid int, check if it is a valid int\n        # 38. if it is a valid int, check if it is a valid int\n        # 39. if it is a valid int, check if it is a valid int\n        # 40. if it is a valid int, check if it is a valid int\n        # 41. if it is a valid int, check if it is a valid int\n        # 42. if it is a valid int, check if it is a valid int\n        # 43. if it is a valid int, check if it is a valid int\n        # 44. if it is a valid int, check if it is a valid int\n        # 45. if it is a valid int, check if it is a valid int\n        # 46. if it is a valid int, check if it is a valid int\n        # 47. if it is a valid int, check if it is a valid int\n        # 48. if it is a valid int, check if it is a valid int\n        # 49. if it is a valid int, check if it is a valid int\n        # 50. if it is a valid int, check if it is a valid int\n        #"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_map = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n        result = ''\n        for key in roman_map.keys():\n            if num >= key:\n                result += roman_map[key] * (num // key)\n                num %= key\n        return result"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR\n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-1 ^ n\n        # 0 ^ 0 ^ 0 ^ ... ^ 0 ^ n\n        # 0 ^ n\n        # \n        # 0 ^ 1 ^ 2 ^ ... ^ n-"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. create a list of numbers 1-9\n        nums = [1,2,3,4,5,6,7,8,9]\n        \n        # 2. create a list of empty cells\n        empty = []\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    empty.append((i,j))\n        \n        # 3. use backtracking to solve the problem\n        def backtrack(empty, nums):\n            if not empty:\n                return True\n            i,j = empty.pop()\n            for n in nums:\n                if isValid(board, i, j, n):\n                    board[i][j] = str(n)\n                    if backtrack(empty, nums):\n                        return True\n                    board[i][j] = '.'\n            empty.append((i,j))\n            return False\n        \n        def isValid(board, i, j, n):\n            # check row\n            for k in range(9):\n                if board[i][k] == str(n):\n                    return False\n            # check column\n            for k in range(9):\n                if board[k][j] == str(n):\n                    return False\n            # check 3x3 box\n            box_i = i//3*3\n            box_j = j//3*3\n            for k in range(box_i, box_i+3):\n                for l in range(box_j, box_j+3):\n                    if board[k][l] == str(n):\n                        return False\n            return True\n        \n        return backtrack(empty, nums)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first and second node that is not in order\n        # swap the values\n        # inorder traversal is in order\n        # if the first node is bigger than the second node, swap them\n        # if the first node is smaller than the second node, swap them\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is smaller than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is bigger than the second node, then the second node is the first node\n        # if the first node is"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        if not head or not head.next:\n            return True\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        curr = slow\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        # compare the first half and the second half\n        left = head\n        right = prev\n        while right:\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        l, r = 0, num\n        while l <= r:\n            m = l + (r - l) // 2\n            if m * m == num:\n                return True\n            elif m * m > num:\n                r = m - 1\n            else:\n                l = m + 1\n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [1]\n        ans = [0,1]\n        cur = 1\n        for i in range(2, n+1):\n            if i & 1 == 0:\n                ans.append(ans[cur])\n                cur += 1\n            else:\n                ans.append(ans[cur] + 1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0, head)\n        curr = dummy\n        \n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return dummy.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        n = len(s1)\n        d = collections.defaultdict(int)\n        for c in s1:\n            d[c] += 1\n        for c in s2:\n            d[c] -= 1\n            if d[c] < 0:\n                return False\n        if any(d.values()):\n            return False\n        if n == 1:\n            return True\n        # if n is odd, we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        if n & 1:\n            return s1[:n/2] == s2[:n/2] and self.isScramble(s1[n/2:], s2[n/2:]) or \\\n                s1[n/2:] == s2[:n/2] and self.isScramble(s1[:n/2], s2[n/2:])\n        # if n is even, we can divide it into two equal parts\n        # so we check if the two parts are scrambled\n        # if so, we return True\n        # otherwise, we check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if the two parts are equal\n        # if so, we return True\n        # otherwise, we return False\n        # we can't divide it into two equal parts\n        # so we just check if"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        path = path.split('/')\n        for p in path:\n            if p == '..' and stack:\n                stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack) if stack else '/'"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['#'] = '#'\n        \n        m, n = len(board), len(board[0])\n        seen = set()\n        def dfs(i, j, node):\n            c = board[i][j]\n            if c not in node:\n                return 0\n            cnt = node.get('#', 0)\n            if cnt:\n                seen.add(cnt)\n                return cnt\n            board[i][j] = '#'\n            res = 1\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < m and 0 <= y < n and board[x][y] != '#':\n                    res += dfs(x, y, node[board[x][y]])\n            board[i][j] = c\n            return res\n        \n        res = []\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    res.append(dfs(i, j, trie[board[i][j]]))\n        return [word for word in words if word in seen]"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        count = [0] * 26\n        \n        for i in range(len(s)):\n            count[ord(s[i]) - ord('a')] += 1\n            count[ord(t[i]) - ord('a')] -= 1\n        \n        for i in count:\n            if i != 0:\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. check if each row has unique numbers\n        # 2. check if each column has unique numbers\n        # 3. check if each 3x3 box has unique numbers\n        \n        # 1.\n        row_seen = [set() for _ in range(9)]\n        col_seen = [set() for _ in range(9)]\n        box_seen = [set() for _ in range(9)]\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    num = int(board[i][j])\n                    if num in row_seen[i]:\n                        return False\n                    row_seen[i].add(num)\n                    \n                    if num in col_seen[j]:\n                        return False\n                    col_seen[j].add(num)\n                    \n                    box_num = (i // 3) * 3 + j // 3\n                    if num in box_seen[box_num]:\n                        return False\n                    box_seen[box_num].add(num)\n                    \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for c in columnTitle:\n            ans = ans * 26 + (ord(c) - ord('A') + 1)\n        return ans"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n < 2:\n            return n\n        \n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        total = candies[-1]\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n            total += candies[i]\n        \n        return total"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = head\n        fast = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev.next = None\n        curr = slow\n        prev = None\n        while curr:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        \n        # merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            tmp = first.next\n            first.next = second\n            first = tmp\n            tmp = second.next\n            second.next = first\n            second = tmp\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the length of pattern is not equal to the length of s, return False\n        if len(pattern) != len(s.split()):\n            return False\n        \n        # create a dictionary to store the mapping between pattern and s\n        # if the pattern is already in the dictionary, check if the corresponding value in s is equal to the value in the dictionary\n        # if the pattern is not in the dictionary, add it to the dictionary with the value in s as the key\n        d = {}\n        for p, s in zip(pattern, s.split()):\n            if p not in d:\n                if s in d.values():\n                    return False\n                d[p] = s\n            elif d[p] != s:\n                return False\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                temp = self.permute(nums[:i] + nums[i+1:])\n                for t in temp:\n                    res.append([nums[i]] + t)\n            else:\n                temp = self.permute(nums[:i] + nums[i+1:])\n                if temp:\n                    res.append([nums[i]] + temp[0])\n                    if len(temp) > 1:\n                        res.append(temp[1:])\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        lo, hi = 0, m*n-1\n        \n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if matrix[mid//n][mid%n] < target:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        \n        return lo % n != 0 and matrix[lo//n][lo%n] == target"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a carry variable\n        carry = 0\n        # iterate over the lists\n        while l1 or l2 or carry:\n            # if l1 is not None, add its value to the carry\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            # if l2 is not None, add its value to the carry\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            # create a new node with the carry modulo 10\n            curr.next = ListNode(carry % 10)\n            # update the carry\n            carry //= 10\n            # move the pointer to the next node\n            curr = curr.next\n        # return the dummy node's next node\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2's complement\n        # 2. 2's complement ^ 1\n        # 3. 2's complement + 1\n        # 4. 2's complement ^ (2^n - 1)\n        # 5. 2's complement ^ (2^n - 1) + 1\n        # 6. 2's complement ^ (2^n - 1) + 1\n        # 7. 2's complement ^ (2^n - 1) + 1\n        # 8. 2's complement ^ (2^n - 1) + 1\n        # 9. 2's complement ^ (2^n - 1) + 1\n        # 10. 2's complement ^ (2^n - 1) + 1\n        # 11. 2's complement ^ (2^n - 1) + 1\n        # 12. 2's complement ^ (2^n - 1) + 1\n        # 13. 2's complement ^ (2^n - 1) + 1\n        # 14. 2's complement ^ (2^n - 1) + 1\n        # 15. 2's complement ^ (2^n - 1) + 1\n        # 16. 2's complement ^ (2^n - 1) + 1\n        # 17. 2's complement ^ (2^n - 1) + 1\n        # 18. 2's complement ^ (2^n - 1) + 1\n        # 19. 2's complement ^ (2^n - 1) + 1\n        # 20. 2's complement ^ (2^n - 1) + 1\n        # 21. 2's complement ^ (2^n - 1) + 1\n        # 22. 2's complement ^ (2^n - 1) + 1\n        # 23. 2's complement ^ (2^n - 1) + 1\n        # 24. 2's complement ^ (2^n - 1) + 1\n        # 25. 2's complement ^ (2^n - 1) + 1\n        # 26. 2's complement ^ (2^n - 1) + 1\n        # 27. 2's complement ^ (2^n - 1) + 1\n        # 28. 2's complement ^ (2^n - 1) + 1\n        # 29. 2's complement ^ (2^n - 1) + 1\n        # 30. 2's complement ^ (2^n - 1) + 1\n        # 31. 2's complement ^ (2^n - 1) + 1\n        # 32. 2's complement ^ (2^n - 1) + 1\n        # 33. 2's complement ^ (2^n - 1) + 1\n        # 34. 2's complement ^ (2^n - 1) + 1\n        # 35. 2's complement ^ (2^n - 1) + 1\n        # 36. 2's complement ^ (2^n - 1) + 1\n        # 37. 2's complement ^ (2^n - 1) + 1\n        # 38. 2's complement ^ (2^n - 1) + 1\n        # 39. 2's complement ^ (2^n - 1) + 1\n        # 40. 2's complement ^ (2^n - 1) + 1\n        # 41. 2's complement ^ (2^n - 1) + 1\n        # 42. 2's complement ^ (2^n - 1) + 1\n        # 43. 2's complement ^ (2^n - 1) + 1\n        # 44. 2's complement ^ (2^n - 1) + 1\n        # 45. 2's complement ^ (2^n - 1) + 1\n        # 46. 2's complement ^ (2^n - 1) + 1\n        # 47"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        diff = nums[1] - nums[0]\n        count = 0\n        ans = 0\n        \n        for i in range(1, len(nums) - 1):\n            if nums[i] - nums[i - 1] == diff:\n                count += 1\n            else:\n                count = 1\n            ans += count\n        \n        return ans"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Initialize the result list\n        result = []\n        \n        # 2. Initialize the current line with the first word\n        curr_line = words[0]\n        curr_len = len(words[0])\n        \n        # 3. Iterate over the rest of the words\n        for i in range(1, len(words)):\n            # 4. If the current line + the next word is longer than maxWidth,\n            #    then add a space to the current line and start a new line\n            if curr_len + 1 + len(words[i]) > maxWidth:\n                # 5. Add the current line to the result list\n                result.append(curr_line)\n                # 6. Reset the current line and the current line length\n                curr_line = words[i]\n                curr_len = len(words[i])\n            # 7. Otherwise, add the next word to the current line\n            else:\n                curr_line += ' ' + words[i]\n                curr_len += 1\n        # 8. Add the last line to the result list\n        result.append(curr_line + ' ' * (maxWidth - curr_len))\n        # 9. Return the result list\n        return [' '.join(result[i:i+spaces]) + ' ' * (spaces % spaces) for i, spaces in enpx enumerate(result[:-1])]"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.left)\n                stack.append(node.right)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(height) - 1\n        max_area = 0\n        \n        while l < r:\n            area = min(height[l], height[r]) * (r - l)\n            max_area = max(max_area, area)\n            \n            if height[l] < height[r]:\n                l += 1\n            else:\n                r -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time: O(NlogN)\n        # Space: O(N)\n        # Use a set to store the words\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with any word in the set\n        # If the word is shorter than 2, we can't concatenate it\n        # Otherwise, we can check if the word can be concatenated with"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        sign = '-' if num < 0 else ''\n        num = abs(num)\n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        return sign + res if res else '0'"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 queen per row\n        # 2. 1 queen per column\n        # 3. 1 queen per diagonal\n        # 4. 1 queen per anti-diagonal\n        # 5. 1 queen per row + column\n        # 6. 1 queen per row - column\n        # 7. 1 queen per diagonal + anti-diagonal\n        # 8. 1 queen per anti-diagonal - diagonal\n        # 9. 1 queen per row + column + diagonal\n        # 10. 1 queen per row - column + diagonal\n        # 11. 1 queen per row + column - diagonal\n        # 12. 1 queen per row - column - diagonal\n        # 13. 1 queen per row + column + diagonal + anti-diagonal\n        # 14. 1 queen per row - column + diagonal + anti-diagonal\n        # 15. 1 queen per row + column - diagonal + anti-diagonal\n        # 16. 1 queen per row - column - diagonal + anti-diagonal\n        # 17. 1 queen per row + column + diagonal + anti-diagonal + row\n        # 18. 1 queen per row - column + diagonal + anti-diagonal + row\n        # 19. 1 queen per row + column - diagonal + anti-diagonal + row\n        # 20. 1 queen per row - column - diagonal + anti-diagonal + row\n        # 21. 1 queen per row + column + diagonal + anti-diagonal + row - column\n        # 22. 1 queen per row - column + diagonal + anti-diagonal + row - column\n        # 23. 1 queen per row + column - diagonal + anti-diagonal + row - column\n        # 24. 1 queen per row - column - diagonal + anti-diagonal + row - column\n        # 25. 1 queen per row + column + diagonal + anti-diagonal + row - column + diagonal\n        # 26. 1 queen per row - column + diagonal + anti-diagonal + row - column + diagonal\n        # 27. 1 queen per row + column - diagonal + anti-diagonal + row - column + diagonal\n        # 28. 1 queen per row - column - diagonal + anti-diagonal + row - column + diagonal\n        # 29. 1 queen per row + column + diagonal + anti-diagonal + row - column + diagonal + anti-diagonal\n        # 30. 1 queen per row - column + diagonal + anti-diagonal + row - column + diagonal + anti-diagonal\n        # 31. 1 queen per row + column - diagonal + anti-diagonal + row - column + diagonal + anti-diagonal\n        # 32. 1 queen per row - column - diagonal + anti-diagonal + row - column + diagonal + anti-diagonal\n        # 33. 1 queen per row + column + diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row\n        # 34. 1 queen per row - column + diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row\n        # 35. 1 queen per row + column - diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row - column\n        # 36. 1 queen per row - column - diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row - column\n        # 37. 1 queen per row + column + diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row - column + diagonal\n        # 38. 1 queen per row - column + diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row - column + diagonal\n        # 39. 1 queen per row + column - diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row - column + diagonal\n        # 40. 1 queen per row - column - diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row - column + diagonal\n        # 41. 1 queen per row + column + diagonal + anti-diagonal + row - column + diagonal + anti-diagonal + row - column + diagonal + anti-diagonal\n        # 42. 1 queen"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. 1D array to store the column index of each queen\n        # 2. 1D array to store the row index of each queen\n        # 3. 1D array to store the diagonal index of each queen\n        # 4. 1D array to store the anti-diagonal index of each queen\n        # 5. 1D array to store the number of queens in each column\n        # 6. 1D array to store the number of queens in each row\n        # 7. 1D array to store the number of queens in each diagonal\n        # 8. 1D array to store the number of queens in each anti-diagonal\n        # 9. 1D array to store the number of queens in each column\n        # 10. 1D array to store the number of queens in each row\n        # 11. 1D array to store the number of queens in each diagonal\n        # 12. 1D array to store the number of queens in each anti-diagonal\n        # 13. 1D array to store the number of queens in each column\n        # 14. 1D array to store the number of queens in each row\n        # 15. 1D array to store the number of queens in each diagonal\n        # 16. 1D array to store the number of queens in each anti-diagonal\n        # 17. 1D array to store the number of queens in each column\n        # 18. 1D array to store the number of queens in each row\n        # 19. 1D array to store the number of queens in each diagonal\n        # 20. 1D array to store the number of queens in each anti-diagonal\n        # 21. 1D array to store the number of queens in each column\n        # 22. 1D array to store the number of queens in each row\n        # 23. 1D array to store the number of queens in each diagonal\n        # 24. 1D array to store the number of queens in each anti-diagonal\n        # 25. 1D array to store the number of queens in each column\n        # 26. 1D array to store the number of queens in each row\n        # 27. 1D array to store the number of queens in each diagonal\n        # 28. 1D array to store the number of queens in each anti-diagonal\n        # 29. 1D array to store the number of queens in each column\n        # 30. 1D array to store the number of queens in each row\n        # 31. 1D array to store the number of queens in each diagonal\n        # 32. 1D array to store the number of queens in each anti-diagonal\n        # 33. 1D array to store the number of queens in each column\n        # 34. 1D array to store the number of queens in each row\n        # 35. 1D array to store the number of queens in each diagonal\n        # 36. 1D array to store the number of queens in each anti-diagonal\n        # 37. 1D array to store the number of queens in each column\n        # 38. 1D array to store the number of queens in each row\n        # 39. 1D array to store the number of queens in each diagonal\n        # 40. 1D array to store the number of queens in each anti-diagonal\n        # 41. 1D array to store the number of queens in each column\n        # 42. 1D array to store the number of queens in each row\n        # 43. 1D array to store the number of queens in each diagonal\n        # 44. 1D array to store the number of queens in each anti-diagonal\n        # 45. 1D array to store the number of queens in each column\n        # 46. 1D array to store the number of queens in each row\n        # 47. 1D array to store the number of queens in each diagonal\n        # 48. 1D array to store the number of queens in each anti-"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return False\n        \n        m, n = len(board), len(board[0])\n        visited = set()\n        \n        for i in xrange(m):\n            for j in xrange(n):\n                if board[i][j] == word[0]:\n                    if self.dfs(board, word, i, j, visited):\n                        return True\n        return False\n        \n    def dfs(self, board, word, i, j, visited):\n        if len(word) == 1:\n            return True\n        m, n = len(board), len(board[0])\n        if board[i][j] != word[1]:\n            return False\n        visited.add((i, j))\n        if i > 0 and board[i-1][j] == word[1] and (i-1, j) not in visited:\n            if self.dfs(board, word[1:], i-1, j, visited):\n                return True\n        if i < m-1 and board[i+1][j] == word[1] and (i+1, j) not in visited:\n            if self.dfs(board, word[1:], i+1, j, visited):\n                return True\n        if j > 0 and board[i][j-1] == word[1] and (i, j-1) not in visited:\n            if self.dfs(board, word[1:], i, j-1, visited):\n                return True\n        if j < n-1 and board[i][j+1] == word[1] and (i, j+1) not in visited:\n            if self.dfs(board, word[1:], i, j+1, visited):\n                return True\n        visited.remove((i, j))\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # two pointers\n        p1 = m - 1\n        p2 = n - 1\n        # last index of nums1\n        last = m + n - 1\n        \n        # iterate backwards through nums1\n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] > nums2[p2]:\n                nums1[last] = nums1[p1]\n                p1 -= 1\n            else:\n                nums1[last] = nums2[p2]\n                p2 -= 1\n            last -= 1\n        \n        # if nums2 is longer, copy over the rest of nums2\n        if p2 >= 0:\n            nums1[:last + 1] = nums2[:p2 + 1]\n\n# Time: O(m + n)\n# Space: O(1)"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max1 = max2 = max3 = float('-inf')\n        for n in nums:\n            if n > max1:\n                max3 = max2\n                max2 = max1\n                max1 = n\n            elif n > max2 and n < max1:\n                max3 = max2\n                max2 = n\n            elif n > max3 and n < max2:\n                max3 = n\n        return max3 if max3 != float('-inf') else max1"}]}