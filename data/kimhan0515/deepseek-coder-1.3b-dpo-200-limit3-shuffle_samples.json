{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Mark all negative numbers as 0\n        # 2. Mark all numbers in the range [1, n] as 1\n        # 3. Iterate through the array and mark the corresponding numbers as -1\n        # 4. Iterate through the array again and find the first number that is not -1\n        # 5. If all numbers are present, return n + 1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        res = \"\"\n        for i in range(n - 1, -1, -1):\n            # 2.1 calculate the number of digits in the current permutation\n            num_digits = fact\n            for j in range(n - 1):\n                num_digits /= (j + 1)\n            \n            # 2.2 calculate the digit in the current permutation\n            digit = k / num_digits\n            k %= num_digits\n            res += str(digit + 1)\n            \n            # 2.3 remove the digit from the list\n            num_digits -= 1\n            for j in range(i):\n                digit = k / num_digits\n                k %= num_digits\n                res += str(digit + 1)\n                num_digits -= 1\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, res, prev, curr):\n            if not num:\n                if curr == target:\n                    res.append(op)\n                return\n            for i in range(1, len(num)+1):\n                if i == 1 or (i > 1 and num[0] != '0'):\n                    curr = int(num[:i])\n                    backtrack(num[i:], target-curr, op+'+'+str(curr), res, curr, curr)\n                    backtrack(num[i:], target+curr, op+'-'+str(curr), res, -curr, curr)\n                    backtrack(num[i:], target-op.count('*')*curr, op+'*'+str(curr), res, curr*prev, curr)\n        res = []\n        backtrack(num, target, '', res, 0, 0)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()[::-1]\n        return '-'.join(s[i:i+k] for i in range(0, len(s), k))[::-1]"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. If the sum of gas[i] - cost[i] is negative, then it is impossible to complete the circuit.\n        ## 2. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 3. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 4. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 5. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 6. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 7. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 8. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 9. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 10. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 11. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 12. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 13. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 14. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 15. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 16. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 17. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 18. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 19. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 20. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 21. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 22. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 23. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 24. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 25. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 26. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 27. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 28. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 29. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 30. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 31. If the sum of gas[i] - cost[i] is negative, then we can start from any station.\n        ## 32. If the sum of gas[i] - cost[i] is positive, then we can start from any station.\n        ## 33. If"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            drop = len(nums) - k\n            out = []\n            for num in nums:\n                while drop and out and out[-1] < num:\n                    out.pop()\n                    drop -= 1\n                out.append(num)\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    out.append(nums1[i])\n                    i += 1\n                else:\n                    out.append(nums2[j])\n                    j += 1\n            out.extend(nums1[i:] or nums2[j:])\n            return out\n        \n        if len(nums1) > k:\n            return pick(nums1, k)\n        if len(nums2) > k:\n            return pick(nums2, k)\n        return merge(merge(nums1, nums2), pick(nums1 if len(nums1) < len(nums2) else nums2, k - len(nums1)))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while nums[i] - nums[j] > mid:\n                    j += 1\n                count += i - j\n            if count >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 = 9\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 = 10\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 = 11\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 = 12\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 = 13\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 = 14\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 = 15\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 = 16\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 = 17\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 = 18\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 = 19\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 = 20\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 = 21\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 = 22\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 ^ 23 = 23\n        ## 0 ^ 1 ^ 2 ^"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        distance = 1\n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    pattern = word[:i] + '_' + word[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor == endWord:\n                            return distance + 1\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            distance += 1\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        a = list(a)\n        b = list(b)\n        carry = 0\n        for i in range(len(a)):\n            if i < len(b):\n                a[i] = str(int(a[i]) + int(b[i]) + carry)\n            else:\n                a[i] = str(int(a[i]) + carry)\n            if a[i] == '2':\n                carry = 1\n            else:\n                carry = 0\n        if carry:\n            a.append('1')\n        return ''.join(a[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1, -1]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        if nums[left] != target:\n            return [-1, -1]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        \n        return [left, right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        max_reach = nums[0]\n        step = 1\n        cur_end = 0\n        for i in range(n):\n            if i > cur_end:\n                step += 1\n                cur_end = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        return step"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) / 2:\n            return sum(max(prices[i] - prices[i - 1] for i in range(1, len(prices))) for i in range(k))\n        \n        buy = [float('-inf')] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                buy[i] = max(buy[i], sell[i - 1] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n        \n        return sell[-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        if num < 0:\n            num = num + 2**32\n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        hex_list.reverse()\n        return ''.join([hex_dict[i] if i in hex_dict else str(i) for i in hex_list])"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first index in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first index in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first index in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first index in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first index in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first index in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first index in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        #"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) <= valueDiff:\n                    if abs(i - j) <= indexDiff:\n                        return True\n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        curr_count = 0\n        \n        for num in nums:\n            if num == 1:\n                curr_count += 1\n            else:\n                curr_count = 0\n            max_count = max(max_count, curr_count)\n        \n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        carry = 0\n        result = \"\"\n        for i in range(len(num1)-1, -1, -1):\n            sum = int(num1[i]) + int(num2[i]) + carry\n            carry = sum / 10\n            result = str(sum % 10) + result\n        \n        for i in range(len(num1)-len(num2)-1, -1, -1):\n            sum = int(num1[i]) + carry\n            carry = sum / 10\n            result = str(sum % 10) + result\n        \n        if carry:\n            result = str(carry) + result\n        \n        return result"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i] == ' ':\n                continue\n            elif s[i] == '+':\n                num += sign * stack.pop()\n                stack.append(sign)\n                sign = 1\n            elif s[i] == '-':\n                num += sign * stack.pop()\n                stack.append(-sign)\n                sign = 1\n            elif s[i] == '(':\n                stack.append(num)\n                stack.append(sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num += sign * stack.pop()\n                stack.pop()\n                num += stack.pop()\n                stack.append(num)\n                num = 0\n                sign = 1\n            else:\n                num = num * 10 + int(s[i])\n        return sum(stack) + num * stack.pop()"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort by capital\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # heap for profits\n        heap = []\n        \n        # iterate over sorted capital\n        for c, p in sorted_capital:\n            # add to heap if we can afford it\n            if c <= w:\n                heapq.heappush(heap, -p)\n            # if we have enough projects, pop the max profit\n            if len(heap) > k:\n                heapq.heappop(heap)\n        \n        # sum up the profits\n        return sum([-x for x in heap])"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(')')\n            elif c == '{':\n                stack.append('}')\n            elif c == '[':\n                stack.append(']')\n            elif stack and c == stack.pop():\n                continue\n            else:\n                return False\n        return not stack"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the point\n        \n        # find the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # find the first number that is larger than the next number\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers after the point\n        nums[i+1:] = nums[len(nums)-1:i:-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time: O(n)\n        # Space: O(n)\n        seen = {}\n        for i, num in enumerate(nums):\n            if num in seen and i - seen[num] <= k:\n                return True\n            seen[num] = i\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n            queue = queue[len(level):]\n        \n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i] ^ 1) for i in range(n)]\n        couples.sort()\n        ans = 0\n        for i in range(n):\n            if couples[i][1] != i:\n                ans += 1\n                j = i + 1\n                while couples[j][1] != i:\n                    j += 1\n                couples[i], couples[j] = couples[j], couples[i]\n        return ans"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        firstRow = set('qwertyuiop')\n        secondRow = set('asdfghjkl')\n        thirdRow = set('zxcvbnm')\n        \n        res = []\n        for word in words:\n            if set(word.lower()) <= firstRow:\n                res.append(word)\n            elif set(word.lower()) <= secondRow:\n                res.append(word)\n            elif set(word.lower()) <= thirdRow:\n                res.append(word)\n                \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for i in range(left-1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right-left):\n            tmp = curr.next\n            curr.next = tmp.next\n            tmp.next = prev.next\n            prev.next = tmp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end of s\n        # and repeat the process\n        \n        # find the longest palindrome that starts with s\n        # reverse the string and add it to the end of s\n        # if the reversed string is a palindrome, then s is a palindrome\n        # if not, then add the reversed string to the end"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        count = collections.Counter(t)\n        required = len(count)\n        left = 0\n        min_window = float('inf'), None, None\n        \n        for right in range(len(s)):\n            if s[right] in count:\n                count[s[right]] -= 1\n                if count[s[right]] == 0:\n                    required -= 1\n            \n            while required == 0:\n                if right - left + 1 < min_window[0]:\n                    min_window = (right - left + 1, left, right)\n                \n                if s[left] in count:\n                    count[s[left]] += 1\n                    if count[s[left]] == 1:\n                        required += 1\n                left += 1\n        \n        return \"\" if min_window[0] == float('inf') else s[min_window[1]:min_window[2] + 1]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)):\n            if distance[i] >= distance[i - 3] and distance[i - 1] <= distance[i - 4]:\n                return True\n            if i >= 4 and distance[i] == distance[i - 4] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 6 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # iterate through the hashmap and add the max of the odd values to the result\n        # if the hashmap has an odd value, add 1 to the result\n        # return the result\n        \n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        result = 0\n        for key in hashmap:\n            if hashmap[key] % 2 == 0:\n                result += hashmap[key]\n            else:\n                result += hashmap[key] - 1\n        \n        return result"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # get all the trees in the forest\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        \n        # sort the trees by height\n        trees.sort()\n        \n        # start from the top left corner\n        steps = 0\n        curr_height = 0\n        for tree in trees:\n            steps += self.bfs(forest, tree[1], tree[2], curr_height)\n            if steps == -1:\n                return -1\n            curr_height = tree[0]\n        return steps\n        \n    def bfs(self, forest, start_row, start_col, curr_height):\n        \"\"\"\n        BFS to find the shortest path from the current tree to the target\n        \"\"\"\n        # initialize the queue with the current tree\n        queue = [(start_row, start_col)]\n        visited = set()\n        steps = 0\n        \n        while queue:\n            # get the next tree to visit\n            next_queue = []\n            for row, col in queue:\n                if (row, col) not in visited:\n                    visited.add((row, col))\n                    if forest[row][col] == 0:\n                        return -1\n                    if forest[row][col] == curr_height:\n                        return steps\n                    for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nr = row + dr\n                        nc = col + dc\n                        if 0 <= nr < len(forest) and 0 <= nc < len(forest[0]):\n                            next_queue.append((nr, nc))\n            steps += 1\n            queue = next_queue\n        return -1"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. calculate the sum of all the elements in nums\n        # 2. sort the sum of all the elements in nums\n        # 3. use two pointers to find the number of ranges that sum to a certain value\n        # 4. use a hashmap to store the number of ranges that sum to a certain value\n        # 5. iterate through the sorted sum of all the elements in nums\n        # 6. for each element in nums, find the number of ranges that sum to the current element\n        # 7. add the number of ranges that sum to the current element to the answer\n        # 8. return the answer\n        \n        # 1. calculate the sum of all the elements in nums\n        sum_nums = [0]\n        for num in nums:\n            sum_nums.append(sum_nums[-1] + num)\n        \n        # 2. sort the sum of all the elements in nums\n        sum_nums.sort()\n        \n        # 3. use two pointers to find the number of ranges that sum to a certain value\n        # 4. use a hashmap to store the number of ranges that sum to a certain value\n        # 5. iterate through the sorted sum of all the elements in nums\n        # 6. for each element in nums, find the number of ranges that sum to the current element\n        # 7. add the number of ranges that sum to the current element to the answer\n        # 8. return the answer\n        \n        # 4. use a hashmap to store the number of ranges that sum to a certain value\n        # 5. iterate through the sorted sum of all the elements in nums\n        # 6. for each element in nums, find the number of ranges that sum to the current element\n        # 7. add the number of ranges that sum to the current element to the answer\n        # 8. return the answer\n        \n        # 5. iterate through the sorted sum of all the elements in nums\n        # 6. for each element in nums, find the number of ranges that sum to the current element\n        # 7. add the number of ranges that sum to the current element to the answer\n        # 8. return the answer\n        \n        # 6. for each element in nums, find the number of ranges that sum to the current element\n        # 7. add the number of ranges that sum to the current element to the answer\n        # 8. return the answer\n        \n        # 7. add the number of ranges that sum to the current element to the answer\n        # 8. return the answer\n        \n        # 8. return the answer\n        \n        # 9. return the answer\n        \n        # 10. return the answer\n        \n        # 11. return the answer\n        \n        # 12. return the answer\n        \n        # 13. return the answer\n        \n        # 14. return the answer\n        \n        # 15. return the answer\n        \n        # 16. return the answer\n        \n        # 17. return the answer\n        \n        # 18. return the answer\n        \n        # 19. return the answer\n        \n        # 20. return the answer\n        \n        # 21. return the answer\n        \n        # 22. return the answer\n        \n        # 23. return the answer\n        \n        # 24. return the answer\n        \n        # 25. return the answer\n        \n        # 26. return the answer\n        \n        # 27. return the answer\n        \n        # 28. return the answer\n        \n        # 29. return the answer\n        \n        # 30. return the answer\n        \n        # 31. return the answer\n        \n        # 32. return the answer\n        \n        # 33. return the answer\n        \n        # 34. return the answer\n        \n        # 35. return the answer\n        \n        # 36. return the answer\n        \n        # 37. return the answer\n        \n        # 38. return the answer\n        \n        # 39. return the answer\n        \n        # 40. return the answer\n        \n        # 41. return the answer\n        \n        # 42. return the answer"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2 * n + 0.25) ** 0.5 - 0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x / 10\n        \n        return x == rev or x == rev / 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        for c in t:\n            if i == len(s):\n                return True\n            if c == s[i]:\n                i += 1\n        return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the last number in the sequence\n        # 2. 2^n - 1 - 2^(n-1) is the first number in the sequence\n        # 3. 2^n - 1 - 2^(n-1) - 2^(n-2) is the second number in the sequence\n        # 4. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) is the third number in the sequence\n        # 5. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) is the fourth number in the sequence\n        # 6. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) - 2^(n-5) is the fifth number in the sequence\n        # 7. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) - 2^(n-5) - 2^(n-6) is the sixth number in the sequence\n        # 8. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) - 2^(n-5) - 2^(n-6) - 2^(n-7) is the seventh number in the sequence\n        # 9. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) - 2^(n-5) - 2^(n-6) - 2^(n-7) - 2^(n-8) is the eighth number in the sequence\n        # 10. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) - 2^(n-5) - 2^(n-6) - 2^(n-7) - 2^(n-8) - 2^(n-9) is the ninth number in the sequence\n        # 11. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) - 2^(n-5) - 2^(n-6) - 2^(n-7) - 2^(n-8) - 2^(n-9) - 2^(n-10) is the tenth number in the sequence\n        # 12. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) - 2^(n-5) - 2^(n-6) - 2^(n-7) - 2^(n-8) - 2^(n-9) - 2^(n-10) - 2^(n-11) is the eleventh number in the sequence\n        # 13. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^(n-4) - 2^(n-5) - 2^(n-6) - 2^(n-7) - 2^(n-8) - 2^(n-9) - 2^(n-10) - 2^(n-11) - 2^(n-12) is the twelfth number in the sequence\n        # 14. 2^n - 1 - 2^(n-1) - 2^(n-2) - 2^(n-3) - 2^("}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # find the index of the first element that is larger than the new interval\n        i = 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            i += 1\n        \n        # find the index of the last element that is smaller than the new interval\n        j = len(intervals) - 1\n        while j >= 0 and intervals[j][0] > newInterval[1]:\n            j -= 1\n        \n        # merge the new interval with the elements before and after it\n        return intervals[:i+1] + [(min(intervals[i][0], newInterval[0]), max(intervals[j][1], newInterval[1]))] + intervals[j+1:]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, start):\n            if start == len(s):\n                return [[]]\n            res = []\n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i+1]):\n                    for item in dfs(s, i+1):\n                        res.append([s[start:i+1]] + item)\n            return res\n        \n        return dfs(s, 0)"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the min and max of all the numbers in the first list\n        min_num = float('inf')\n        max_num = float('-inf')\n        for num in nums[0]:\n            min_num = min(min_num, num)\n            max_num = max(max_num, num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = float('inf')\n        max_num_rest = float('-inf')\n        for nums_i in nums[1:]:\n            for num in nums_i:\n                min_num_rest = min(min_num_rest, num)\n                max_num_rest = max(max_num_rest, num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num_rest)\n        max_num_rest = max(max_num_rest, min_num)\n        \n        # find the min and max of all the numbers in the rest of the lists\n        min_num_rest = min(min_num_rest, max_num"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can be fed to any bucket\n        # 2. 1 pig can be fed to any bucket\n        # 3. 1 pig can be fed to any bucket\n        # 4. 1 pig can be fed to any bucket\n        # 5. 1 pig can be fed to any bucket\n        # 6. 1 pig can be fed to any bucket\n        # 7. 1 pig can be fed to any bucket\n        # 8. 1 pig can be fed to any bucket\n        # 9. 1 pig can be fed to any bucket\n        # 10. 1 pig can be fed to any bucket\n        # 11. 1 pig can be fed to any bucket\n        # 12. 1 pig can be fed to any bucket\n        # 13. 1 pig can be fed to any bucket\n        # 14. 1 pig can be fed to any bucket\n        # 15. 1 pig can be fed to any bucket\n        # 16. 1 pig can be fed to any bucket\n        # 17. 1 pig can be fed to any bucket\n        # 18. 1 pig can be fed to any bucket\n        # 19. 1 pig can be fed to any bucket\n        # 20. 1 pig can be fed to any bucket\n        # 21. 1 pig can be fed to any bucket\n        # 22. 1 pig can be fed to any bucket\n        # 23. 1 pig can be fed to any bucket\n        # 24. 1 pig can be fed to any bucket\n        # 25. 1 pig can be fed to any bucket\n        # 26. 1 pig can be fed to any bucket\n        # 27. 1 pig can be fed to any bucket\n        # 28. 1 pig can be fed to any bucket\n        # 29. 1 pig can be fed to any bucket\n        # 30. 1 pig can be fed to any bucket\n        # 31. 1 pig can be fed to any bucket\n        # 32. 1 pig can be fed to any bucket\n        # 33. 1 pig can be fed to any bucket\n        # 34. 1 pig can be fed to any bucket\n        # 35. 1 pig can be fed to any bucket\n        # 36. 1 pig can be fed to any bucket\n        # 37. 1 pig can be fed to any bucket\n        # 38. 1 pig can be fed to any bucket\n        # 39. 1 pig can be fed to any bucket\n        # 40. 1 pig can be fed to any bucket\n        # 41. 1 pig can be fed to any bucket\n        # 42. 1 pig can be fed to any bucket\n        # 43. 1 pig can be fed to any bucket\n        # 44. 1 pig can be fed to any bucket\n        # 45. 1 pig can be fed to any bucket\n        # 46. 1 pig can be fed to any bucket\n        # 47. 1 pig can be fed to any bucket\n        # 48. 1 pig can be fed to any bucket\n        # 49. 1 pig can be fed to any bucket\n        # 50. 1 pig can be fed to any bucket\n        # 51. 1 pig can be fed to any bucket\n        # 52. 1 pig can be fed to any bucket\n        # 53. 1 pig can be fed to any bucket\n        # 54. 1 pig can be fed to any bucket\n        # 55. 1 pig can be fed to any bucket\n        # 56. 1 pig can be fed to any bucket\n        # 57. 1 pig can be fed to any bucket\n        # 58. 1 pig can be fed to any bucket\n        # 59. 1 pig can be fed to any bucket\n        # 60. 1 pig can be fed to any bucket\n        # 61. 1 pig can be fed to any bucket\n        # 62. 1 pig can be fed to any bucket\n        # 63. 1 pig can be fed to any bucket\n        # 64. 1 pig can be fed to any bucket\n        # 65. 1 pig"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set([(0, 0)])\n        res = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            res = max(res, t)\n            if i == j == n-1:\n                return res\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    seen.add((ni, nj))\n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a 2D array with all zeros\n        grid = [[0] * n for _ in range(m)]\n        \n        # Fill the first row with ones\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # Fill the first column with ones\n        for j in range(n):\n            grid[0][j] = 1\n        \n        # Fill the rest of the grid with the sum of the values above and to the left\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        # Return the value in the bottom-right corner\n        return grid[m-1][n-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1_len = len(num1)\n        num2_len = len(num2)\n        result = [0] * (num1_len + num2_len)\n        \n        for i in range(num1_len - 1, -1, -1):\n            for j in range(num2_len - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1 = i + j\n                p2 = i + j + 1\n                sum = mul + result[p2]\n                result[p1] += sum / 10\n                result[p2] = sum % 10\n        \n        i = 0\n        while i < len(result) and result[i] == 0:\n            i += 1\n        \n        return ''.join(map(str, result[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. 2 pointers\n        ## 2. 1 pointer, 2 variables\n        ## 3. 1 pointer, 1 variable\n        ## 4. 1 pointer, 2 variables\n        ## 5. 1 pointer, 3 variables\n        ## 6. 1 pointer, 4 variables\n        ## 7. 1 pointer, 5 variables\n        ## 8. 1 pointer, 6 variables\n        ## 9. 1 pointer, 7 variables\n        ## 10. 1 pointer, 8 variables\n        ## 11. 1 pointer, 9 variables\n        ## 12. 1 pointer, 10 variables\n        ## 13. 1 pointer, 11 variables\n        ## 14. 1 pointer, 12 variables\n        ## 15. 1 pointer, 13 variables\n        ## 16. 1 pointer, 14 variables\n        ## 17. 1 pointer, 15 variables\n        ## 18. 1 pointer, 16 variables\n        ## 19. 1 pointer, 17 variables\n        ## 20. 1 pointer, 18 variables\n        ## 21. 1 pointer, 19 variables\n        ## 22. 1 pointer, 20 variables\n        ## 23. 1 pointer, 21 variables\n        ## 24. 1 pointer, 22 variables\n        ## 25. 1 pointer, 23 variables\n        ## 26. 1 pointer, 24 variables\n        ## 27. 1 pointer, 25 variables\n        ## 28. 1 pointer, 26 variables\n        ## 29. 1 pointer, 27 variables\n        ## 30. 1 pointer, 28 variables\n        ## 31. 1 pointer, 29 variables\n        ## 32. 1 pointer, 30 variables\n        ## 33. 1 pointer, 31 variables\n        ## 34. 1 pointer, 32 variables\n        ## 35. 1 pointer, 33 variables\n        ## 36. 1 pointer, 34 variables\n        ## 37. 1 pointer, 35 variables\n        ## 38. 1 pointer, 36 variables\n        ## 39. 1 pointer, 37 variables\n        ## 40. 1 pointer, 38 variables\n        ## 41. 1 pointer, 39 variables\n        ## 42. 1 pointer, 40 variables\n        ## 43. 1 pointer, 41 variables\n        ## 44. 1 pointer, 42 variables\n        ## 45. 1 pointer, 43 variables\n        ## 46. 1 pointer, 44 variables\n        ## 47. 1 pointer, 45 variables\n        ## 48. 1 pointer, 46 variables\n        ## 49. 1 pointer, 47 variables\n        ## 50. 1 pointer, 48 variables\n        ## 51. 1 pointer, 49 variables\n        ## 52. 1 pointer, 50 variables\n        ## 53. 1 pointer, 51 variables\n        ## 54. 1 pointer, 52 variables\n        ## 55. 1 pointer, 53 variables\n        ## 56. 1 pointer, 54 variables\n        ## 57. 1 pointer, 55 variables\n        ## 58. 1 pointer, 56 variables\n        ## 59. 1 pointer, 57 variables\n        ## 60. 1 pointer, 58 variables\n        ## 61. 1 pointer, 59 variables\n        ## 62. 1 pointer, 60 variables\n        ## 63. 1 pointer, 61 variables\n        ## 64. 1 pointer, 62 variables\n        ## 65. 1 pointer, 63 variables\n        ## 66"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, nums, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                result.append(curr.val)\n                curr = curr.right\n        \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # find the first and last invalid parentheses\n        # remove the invalid parentheses from the left and right\n        # add the valid parentheses to the result\n        # if the left and right are equal, add it to the result\n        # if the left is not equal, remove the invalid parentheses from the left\n        # if the right is not equal, remove the invalid parentheses from the right\n        # repeat the process until the left and right are equal\n        \n        # find the first and last invalid parentheses\n        left_invalid = []\n        right_invalid = []\n        for i, c in enumerate(s):\n            if c == '(':\n                left_invalid.append(i)\n            elif c == ')':\n                if left_invalid:\n                    left_invalid.pop()\n                else:\n                    right_invalid.append(i)\n        \n        # remove the invalid parentheses from the left and right\n        while left_invalid and right_invalid:\n            left = left_invalid.pop()\n            right = right_invalid.pop()\n            if left > right:\n                left_invalid.append(left)\n            else:\n                right_invalid.append(right)\n        \n        # add the valid parentheses to the result\n        result = []\n        for i in range(len(s)):\n            if i not in left_invalid and i not in right_invalid:\n                result.append(s[:i] + s[i+1:])\n        \n        return result"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i+1] if i+1 < len(lists) else None\n                mergedLists.append(self.mergeTwoLists(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode()\n        curr = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        if l1:\n            curr.next = l1\n        if l2:\n            curr.next = l2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [n-i-1 for i in range(n)]\n        for i in range(n):\n            for j in range(i+1):\n                if s[j] == s[i] and (i-j <= 1 or dp[i-j-1] == dp[i-1]):\n                    dp[i] = dp[i-1] - (i-j <= 1)\n                    break\n        return dp[-1]"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a reverse lookup table\n        reverse_lookup = {word[::-1]: i for i, word in enumerate(words)}\n        \n        # build a list of all palindromes\n        palindromes = []\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                if prefix in reverse_lookup and reverse_lookup[prefix] != i and suffix == suffix[::-1]:\n                    palindromes.append([i, reverse_lookup[prefix]])\n                if suffix in reverse_lookup and reverse_lookup[suffix] != i and prefix == prefix[::-1]:\n                    palindromes.append([reverse_lookup[suffix], i])\n        return palindromes"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, r, c):\n            q = collections.deque()\n            q.append((r, c))\n            while q:\n                r, c = q.popleft()\n                for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):\n                    if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                        isInfected[nr][nc] = 2\n                        q.append((nr, nc))\n        \n        m, n = len(isInfected), len(isInfected[0])\n        total = 0\n        while True:\n            infected = set()\n            for r in range(m):\n                for c in range(n):\n                    if isInfected[r][c] == 1:\n                        infected.add((r, c))\n            if not infected:\n                break\n            for r, c in infected:\n                spread(isInfected, r, c)\n            total += 1\n            for r in range(m):\n                for c in range(n):\n                    if isInfected[r][c] == 2:\n                        isInfected[r][c] = 3\n        return total"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, i, j, dp))\n        \n        return max_len\n    \n    def dfs(self, matrix, i, j, dp):\n        if dp[i][j] > 0:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], self.dfs(matrix, ni, nj, dp))\n        \n        return dp[i][j] + 1"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += (n / i) * i + max(0, min(i, n % i))\n            i *= 10\n        \n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a dict for each word\n        word_dict = {}\n        for word in wordDict:\n            word_dict[word] = True\n        \n        # build a list for each word\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # build a list for each word\n        word_list_2 = []\n        for word in wordDict:\n            word_list_2.append(word)\n        \n        # build a list for each word\n        word_list_3 = []\n        for word in wordDict:\n            word_list_3.append(word)\n        \n        # build a list for each word\n        word_list_4 = []\n        for word in wordDict:\n            word_list_4.append(word)\n        \n        # build a list for each word\n        word_list_5 = []\n        for word in wordDict:\n            word_list_5.append(word)\n        \n        # build a list for each word\n        word_list_6 = []\n        for word in wordDict:\n            word_list_6.append(word)\n        \n        # build a list for each word\n        word_list_7 = []\n        for word in wordDict:\n            word_list_7.append(word)\n        \n        # build a list for each word\n        word_list_8 = []\n        for word in wordDict:\n            word_list_8.append(word)\n        \n        # build a list for each word\n        word_list_9 = []\n        for word in wordDict:\n            word_list_9.append(word)\n        \n        # build a list for each word\n        word_list_10 = []\n        for word in wordDict:\n            word_list_10.append(word)\n        \n        # build a list for each word\n        word_list_11 = []\n        for word in wordDict:\n            word_list_11.append(word)\n        \n        # build a list for each word\n        word_list_12 = []\n        for word in wordDict:\n            word_list_12.append(word)\n        \n        # build a list for each word\n        word_list_13 = []\n        for word in wordDict:\n            word_list_13.append(word)\n        \n        # build a list for each word\n        word_list_14 = []\n        for word in wordDict:\n            word_list_14.append(word)\n        \n        # build a list for each word\n        word_list_15 = []\n        for word in wordDict:\n            word_list_15.append(word)\n        \n        # build a list for each word\n        word_list_16 = []\n        for word in wordDict:\n            word_list_16.append(word)\n        \n        # build a list for each word\n        word_list_17 = []\n        for word in wordDict:\n            word_list_17.append(word)\n        \n        # build a list for each word\n        word_list_18 = []\n        for word in wordDict:\n            word_list_18.append(word)\n        \n        # build a list for each word\n        word_list_19 = []\n        for word in wordDict:\n            word_list_19.append(word)\n        \n        # build a list for each word\n        word_list_20 = []\n        for word in wordDict:\n            word_list_20.append(word)\n        \n        # build a list for each word\n        word_list_21 = []\n        for word in wordDict:\n            word_list_21.append(word)\n        \n        # build a list for each word\n        word_list_22 = []\n        for word in wordDict:\n            word_list_22.append(word)\n        \n        # build a list for each word\n        word_list_23 = []\n        for word in wordDict:\n            word_list_23.append(word)\n        \n        # build a list for each word\n        word_list_24 = []"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        left_to_right = True\n        \n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.pop(0)\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n            left_to_right = not left_to_right\n        \n        return res"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def gen_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return \"%d:%02d\" % (h, m)\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h) + bin(m)).count('1') == turnedOn:\n                    res.append(gen_time(h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, len(res[-1])):\n                row.append(res[-1][j] + res[-1][j-1])\n            row.append(1)\n            res.append(row)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n        \n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                    ans += max(0, h - heightMap[ni][nj])\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n                    seen.add((ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # remove non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the median\n        # 3. return the median\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. find the median\n        if len(nums) % 2 == 0:\n            return (nums[k-1] + nums[k]) / 2.0\n        else:\n            return nums[k-1]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k % length - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = head\n        for i in range(length - k % length):\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        while n % 3 == 0:\n            n /= 3\n        while n % 5 == 0:\n            n /= 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                sums.sort()\n                j = bisect.bisect_left(sums, k)\n                if j < m:\n                    res = max(res, sums[j] - k)\n                for i in range(m):\n                    sums[i] -= matrix[i][r]\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        if dividend > 0 and divisor > 0:\n            return int(dividend/divisor)\n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend)/abs(divisor))\n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend)/abs(divisor))\n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend)/abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i-1, j)\n            dfs(i+1, j)\n            dfs(i, j-1)\n            dfs(i, j+1)\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    dfs(i, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # iterate through the list\n        # subtract the current number from the target\n        # check if the difference is in the dictionary\n        # if it is, return the index of the difference and the index of the current number\n        # if it is not, add the current number to the dictionary\n        \n        # create a dictionary\n        d = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            \n            # subtract the current number from the target\n            diff = target - num\n            \n            # check if the difference is in the dictionary\n            if diff in d:\n                \n                # if it is, return the index of the difference and the index of the current number\n                return [d[diff], i]\n            \n            # if it is not, add the current number to the dictionary\n            d[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24.0) < 1e-6\n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                nxt = a + b\n                            elif op == '-':\n                                nxt = a - b\n                            elif op == '*':\n                                nxt = a * b\n                            else:\n                                if b == 0:\n                                    continue\n                                nxt = float(a) / b\n                            if nxt not in cards:\n                                cards.append(nxt)\n                                if dfs(cards):\n                                    return True\n                                cards.pop()\n            return False\n        \n        return dfs(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if p[0] == s[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/problems/majority-element/discuss/100988/Python-O(n)-solution-with-detailed-explanation\n        # https://leetcode.com/pro"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for fromi, toi in tickets:\n            graph[fromi].append(toi)\n        \n        # sort the nodes by alphabetical order\n        for node in graph:\n            graph[node].sort(reverse=True)\n        \n        # do a DFS\n        res = []\n        def dfs(node):\n            # if there is no more nodes, add the current node to the result\n            if len(graph[node]) == 0:\n                res.append(node)\n            # otherwise, visit all the nodes that are adjacent to the current node\n            else:\n                for i in range(len(graph[node])-1, -1, -1):\n                    next_node = graph[node][i]\n                    del graph[node][i]\n                    dfs(next_node)\n        \n        dfs(\"JFK\")\n        return res"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = [[0, 0]]\n        \n        # iterate over the buildings\n        for b in buildings:\n            # if the left edge of the current building is larger than the last building's left edge, add it to the result\n            if b[0] > result[-1][1]:\n                result.append([b[0], b[2]])\n            # if the right edge of the current building is larger than the last building's right edge, add it to the result\n            elif b[1] > result[-1][1]:\n                result.append([b[1], b[2]])\n            # if the right edge of the current building is smaller than the last building's right edge, remove it from the result\n            else:\n                result.pop()\n        # sort the result by height\n        result.sort(key=lambda x: x[1])\n        # return the result\n        return result[1:]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # reverse each word\n        for i in range(len(s)):\n            s[i] = s[i][::-1]"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return 'Zero'\n        \n        num_str = str(num)\n        num_len = len(num_str)\n        num_dict = {\n            '1': 'One',\n            '2': 'Two',\n            '3': 'Three',\n            '4': 'Four',\n            '5': 'Five',\n            '6': 'Six',\n            '7': 'Seven',\n            '8': 'Eight',\n            '9': 'Nine',\n            '10': 'Ten',\n            '11': 'Eleven',\n            '12': 'Twelve',\n            '13': 'Thirteen',\n            '14': 'Fourteen',\n            '15': 'Fifteen',\n            '16': 'Sixteen',\n            '17': 'Seventeen',\n            '18': 'Eighteen',\n            '19': 'Nineteen',\n            '20': 'Twenty',\n            '30': 'Thirty',\n            '40': 'Forty',\n            '50': 'Fifty',\n            '60': 'Sixty',\n            '70': 'Seventy',\n            '80': 'Eighty',\n            '90': 'Ninety',\n        }\n        \n        if num_len == 1:\n            return num_dict[num_str]\n        \n        if num_len == 2:\n            if num_str[1] == '0':\n                return num_dict[num_str[0]]\n            else:\n                return num_dict[num_str[0] + '0'] + ' ' + num_dict[num_str[1]]\n        \n        if num_len == 3:\n            if num_str[1] == '0' and num_str[2] == '0':\n                return num_dict[num_str[0]] + ' Hundred'\n            elif num_str[1] == '0':\n                return num_dict[num_str[0]] + ' Hundred ' + num_dict[num_str[2]]\n            else:\n                return num_dict[num_str[0]] + ' Hundred ' + num_dict[num_str[1] + '0'] + ' ' + num_dict[num_str[2]]\n        \n        if num_len == 4:\n            if num_str[1] == '0' and num_str[2] == '0' and num_str[3] == '0':\n                return num_dict[num_str[0]] + ' Thousand'\n            elif num_str[1] == '0' and num_str[2] == '0':\n                return num_dict[num_str[0]] + ' Thousand ' + num_dict[num_str[3]]\n            elif num_str[1] == '0':\n                return num_dict[num_str[0]] + ' Thousand ' + num_dict[num_str[2] + '0'] + ' ' + num_dict[num_str[3]]\n            else:\n                return num_dict[num_str[0]] + ' Thousand ' + num_dict[num_str[1] + '0'] + ' ' + num_dict[num_str[2] + '0'] + ' ' + num_dict[num_str[3]]\n        \n        if num_len == 5:\n            if num_str[1] == '0' and num_str[2] == '0' and num_str[3] == '0' and num_str[4] == '0':\n                return num_dict[num_str[0]] + ' Million'\n            elif num_str[1] == '0' and num_str[2] == '0' and num_str[3] == '0':\n                return num_dict[num_str[0]] + ' Million ' + num_dict[num_str[4]]\n            elif num_str[1] == '0' and num_str[2] == '0':\n                return num_dict[num_str[0]] + ' Million ' + num_dict[num_str[3] + '0'] + ' ' + num_dict[num_str[4]]\n            elif num_str[1] == '0':\n                return"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            curr.next = second\n            first.next = second.next\n            second.next = first\n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to p1\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to p2\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the head of the second list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent = {}\n        child = {}\n        for edge in edges:\n            if edge[1] in parent:\n                return [parent[edge[1]], edge[1]]\n            else:\n                parent[edge[1]] = edge[0]\n        \n        # find the node with only one parent\n        for edge in edges:\n            if edge[0] in child:\n                return [child[edge[0]], edge[0]]\n            else:\n                child[edge[0]] = edge[1]\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        used = [False] * len(nums)\n        self.dfs(nums, [], res, used)\n        return res\n        \n    def dfs(self, nums, path, res, used):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            self.dfs(nums, path, res, used)\n            path.pop()\n            used[i] = False"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use a hashmap to store the occurence of each element\n        ## 2. iterate through the list and check if the element is in the hashmap\n        ## 3. if it is, remove it from the hashmap\n        ## 4. if it is not, add it to the hashmap\n        ## 5. return the last element in the hashmap\n        \n        occurence = {}\n        for num in nums:\n            if num in occurence:\n                occurence.pop(num)\n            else:\n                occurence[num] = 1\n        return occurence.popitem()[0]"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j] = -float('inf')\n                if i > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + (grid[i][j] if i > 0 else 0))\n                if j > 0:\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + (grid[i][j] if j > 0 else 0))\n                if i < n - 1 and j < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j + 1] + (grid[i][j] if i < n - 1 and j < n - 1 else 0))\n                if i > 0 and j < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + (grid[i][j] if i > 0 and j < n - 1 else 0))\n                if j > 0 and i < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + (grid[i][j] if j > 0 and i < n - 1 else 0))\n        return max(dp[n - 1][n - 1], 0)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        seen = set()\n        while n not in seen:\n            seen.add(n)\n            n = sum(int(d)**2 for d in str(n))\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        # 1. find the index of the first element that is larger than target\n        # 2. if the target is larger than all elements, return len(nums)\n        # 3. if the target is smaller than all elements, return 0\n        # 4. otherwise, return the index\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_reach = nums[0]\n        # for i in range(1, len(nums)):\n        #     if i > max_reach:\n        #         return False\n        #     max_reach = max(max_reach, i + nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_reach = nums[0]\n        # for i in range(1, len(nums)):\n        #     if i > max_reach:\n        #         return False\n        #     max_reach = max(max_reach, i + nums[i])\n        #     if max_reach >= len(nums) - 1:\n        #         return True\n        # return False\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_reach = nums[0]\n        # for i in range(1, len(nums)):\n        #     if i > max_reach:\n        #         return False\n        #     max_reach = max(max_reach, i + nums[i])\n        #     if max_reach >= len(nums) - 1:\n        #         return True\n        # return False\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_reach = nums[0]\n        # for i in range(1, len(nums)):\n        #     if i > max_reach:\n        #         return False\n        #     max_reach = max(max_reach, i + nums[i])\n        #     if max_reach >= len(nums) - 1:\n        #         return True\n        #     if max_reach == i:\n        #         return False\n        # return False\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_reach = nums[0]\n        # for i in range(1, len(nums)):\n        #     if i > max_reach:\n        #         return False\n        #     max_reach = max(max_reach, i + nums[i])\n        #     if max_reach >= len(nums) - 1:\n        #         return True\n        #     if max_reach == i:\n        #         max_reach = max(max_reach, i + nums[i])\n        # return False\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_reach = nums[0]\n        # for i in range(1, len(nums)):\n        #     if i > max_reach:\n        #         return False\n        #     max_reach = max(max_reach, i + nums[i])\n        #     if max_reach >= len(nums) - 1:\n        #         return True\n        #     if max_reach == i:\n        #         max_reach = max(max_reach, i + nums[i])\n        #     if max_reach >= len(nums) - 1:\n        #         return True\n        # return False\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_reach = nums[0]\n        # for i in range(1, len(nums)):\n        #     if i > max_reach:\n        #         return False\n        #     max_reach = max(max_reach, i + nums[i])\n        #     if max_reach >= len(nums) - 1:\n        #         return True\n        #     if max_reach == i:\n        #         max_reach = max(max_reach, i + nums[i])\n        #     if max_reach >= len(nums) - 1:\n        #         return True\n        #     if max_reach == i:\n        #         max_reach = max(max_reach, i + nums[i])\n        # return False\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_reach = nums[0]\n        # for i"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j-1]\n                elif j == 0:\n                    grid[i][j] += grid[i-1][j]\n                else:\n                    grid[i][j] += min(grid[i][j-1], grid[i-1][j])\n        \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        prev = '1'\n        curr = ''\n        count = 1\n        \n        for i in range(2, n+1):\n            for j in range(len(prev)):\n                if j+1 < len(prev) and prev[j] == prev[j+1]:\n                    count += 1\n                else:\n                    curr += str(count) + prev[j]\n                    count = 1\n            prev = curr\n            curr = ''\n        \n        return prev"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        pivot = left\n        \n        # find the target\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            real_mid = (mid + pivot) % len(nums)\n            if nums[real_mid] == target:\n                return real_mid\n            elif nums[real_mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}\n        res = ['']\n        for d in digits:\n            for c in phone[d]:\n                res += [r + c for r in res]\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, nums, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            self.dfs(nums, target - nums[i], i, path + [nums[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # get the length of the string\n        length = len(n)\n        \n        # get the number of digits in the string\n        digits = length / 2\n        \n        # get the left and right halves of the string\n        left = n[:digits]\n        right = n[digits:]\n        \n        # get the possible candidates for the closest palindrome\n        candidates = [int(left), int(right)]\n        if left:\n            candidates.append(int(left + '9' * (length - digits)))\n        if right:\n            candidates.append(int(right + '9' * (length - digits - 1)))\n        \n        # get the closest palindrome\n        closest = min(candidates, key=lambda x: abs(x - int(n)))\n        \n        # return the closest palindrome\n        return str(closest)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        if rev > 2**31:\n            return 0\n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum product and the minimum product\n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n        \n        # Iterate through the array\n        for i in range(1, len(nums)):\n            # Calculate the current maximum and minimum product\n            max_prod, min_prod = max(nums[i], max_prod * nums[i], min_prod * nums[i]), min(nums[i], max_prod * nums[i], min_prod * nums[i])\n            # Update the maximum product\n            result = max(result, max_prod)\n        \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if there is a way to get to the last stone from the first stone\n        # dp[i] = False if there is no way to get to the last stone from the first stone\n        dp = {0: True}\n        \n        for s in stones:\n            for k in range(s+1):\n                if k not in dp:\n                    continue\n                for i in range(s+1):\n                    if i+k == s:\n                        if i-1 in dp:\n                            dp[i+k] = True\n                        break\n                    elif i+k-1 in dp:\n                        dp[i+k] = True\n                    elif i+k+1 in dp:\n                        dp[i+k] = True\n        return dp[stones[-1]]"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dict to store the index of each score\n        score_dict = {}\n        for i, s in enumerate(score_sorted):\n            score_dict[s] = i\n        \n        # create a list to store the result\n        result = [None] * len(score)\n        \n        # assign the rank to each score\n        for i, s in enumerate(score):\n            if i == 0:\n                result[score_dict[s]] = \"Gold Medal\"\n            elif i == 1:\n                result[score_dict[s]] = \"Silver Medal\"\n            elif i == 2:\n                result[score_dict[s]] = \"Bronze Medal\"\n            else:\n                result[score_dict[s]] = str(i+1)\n        \n        return result"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the max length to 0\n        max_len = 0\n        \n        # Initialize the dictionary to store the last index of each character\n        char_dict = {}\n        \n        # Initialize the start index to 0\n        start = 0\n        \n        # Iterate through the string\n        for i, char in enumerate(s):\n            # If the character is already in the dictionary, update the start index to the index of the character + 1\n            if char in char_dict:\n                start = max(start, char_dict[char] + 1)\n            # Update the max length to the max of the current length and the difference between the current index and the start index\n            max_len = max(max_len, i - start + 1)\n            # Update the dictionary with the character and its index\n            char_dict[char] = i\n        \n        # Return the max length\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            word_dict_copy = word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                else:\n                    left = j + word_len\n                    word_dict_copy = word_dict.copy()\n            if not word_dict_copy:\n                res.append(left)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = -1\n        res = 0\n        for i in range(len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if max_val == i:\n                res += 1\n        return res"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        cur = head\n        \n        while cur:\n            temp = cur\n            cur = cur.next\n            prev = dummy\n            while prev.next and prev.next.val < temp.val:\n                prev = prev.next\n            temp.next = prev.next\n            prev.next = temp\n            \n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            j = mid + 1\n            for i in range(left, mid + 1):\n                while j <= right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += (j - (mid + 1))\n            nums[left:right + 1] = sorted(nums[left:right + 1])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            return merge(nums, left, mid, right) + mergeSort(nums, mid + 1, right) + mergeSort(nums, left, mid)\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if i < len(v2):\n                    if v1[i] < v2[i]:\n                        return -1\n                    elif v1[i] > v2[i]:\n                        return 1\n                else:\n                    return -1\n            else:\n                if i < len(v2):\n                    return 1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end time\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, end in courses:\n            # add to pq\n            heapq.heappush(pq, -duration)\n            \n            # add to total\n            total += duration\n            \n            # if total exceeds end time, remove from pq\n            if total > end:\n                total += heapq.heappop(pq)\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while True:\n            tail = prev\n            for i in range(k):\n                if not tail:\n                    return dummy.next\n                tail = tail.next\n            head = prev.next\n            next = head.next\n            for i in range(k):\n                head.next = next\n                if not next:\n                    break\n                head = next\n                next = head.next\n            tail.next = head\n            prev.next = tail\n            prev = head\n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % len(s[0]) != 0:\n        #     return False\n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1]\n        \n        # return s in (s + s)[1:-1"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] * 2 + dp[i-2] * 2 + ... + dp[0] * 2\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i] + dp[i-2] * dp[n-i-1] + ... + dp[0] * dp[n-i-1]\n        # dp[i] = dp[i-1] * dp[n-i]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a dict to store the count of each number\n        # 2. iterate through the list and check if the count is 1\n        # 3. if it is, return the key\n        # 4. if it is not, add it to the dict\n        \n        num_dict = {}\n        for num in nums:\n            if num not in num_dict:\n                num_dict[num] = 1\n            else:\n                num_dict[num] += 1\n        \n        for num in nums:\n            if num_dict[num] == 1:\n                return num"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict for each sticker\n        # 2. build a dict for each letter in target\n        # 3. for each letter in target, check if it can be made from stickers\n        # 4. if it can, add 1 to the count\n        # 5. if it can't, check if it can be made from stickers with the letter removed\n        # 6. if it can, add 1 to the count\n        # 7. if it can't, return -1\n        \n        sticker_dict = {}\n        for sticker in stickers:\n            for letter in sticker:\n                if letter not in sticker_dict:\n                    sticker_dict[letter] = 0\n                sticker_dict[letter] += 1\n        \n        target_dict = {}\n        for letter in target:\n            if letter not in target_dict:\n                target_dict[letter] = 0\n            target_dict[letter] += 1\n        \n        queue = [target_dict]\n        count = 0\n        while queue:\n            new_queue = []\n            for sticker in queue:\n                for letter in sticker:\n                    new_sticker = sticker.copy()\n                    new_sticker[letter] -= 1\n                    if new_sticker[letter] == 0:\n                        new_sticker.pop(letter)\n                    if new_sticker not in sticker_dict:\n                        continue\n                    if sticker_dict[new_sticker] < new_sticker[sticker_dict[new_sticker]]:\n                        new_sticker[sticker_dict[new_sticker]] = sticker_dict[new_sticker]\n                    new_queue.append(new_sticker)\n            queue = new_queue\n            count += 1\n        return -1 if len(queue) == 0 else count"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1] + 1, dp[j][j])\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        total = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total -= roman_dict[s[i]]\n            else:\n                total += roman_dict[s[i]]\n        return total"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        q = []\n        res = []\n        for i in range(len(nums)):\n            while q and q[0] <= i - k:\n                q.pop(0)\n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                res.append(nums[q[0]])\n        return res"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge nums1 and nums2 into a single list\n        nums = nums1 + nums2\n        \n        # sort the merged list\n        nums.sort()\n        \n        # find the median\n        if len(nums) % 2 == 1:\n            return nums[len(nums) // 2]\n        else:\n            return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2.0"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        # if the pivot point is not found, return the first element\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found,"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right:\n                if root.val == targetSum:\n                    return [[root.val]]\n                else:\n                    return []\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the square root of area\n        # 2. find the largest number that is smaller than square root of area\n        # 3. return [largest number, square root of area]\n        # 4. if area is perfect square, return [area, 1]\n        \n        import math\n        sqrt_area = int(math.sqrt(area))\n        if sqrt_area * sqrt_area == area:\n            return [sqrt_area, 1]\n        else:\n            return [area, sqrt_area]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build the queue\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        found = False\n        \n        while queue:\n            curr = queue.popleft()\n            for i in range(len(curr)):\n                for j in range(26):\n                    neighbor = curr[:i] + chr(ord('a') + j) + curr[i+1:]\n                    for word in graph[neighbor]:\n                        if word == endWord:\n                            found = True\n                        if word not in visited:\n                            visited[word] = curr\n                            queue.append(word)\n                    if found:\n                        break\n                if found:\n                    break\n        \n        # build the result\n        res = []\n        curr = endWord\n        while curr:\n            res.append(curr)\n            curr = visited[curr]\n        return res[::-1]"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]] + r for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                op2 = stack.pop()\n                op1 = stack.pop()\n                if token == \"+\":\n                    stack.append(op1 + op2)\n                elif token == \"-\":\n                    stack.append(op1 - op2)\n                elif token == \"*\":\n                    stack.append(op1 * op2)\n                else:\n                    stack.append(int(float(op1) / op2))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        \n        for num in nums:\n            if cur_sum < 0:\n                cur_sum = num\n            else:\n                cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = []\n        for row in board:\n            for col in row:\n                board_1d.append(col)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a 10-digit number\n        board_num = int(board_str)\n        \n        # convert board_num to a list of 4 numbers\n        board_list = [board_num // 1000, (board_num % 1000) // 100, (board_num % 100) // 10, board_num % 10]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for num in board_list:\n            board_1d.append(num)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a 10-digit number\n        board_num = int(board_str)\n        \n        # convert board_num to a list of 4 numbers\n        board_list = [board_num // 1000, (board_num % 1000) // 100, (board_num % 100) // 10, board_num % 10]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for num in board_list:\n            board_1d.append(num)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a 10-digit number\n        board_num = int(board_str)\n        \n        # convert board_num to a list of 4 numbers\n        board_list = [board_num // 1000, (board_num % 1000) // 100, (board_num % 100) // 10, board_num % 10]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for num in board_list:\n            board_1d.append(num)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a 10-digit number\n        board_num = int(board_str)\n        \n        # convert board_num to a list of 4 numbers\n        board_list = [board_num // 1000, (board_num % 1000) // 100, (board_num % 100) // 10, board_num % 10]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for num in board_list:\n            board_1d.append(num)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a 10-digit number\n        board_num = int(board_str)\n        \n        # convert board_num to a list of 4 numbers\n        board_list = [board_num // 1000, (board_num % 1000) // 100, (board_num % 100) // 10, board_num % 10]\n        \n        # convert board_list to a 1D array\n        board_1d = []\n        for num in board_list:\n            board_1d.append(num)\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a 10-digit number\n        board_num = int(board_str)\n        \n        # convert board_num to a"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t:\n                if s_to_t[s[i]] != t[i]:\n                    return False\n            else:\n                if t[i] in t_to_s:\n                    return False\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = None\n        for i in range(len(nums)-1):\n            if nums[i] > nums[i+1]:\n                pivot = i+1\n                break\n        \n        # if pivot is None, then the array is not rotated\n        if pivot == None:\n            return target in nums\n        \n        # if target is smaller than the first element, then it must be in the right part of pivot\n        if nums[0] <= target:\n            return self.binary_search(nums, 0, pivot-1, target)\n        # if target is larger than the first element, then it must be in the left part of pivot\n        else:\n            return self.binary_search(nums, pivot, len(nums)-1, target)\n        \n    def binary_search(self, nums, left, right, target):\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(closest - target):\n                    closest = s\n                if s < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        d = {}\n        for i in nums1:\n            if i not in d:\n                d[i] = 1\n            else:\n                d[i] += 1\n        \n        res = []\n        for i in nums2:\n            if i in d:\n                res.append(i)\n                d[i] -= 1\n                if d[i] == 0:\n                    del d[i]\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        prev = None\n        min_diff = float('inf')\n        for n in inorder(root):\n            if prev:\n                min_diff = min(min_diff, n - prev)\n            prev = n\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        # find the max frequency\n        max_freq = 0\n        max_freq_list = []\n        curr_freq = 0\n        prev_val = None\n        curr_val = None\n        \n        stack = []\n        while root or stack:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                if prev_val == root.val:\n                    curr_freq += 1\n                else:\n                    if curr_freq > max_freq:\n                        max_freq = curr_freq\n                        max_freq_list = [root.val]\n                    elif curr_freq == max_freq:\n                        max_freq_list.append(root.val)\n                    curr_freq = 1\n                prev_val = root.val\n                root = root.right\n        \n        if curr_freq > max_freq:\n            max_freq = curr_freq\n            max_freq_list = [root.val]\n        elif curr_freq == max_freq:\n            max_freq_list.append(root.val)\n        \n        return max_freq_list"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4."}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        return n/5 + self.trailingZeroes(n/5)"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        currRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[currRow] += c\n            if currRow == 0 or currRow == numRows - 1:\n                goingDown = not goingDown\n            currRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        res = 0\n        \n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                res += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                res += right_max - height[right]\n                \n        return res"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] = -nums[index]\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use a dict to store the number of smaller elements to the left\n        # 5. use a list to store the number of smaller elements to the right\n        # 6. return the number of smaller elements to the right\n        \n        # 1. sort the array\n        nums = [(num, i) for i, num in enumerate(nums)]\n        nums.sort()\n        \n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use a dict to store the number of smaller elements to the left\n        # 5. use a list to store the number of smaller elements to the right\n        # 6. return the number of smaller elements to the right\n        res = [0] * len(nums)\n        for num, i in nums:\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid][0] >= num:\n                    right = mid - 1\n                else:\n                    res[i] += mid - i\n                    left = mid + 1\n            nums[i] = (num, res[i])\n        return res"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = curr = 0\n        for i in intervals:\n            if i[0] > curr:\n                ans += 2\n                curr = i[1] - 1\n            else:\n                curr = min(curr, i[1] - 1)\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. build a dict to store the count of each atom\n        # 2. build a dict to store the count of each element\n        # 3. build a dict to store the count of each parentheses\n        # 4. build a dict to store the count of each parentheses\n        # 5. build a dict to store the count of each parentheses\n        # 6. build a dict to store the count of each parentheses\n        # 7. build a dict to store the count of each parentheses\n        # 8. build a dict to store the count of each parentheses\n        # 9. build a dict to store the count of each parentheses\n        # 10. build a dict to store the count of each parentheses\n        # 11. build a dict to store the count of each parentheses\n        # 12. build a dict to store the count of each parentheses\n        # 13. build a dict to store the count of each parentheses\n        # 14. build a dict to store the count of each parentheses\n        # 15. build a dict to store the count of each parentheses\n        # 16. build a dict to store the count of each parentheses\n        # 17. build a dict to store the count of each parentheses\n        # 18. build a dict to store the count of each parentheses\n        # 19. build a dict to store the count of each parentheses\n        # 20. build a dict to store the count of each parentheses\n        # 21. build a dict to store the count of each parentheses\n        # 22. build a dict to store the count of each parentheses\n        # 23. build a dict to store the count of each parentheses\n        # 24. build a dict to store the count of each parentheses\n        # 25. build a dict to store the count of each parentheses\n        # 26. build a dict to store the count of each parentheses\n        # 27. build a dict to store the count of each parentheses\n        # 28. build a dict to store the count of each parentheses\n        # 29. build a dict to store the count of each parentheses\n        # 30. build a dict to store the count of each parentheses\n        # 31. build a dict to store the count of each parentheses\n        # 32. build a dict to store the count of each parentheses\n        # 33. build a dict to store the count of each parentheses\n        # 34. build a dict to store the count of each parentheses\n        # 35. build a dict to store the count of each parentheses\n        # 36. build a dict to store the count of each parentheses\n        # 37. build a dict to store the count of each parentheses\n        # 38. build a dict to store the count of each parentheses\n        # 39. build a dict to store the count of each parentheses\n        # 40. build a dict to store the count of each parentheses\n        # 41. build a dict to store the count of each parentheses\n        # 42. build a dict to store the count of each parentheses\n        # 43. build a dict to store the count of each parentheses\n        # 44. build a dict to store the count of each parentheses\n        # 45. build a dict to store the count of each parentheses\n        # 46. build a dict to store the count of each parentheses\n        # 47. build a dict to store the count of each parentheses\n        # 48. build a dict to store the count of each parentheses\n        # 49. build a dict to store the count of each parentheses\n        # 50. build a dict to store the count of each parentheses\n        # 51. build a dict to store the count of each parentheses\n        # 52. build a dict to store the count of each parentheses\n        # 53. build a dict to store the count of each parentheses\n        # 54. build a dict to store the count of each parentheses\n        # 55. build a dict to store"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        \n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - i - 1):\n                    res.append('({}){}'.format(left, right))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the result and the current sum\n        res, curr_sum = 0, 0\n        \n        # Iterate over the array\n        for num in nums:\n            # If the current sum is less than the current number\n            if curr_sum < num:\n                # Add the missing number to the result\n                res += curr_sum + 1\n                # Update the current sum\n                curr_sum += curr_sum + 1\n            # Update the current sum\n            curr_sum += num\n        \n        # Add the remaining numbers to the result\n        res += curr_sum\n        \n        # Return the result\n        return res"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # stack to store the index of '('\n        stack = [-1]\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_len = max(max_len, i - stack[-1])\n        \n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        res = \"\"\n        if (numerator < 0) ^ (denominator < 0):\n            res += \"-\"\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        res += str(numerator // denominator)\n        numerator %= denominator\n        \n        if numerator == 0:\n            return res\n        \n        res += \".\"\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res = res[:seen[numerator]] + \"(\" + res[seen[numerator]:] + \")\"\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode(0)\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # merge the remaining nodes\n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        \n        for e in envelopes:\n            if not dp or e[1] > dp[-1]:\n                dp.append(e[1])\n            else:\n                left, right = 0, len(dp) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if dp[mid] < e[1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                dp[left] = e[1]\n        \n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        ## row and col are set to 0 if the element is 0\n        ## we iterate over the matrix and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set the element to 0 if the element is 0\n        ## we iterate over the matrix again and set"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create two pointers\n        left = dummy\n        right = dummy\n        \n        # move right pointer n steps\n        for i in range(n + 1):\n            right = right.next\n        \n        # move both pointers until right is None\n        while right:\n            left = left.next\n            right = right.next\n        \n        # delete the node\n        left.next = left.next.next\n        \n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        if total % len(machines) != 0:\n            return -1\n        avg = total / len(machines)\n        curr = 0\n        ans = 0\n        for m in machines:\n            curr += m - avg\n            ans = max(ans, abs(curr))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x / i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) / 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[i] <= heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [item + [num] for item in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the index of the smallest element\n        # if the smallest element is not at the beginning, then it is the smallest\n        # if the smallest element is at the beginning, then it is the largest\n        # if the smallest element is at the end, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle, then it is the smallest\n        # if the smallest element is at the middle"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        if not s:\n            return False\n        \n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        \n        if s[-1] in ['+', '-']:\n            s = s[:-1]\n        if not s:\n            return False\n        \n        if 'e' in s:\n            try:\n                num, exp = s.split('e')\n                return (self.isInteger(num) and self.isInteger(exp))\n            except ValueError:\n                return False\n        else:\n            return self.isInteger(s)\n        \n    def isInteger(self, s):\n        if not s:\n            return False\n        if s[0] in ['+', '-']:\n            s = s[1:]\n        if not s:\n            return False\n        if not s.isdigit():\n            return False\n        return True"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n        roman_num = ''\n        for key in sorted(roman_dict.keys(), reverse=True):\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 26 letters\n        ## 128 - 97 = 26\n        ## 26 - 128 = 128\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128 = 0\n        ## 128 - 128"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_space(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        return (i, j)\n            return None\n        \n        def is_valid(board, num, pos):\n            # check row\n            for i in range(9):\n                if board[pos[0]][i] == num and pos[1] != i:\n                    return False\n            \n            # check column\n            for i in range(9):\n                if board[i][pos[1]] == num and pos[0] != i:\n                    return False\n            \n            # check box\n            box_x = pos[0] // 3\n            box_y = pos[1] // 3\n            \n            for i in range(box_x * 3, box_x * 3 + 3):\n                for j in range(box_y * 3, box_y * 3 + 3):\n                    if board[i][j] == num and (i, j) != pos:\n                        return False\n            \n            return True\n        \n        def solve(board):\n            empty = find_empty_space(board)\n            if empty is None:\n                return True\n            \n            for i in range(1, 10):\n                if is_valid(board, str(i), empty):\n                    board[empty[0]][empty[1]] = str(i)\n                    \n                    if solve(board):\n                        return True\n                    \n                    board[empty[0]][empty[1]] = '.'\n            \n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node that is out of order\n        first_node = None\n        second_node = None\n        prev = None\n        \n        # traverse the tree in-order\n        while root:\n            if root.left:\n                # find the predecessor\n                pred = root.left\n                while pred.right and pred.right != root:\n                    pred = pred.right\n                \n                if pred.right:\n                    # if the predecessor is the first node, set it as the first node\n                    if first_node is None:\n                        first_node = pred\n                    # if the predecessor is the second node, set it as the second node\n                    second_node = root\n                \n                # restore the predecessor\n                pred.right = root\n                root = root.left\n            else:\n                # if the first node is None, set it as the first node\n                if first_node is None:\n                    first_node = root\n                # if the second node is None, set it as the second node\n                if second_node is None:\n                    second_node = root\n                # restore the predecessor\n                root = root.right\n        \n        # swap the values of the first and second node\n        first_node.val, second_node.val = second_node.val, first_node.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node that is out of order\n        first_node = None\n        second_node = None\n        prev = None\n        \n        # traverse the tree in-order\n        while root:\n            if root.left:\n                # find the predecessor\n                pred = root.left\n                while pred.right and pred.right != root:\n                    pred = pred.right\n                \n                if pred.right:\n                    # if the predecessor is the first node, set it as the first node\n                    if first_node is None:\n                        first_node = pred\n                    # if the predecessor is the second node, set it as the second node\n                    second_node = root\n                \n                # restore the predecessor\n                pred.right = root\n                root = root.left\n            else:\n                # if the first node is None, set it as the first node\n                if first_node is None:\n                    first_node = root\n                # if the second node is None, set it as the second node\n                if second_node is None:\n                    second_node = root\n                # restore the predecessor\n                root = root.right\n        \n        # swap the values of the first and second node\n        first_node.val, second_node.val = second_node.val, first_node.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node that is out of order\n        first_node = None\n        second_node = None\n        prev = None\n        \n        # traverse the tree in-order\n        while root:\n            if root.left:\n                # find the predecessor\n                pred = root.left\n                while pred.right and pred.right != root:\n                    pred = pred.right\n                \n                if pred.right:\n                    # if the predecessor is the first node, set it as the first node\n                    if first_node is None:\n                        first_node = pred\n                    # if the predecessor is the second node, set it as the second node\n                    second_node = root\n                \n                # restore the predecessor\n                pred.right = root\n                root = root.left\n            else:"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        if not head:\n            return True\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 1\n        right = num\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        ans = [0]\n        for i in range(1, n+1):\n            ans.append(ans[i & (i-1)] + 1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['#'] = word\n        \n        def dfs(i, j, node):\n            letter = board[i][j]\n            word = node.get('#')\n            if word:\n                res.add(word)\n            if letter not in node:\n                return\n            board[i][j] = '#'\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] != '#':\n                    dfs(x, y, node[board[x][y]])\n            board[i][j] = letter\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, trie)\n        return list(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 squares\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(square)) != len(square):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the whole string\n        s = s[::-1]\n        \n        # reverse each word\n        s = s.split()\n        s = ' '.join(s[::-1])\n        \n        return s"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res += (ord(columnTitle[i]) - ord('A') + 1) * (26 ** (len(columnTitle) - i - 1))\n        return res"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first_next = first.next\n            second_next = second.next\n            first.next = second\n            second.next = first_next\n            first = first_next\n            second = second_next\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the number of words is not equal to the number of letters in the pattern, return False\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the dictionary, check if the word is the same as the corresponding word in the dictionary\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the dictionary, add it to the dictionary with the word as the value\n            else:\n                if word in mapping.values():\n                    return False\n                mapping[letter] = word\n        \n        # if all the letters and words are mapped correctly, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid/n][mid%n] == target:\n                return True\n            elif matrix[mid/n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n                \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            carry /= 10\n            curr = curr.next\n            \n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip bits\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip bits\n        flipped = \"\"\n        for bit in binary:\n            if bit == \"1\":\n                flipped += \"0\"\n            else:\n                flipped += \"1\"\n        \n        # 3. convert back to decimal\n        return int(flipped, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        diff = nums[1] - nums[0]\n        count = 0\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current line\n        current_line = []\n        \n        # initialize the current line length\n        current_line_length = 0\n        \n        # loop through the words\n        for word in words:\n            # if the current line length + the length of the current word + the number of spaces is less than the max width\n            if current_line_length + len(word) + len(current_line) <= maxWidth:\n                # add the word to the current line\n                current_line.append(word)\n                # add the length of the word to the current line length\n                current_line_length += len(word)\n            else:\n                # if the current line is not empty\n                if current_line:\n                    # if the number of words in the current line is 1\n                    if len(current_line) == 1:\n                        # add the current line to the result list\n                        result.append(' '.join(current_line) + ' ' * (maxWidth - current_line_length))\n                    else:\n                        # calculate the number of spaces to add\n                        spaces_to_add = (maxWidth - current_line_length) // (len(current_line) - 1)\n                        # calculate the number of spaces to distribute\n                        extra_spaces = (maxWidth - current_line_length) % (len(current_line) - 1)\n                        # loop through the current line\n                        for i in range(len(current_line)):\n                            # if the current word is the last word\n                            if i == len(current_line) - 1:\n                                # add the current word to the current line\n                                current_line[i] += ' ' * extra_spaces\n                            else:\n                                # add the current word to the current line\n                                current_line[i] += ' ' * spaces_to_add\n                                # add the extra space to the current line\n                                current_line[i] += ' '\n                        # add the current line to the result list\n                        result.append(' '.join(current_line))\n                # reset the current line\n                current_line = [word]\n                # reset the current line length\n                current_line_length = len(word)\n        \n        # if the current line is not empty\n        if current_line:\n            # if the number of words in the current line is 1\n            if len(current_line) == 1:\n                # add the current line to the result list\n                result.append(' '.join(current_line) + ' ' * (maxWidth - current_line_length))\n            else:\n                # calculate the number of spaces to add\n                spaces_to_add = (maxWidth - current_line_length) // (len(current_line) - 1)\n                # calculate the number of spaces to distribute\n                extra_spaces = (maxWidth - current_line_length) % (len(current_line) - 1)\n                # loop through the current line\n                for i in range(len(current_line)):\n                    # if the current word is the last word\n                    if i == len(current_line) - 1:\n                        # add the current word to the current line\n                        current_line[i] += ' ' * extra_spaces\n                    else:\n                        # add the current word to the current line\n                        current_line[i] += ' ' * spaces_to_add\n                        # add the extra space to the current line\n                        current_line[i] += ' '\n                # add the current line to the result list\n                result.append(' '.join(current_line))\n        \n        # return the result list\n        return result"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.left)\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        word_set = set(words)\n        res = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                res.append(word)\n                \n        return res\n    \n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and (suffix in word_set or self.dfs(suffix, word_set)):\n                return True\n        return False"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = -num\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num /= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(queens, row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(queens + [col], row + 1, cols + [col], diag1 + [row + col], diag2 + [row - col])\n            return count\n        \n        return backtrack([], 0, [], {}, {})"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                return [''.join(board[i]) for i in range(n)]\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    res = backtrack(board, row + 1)\n                    if res:\n                        return res\n                    board[row][col] = '.'\n            return []\n        \n        board = [['.' for _ in range(n)] for _ in range(n)]\n        return backtrack(board, 0)"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.dfs(board, word, i, j):\n                    return True\n        return False\n    \n    def dfs(self, board, word, i, j):\n        if len(word) == 0:\n            return True\n        \n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n            return False\n        \n        tmp = board[i][j]\n        board[i][j] = '#'\n        res = self.dfs(board, word[1:], i+1, j) or self.dfs(board, word[1:], i-1, j) or self.dfs(board, word[1:], i, j+1) or self.dfs(board, word[1:], i, j-1)\n        board[i][j] = tmp\n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max\n        # 3. if the list has 3 elements, return the 3rd element\n        # 4. if the list has 4 elements, return the 3rd element\n        # 5. if the list has 5 elements, return the 3rd element\n        # 6. if the list has 6 elements, return the 3rd element\n        # 7. if the list has 7 elements, return the 3rd element\n        # 8. if the list has 8 elements, return the 3rd element\n        # 9. if the list has 9 elements, return the 3rd element\n        # 10. if the list has 10 elements, return the 3rd element\n        # 11. if the list has 11 elements, return the 3rd element\n        # 12. if the list has 12 elements, return the 3rd element\n        # 13. if the list has 13 elements, return the 3rd element\n        # 14. if the list has 14 elements, return the 3rd element\n        # 15. if the list has 15 elements, return the 3rd element\n        # 16. if the list has 16 elements, return the 3rd element\n        # 17. if the list has 17 elements, return the 3rd element\n        # 18. if the list has 18 elements, return the 3rd element\n        # 19. if the list has 19 elements, return the 3rd element\n        # 20. if the list has 20 elements, return the 3rd element\n        # 21. if the list has 21 elements, return the 3rd element\n        # 22. if the list has 22 elements, return the 3rd element\n        # 23. if the list has 23 elements, return the 3rd element\n        # 24. if the list has 24 elements, return the 3rd element\n        # 25. if the list has 25 elements, return the 3rd element\n        # 26. if the list has 26 elements, return the 3rd element\n        # 27. if the list has 27 elements, return the 3rd element\n        # 28. if the list has 28 elements, return the 3rd element\n        # 29. if the list has 29 elements, return the 3rd element\n        # 30. if the list has 30 elements, return the 3rd element\n        # 31. if the list has 31 elements, return the 3rd element\n        # 32. if the list has 32 elements, return the 3rd element\n        # 33. if the list has 33 elements, return the 3rd element\n        # 34. if the list has 34 elements, return the 3rd element\n        # 35. if the list has 35 elements, return the 3rd element\n        # 36. if the list has 36 elements, return the 3rd element\n        # 37. if the list has 37 elements, return the 3rd element\n        # 38. if the list has 38 elements, return the 3rd element\n        # 39. if the list has 39 elements, return the 3rd element\n        # 40. if the list has 40 elements, return the 3rd element\n        # 41. if the list has 41 elements, return the 3rd element\n        # 42. if the list has 42 elements, return the 3rd element\n        # 43. if the list has 43 elements, return the 3rd element\n        # 44. if the list has 44 elements, return the 3rd element\n        # 45. if the list has 45 elements, return the 3rd element\n        # 46. if the list has 46 elements, return the 3rd element\n        # 47. if the list has 47 elements, return the 3rd element\n        # 48. if the list has 48 elements, return the 3rd"}]}