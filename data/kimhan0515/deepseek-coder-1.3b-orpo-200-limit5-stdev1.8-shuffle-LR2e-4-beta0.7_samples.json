{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n - 1\n        top, bottom = 0, m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        n, m = len(s), len(t)\n        dp = [0] * (m + 1)\n        dp[0] = 1\n        for i in range(n):\n            for j in range(m, 0, -1):\n                dp[j] += dp[j - 1] if s[i] == t[j - 1] else 0\n        return dp[m]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] < 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            if abs(nums[i]) - 1 < n and nums[abs(nums[i]) - 1] > 0:\n                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1]\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # Calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # Calculate the kth permutation\n        k -= 1\n        ans = \"\"\n        while n > 0:\n            n -= 1\n            fact //= n\n            ans += str(k // fact + 1)\n            k %= fact\n        return ans"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Use two pointers to find the two numbers that add up to the target\n        # If the sum is greater than the target, move the right pointer to the left\n        # If the sum is less than the target, move the left pointer to the right\n        # If the sum is equal to the target, return the two indices\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is, return the indices of the two numbers\n        # If it is not, add the number to the dictionary with the index as the value\n        \n        # Use a dictionary to store the numbers and their indices\n        # Iterate through the numbers and check if the target minus the current number is in the dictionary\n        # If it is"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\""}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, num):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return num * 10 + root.val\n            return dfs(root.left, num * 10 + root.val) + dfs(root.right, num * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in xrange(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        if total_gas < total_cost:\n            return -1\n        \n        cur_gas = 0\n        start = 0\n        for i in range(n):\n            cur_gas += gas[i] - cost[i]\n            if cur_gas < 0:\n                start = i + 1\n                cur_gas = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for l in range(2, n):\n            for i in range(n - l):\n                j = i + l\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        digits[-1] += 1\n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] == 10:\n                digits[i] = 0\n                if i == 0:\n                    digits.insert(0, 1)\n                else:\n                    digits[i-1] += 1\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p.replace(\"*\", \"\"):\n            return not s\n        \n        p_star = p.find(\"*\")\n        s_star = len(s) - 1\n        p_len = len(p)\n        s_len = len(s)\n        \n        while s_star >= 0 and p_star < p_len:\n            if p[p_star + 1] == \"*\":\n                if p[p_star] == s[s_star] or p[p_star] == \".\":\n                    p_star += 2\n                    s_star -= 1\n                else:\n                    p_star += 2\n            else:\n                if p[p_star] == s[s_star] or p[p_star] == \".\":\n                    p_star += 1\n                    s_star -= 1\n                else:\n                    return False\n        \n        if p_star == p_len:\n            return True\n        else:\n            return False"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def find_max_num(nums1, nums2, k):\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if len(nums1) > len(nums2):\n                return find_max_num(nums2, nums1, k)\n            if len(nums1) == 0:\n                return nums2[:k]\n            if k == 0:\n                return []\n            if k == 1:\n                return [max(nums1, nums2)]\n            if nums1[0] > nums2[0]:\n                return nums1\n            if nums1[0] < nums2[0]:\n                return nums2\n            if len(nums1) > k - 1 and len(nums2) > k - 1:\n                return find_max_num(nums1[1:], nums2[1:], k - 1)\n            if len(nums1) > k - 1:\n                return nums1\n            if len(nums2) > k - 1:\n                return nums2\n            return []\n        \n        m, n = len(nums1), len(nums2)\n        if m + n < k:\n            return []\n        if m + n == k:\n            return nums1 + nums2\n        if m > n:\n            return find_max_num(nums1, nums2, k)\n        if m < n:\n            return find_max_num(nums2, nums1, k)\n        return []"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        i = 2\n        while i * i < num:\n            if num % i == 0:\n                sum += i + num // i\n            i += 1\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n + 1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0 for i in range(n)] for j in range(m)]\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(dp[i+1][n-1] - dungeon[i][n-1], 1)\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(dp[m-1][j+1] - dungeon[m-1][j], 1)\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        longest_seq = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                cur_seq = 0\n                while num in nums_set:\n                    cur_seq += 1\n                    num += 1\n                longest_seq = max(longest_seq, cur_seq)\n        \n        return longest_seq"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        sum_n = n * (n + 1) // 2\n        sum_nums = sum(nums)\n        return sum_n - sum_nums"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # Convert the wordList into a set to avoid duplicates\n        wordList = set(wordList)\n        \n        # If endWord is not in wordList, return 0\n        if endWord not in wordList:\n            return 0\n        \n        # Create a queue and add beginWord to it\n        queue = collections.deque([beginWord])\n        \n        # Create a set to keep track of visited words\n        visited = set([beginWord])\n        \n        # Initialize the number of steps to 1\n        steps = 1\n        \n        # While the queue is not empty\n        while queue:\n            # Get the number of words in the queue\n            size = len(queue)\n            \n            # Iterate through the words in the queue\n            for i in range(size):\n                # Get the current word\n                word = queue.popleft()\n                \n                # If the current word is the endWord, return the number of steps\n                if word == endWord:\n                    return steps\n                \n                # Iterate through the words in the wordList\n                for j in range(len(word)):\n                    # Get the current letter\n                    letter = word[j]\n                    \n                    # Iterate through the letters of the alphabet\n                    for letter in string.ascii_lowercase:\n                        # Get the new word\n                        new_word = word[:j] + letter + word[j+1:]\n                        \n                        # If the new word is in the wordList, add it to the queue and the visited set\n                        if new_word in wordList and new_word not in visited:\n                            queue.append(new_word)\n                            visited.add(new_word)\n            \n            # Increment the number of steps by 1\n            steps += 1\n        \n        # Return 0 if the endWord is not in the wordList\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        return bin(a + b)"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return [-1, -1]\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        if nums[left] != target:\n            return [-1, -1]\n        \n        left = left\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2 + 1\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        \n        return [left, right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        k = 0\n        for i in range(len(nums)):\n            if nums[k] != nums[i]:\n                k += 1\n                nums[k] = nums[i]\n        return k + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        jumps = 0\n        max_reach = 0\n        cur_reach = 0\n        \n        for i in range(n):\n            if i > max_reach:\n                jumps += 1\n                max_reach = cur_reach\n            cur_reach = max(cur_reach, i + nums[i])\n            \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) / 2:\n            profit = 0\n            for i in range(1, len(prices)):\n                profit += max(0, prices[i] - prices[i - 1])\n            return profit\n        \n        if k == 0:\n            return 0\n        \n        dp = [0] * (k + 1)\n        for price in prices:\n            for i in range(1, k + 1):\n                dp[i] = max(dp[i], dp[i - 1] + price)\n                dp[i] = max(dp[i], dp[i - 1] - price)\n        return dp[k]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_dict_rev = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_dict_rev.update({10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"})\n        hex_"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in range(len(s)):\n            if s[i] in d:\n                d[s[i]] = -1\n            else:\n                d[s[i]] = i\n        \n        min_index = len(s)\n        for i in d.values():\n            if i != -1 and i < min_index:\n                min_index = i\n        \n        return min_index if min_index < len(s) else -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\""}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # We use two pointers, left and right, to keep track of the boundaries of the zero, one, and two sections of the array. We move the right pointer to the end of the array, and we move the left pointer to the beginning of the array. We swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. If the value at the left pointer is 0, we swap the value at the left pointer with the value at the left pointer, and increment the left pointer by one. If the value at the left pointer is 2, we swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. We repeat this process until the left pointer is less than the right pointer.\n\n        # We use a single pointer, left, to keep track of the boundaries of the zero, one, and two sections of the array. We move the left pointer to the beginning of the array, and we move the right pointer to the end of the array. We swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. If the value at the left pointer is 0, we swap the value at the left pointer with the value at the left pointer, and increment the left pointer by one. If the value at the left pointer is 2, we swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. We repeat this process until the left pointer is less than the right pointer.\n\n        # We use a single pointer, left, to keep track of the boundaries of the zero, one, and two sections of the array. We move the left pointer to the beginning of the array, and we move the right pointer to the end of the array. We swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. If the value at the left pointer is 0, we swap the value at the left pointer with the value at the left pointer, and increment the left pointer by one. If the value at the left pointer is 2, we swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. We repeat this process until the left pointer is less than the right pointer.\n\n        # We use a single pointer, left, to keep track of the boundaries of the zero, one, and two sections of the array. We move the left pointer to the beginning of the array, and we move the right pointer to the end of the array. We swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. If the value at the left pointer is 0, we swap the value at the left pointer with the value at the left pointer, and increment the left pointer by one. If the value at the left pointer is 2, we swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. We repeat this process until the left pointer is less than the right pointer.\n\n        # We use a single pointer, left, to keep track of the boundaries of the zero, one, and two sections of the array. We move the left pointer to the beginning of the array, and we move the right pointer to the end of the array. We swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. If the value at the left pointer is 0, we swap the value at the left pointer with the value at the left pointer, and increment the left pointer by one. If the value at the left pointer is 2, we swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. We repeat this process until the left pointer is less than the right pointer.\n\n        # We use a single pointer, left, to keep track of the boundaries of the zero, one, and two sections of the array. We move the left pointer to the beginning of the array, and we move the right pointer to the end of the array. We swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. If the value at the left pointer is 0, we swap the value at the left pointer with the value at the left pointer, and increment the left pointer by one. If the value at the left pointer is 2, we swap the value at the left pointer with the value at the right pointer, and decrement the right pointer by one. We repeat this process until the left pointer is less than the right pointer.\n\n        # We use a single pointer, left, to keep track of the boundaries of the zero"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return (2**left_height) + self.countNodes(root.right)\n        else:\n            return (2**right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = \"\"\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res += str(carry % 10)\n            carry //= 10\n            i += 1\n        return res[::-1]"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\""}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\""}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        d = {')': '(', ']': '[', '}': '{'}\n        for i in s:\n            if i in d:\n                if stack and stack[-1] == d[i]:\n                    stack.pop()\n                else:\n                    return False\n            else:\n                stack.append(i)\n        return True if not stack else False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while j >= 0 and nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        i += 1\n        j = len(nums) - 1\n        while i < j:\n            nums[i], nums[j] = nums[j], nums[i]\n            i += 1\n            j -= 1"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        d = {}\n        for i, num in enumerate(nums):\n            if num in d and i - d[num] <= k:\n                return True\n            d[num] = i\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n            queue = queue[len(level):]\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row) // 2\n        couples = [(row[i], row[i + 1]) for i in range(0, n * 2, 2)]\n        couples.sort()\n        swaps = 0\n        for i in range(n):\n            if couples[i][0] // 2 != couples[i][1] // 2:\n                swaps += 1\n                couples[i], couples[couples[i][0] // 2] = couples[couples[i][0] // 2], couples[i]\n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        for word in words:\n            if word[0].lower() in row1:\n                if set(word.lower()) <= row1:\n                    ans.append(word)\n            elif word[0].lower() in row2:\n                if set(word.lower()) <= row2:\n                    ans.append(word)\n            else:\n                if set(word.lower()) <= row3:\n                    ans.append(word)\n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next or left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        cur = head\n        i = 1\n        \n        while i < left:\n            prev = cur\n            cur = cur.next\n            i += 1\n        \n        tail = cur\n        while i <= right:\n            temp = cur.next\n            cur.next = prev\n            prev = cur\n            cur = temp\n            i += 1\n        \n        tail.next = cur\n        head = prev\n        \n        return head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can be formed from the end of the string\n        # Add the string to the beginning of the string\n        # Return the string\n        \n        # Find the longest palindrome that can"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 0\n            t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 0\n            s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        found = False\n        \n        while right < len(s):\n            if s[right] in t_dict:\n                if s_dict[s[right]] > t_dict[s[right]]:\n                    s_dict[s[right]] -= 1\n                else:\n                    found = True\n            right += 1\n            \n            if found:\n                if right - left < min_len:\n                    min_len = right - left\n                    min_left = left\n                    min_right = right\n                if s[left] in t_dict:\n                    if s_dict[s[left]] < t_dict[s[left]]:\n                        s_dict[s[left]] += 1\n                    else:\n                        found = False\n                left += 1\n        \n        return s[min_left:min_right]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(distance)\n        if n < 4:\n            return False\n        if distance[0] >= distance[3] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[3] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[3] and distance[1] >= distance[2]:\n            return True\n        if distance[0] <= distance[3] and distance[1] <= distance[2]:\n            return True\n        if distance[0] >= distance[3] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[3] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[3] and distance[1] >= distance[2]:\n            return True\n        if distance[0] <= distance[3] and distance[1] <= distance[2]:\n            return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        d = {}\n        for i in s:\n            if i in d:\n                d[i] += 1\n            else:\n                d[i] = 1\n        \n        ans = 0\n        for i in d.values():\n            ans += i // 2 * 2\n            if ans % 2 == 0 and i % 2 == 1:\n                ans += 1\n        \n        return ans"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        inorder_index = inorder.index(root.val)\n        root.right = self.buildTree(inorder[inorder_index+1:], postorder[inorder_index:-1])\n        root.left = self.buildTree(inorder[:inorder_index], postorder[:inorder_index])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        rows, cols = len(forest), len(forest[0])\n        trees = []\n        for i in range(rows):\n            for j in range(cols):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        ans = 0\n        cur_row, cur_col = 0, 0\n        for height, row, col in trees:\n            dist = self.bfs(forest, cur_row, cur_col, row, col)\n            if dist == -1:\n                return -1\n            ans += dist\n            cur_row, cur_col = row, col\n        return ans\n        \n    def bfs(self, forest, cur_row, cur_col, row, col):\n        rows, cols = len(forest), len(forest[0])\n        queue = [(cur_row, cur_col)]\n        visited = set()\n        visited.add((cur_row, cur_col))\n        steps = 0\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                cur_row, cur_col = queue.pop(0)\n                if cur_row == row and cur_col == col:\n                    return steps\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    new_row, new_col = cur_row + dx, cur_col + dy\n                    if new_row < 0 or new_row >= rows or new_col < 0 or new_col >= cols or (new_row, new_col) in visited or forest[new_row][new_col] == 0:\n                        continue\n                    visited.add((new_row, new_col))\n                    queue.append((new_row, new_col))\n            steps += 1\n        return -1"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # Sum of the array\n        sum_arr = [0]\n        for num in nums:\n            sum_arr.append(sum_arr[-1] + num)\n        \n        # Sort the sum array\n        sum_arr.sort()\n        \n        # Count the number of ranges\n        count = 0\n        for i in range(len(sum_arr)):\n            j = sum_arr.index(lower + upper + sum_arr[i])\n            k = sum_arr.index(lower + upper + sum_arr[i])\n            if j < k:\n                count += k - j\n        \n        return count"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((-1 + sqrt(1 + 8 * n)) / 2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n            queue = queue[len(level):]\n        \n        return result[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        a, b = 1, 1\n        for i in range(1, len(s)):\n            c = a\n            if s[i] == '0':\n                if s[i-1] == '1' or s[i-1] == '2':\n                    c += b\n                else:\n                    return 0\n            if s[i-1] == '1' or (s[i-1] == '2' and s[i] in '123'):\n                c += b\n            b = c\n            a = c\n        return c"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for c in t:\n            if i < len(s) and c == s[i]:\n                i += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        return [i ^ i >> 1 for i in range(2**n)]"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        a = 1\n        b = 2\n        for i in range(3, n + 1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for word in wordDict:\n                if s[i:i + len(word)] == word:\n                    dp[i + len(word)] = dp[i]\n                if dp[i]:\n                    dp[i + len(word)] = True\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if left and node.val <= left.val:\n                return False\n            \n            if right and node.val >= right.val:\n                return False\n            \n            return valid(node.left, left, node) and valid(node.right, node, right)\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        intervals.append(newInterval)\n        intervals.sort()\n        res = []\n        for interval in intervals:\n            if not res or res[-1][1] < interval[0]:\n                res.append(interval)\n            else:\n                res[-1][1] = max(res[-1][1], interval[1])\n        return res"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        res = []\n        n = len(s)\n        dp = [[False for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                dp[i][j] = s[i:j+1] and isPalindrome(s[i:j+1])\n        \n        def backtrack(s, i, res):\n            if i == len(s):\n                res.append([])\n                return\n            for j in range(i, len(s)):\n                if dp[i][j]:\n                    res.append(s[i:j+1])\n                    backtrack(s, j+1, res)\n                    res.pop()\n        \n        backtrack(s, 0, res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\""}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # We know that the number of pigs is the number of buckets minus 1.\n        # We know that the number of pigs is the number of minutesToTest divided by minutesToDie plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie) plus 1.\n        # We know that the number of pigs is the log(buckets, minutesToDie)"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # We need to find the minimum time to reach the bottom right square (n - 1, n - 1)\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the minimum time to reach the bottom right square\n        # We can use a priority queue to find the"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if m or n is 1, return 1\n        if m == 1 or n == 1:\n            return 1\n        \n        # if m or n is 0, return 0\n        if m == 0 or n == 0:\n            return 0\n        \n        # initialize a 2d array with m rows and n columns\n        # the value at grid[i][j] is the number of unique paths from the top left corner to grid[i][j]\n        grid = [[0 for j in range(n)] for i in range(m)]\n        \n        # set the value at grid[0][0] to 1\n        grid[0][0] = 1\n        \n        # iterate through the grid\n        for i in range(m):\n            for j in range(n):\n                # if the value at grid[i][j] is 0, set the value at grid[i][j] to 0\n                if grid[i][j] == 0:\n                    grid[i][j] = 0\n                # if i is 0, set the value at grid[i][j] to the value at grid[i][j - 1]\n                elif i == 0:\n                    grid[i][j] = grid[i][j - 1]\n                # if j is 0, set the value at grid[i][j] to the value at grid[i - 1][j]\n                elif j == 0:\n                    grid[i][j] = grid[i - 1][j]\n                # if i is not 0 and j is not 0, set the value at grid[i][j] to the sum of the values at grid[i - 1][j] and grid[i][j - 1]\n                else:\n                    grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        \n        # return the value at grid[m - 1][n - 1]\n        return grid[m - 1][n - 1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = \"0\"\n        \n        for i in range(len(num1)):\n            carry = 0\n            num2 = num2 + \"0\" * i\n            for j in range(len(num2)):\n                carry += int(num1[i]) * int(num2[j])\n                res = str(carry % 10) + res\n                carry //= 10\n            res = res[:-1]\n        \n        return res"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(prices) < 2:\n            return 0\n        \n        profit = 0\n        min_price = prices[0]\n        for price in prices:\n            if price < min_price:\n                min_price = price\n            else:\n                profit = max(profit, price - min_price)\n        \n        return profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        ans = []\n        def dfs(i, target):\n            if target == 0:\n                ans.append(tuple(sorted(combination)))\n                return\n            for j in xrange(i, len(candidates)):\n                if target < candidates[j]:\n                    break\n                if j > i and candidates[j] == candidates[j-1]:\n                    continue\n                combination.append(candidates[j])\n                dfs(j+1, target - candidates[j])\n                combination.pop()\n        combination = []\n        dfs(0, target)\n        return [list(a) for a in set(ans)]"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(word) == 1:\n            return True\n        if word[0].isupper() and word[1].islower():\n            return True\n        if word[0].islower() and word[1].isupper():\n            return False\n        if word[0].isupper() and word[1:].islower():\n            return True\n        return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr or stack:\n            if curr:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                result.append(curr.val)\n                curr = curr.right\n        \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        inorder_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:inorder_index+1], inorder[:inorder_index])\n        root.right = self.buildTree(preorder[inorder_index+1:], inorder[inorder_index+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\""}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        length = len(lists)\n        interval = 1\n        while interval < length:\n            for i in range(0, length - interval, interval * 2):\n                lists[i] = self.mergeTwoLists(lists[i], lists[i + interval])\n            interval *= 2\n        return lists[0] if length > 0 else None\n        \n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: ListNode\n        :type list2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode()\n        cur = dummy\n        while list1 and list2:\n            if list1.val < list2.val:\n                cur.next = list1\n                list1 = list1.next\n            else:\n                cur.next = list2\n                list2 = list2.next\n            cur = cur.next\n        cur.next = list1 if list1 else list2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [n-i-1 for i in range(n)]\n        for i in range(n):\n            for j in range(i+1):\n                if s[j:i+1] == s[j:i+1][::-1]:\n                    dp[i] = min(dp[i], dp[j-1]+1 if j > 0 else 0)\n        return dp[-1]"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 0 is the number of zeroes at the end of 1, 2, 3, ..., n\n        # 1 is the number of zeroes at the end of 10, 20, 30, ..., n\n        # 2 is the number of zeroes at the end of 100, 200, 300, ..., n\n        # 3 is the number of zeroes at the end of 1000, 2000, 3000, ..., n\n        # 4 is the number of zeroes at the end of 10000, 20000, 30000, ..., n\n        # 5 is the number of zeroes at the end of 100000, 200000, 300000, ..., n\n        # 6 is the number of zeroes at the end of 1000000, 2000000, 3000000, ..., n\n        # 7 is the number of zeroes at the end of 10000000, 20000000, 30000000, ..., n\n        # 8 is the number of zeroes at the end of 100000000, 200000000, 300000000, ..., n\n        # 9 is the number of zeroes at the end of 1000000000, 2000000000, 3000000000, ..., n\n        # 10 is the number of zeroes at the end of 10000000000, 20000000000, 30000000000, ..., n\n        # 11 is the number of zeroes at the end of 100000000000, 200000000000, 300000000000, ..., n\n        # 12 is the number of zeroes at the end of 1000000000000, 2000000000000, 3000000000000, ..., n\n        # 13 is the number of zeroes at the end of 10000000000000, 20000000000000, 30000000000000, ..., n\n        # 14 is the number of zeroes at the end of 100000000000000, 200000000000000, 300000000000000, ..., n\n        # 15 is the number of zeroes at the end of 1000000000000000, 2000000000000000, 3000000000000000, ..., n\n        # 16 is the number of zeroes at the end of 10000000000000000, 20000000000000000, 30000000000000000, ..., n\n        # 17 is the number of zeroes at the end of 100000000000000000, 200000000000000000, 300000000000000000, ..., n\n        # 18 is the number of zeroes at the end of 1000000000000000000, 2000000000000000000, 3000000000000"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        d = {word: i for i, word in enumerate(words)}\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                pre, suf = word[:j], word[j:]\n                if pre in d and suf in d and pre[::-1] == suf:\n                    ans.append([d[pre], d[suf]])\n                if suf in d and len(suf) > 0 and suf[::-1] in d and i != d[suf]:\n                    ans.append([d[suf], d[pre]])\n        return ans"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\""}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        ans = 0\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, self.dfs(matrix, dp, i, j))\n        \n        return ans\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        dp[i][j] = 1\n        \n        if i + 1 < m and matrix[i][j] < matrix[i + 1][j]:\n            dp[i][j] = max(dp[i][j], 1 + self.dfs(matrix, dp, i + 1, j))\n        \n        if i - 1 >= 0 and matrix[i][j] < matrix[i - 1][j]:\n            dp[i][j] = max(dp[i][j], 1 + self.dfs(matrix, dp, i - 1, j))\n        \n        if j + 1 < n and matrix[i][j] < matrix[i][j + 1]:\n            dp[i][j] = max(dp[i][j], 1 + self.dfs(matrix, dp, i, j + 1))\n        \n        if j - 1 >= 0 and matrix[i][j] < matrix[i][j - 1]:\n            dp[i][j] = max(dp[i][j], 1 + self.dfs(matrix, dp, i, j - 1))\n        \n        return dp[i][j]"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        digit = 1\n        res = 0\n        while n // (10 ** digit) > 0:\n            a = n // (10 ** digit)\n            b = n % (10 ** digit)\n            res += a * digit\n            if a * digit + digit >= b:\n                res += b + 1\n            else:\n                res += digit\n            digit *= 10\n        \n        return res"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        dp = [False for i in range(len(s) + 1)]\n        dp[0] = True\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if dp[i] and s[i:j] in wordDict:\n                    dp[j] = True\n        \n        if not dp[-1]:\n            return []\n        \n        ans = []\n        cur = []\n        self.dfs(s, 0, dp, cur, ans, wordDict)\n        return ans\n    \n    def dfs(self, s, start, dp, cur, ans, wordDict):\n        if start == len(s):\n            ans.append(' '.join(cur))\n            return\n        \n        for i in range(start, len(s)):\n            if dp[i + 1]:\n                cur.append(s[start:i + 1])\n                self.dfs(s, i + 1, dp, cur, ans, wordDict)\n                cur.pop()"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        leftToRight = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if not leftToRight:\n                level = level[::-1]\n            result.append(level)\n            leftToRight = not leftToRight\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if turnedOn > 10:\n            return []\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h) + bin(m)).count('1') == turnedOn:\n                    res.append('%d:%02d' % (h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1, 1]]\n        \n        res = [[1], [1, 1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i - 1][j - 1] + res[i - 1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n > 0 and 1162261467 % n == 0"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            self.max_sum = max(self.max_sum, left_gain + right_gain + node.val)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            heapq.heappush(heap, (heightMap[i][0], i, 0))\n            visited.add((i, 0))\n            heapq.heappush(heap, (heightMap[i][n-1], i, n-1))\n            visited.add((i, n-1))\n        for j in range(1, n-1):\n            heapq.heappush(heap, (heightMap[0][j], 0, j))\n            visited.add((0, j))\n            heapq.heappush(heap, (heightMap[m-1][j], m-1, j))\n            visited.add((m-1, j))\n        \n        ans = 0\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            ans += h - heightMap[i][j]\n            for di, dj in dirs:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = ''.join(c for c in s if c.isalnum())\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n\n        # Your Code Here"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next or k == 0:\n            return head\n        \n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        cur = head\n        for i in range(length - k - 1):\n            cur = cur.next\n        \n        new_head = cur.next\n        cur.next = None\n        \n        cur = new_head\n        while cur.next:\n            cur = cur.next\n        \n        cur.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\""}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        ans = float('-inf')\n        for l in range(n):\n            sum_arr = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sum_arr[i] += matrix[i][r]\n                sum_arr = self.max_sum_subarray(sum_arr, k)\n                ans = max(ans, max(sum_arr))\n        return ans\n    \n    def max_sum_subarray(self, arr, k):\n        ans = float('-inf')\n        sum_arr = 0\n        prefix_sum = {0: -1}\n        for i, x in enumerate(arr):\n            sum_arr += x\n            if sum_arr - k in prefix_sum:\n                ans = max(ans, sum_arr - prefix_sum[sum_arr - k])\n            if sum_arr not in prefix_sum:\n                prefix_sum[sum_arr] = i\n            ans = max(ans, sum_arr)\n        return ans"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        if dividend == 2147483647 and divisor == -1:\n            return -2147483647\n        if dividend == 2147483647 and divisor == -2147483648:\n            return 0\n        if dividend == -2147483648 and divisor == -2147483647:\n            return -1\n        if dividend == -2147483648 and divisor == -3:\n            return 0\n        if dividend == 2147483647 and divisor == -2147483647:\n            return 1\n        if dividend == 2147483647 and divisor == -3:\n            return -1\n        if dividend == 2147483647 and divisor == 2147483647:\n            return 1\n        if dividend == 2147483647 and divisor == 3:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 4:\n            return -1\n        if dividend == 2147483647 and divisor == 5:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 6:\n            return -3\n        if dividend == 2147483647 and divisor == 7:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 8:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 9:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 10:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 11:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 12:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 13:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 14:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 15:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 16:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 17:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 18:\n            return -2147483647\n        if dividend == 2147483647 and divisor == 19:\n            return -2147483647\n        if dividend == 2147483647 and"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        m = len(board)\n        n = len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Use a dictionary to store the values and their indices\n        # If the target - nums[i] is in the dictionary, return the index of nums[i] and the index of the value in the dictionary\n        # Otherwise, add nums[i] to the dictionary\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        d = {}\n        for i in range(len(nums)):\n            if nums[i] in d:\n                return [d[nums[i]], i]\n            d[target - nums[i]] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        cards_new = cards[:]\n                        del cards_new[i]\n                        del cards_new[j]\n                        for c in [a + b, a - b, b - a, a * b]:\n                            if c not in cards_new:\n                                cards_new.append(c)\n                                if dfs(cards_new):\n                                    return True\n                            del cards_new[-1]\n            return False\n        \n        return dfs(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p.replace('*', ''):\n            return not s\n        \n        if not s:\n            return not p.replace('*', '')\n        \n        if p[-1] != '*':\n            return False\n        \n        p = p[:-1]\n        p = p.replace('*', '.*')\n        \n        return re.match(p, s) is not None"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        majority_element = nums[0]\n        \n        for num in nums:\n            if count == 0:\n                majority_element = num\n            count += 1 if num == majority_element else -1\n        \n        return majority_element"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for fromi, toi in tickets:\n            if fromi not in graph:\n                graph[fromi] = []\n            graph[fromi].append(toi)\n        \n        # Sort the graph by the keys\n        for fromi in graph:\n            graph[fromi].sort()\n        \n        # Build the itinerary\n        itinerary = []\n        def dfs(fromi):\n            if fromi not in graph:\n                return True\n            toi = graph[fromi].pop()\n            itinerary.append(toi)\n            return dfs(toi)\n        \n        dfs(\"JFK\")\n        return itinerary[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        ans = []\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, n):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = n-1\n                while l < r:\n                    sum_ = nums[i] + nums[j] + nums[l] + nums[r]\n                    if sum_ < target:\n                        l += 1\n                    elif sum_ > target:\n                        r -= 1\n                    else:\n                        ans.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n        return ans"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\""}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(len(triangle)-2,-1,-1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1])\n        return triangle[0][0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        words = {1000000000:\"Billion\", 1000000:\"Crore\", 1000:\"Thousand\", 100:\"Hundred\", 90:\"Ninety\", 80:\"Eighty\", 70:\"Seventy\", 60:\"Sixty\", 50:\"Fifty\", 40:\"Forty\", 30:\"Thirty\", 20:\"Twenty\", 19:\"Nineteen\", 18:\"Eighteen\", 17:\"Seventeen\", 16:\"Sixteen\", 15:\"Fifteen\", 14:\"Fourteen\", 13:\"Thirteen\", 12:\"Twelve\", 11:\"Eleven\", 10:\"Ten\", 9:\"Nine\", 8:\"Eight\", 7:\"Seven\", 6:\"Six\", 5:\"Five\", 4:\"Four\", 3:\"Three\", 2:\"Two\", 1:\"One\"}\n        \n        words_list = []\n        \n        while num:\n            if num % 1000 != 0:\n                words_list.append(self.convert_to_words(num % 1000))\n            num //= 1000\n        \n        return \" \".join(words_list[::-1])\n        \n    def convert_to_words(self, num):\n        if num == 0:\n            return \"\"\n        if num < 20:\n            return words[num]\n        if num < 100:\n            return words[num // 10 * 10] + \" \" + self.convert_to_words(num % 10)\n        if num < 1000:\n            return words[num // 100] + \" \" + self.convert_to_words(num % 100)\n        if num < 1000000:\n            return self.convert_to_words(num // 1000) + \" \" + words[1000] + \" \" + self.convert_to_words(num % 1000)\n        if num < 1000000000:\n            return self.convert_to_words(num // 1000000) + \" \" + words[1000000] + \" \" + self.convert_to_words(num % 1000000)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [0] * (k + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            new_dp = [0] * (k + 1)\n            for j in range(0, k + 1):\n                new_dp[j] = dp[j]\n                if j - i >= 0:\n                    new_dp[j] += dp[j - i]\n                new_dp[j] %= mod\n            dp = new_dp\n        return dp[k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = dummy\n        \n        while cur.next and cur.next.next:\n            first = cur.next\n            second = cur.next.next\n            cur.next = second\n            first.next = second.next\n            second.next = first\n            cur = cur.next.next\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        less = ListNode(0)\n        greater = ListNode(0)\n        less_head = less\n        greater_head = greater\n        \n        while head:\n            if head.val < x:\n                less.next = head\n                less = less.next\n            else:\n                greater.next = head\n                greater = greater.next\n            head = head.next\n        \n        less.next = greater_head.next\n        greater.next = None\n        \n        return less_head.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Find the node with two parents\n        parent = {}\n        for u, v in edges:\n            if v in parent:\n                # If there is a cycle, return the edge that has two parents\n                return [parent[v], v]\n            parent[v] = u\n        \n        # Find the node with one parent\n        parent = {}\n        for u, v in edges:\n            if u in parent:\n                # If there is a cycle, return the edge that has one parent\n                return [parent[u], u]\n            parent[u] = v\n        \n        # Return the edge that has two parents\n        return [parent[v], v]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        ans = []\n        used = [False] * len(nums)\n        self.backtrack(nums, [], used, ans)\n        return ans\n        \n    def backtrack(self, nums, path, used, ans):\n        if len(path) == len(nums):\n            ans.append(path[:])\n            return\n        for i in range(len(nums)):\n            if used[i]:\n                continue\n            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                continue\n            used[i] = True\n            path.append(nums[i])\n            self.backtrack(nums, path, used, ans)\n            used[i] = False\n            path.pop()"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2 * sum(set(nums)) - sum(nums)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.strip().split(' ')[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\""}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        a = 0\n        l = 0\n        p = 0\n        for i in range(n):\n            a, l, p = (a + l + p) % mod, a, l\n            a = a * 2 % mod\n            l = l * 2 % mod\n            p = p * 2 % mod\n        return (a + l + p) % mod"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        seen = set()\n        while n not in seen:\n            seen.add(n)\n            n = sum(int(d)**2 for d in str(n))\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i, num in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + num)\n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j-1]\n                elif j == 0:\n                    grid[i][j] += grid[i-1][j]\n                else:\n                    grid[i][j] += min(grid[i][j-1], grid[i-1][j])\n        \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        res = \"1\"\n        for i in range(1, n):\n            res = self.say(res)\n        return res\n        \n    def say(self, s):\n        res = \"\"\n        count = 1\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and s[i] == s[i + 1]:\n                count += 1\n            else:\n                res += str(count) + s[i]\n                count = 1\n            i += 1\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # We need to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums.\n        # We can use binary search to find the largest sum of any subarray in nums"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < nums[r]:\n                if nums[mid] < target and target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:\n                if nums[l] <= target and target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        result = []\n        for digit in digits:\n            if digit in mapping:\n                if len(result) == 0:\n                    result = mapping[digit]\n                else:\n                    temp = []\n                    for letter in result:\n                        for item in mapping[digit]:\n                            temp.append(letter + item)\n                    result = temp\n        \n        return result"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        ans = []\n        def dfs(i, cur, target):\n            if target == 0:\n                ans.append(cur[:])\n                return\n            for j in xrange(i, len(candidates)):\n                if target - candidates[j] < 0:\n                    break\n                dfs(j, cur + [candidates[j]], target - candidates[j])\n        dfs(0, [], target)\n        return ans"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\""}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n            x = -x\n        else:\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n - j - 1][i]\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n                matrix[j][n - i - 1] = temp"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            cur_max = max_prod\n            max_prod = max(nums[i], min_prod * nums[i], cur_max * nums[i])\n            min_prod = min(nums[i], cur_max * nums[i], min_prod * nums[i])\n            result = max(result, max_prod)\n        \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        # since the last stone is not 0, the last stone must be the last stone in the list\n        # so the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone in the list\n        # the last stone is the last stone"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        score_sorted = sorted(score, reverse=True)\n        score_dict = {}\n        for i in range(len(score_sorted)):\n            score_dict[score_sorted[i]] = i + 1\n        \n        answer = []\n        for i in score:\n            answer.append(str(score_dict[i]))\n            if answer[-1] == \"1\":\n                answer[-1] = \"Gold Medal\"\n            elif answer[-1] == \"2\":\n                answer[-1] = \"Silver Medal\"\n            elif answer[-1] == \"3\":\n                answer[-1] = \"Bronze Medal\"\n        \n        return answer"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 1\n        start = 0\n        end = 0\n        seen = {}\n        \n        while end < len(s):\n            if s[end] in seen:\n                start = max(start, seen[s[end]] + 1)\n            seen[s[end]] = end\n            max_len = max(max_len, end - start + 1)\n            end += 1\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        s_len = len(s)\n        ans = []\n        for i in range(word_len):\n            word_dict_copy = word_dict.copy()\n            j = i\n            while j < s_len:\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                    j += word_len\n                else:\n                    j += word_len\n                    word_dict_copy = word_dict.copy()\n                if not word_dict_copy:\n                    ans.append(i)\n        return ans"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        chunks = 1\n        for i in range(1, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if max_val == i:\n                chunks += 1\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head\n        while cur:\n            if cur.next and cur.next.val < cur.val:\n                prev = dummy\n                while prev.next and prev.next.val < cur.next.val:\n                    prev = prev.next\n                temp = cur.next\n                cur.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                cur = cur.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        cur = head\n        \n        while cur:\n            if cur.next and cur.val == cur.next.val:\n                while cur.next and cur.val == cur.next.val:\n                    cur = cur.next\n                prev.next = cur.next\n            else:\n                prev = cur\n            cur = cur.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        ans = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    ans.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return ans"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = merge(nums, left, mid) + merge(nums, mid + 1, right)\n            i, j = left, mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            temp.extend(nums[i:mid + 1])\n            temp.extend(nums[j:right + 1])\n            nums[left:right + 1] = temp\n            return count\n        \n        return merge(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > sy:\n                tx %= sy\n            else:\n                ty %= sx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        l1 = len(v1)\n        l2 = len(v2)\n        if l1 > l2:\n            v2 += ['0'] * (l1 - l2)\n        else:\n            v1 += ['0'] * (l2 - l1)\n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        profit = 0\n        min_price = float('inf')\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            profit = max(profit, price - min_price)\n        \n        return profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        cur_time = 0\n        cur_courses = 0\n        for duration, last_day in courses:\n            cur_time += duration\n            if cur_time > last_day:\n                cur_time -= duration\n                continue\n            cur_courses += 1\n        return cur_courses"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k <= 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        cur = head\n        count = 0\n        \n        while cur:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, cur.next)\n                cur = prev.next\n            else:\n                cur = cur.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, cur):\n        cur_prev = cur\n        while cur:\n            next_node = cur.next\n            cur.next = prev.next\n            prev.next = cur\n            cur = next_node\n        return cur_prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s + s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        a = 0\n        for i in nums:\n            a = a ^ i\n        return a"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\""}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i][j - 1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j - 1])\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        low = 0\n        high = x\n        while low < high:\n            mid = (low + high) // 2\n            if mid * mid <= x:\n                low = mid\n            else:\n                high = mid - 1\n        return low"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i + 1]]:\n                result += roman_dict[s[i + 1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                result += roman_dict[s[i]]\n                i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        queue = []\n        res = []\n        for i in range(len(nums)):\n            while len(queue) > 0 and queue[-1] < nums[i]:\n                queue.pop()\n            queue.append(nums[i])\n            if i >= k and queue[0] == nums[i - k]:\n                queue.pop(0)\n            if i >= k - 1:\n                res.append(queue[0])\n        return res"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2\n        else:\n            return nums1[len(nums1) // 2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] < nums[r]:\n                r = mid\n            else:\n                l = mid + 1\n        return nums[l]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        row = [1,1]\n        for i in range(2, rowIndex + 1):\n            row = [1] + [row[j] + row[j + 1] for j in range(len(row) - 1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = []\n        def dfs(root, targetSum, path):\n            if not root:\n                return\n            path.append(root.val)\n            if not root.left and not root.right and targetSum == root.val:\n                ans.append(path[:])\n            dfs(root.left, targetSum - root.val, path)\n            dfs(root.right, targetSum - root.val, path)\n            path.pop()\n        \n        dfs(root, targetSum, [])\n        return ans"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        w = int(area ** 0.5)\n        while area % w:\n            w -= 1\n        return [area // w, w]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\""}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            return 1 + max(height(root.left), height(root.right))\n        \n        if not root:\n            return True\n        \n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n > 0 and not (n & n - 1)"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        i = 0\n        while i < len(nums):\n            j = i + 1\n            while j < len(nums) and nums[j] == nums[i]:\n                j += 1\n            k = len(res)\n            while k:\n                res.append(res[k - 1] + [nums[i]])\n                k -= 1\n            i = j\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(heights)\n        if n == 0:\n            return 0\n        \n        left = [0] * n\n        right = [0] * n\n        \n        stack = []\n        for i in range(n):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            if not stack:\n                left[i] = 0\n            else:\n                left[i] = stack[-1] + 1\n            stack.append(i)\n        \n        stack = []\n        for i in range(n - 1, -1, -1):\n            while stack and heights[stack[-1]] >= heights[i]:\n                stack.pop()\n            if not stack:\n                right[i] = n - 1\n            else:\n                right[i] = stack[-1] - 1\n            stack.append(i)\n        \n        ans = 0\n        for i in range(n):\n            ans = max(ans, (right[i] - left[i] + 1) * heights[i])\n        return ans"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i not in [\"+\", \"-\", \"*\", \"/\"]:\n                stack.append(int(i))\n            else:\n                a = stack.pop()\n                b = stack.pop()\n                if i == \"+\":\n                    stack.append(a + b)\n                elif i == \"-\":\n                    stack.append(b - a)\n                elif i == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(b / a))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x, y, a, b in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x), min(y_min, y), max(x_max, a), max(y_max, b)\n            area += (a - x) * (b - y)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if x_min < rectangles[0][0] or x_max > rectangles[-1][2] or y_min < rectangles[0][1] or y_max > rectangles[-1][3]:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = \"\"\n        while columnNumber:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + ord('A')) + ans\n            columnNumber //= 26\n        return ans"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        for num in nums:\n            if cur_sum < 0:\n                cur_sum = 0\n            cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Convert the board into a 1-D array\n        board_str = \"\"\n        for row in board:\n            for num in row:\n                board_str += str(num)\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"0\", \"1\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"5\", \"0\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"1\", \"5\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"2\", \"4\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"3\", \"2\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"4\", \"3\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"6\", \"7\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"7\", \"6\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"8\", \"9\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"9\", \"8\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"0\", \"0\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"1\", \"1\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"2\", \"2\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"3\", \"3\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"4\", \"4\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"5\", \"5\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"6\", \"6\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"7\", \"7\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"8\", \"8\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"9\", \"9\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"0\", \"0\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"1\", \"1\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"2\", \"2\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"3\", \"3\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"4\", \"4\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"5\", \"5\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"6\", \"6\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"7\", \"7\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"8\", \"8\")\n        \n        # Convert the board into a 1-D array\n        board_str = board_str.replace(\"9\", \"9\")\n        \n        # Convert the board into a 1-D array\n        board_str ="}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return True\n            if nums[m] < nums[r]:\n                if nums[m] < target and target <= nums[r]:\n                    l = m + 1\n                else:\n                    r = m - 1\n            else:\n                if nums[l] <= target and target < nums[m]:\n                    r = m - 1\n                else:\n                    l = m + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if m == 1 and n == 1:\n            return 1\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            if obstacleGrid[i][n-1] == 1:\n                break\n            dp[i][n-1] = 1\n        \n        for i in range(n):\n            if obstacleGrid[m-1][i] == 1:\n                break\n            dp[m-1][i] = 1\n        \n        for i in range(m-2,-1,-1):\n            for j in range(n-2,-1,-1):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1]\n        \n        return dp[0][0]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        a, b = 1, 1\n        for i in range(1, len(s)):\n            c = a\n            if s[i] == '0':\n                if s[i-1] == '1' or s[i-1] == '2':\n                    a = b\n                else:\n                    return 0\n            elif s[i-1] == '1' or (s[i-1] == '2' and s[i] in '123'):\n                a += b\n            b = c\n        return a"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        a = inorder(root)\n        return min(a[i+1] - a[i] for i in range(len(a)-1))"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.mode = []\n        self.prev_val = None\n        self.count = 0\n        \n        self.inorder(root)\n        \n        return self.mode\n        \n    def inorder(self, root):\n        if not root:\n            return\n        \n        self.inorder(root.left)\n        \n        if self.prev_val == root.val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        self.prev_val = root.val\n        \n        if self.count == self.max_count:\n            self.mode.append(root.val)\n        elif self.count > self.max_count:\n            self.mode = [root.val]\n            self.max_count = self.count\n        \n        self.inorder(root.right)\n        \n        return"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong.\n        # We have to find the minimum number of steps required to make password strong"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        zero = 0\n        while n > 0:\n            zero += n // 5\n            n //= 5\n        return zero"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [\"\" for i in range(numRows)]\n        row = 0\n        direction = 1\n        \n        for c in s:\n            rows[row] += c\n            row += direction\n            if row == numRows - 1 or row == 0:\n                direction *= -1\n        \n        return \"\".join(rows)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(height)\n        left, right = 0, n - 1\n        left_max, right_max = 0, 0\n        ans = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                left_max = max(left_max, height[left])\n                ans += left_max - height[left]\n                left += 1\n            else:\n                right_max = max(right_max, height[right])\n                ans += right_max - height[right]\n                right -= 1\n        \n        return ans"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        if n == 0:\n            return []\n        nums = [(nums[i], i) for i in range(n)]\n        ans = [0] * n\n        self.build(nums, ans, 0, n)\n        return ans\n        \n    def build(self, nums, ans, l, r):\n        if l + 1 == r:\n            return [nums[l]]\n        m = (l + r) // 2\n        left = self.build(nums, ans, l, m)\n        right = self.build(nums, ans, m, r)\n        i, j, k = 0, 0, l\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                ans[left[i][1]] += j\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            ans[left[i][1]] += j\n            nums[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n        return nums"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\""}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isSymmetric(root.left, root.right)\n        \n    def isSymmetric(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        return left.val == right.val and self.isSymmetric(left.left, right.right) and self.isSymmetric(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\""}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n > 0 and not n & (n - 1) and not n & 0x55555555"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        \n        res = []\n        self.generateParenthesisHelper(n, n, \"\", res)\n        return res\n        \n    def generateParenthesisHelper(self, left, right, cur, res):\n        if left == 0 and right == 0:\n            res.append(cur)\n            return\n        if left > 0:\n            self.generateParenthesisHelper(left - 1, right, cur + \"(\", res)\n        if right > left:\n            self.generateParenthesisHelper(left, right - 1, cur + \")\", res)"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        patch = 0\n        i = 0\n        nums.sort()\n        while i < len(nums) and nums[i] <= n:\n            n += nums[i]\n            i += 1\n        if n < nums[-1]:\n            patch += (n - nums[-1])\n        return patch"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if the string is empty, return 0\n        if not s:\n            return 0\n        \n        # initialize the longest valid parentheses substring length to 0\n        longest_valid_substring_length = 0\n        \n        # initialize the number of opening parentheses to 0\n        number_of_open_parentheses = 0\n        \n        # iterate through the string\n        for i in range(len(s)):\n            \n            # if the current character is a closing parentheses, increment the number of opening parentheses\n            if s[i] == ')':\n                number_of_open_parentheses += 1\n            \n            # if the current character is an opening parentheses, increment the number of opening parentheses\n            else:\n                number_of_open_parentheses += 1\n                \n            # if the number of opening parentheses is greater than the longest valid parentheses substring length, update the longest valid parentheses substring length\n            if number_of_open_parentheses > longest_valid_substring_length:\n                longest_valid_substring_length = number_of_open_parentheses\n            \n            # if the number of opening parentheses is 0, reset the number of opening parentheses to 0\n            if number_of_open_parentheses == 0:\n                number_of_open_parentheses = 0\n        \n        # return the longest valid parentheses substring length\n        return longest_valid_substring_length"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        res = []\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        res.append(str(numerator // denominator))\n        numerator %= denominator\n        \n        if numerator == 0:\n            return \"\".join(res)\n        \n        res.append(\".\")\n        numerator *= 10\n        seen = {}\n        \n        while numerator not in seen:\n            seen[numerator] = len(res)\n            res.append(str(numerator // denominator))\n            numerator %= denominator\n            numerator *= 10\n        \n        res.insert(seen[numerator], \"(\")\n        res.append(\")\")\n        return \"\".join(res)"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        cur = dummy\n        while left and right:\n            if left.val < right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        if left:\n            cur.next = left\n        else:\n            cur.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for envelope in envelopes:\n            left, right = 0, len(dp)\n            while left < right:\n                mid = (left + right) // 2\n                if dp[mid] < envelope[1]:\n                    left = mid + 1\n                else:\n                    right = mid\n            if left == len(dp):\n                dp.append(envelope[1])\n            else:\n                dp[left] = envelope[1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = set()\n        cols = set()\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        \n        for i in rows:\n            for j in range(len(matrix[0])):\n                matrix[i][j] = 0\n        \n        for j in cols:\n            for i in range(len(matrix)):\n                matrix[i][j] = 0\n        \n        return matrix"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n        \n        while n > 0 and right:\n            right = right.next\n            n -= 1\n        \n        while right:\n            left = left.next\n            right = right.next\n        \n        left.next = left.next.next\n        \n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\""}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(m, n, i):\n            res = 0\n            while i // n > 0:\n                res += i // n\n                i = i % n\n            return res\n        \n        i = 1\n        while True:\n            c = count(m, n, i)\n            if c >= k:\n                i *= n\n            else:\n                i += 1\n                k -= c\n        \n        return i"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        maxArea = 0\n        heights = [0] * cols\n        \n        for row in range(rows):\n            for col in range(cols):\n                if matrix[row][col] == '1':\n                    heights[col] += 1\n                else:\n                    heights[col] = 0\n            maxArea = max(maxArea, self.largestRectangleArea(heights))\n        \n        return maxArea\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        maxArea = 0\n        heights.append(0)\n        for i in range(len(heights)):\n            while stack and heights[i] < heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                maxArea = max(maxArea, height * width)\n            stack.append(i)\n        \n        return maxArea"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = [[]]\n        for i in nums:\n            ans += [a + [i] for a in ans]\n        return ans"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] < nums[r]:\n                r = m\n            elif nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r -= 1\n        return nums[l]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n        roman_num = ''\n        for key in roman:\n            roman_num += roman[key] * (num // key)\n            num %= key\n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        return chr(sum(map(ord, s)) - sum(map(ord, t)))"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def solve(board):\n            # Find an empty cell\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        # Try each digit\n                        for d in range(1, 10):\n                            if isValid(board, i, j, str(d)):\n                                # Place digit and continue to next cell\n                                board[i][j] = str(d)\n                                if solve(board):\n                                    return True\n                                # If digit doesn't work, then backtrack\n                                board[i][j] = '.'\n                        return False\n            return True\n        \n        def isValid(board, i, j, d):\n            # Check row\n            for c in range(9):\n                if board[i][c] == d:\n                    return False\n            # Check column\n            for r in range(9):\n                if board[r][j] == d:\n                    return False\n            # Check 3x3 box\n            box_i = i // 3 * 3\n            box_j = j // 3 * 3\n            for r in range(box_i, box_i + 3):\n                for c in range(box_j, box_j + 3):\n                    if board[r][c] == d:\n                        return False\n            return True\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the two nodes that are swapped\n        # Find the first node that is larger than the previous node\n        # Find the second node that is smaller than the previous node\n        # Swap the values of the two nodes\n\n        # Find the"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        if not head:\n            return True\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        slow = slow.next if fast else slow\n        \n        slow = self.reverse(slow)\n        fast = head\n        \n        while slow:\n            if slow.val != fast.val:\n                return False\n            slow = slow.next\n            fast = fast.next\n        \n        return True\n    \n    def reverse(self, head):\n        prev = None\n        while head:\n            next = head.next\n            head.next = prev\n            prev = head\n            head = next\n        return prev"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        i = 1\n        while num > 0:\n            num -= i\n            i += 2\n        return num == 0"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i & (i - 1)] + 1\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return head\n        \n        cur = head\n        while cur.next:\n            if cur.next.val == val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        path = path.split('/')\n        stack = []\n        for p in path:\n            if p == '':\n                continue\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        root = {}\n        for word in words:\n            node = root\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['#'] = word\n        \n        self.result = []\n        self.rows = len(board)\n        self.cols = len(board[0])\n        self.visited = set()\n        \n        for i in range(self.rows):\n            for j in range(self.cols):\n                self.dfs(board, i, j, root)\n        \n        return self.result\n        \n    def dfs(self, board, i, j, node):\n        if '#' in node:\n            self.result.append(node['#'])\n        \n        if i < 0 or i >= self.rows or j < 0 or j >= self.cols:\n            return\n        \n        if (i, j) in self.visited:\n            return\n        \n        self.visited.add((i, j))\n        \n        self.dfs(board, i + 1, j, node.get(board[i][j], {}))\n        self.dfs(board, i - 1, j, node.get(board[i][j], {}))\n        self.dfs(board, i, j + 1, node.get(board[i][j], {}))\n        self.dfs(board, i, j - 1, node.get(board[i][j], {}))\n        \n        self.visited.remove((i, j))"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        rows = [set() for i in range(9)]\n        cols = [set() for i in range(9)]\n        boxes = [set() for i in range(9)]\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    num = int(board[i][j])\n                    box_index = (i // 3) * 3 + j // 3\n                    if num in rows[i] or num in cols[j] or num in boxes[box_index]:\n                        return False\n                    rows[i].add(num)\n                    cols[j].add(num)\n                    boxes[box_index].add(num)\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                answer.append(\"Fizz\")\n            elif i % 5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in columnTitle:\n            ans = ans * 26 + (ord(i) - ord('A') + 1)\n        return ans"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head.next\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        fast = slow.next\n        slow.next = None\n        slow = head\n        fast = self.reverse(fast)\n        \n        while slow and fast:\n            temp = slow.next\n            slow.next = fast\n            slow = slow.next\n            fast = fast.next\n            slow.next = temp\n            slow = slow.next\n        \n        return head\n        \n    def reverse(self, head):\n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        return prev"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] in d:\n                if d[pattern[i]] != s[i]:\n                    return False\n            else:\n                if s[i] in d.values():\n                    return False\n                d[pattern[i]] = s[i]\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        ans = []\n        for i in range(len(nums)):\n            ans.extend([nums[i] + a for a in self.permute(nums[:i] + nums[i+1:])])\n        \n        return ans"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m * n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid // n][mid % n] == target:\n                return True\n            elif matrix[mid // n][mid % n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            carry //= 10\n            curr = curr.next\n        \n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # Convert the integer to binary\n        binary = bin(num)[2:]\n        \n        # Reverse the binary string\n        binary = binary[::-1]\n        \n        # Convert the binary string to a decimal integer\n        decimal = int(binary, 2)\n        \n        # Return the complement of the decimal integer\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        ans = 0\n        diff = nums[1] - nums[0]\n        count = 2\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n                ans += (count - 1) * (count - 2) // 2\n                count = 2\n        \n        ans += (count - 1) * (count - 2) // 2\n        \n        return ans"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\""}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.left)\n                stack.append(node.right)\n        \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        maxArea = 0\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            maxArea = max(area, maxArea)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return maxArea"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=len)\n        d = set(words)\n        ans = []\n        for word in words:\n            if self.dfs(word, d):\n                ans.append(word)\n        return ans\n        \n    def dfs(self, word, d):\n        for i in range(1, len(word)):\n            left, right = word[:i], word[i:]\n            if left in d and (right in d or self.dfs(right, d)):\n                return True\n        return len(word) == 0 or word in d"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        if num == 0:\n            return \"0\"\n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        self.ans = 0\n        self.solve(0, [], n)\n        return self.ans\n        \n    def solve(self, row, cols, n):\n        if row == n:\n            self.ans += 1\n            return\n        \n        for col in range(n):\n            if col not in cols and row + col not in [a + b for a, b in cols]:\n                self.solve(row + 1, cols + [col], n)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isValid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row, col\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row, col\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if isValid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for i in range(n)] for j in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] == word[0]:\n                    if self.dfs(board, word[1:], i, j):\n                        return True\n        \n        return False\n        \n    def dfs(self, board, word, i, j):\n        if not word:\n            return True\n        \n        rows = len(board)\n        cols = len(board[0])\n        \n        if i < 0 or i >= rows or j < 0 or j >= cols or board[i][j] != word[0]:\n            return False\n        \n        temp = board[i][j]\n        board[i][j] = '#'\n        \n        res = self.dfs(board, word[1:], i + 1, j) or self.dfs(board, word[1:], i - 1, j) or self.dfs(board, word[1:], i, j + 1) or self.dfs(board, word[1:], i, j - 1)\n        \n        board[i][j] = temp\n        \n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        a = set()\n        for i in nums:\n            a.add(i)\n            if len(a) > 3:\n                a.remove(min(a))\n        return min(a) if len(a) < 3 else max(a)"}]}