{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n - 1\n        top, bottom = 0, m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n                    \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers as 0\n        # 2. mark all numbers in the range [1, len(nums)] as 1\n        # 3. iterate through the array and mark the corresponding number as -1\n        # 4. iterate through the array again and return the first number that is not -1\n        \n        # 1. mark all negative numbers as 0\n        for i in range(len(nums)):\n            if nums[i] <= 0:\n                nums[i] = float('inf')\n        \n        # 2. mark all numbers in the range [1, len(nums)] as 1\n        for i in range(len(nums)):\n            if abs(nums[i]) <= len(nums):\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\n        \n        # 3. iterate through the array and mark the corresponding number as -1\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i + 1\n        \n        # 4. iterate through the array again and return the first number that is not -1\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        # left, right = 0, len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 4. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 5. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 6. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 7. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 8. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 9. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 10. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 11. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 12. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers[i+1:].index(complement) + i + 2]\n        \n        # 13. Binary search\n        # for i in range(len(numbers)):\n        #     complement = target - numbers[i]\n        #     if complement in numbers[i+1:]:\n        #         return [i+1, numbers"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = curr * 10 + int(num[j])\n                if prev:\n                    backtrack(j + 1, curr, curr, prod, res)\n                backtrack(j + 1, curr, prev + '+' + curr, curr, res)\n                backtrack(j + 1, -curr, prev + '-' + curr, -curr, res)\n                backtrack(j + 1, prod, prev + '*' + curr, prod * curr, res)\n        \n        if not num:\n            return []\n        return backtrack(0, 0, '', 1, [])"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    (first_match and self.isMatch(s[1:], p)))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enumerate(nums):\n                if len(out) < k:\n                    if n > out[-1]:\n                        out.append(n)\n                else:\n                    if n > out[-1] and len(out) < k:\n                        out.append(n)\n                        out.pop()\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while nums1 or nums2:\n                if nums1 > nums2:\n                    out.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    out.append(nums2[0])\n                    nums2 = nums2[1:]\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        return merge(pick(nums1, k), pick(nums2, k - len(nums1)))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[m - 1][n] = 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            cnt = 0\n            j = 0\n            for i in range(len(nums)):\n                while nums[i] - nums[j] > mid:\n                    j += 1\n                cnt += i - j\n            if cnt >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 98.56% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 100.00% of Python online submissions for Missing Number.\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        level = 1\n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    return level\n                for i in range(len(word)):\n                    for neighbor in graph[word[:i] + '*' + word[i+1:]]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            level += 1\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        return bin(a + b)[2:]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_left):\n            left, right = 0, len(nums) - 1\n            idx = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (find_left and nums[mid] == target):\n                    right = mid - 1\n                    idx = mid\n                else:\n                    left = mid + 1\n            return idx\n        \n        left_idx = binary_search(nums, target, True)\n        right_idx = binary_search(nums, target, False)\n        \n        return [left_idx, right_idx]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return len(nums)\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        cur_reach = 0\n        \n        for i in range(1, n):\n            if i > cur_reach:\n                jumps += 1\n                cur_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) / 2:\n            return sum(max(0, prices[i] - prices[i - 1]) for i in range(1, len(prices)))\n        \n        buy = [float('-inf')] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                buy[i] = max(buy[i], sell[i - 1] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n        \n        return sell[-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        \n        hex_str = ''\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first occurence of each character\n        # iterate through the string and update the hashmap and list\n        # return the min value in the list\n        \n        # create a hashmap to store the frequency of each character\n        freq = {}\n        # create a list to store the indices of the first occurence of each character\n        idx = [-1] * 26\n        # iterate through the string and update the hashmap and list\n        for i, c in enumerate(s):\n            if c not in freq:\n                freq[c] = 1\n                idx[ord(c) - ord('a')] = i\n            else:\n                freq[c] += 1\n                idx[ord(c) - ord('a')] = -1\n        # return the min value in the list\n        return min(idx)"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0: red, 1: white, 2: blue\n        red, white, blue = 0, 0, len(nums) - 1\n        \n        while white <= blue:\n            if nums[white] == 0:\n                nums[red], nums[white] = nums[white], nums[red]\n                red += 1\n                white += 1\n            elif nums[white] == 2:\n                nums[blue], nums[white] = nums[white], nums[blue]\n                blue -= 1\n            else:\n                white += 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        curr_count = 0\n        \n        for i in nums:\n            if i == 1:\n                curr_count += 1\n            else:\n                max_count = max(max_count, curr_count)\n                curr_count = 0\n                \n        return max(max_count, curr_count)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to int\n        # 2. add\n        # 3. convert back to str\n        \n        # 1. convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # 2. add\n        sum = num1 + num2\n        \n        # 3. convert back to str\n        return str(sum)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def calculate(s):\n            stack = []\n            num = 0\n            sign = 1\n            for i in range(len(s)):\n                if s[i] == ' ':\n                    continue\n                elif s[i] == '+':\n                    num += sign\n                elif s[i] == '-':\n                    num -= sign\n                elif s[i] == '(':\n                    stack.append(num)\n                    stack.append(sign)\n                    num = 0\n                    sign = 1\n                elif s[i] == ')':\n                    num *= stack.pop()\n                    num += stack.pop()\n                else:\n                    num = num * 10 + int(s[i])\n            return num\n        \n        return calculate(s.replace(' ', ''))"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for each capital, find the max profit\n        # if k > 0, then add the max profit to w\n        # if k == 0, then return w\n        # if k < 0, then return w\n        \n        # sort capital and profits\n        # iterate over capital, and for"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '{':\n                stack.append('}')\n            elif i == '[':\n                stack.append(']')\n            elif stack and stack[-1] == i:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2, -1, -1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1, i, -1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers after the first number\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time: O(n)\n        # Space: O(n)\n        # 1. Create a hashmap\n        # 2. Iterate through the array\n        # 3. If the current element is already in the hashmap, return True\n        # 4. Otherwise, add the element to the hashmap\n        # 5. If the length of the hashmap is greater than k, remove the element at the beginning of the array\n        # 6. Return False\n        \n        hashmap = {}\n        for i in range(len(nums)):\n            if nums[i] in hashmap and i - hashmap[nums[i]] <= k:\n                return True\n            hashmap[nums[i]] = i\n            if len(hashmap) > k:\n                del hashmap[nums[i - k]]\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            level = []\n            for i in range(len(q)):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the number of couples\n        n = len(row) // 2\n        \n        # 2. find the number of swaps\n        swaps = 0\n        \n        # 3. find the number of swaps\n        for i in range(0, n):\n            # 3.1 find the number of swaps\n            if row[2*i] != row[2*i+1] - 1:\n                swaps += 1\n            if row[2*i+1] != row[2*i] + 1:\n                swaps += 1\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. create a dictionary with the first row of the keyboard\n        # 2. iterate through the words and check if the word is in the dictionary\n        # 3. if it is, add it to the list\n        # 4. return the list\n        \n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        \n        res = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                res.append(word)\n                \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right - left):\n            tmp = curr.next\n            curr.next = tmp.next\n            tmp.next = prev.next\n            prev.next = tmp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the reverse of the suffix of the string\n        # that is also a palindrome\n        # if the string is a palindrome, then the longest palindrome is itself"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return t\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        while right < len(s):\n            if s[right] in t_dict:\n                if s_dict[s[right]] > t_dict[s[right]]:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] -= 1\n                    left += 1\n            right += 1\n        \n        while left < len(s):\n            if s[left] in t_dict:\n                if s_dict[s[left]] > t_dict[s[left]]:\n                    s_dict[s[left]] -= 1\n                else:\n                    s_dict[s[left]] -= 1\n                    left += 1\n            else:\n                left += 1\n            \n            if right - left < min_len:\n                min_len = right - left\n                min_left = left\n                min_right = right\n            \n            left += 1\n        \n        return s[min_left:min_right]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] == distance[i - 3] and distance[i - 1] == distance[i - 4]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 6 and distance[i] + distance[i - 5] >= distance[i - 2] and distance[i - 2] == distance[i - 4] and distance[i - 1] == distance[i - 3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of each letter\n        # 2. if the number of each letter is odd, add 1 to the result\n        # 3. if the number of each letter is even, add it to the result\n        # 4. return the result\n        \n        # 1.\n        letter_dict = {}\n        for letter in s:\n            if letter not in letter_dict:\n                letter_dict[letter] = 1\n            else:\n                letter_dict[letter] += 1\n        \n        # 2.\n        result = 0\n        for letter in letter_dict.values():\n            if letter % 2 == 1:\n                result += 1\n        \n        # 3.\n        return result + (1 if result < len(s) else 0)"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                if q:\n                    steps += 1\n                for x, y in q:\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        if 0 <= x + dx < len(forest) and 0 <= y + dy < len(forest[0]) and forest[x + dx][y + dy] > 0:\n                            q.append((x + dx, y + dy))\n                            visited.add((x + dx, y + dy))\n            return -1\n        \n        forest = [[(i, j) for j, i in enumerate(row)] for i, row in enumerate(forest)]\n        forest = sorted([(i, j) for i, row in enumerate(forest) for j, i in enumerate(row) if i > 0])\n        steps = 0\n        for i, j in forest:\n            steps += bfs((i, j), (i, j - 1))\n            steps += bfs((i, j), (i - 1, j))\n            steps += bfs((i, j), (i, j + 1))\n            steps += bfs((i, j), (i + 1, j))\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. calculate the prefix sum\n        # 2. sort the prefix sum\n        # 3. use two pointers to find the range sum\n        # 4. use a hashmap to store the count of range sum\n        # 5. return the count\n        \n        # 1. calculate the prefix sum\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        # 2. sort the prefix sum\n        # 3. use two pointers to find the range sum\n        # 4. use a hashmap to store the count of range sum\n        # 5. return the count\n        prefix_sum.sort()\n        count = 0\n        for i in range(n):\n            count += bisect.bisect_right(prefix_sum, upper) - bisect.bisect_left(prefix_sum, lower + prefix_sum[i])\n        return count"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2 * n + 0.25) ** 0.5 - 0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the last number in the sequence\n        # 2. 2^n - 1 is the last number in the sequence\n        # 3. 2^n - 1 is the last number in the sequence\n        # 4. 2^n - 1 is the last number in the sequence\n        # 5. 2^n - 1 is the last number in the sequence\n        # 6. 2^n - 1 is the last number in the sequence\n        # 7. 2^n - 1 is the last number in the sequence\n        # 8. 2^n - 1 is the last number in the sequence\n        # 9. 2^n - 1 is the last number in the sequence\n        # 10. 2^n - 1 is the last number in the sequence\n        # 11. 2^n - 1 is the last number in the sequence\n        # 12. 2^n - 1 is the last number in the sequence\n        # 13. 2^n - 1 is the last number in the sequence\n        # 14. 2^n - 1 is the last number in the sequence\n        # 15. 2^n - 1 is the last number in the sequence\n        # 16. 2^n - 1 is the last number in the sequence\n        # 17. 2^n - 1 is the last number in the sequence\n        # 18. 2^n - 1 is the last number in the sequence\n        # 19. 2^n - 1 is the last number in the sequence\n        # 20. 2^n - 1 is the last number in the sequence\n        # 21. 2^n - 1 is the last number in the sequence\n        # 22. 2^n - 1 is the last number in the sequence\n        # 23. 2^n - 1 is the last number in the sequence\n        # 24. 2^n - 1 is the last number in the sequence\n        # 25. 2^n - 1 is the last number in the sequence\n        # 26. 2^n - 1 is the last number in the sequence\n        # 27. 2^n - 1 is the last number in the sequence\n        # 28. 2^n - 1 is the last number in the sequence\n        # 29. 2^n - 1 is the last number in the sequence\n        # 30. 2^n - 1 is the last number in the sequence\n        # 31. 2^n - 1 is the last number in the sequence\n        # 32. 2^n - 1 is the last number in the sequence\n        # 33. 2^n - 1 is the last number in the sequence\n        # 34. 2^n - 1 is the last number in the sequence\n        # 35. 2^n - 1 is the last number in the sequence\n        # 36. 2^n - 1 is the last number in the sequence\n        # 37. 2^n - 1 is the last number in the sequence\n        # 38. 2^n - 1 is the last number in the sequence\n        # 39. 2^n - 1 is the last number in the sequence\n        # 40. 2^n - 1 is the last number in the sequence\n        # 41. 2^n - 1 is the last number in the sequence\n        # 42. 2^n - 1 is the last number in the sequence\n        # 43. 2^n - 1 is the last number in the sequence\n        # 44. 2^n - 1 is the last number in the sequence\n        # 45. 2^n - 1 is the last number in the sequence\n        # 46. 2^n - 1 is the last number in the sequence\n        # 47. 2^n - 1 is the last number in the sequence\n        # 48. 2^n - 1 is the last number in the sequence\n        # 49. 2^n - 1 is the last number in the sequence\n        # 5"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a, b = 1, 2\n        for i in range(3, n+1):\n            a, b = b, a+b\n        return b"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (node.val < right and node.val > left):\n                return False\n            return valid(node.left, left, node.val) and valid(node.right, node.val, right)\n        \n        return valid(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element in the list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element in the list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element in the list, merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element in the list, merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [(min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1]))] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <="}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if is_palindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. use min heap to store the max of each list\n        # 3. use max heap to store the min of each list\n        # 4. compare the max of each list with the min of the max heap\n        # 5. if the max of the max heap is greater than the min of the min heap, update the min range\n        # 6. if the max of the max heap is equal to the min of the min heap, update the min range\n        # 7. if the max of the max heap is less than the min of the min heap, pop the min of the min heap\n        # 8. repeat step 4 and 5 until the max of the max heap is greater than the min of the min heap\n        # 9. return the min range\n        \n        import heapq\n        min_range = [float('inf'), float('-inf')]\n        max_heap = []\n        for num in nums:\n            heapq.heappush(max_heap, (num[0], 0, num))\n        min_val = max_heap[0][0]\n        max_val = max_heap[0][0]\n        while True:\n            val, idx, num = heapq.heappop(max_heap)\n            if val > min_val:\n                min_val = val\n            if val == max_val:\n                min_range[0] = min(min_range[0], val)\n                min_range[1] = max(min_range[1], val)\n            if idx + 1 < len(num):\n                heapq.heappush(max_heap, (num[idx + 1], idx + 1, num))\n                max_val = max(max_val, num[idx + 1])\n            else:\n                break\n        return min_range"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000 buckets, 15 minutes, 15 minutes\n        # 2. 1000 buckets, 15 minutes, 30 minutes\n        # 3. 1000 buckets, 15 minutes, 60 minutes\n        # 4. 1000 buckets, 15 minutes, 120 minutes\n        # 5. 1000 buckets, 15 minutes, 240 minutes\n        # 6. 1000 buckets, 15 minutes, 480 minutes\n        # 7. 1000 buckets, 15 minutes, 960 minutes\n        # 8. 1000 buckets, 15 minutes, 1920 minutes\n        # 9. 1000 buckets, 15 minutes, 3840 minutes\n        # 10. 1000 buckets, 15 minutes, 7680 minutes\n        # 11. 1000 buckets, 15 minutes, 15360 minutes\n        # 12. 1000 buckets, 15 minutes, 30720 minutes\n        # 13. 1000 buckets, 15 minutes, 61440 minutes\n        # 14. 1000 buckets, 15 minutes, 122880 minutes\n        # 15. 1000 buckets, 15 minutes, 245760 minutes\n        # 16. 1000 buckets, 15 minutes, 491520 minutes\n        # 17. 1000 buckets, 15 minutes, 983040 minutes\n        # 18. 1000 buckets, 15 minutes, 1966080 minutes\n        # 19. 1000 buckets, 15 minutes, 3932160 minutes\n        # 20. 1000 buckets, 15 minutes, 7864320 minutes\n        # 21. 1000 buckets, 15 minutes, 15728640 minutes\n        # 22. 1000 buckets, 15 minutes, 31457280 minutes\n        # 23. 1000 buckets, 15 minutes, 62914560 minutes\n        # 24. 1000 buckets, 15 minutes, 125829120 minutes\n        # 25. 1000 buckets, 15 minutes, 251658240 minutes\n        # 26. 1000 buckets, 15 minutes, 503316480 minutes\n        # 27. 1000 buckets, 15 minutes, 1006632960 minutes\n        # 28. 1000 buckets, 15 minutes, 2013265920 minutes\n        # 29. 1000 buckets, 15 minutes, 4026531840 minutes\n        # 30. 1000 buckets, 15 minutes, 8053063680 minutes\n        # 31. 1000 buckets, 15 minutes, 16106127360 minutes\n        # 32. 1000 buckets, 15 minutes, 32212254720 minutes\n        # 33. 1000 buckets, 15 minutes, 64424509440 minutes\n        # 34. 1000 buckets, 15 minutes, 128849018880 minutes\n        # 35. 1000 buckets, 15 minutes, 257698037760 minutes\n        # 36. 1000 buckets, 15 minutes, 51539"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set()\n        seen.add((0, 0))\n        ans = 0\n        while heap:\n            t, i, j = heapq.heappop(heap)\n            ans = max(ans, t)\n            if i == j == n - 1:\n                return ans\n            for ni, nj in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    seen.add((ni, nj))\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n        return ans"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        # 5. BFS\n        # 6. DFS\n        # 7. Greedy\n        # 8. Backtracking\n        # 9. Bit Manipulation\n        # 10. Combinatorics\n        # 11. Math\n        # 12. Math\n        # 13. Math\n        # 14. Math\n        # 15. Math\n        # 16. Math\n        # 17. Math\n        # 18. Math\n        # 19. Math\n        # 20. Math\n        # 21. Math\n        # 22. Math\n        # 23. Math\n        # 24. Math\n        # 25. Math\n        # 26. Math\n        # 27. Math\n        # 28. Math\n        # 29. Math\n        # 30. Math\n        # 31. Math\n        # 32. Math\n        # 33. Math\n        # 34. Math\n        # 35. Math\n        # 36. Math\n        # 37. Math\n        # 38. Math\n        # 39. Math\n        # 40. Math\n        # 41. Math\n        # 42. Math\n        # 43. Math\n        # 44. Math\n        # 45. Math\n        # 46. Math\n        # 47. Math\n        # 48. Math\n        # 49. Math\n        # 50. Math\n        # 51. Math\n        # 52. Math\n        # 53. Math\n        # 54. Math\n        # 55. Math\n        # 56. Math\n        # 57. Math\n        # 58. Math\n        # 59. Math\n        # 60. Math\n        # 61. Math\n        # 62. Math\n        # 63. Math\n        # 64. Math\n        # 65. Math\n        # 66. Math\n        # 67. Math\n        # 68. Math\n        # 69. Math\n        # 70. Math\n        # 71. Math\n        # 72. Math\n        # 73. Math\n        # 74. Math\n        # 75. Math\n        # 76. Math\n        # 77. Math\n        # 78. Math\n        # 79. Math\n        # 80. Math\n        # 81. Math\n        # 82. Math\n        # 83. Math\n        # 84. Math\n        # 85. Math\n        # 86. Math\n        # 87. Math\n        # 88. Math\n        # 89. Math\n        # 90. Math\n        # 91. Math\n        # 92. Math\n        # 93. Math\n        # 94. Math\n        # 95. Math\n        # 96. Math\n        # 97. Math\n        # 98. Math\n        # 99. Math\n        # 100. Math\n        # 101. Math\n        # 102. Math\n        # 103. Math\n        # 104. Math\n        # 105. Math\n        # 106. Math\n        # 107. Math\n        # 108. Math\n        # 109. Math\n        # 110. Math\n        # 111. Math\n        # 112. Math\n        # 113. Math\n        # 114. Math\n        # 115. Math\n        # 116. Math\n        # 117. Math\n        # 118. Math\n        # 119. Math\n        # 120. Math\n        # 121. Math\n        # 122. Math\n        # 123. Math\n        # 124."}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = [str(x) for x in res]\n        res = ''.join(res[::-1]).lstrip('0')\n        \n        return res or '0'"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur[:])\n                return\n            if i >= len(candidates) or total > target:\n                return\n            if total + candidates[i] > target:\n                return\n            if i > 0 and candidates[i] == candidates[i-1]:\n                dfs(i+1, cur, total)\n                return\n            dfs(i+1, cur+[candidates[i]], total+candidates[i])\n            dfs(i+1, cur, total)\n        dfs(0, [], 0)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        while root or stack:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                result.append(root.val)\n                root = root.right\n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. find the left and right parentheses\n        # 2. remove the left and right parentheses\n        # 3. find the valid parentheses\n        # 4. add the valid parentheses to the result\n        \n        # 1. find the left and right parentheses\n        left_count = 0\n        right_count = 0\n        for c in s:\n            if c == '(':\n                left_count += 1\n            elif c == ')':\n                if left_count > 0:\n                    left_count -= 1\n                else:\n                    right_count += 1\n        # 2. remove the left and right parentheses\n        left_removed = right_removed = 0\n        for c in s:\n            if c == '(':\n                left_removed += 1\n            elif c == ')':\n                if left_removed > 0:\n                    left_removed -= 1\n                else:\n                    right_removed += 1\n        # 3. find the valid parentheses\n        left_removed = right_removed = 0\n        for c in s:\n            if c == '(':\n                left_removed += 1\n            elif c == ')':\n                if left_removed > 0:\n                    left_removed -= 1\n                else:\n                    right_removed += 1\n                    if right_removed > 0:\n                        right_removed -= 1\n        # 4. add the valid parentheses to the result\n        result = []\n        self.dfs(s, 0, left_removed, right_removed, 0, result)\n        return result\n    \n    def dfs(self, s, start, left_removed, right_removed, depth, result):\n        if left_removed == 0 and right_removed == 0:\n            if s[start:] == s[start:][::-1]:\n                result.append(s[start:])\n            return\n        for i in range(start, len(s)):\n            if i > start and s[i] == s[i - 1]:\n                continue\n            if s[i] == '(' or s[i] == ')':\n                if left_removed > 0 or (s[i] == '(' and left_removed == 0):\n                    self.dfs(s[:i] + s[i + 1:], i, left_removed - 1, right_removed, depth + 1, result)\n                if right_removed > 0 or (s[i] == ')' and right_removed == 0):\n                    self.dfs(s[:i] + s[i + 1:], i, left_removed, right_removed - 1, depth + 1, result)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Merge 2 lists\n        # 2. Merge 3 lists\n        # 3. Merge 4 lists\n        # 4. Merge 5 lists\n        # 5. Merge 6 lists\n        # 6. Merge 7 lists\n        # 7. Merge 8 lists\n        # 8. Merge 9 lists\n        # 9. Merge 10 lists\n        # 10. Merge 11 lists\n        # 11. Merge 12 lists\n        # 12. Merge 13 lists\n        # 13. Merge 14 lists\n        # 14. Merge 15 lists\n        # 15. Merge 16 lists\n        # 16. Merge 17 lists\n        # 17. Merge 18 lists\n        # 18. Merge 19 lists\n        # 19. Merge 20 lists\n        # 20. Merge 21 lists\n        # 21. Merge 22 lists\n        # 22. Merge 23 lists\n        # 23. Merge 24 lists\n        # 24. Merge 25 lists\n        # 25. Merge 26 lists\n        # 26. Merge 27 lists\n        # 27. Merge 28 lists\n        # 28. Merge 29 lists\n        # 29. Merge 30 lists\n        # 30. Merge 31 lists\n        # 31. Merge 32 lists\n        # 32. Merge 33 lists\n        # 33. Merge 34 lists\n        # 34. Merge 35 lists\n        # 35. Merge 36 lists\n        # 36. Merge 37 lists\n        # 37. Merge 38 lists\n        # 38. Merge 39 lists\n        # 39. Merge 40 lists\n        # 40. Merge 41 lists\n        # 41. Merge 42 lists\n        # 42. Merge 43 lists\n        # 43. Merge 44 lists\n        # 44. Merge 45 lists\n        # 45. Merge 46 lists\n        # 46. Merge 47 lists\n        # 47. Merge 48 lists\n        # 48. Merge 49 lists\n        # 49. Merge 50 lists\n        # 50. Merge 51 lists\n        # 51. Merge 52 lists\n        # 52. Merge 53 lists\n        # 53. Merge 54 lists\n        # 54. Merge 55 lists\n        # 55. Merge 56 lists\n        # 56. Merge 57 lists\n        # 57. Merge 58 lists\n        # 58. Merge 59 lists\n        # 59. Merge 60 lists\n        # 60. Merge 61 lists\n        # 61. Merge 62 lists\n        # 62. Merge 63 lists\n        # 63. Merge 64 lists\n        # 64. Merge 65 lists\n        # 65. Merge 66 lists\n        # 66. Merge 67 lists\n        # 67. Merge 68 lists\n        # 68. Merge 69 lists\n        # 69. Merge 70 lists\n        # 70. Merge 71 lists\n        # 71. Merge 72 lists\n        # 72. Merge 73 lists\n        # 73. Merge 74 lists\n        # 74. Merge 75 lists\n        # 75. Merge 76 lists\n        # 76. Merge 77 lists\n        # 77. Merge 78 lists\n        # 78. Merge 79 lists\n        # 79. Merge 80 lists\n        # 80. Merge 81 lists"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the number of 5's in the factorial of k\n        # 2. find the number of 5's in the factorial of k+1\n        # 3. subtract the number of 5's in the factorial of k from the number of 5's in the factorial of k+1\n        # 4. return the result\n        \n        # 1. find the number of 5's in the factorial of k\n        count = 0\n        i = 5\n        while k >= i:\n            count += k//i\n            i *= 5\n        return count"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a hashmap for words\n        word_map = {word: i for i, word in enumerate(words)}\n        \n        # build a hashmap for reversed words\n        reverse_map = {v: k for k, v in word_map.items()}\n        \n        # build a hashmap for palindrome pairs\n        res = []\n        \n        # iterate over words\n        for i, word in enumerate(words):\n            # reverse the word\n            rev = word[::-1]\n            \n            # check if the reversed word is in the hashmap\n            if rev in reverse_map:\n                # check if the reversed word is itself\n                if rev == word:\n                    # skip if the word is itself\n                    if i == 0:\n                        continue\n                    else:\n                        res.append([i, reverse_map[rev]])\n                else:\n                    res.append([i, reverse_map[rev]])\n            \n            # check if the reversed word is in the hashmap\n            if word in reverse_map:\n                # check if the reversed word is itself\n                if rev == word:\n                    # skip if the word is itself\n                    if i == 0:\n                        continue\n                    else:\n                        res.append([reverse_map[rev], i])\n                else:\n                    res.append([reverse_map[rev], i])\n        \n        return res"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    return res\n                res += 1\n                for i, j in infected:\n                    for x, y in [(i, j), (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                        if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 0:\n                            isInfected[x][y] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 2:\n                            isInfected[i][j] = 1\n        return len(isInfected) * len(isInfected[0]) - spread(isInfected) - spread(list(zip(*isInfected)))"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                res = max(res, self.dfs(matrix, dp, i, j))\n        \n        return res\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], self.dfs(matrix, dp, x, y))\n        \n        return dp[i][j] + 1"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n                    break\n        \n        # build the result list from the dp array\n        res = []\n        if dp[-1]:\n            start = 0\n            for i in range(len(s) + 1):\n                if dp[i]:\n                    res.append(s[start:i])\n                    start = i\n            return res\n        else:\n            return []"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_result = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_result.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                level_result.reverse()\n            result.append(level_result)\n            level += 1\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def gen_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return '%d:%02d' % (h, m)\n        \n        def gen_hour(h):\n            return gen_time(h, 0)\n        \n        def gen_minute(m):\n            return gen_time(0, m)\n        \n        def gen_all_hour(h):\n            return [gen_hour(h) for h in range(12)]\n        \n        def gen_all_minute(m):\n            return [gen_minute(m) for m in range(60)]\n        \n        def gen_all_comb(h, m):\n            return [h + m for h in gen_all_hour(h) for m in gen_all_minute(m)]\n        \n        return [gen_time(h, m) for h in range(12) for m in range(60) if (h * 60 + m) in gen_all_comb(turnedOn)]"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        for i in range(2, numRows):\n            tmp = [1]\n            for j in range(1, len(res[-1])):\n                tmp.append(res[-1][j] + res[-1][j-1])\n            tmp.append(1)\n            res.append(tmp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n /= 3\n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            node.val = max(node.val, node.val + left_gain, node.val + right_gain)\n            \n            return node.val\n        \n        max_gain(root)\n        return root.val"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            if (i, j) not in seen:\n                ans += h\n                seen.add((i, j))\n                for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                        heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the median\n        # 3. return the median\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. find the median\n        if len(nums) % 2 == 1:\n            return float(nums[len(nums) // 2])\n        else:\n            return (nums[len(nums) // 2] + nums[len(nums) // 2 - 1]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k % length - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = new_head\n        while new_tail.next:\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = head\n        \n        # cut the old list off\n        new_head = new_head.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        while n % 3 == 0:\n            n /= 3\n        while n % 5 == 0:\n            n /= 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                sums.sort()\n                s = sums[0]\n                for i in range(m):\n                    while sums[i] - s > k:\n                        s += sums[i]\n                        sums[i] -= sums[i - m]\n                    res = max(res, s)\n                    if res == k:\n                        return k\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 2147483647:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483648:"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # iterate through the list\n        # if the difference is in the dictionary, return the index of the difference and the index of the current number\n        # else, add the current number to the dictionary\n        # if the difference is not in the dictionary, add the current number to the dictionary\n        # return the index of the difference and the index of the current number\n        \n        # create a dictionary\n        d = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            \n            # if the difference is in the dictionary, return the index of the difference and the index of the current number\n            if target - num in d:\n                return [d[target - num], i]\n            \n            # else, add the current number to the dictionary\n            d[num] = i\n            \n        # return the index of the difference and the index of the current number\n        return None"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                nxt = cards[i] + cards[j]\n                            elif op == '-':\n                                nxt = cards[i] - cards[j]\n                            elif op == '*':\n                                nxt = cards[i] * cards[j]\n                            elif op == '/':\n                                if cards[j] == 0:\n                                    continue\n                                nxt = float(cards[i]) / cards[j]\n                            if nxt not in cards[:i] + cards[i + 1:j] + cards[j + 1:]:\n                                return abs(nxt - 24) < 1e-6\n            return False\n        \n        return dfs(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p.replace('*', ''):\n            return not s\n        \n        star = p.find('*')\n        if star == -1:\n            return False\n        \n        i = 0\n        for c in p:\n            if c == '*':\n                if i < len(s):\n                    if not self.isMatch(s[i:], p[star+1:]):\n                        return False\n                else:\n                    return self.isMatch(s, p[star+1:])\n            else:\n                if i < len(s) and s[i] == c:\n                    i += 1\n                else:\n                    return False\n        return True"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://leetcode.com/problems/majority-element/discuss/144518/Python-O(n)-time-O(1)-space-with-explanation\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in sorted(tickets):\n            graph[from_city].append(to_city)\n            \n        # dfs\n        res = []\n        def dfs(from_city):\n            # if there is no more city to visit, add to the result\n            if len(graph[from_city]) == 0:\n                res.append(from_city)\n                return True\n            # if there is no more city to visit, return False\n            for i in range(len(graph[from_city])):\n                # remove the edge\n                to_city = graph[from_city].pop(i)\n                # dfs\n                if dfs(to_city):\n                    return True\n                # add the edge back\n                graph[from_city].insert(i, to_city)\n            # if there is no more city to visit, return False\n            return False\n        \n        # dfs from JFK\n        dfs(\"JFK\")\n        # reverse the result\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = [[0, 0]]\n        \n        # initialize the current height\n        curr_height = 0\n        \n        # iterate over the buildings\n        for l, r, h in buildings:\n            # if the current building is the last one\n            if l > result[-1][1]:\n                # add the current building to the result\n                result.append([r, h])\n            # if the current building is not the last one\n            else:\n                # update the current height\n                curr_height = max(curr_height, h)\n                # if the current building is taller than the last one\n                if h > result[-1][1]:\n                    # update the last one\n                    result[-1][1] = h\n                # if the current building is shorter than the last one\n                elif h < result[-1][1]:\n                    # update the last one\n                    result[-1][1] = h\n                    # if the current building is taller than the last one\n                    if h > curr_height:\n                        # update the current height\n                        curr_height = h\n                        # add the current building to the result\n                        result.append([r, h])\n        \n        # return the result\n        return result[1:]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the reversed string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        num_str = str(num)\n        num_len = len(num_str)\n        num_dict = {\n            \"1\": \"One\",\n            \"2\": \"Two\",\n            \"3\": \"Three\",\n            \"4\": \"Four\",\n            \"5\": \"Five\",\n            \"6\": \"Six\",\n            \"7\": \"Seven\",\n            \"8\": \"Eight\",\n            \"9\": \"Nine\",\n            \"10\": \"Ten\",\n            \"11\": \"Eleven\",\n            \"12\": \"Twelve\",\n            \"13\": \"Thirteen\",\n            \"14\": \"Fourteen\",\n            \"15\": \"Fifteen\",\n            \"16\": \"Sixteen\",\n            \"17\": \"Seventeen\",\n            \"18\": \"Eighteen\",\n            \"19\": \"Nineteen\",\n            \"20\": \"Twenty\",\n            \"30\": \"Thirty\",\n            \"40\": \"Forty\",\n            \"50\": \"Fifty\",\n            \"60\": \"Sixty\",\n            \"70\": \"Seventy\",\n            \"80\": \"Eighty\",\n            \"90\": \"Ninety\",\n        }\n        \n        if num_len == 1:\n            return num_dict[num_str]\n        \n        if num_len == 2:\n            if num_str[1] == \"0\":\n                return num_dict[num_str[0]]\n            else:\n                return num_dict[num_str[0] + \"0\"] + \" \" + num_dict[num_str[1]]\n        \n        if num_len == 3:\n            if num_str[1] == \"0\" and num_str[2] == \"0\":\n                return num_dict[num_str[0]] + \" Hundred\"\n            elif num_str[1] == \"0\":\n                return num_dict[num_str[0]] + \" Hundred \" + num_dict[num_str[2]]\n            elif num_str[2] == \"0\":\n                return num_dict[num_str[0]] + \" Hundred \" + num_dict[num_str[1]]\n            else:\n                return num_dict[num_str[0]] + \" Hundred \" + num_dict[num_str[1] + \"0\"] + \" \" + num_dict[num_str[2]]\n        \n        if num_len == 4:\n            if num_str[1] == \"0\" and num_str[2] == \"0\" and num_str[3] == \"0\":\n                return num_dict[num_str[0]] + \" Thousand\"\n            elif num_str[1] == \"0\" and num_str[2] == \"0\":\n                return num_dict[num_str[0]] + \" Thousand \" + num_dict[num_str[3]]\n            elif num_str[2] == \"0\" and num_str[3] == \"0\":\n                return num_dict[num_str[0]] + \" Thousand \" + num_dict[num_str[1]]\n            else:\n                return num_dict[num_str[0]] + \" Thousand \" + num_dict[num_str[1] + \"0\"] + \" \" + num_dict[num_str[2]] + \" \" + num_dict[num_str[3]]\n        \n        if num_len == 5:\n            if num_str[1] == \"0\" and num_str[2] == \"0\" and num_str[3] == \"0\" and num_str[4] == \"0\":\n                return num_dict[num_str[0]] + \" Million\"\n            elif num_str[1] == \"0\" and num_str[2] == \"0\" and num_str[3] == \"0\":\n                return num_dict[num_str[0]] + \" Million \" + num_dict[num_str[4]]\n            elif num_str[2] == \"0\" and num_str[3] == \"0\" and num_str[4] == \"0\":\n                return num_dict[num_str[0]] + \" Million \" + num_"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-k-1]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-k] + dp[i-1][j-k] + dp[i-1][j-k] + dp[i"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent = {}\n        child = {}\n        for u, v in edges:\n            if u in parent:\n                if v in child:\n                    return [parent[u], v]\n                else:\n                    child[u] = v\n            else:\n                parent[u] = v\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u in parent:\n                if v in child:\n                    continue\n                else:\n                    child[u] = v\n            else:\n                parent[u] = v\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u in parent:\n                if v in child:\n                    return [parent[u], v]\n                else:\n                    child[u] = v\n            else:\n                parent[u] = v\n        \n        return [parent[u], v]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2*sum(set(nums))-sum(nums)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(max(i - 1, 0), min(i + 1, n - 1) + 1):\n                dp[i][j] = dp[i - 1][j - 1] + grid[i][j]\n                if j > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + grid[i][j])\n                if j < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n        return max(dp[-1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # return the index of the target if it exists, otherwise return the index where it would be inserted\n        # if the target is smaller than the first element, return 0\n        # if the target is larger than the last element, return len(nums)\n        # otherwise, use binary search to find the index of the target\n        \n        if target < nums[0]:\n            return 0\n        if target > nums[-1]:\n            return len(nums)\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,m):\n            grid[i][0] += grid[i-1][0]\n        \n        for j in range(1,n):\n            grid[0][j] += grid[0][j-1]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] += min(grid[i-1][j],grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '11131221133112132132221'\n        \n        if n == 12:\n            return '3113112221232132211311121312211'\n        \n        if n == 13:\n            return '13211311123113112211231131221131211'\n        \n        if n == 14:\n            return '111312211331121321322212311312211213211'\n        \n        if n == 15:\n            return '31131122212321322113111213122112311312211213211322211'\n        \n        if n == 16:\n            return '1321131112311311221123113122112132113222112311312211213211322212321131211'\n        \n        if n == 17:\n            return '1113122113311213213222123113122112132113222112311312211213211322212321131211232211'\n        \n        if n == 18:\n            return '311311222123213221131112131221123113122112132113222112311312211213211322212321131211232211213211'\n        \n        if n == 19:\n            return '13211311123113112211231131221121321132221123113122112132113222123211312112322112132113222123211312112322112311312211'\n        \n        if n == 20:\n            return '11131221133112132132221231131221121321132221123113122112132113222123211312112322112132113222123211312112322112311312"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, m):\n            cnt = 1\n            curr = 0\n            for n in nums:\n                if curr + n > m:\n                    cnt += 1\n                    curr = n\n                else:\n                    curr += n\n            return cnt <= k\n        \n        lo, hi = max(nums), sum(nums)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if check(nums, k, mid):\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        pivot = l\n        \n        # find the target\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[(m + pivot) % len(nums)] < target:\n                l = m + 1\n            elif nums[(m + pivot) % len(nums)] > target:\n                r = m - 1\n            else:\n                return (m + pivot) % len(nums)\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}\n        res = ['']\n        for d in digits:\n            res = [x+y for x in res for y in phone[d]]\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur[:])\n                return\n            if i >= len(candidates) or total > target:\n                return\n            dfs(i, cur, total + candidates[i])\n            cur.append(candidates[i])\n            dfs(i, cur, total)\n            cur.pop()\n        dfs(0, [], 0)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the number of digits\n        # 2. get the number of digits\n        # 3. get the number of digits\n        # 4. get the number of digits\n        # 5. get the number of digits\n        # 6. get the number of digits\n        # 7. get the number of digits\n        # 8. get the number of digits\n        # 9. get the number of digits\n        # 10. get the number of digits\n        # 11. get the number of digits\n        # 12. get the number of digits\n        # 13. get the number of digits\n        # 14. get the number of digits\n        # 15. get the number of digits\n        # 16. get the number of digits\n        # 17. get the number of digits\n        # 18. get the number of digits\n        # 19. get the number of digits\n        # 20. get the number of digits\n        # 21. get the number of digits\n        # 22. get the number of digits\n        # 23. get the number of digits\n        # 24. get the number of digits\n        # 25. get the number of digits\n        # 26. get the number of digits\n        # 27. get the number of digits\n        # 28. get the number of digits\n        # 29. get the number of digits\n        # 30. get the number of digits\n        # 31. get the number of digits\n        # 32. get the number of digits\n        # 33. get the number of digits\n        # 34. get the number of digits\n        # 35. get the number of digits\n        # 36. get the number of digits\n        # 37. get the number of digits\n        # 38. get the number of digits\n        # 39. get the number of digits\n        # 40. get the number of digits\n        # 41. get the number of digits\n        # 42. get the number of digits\n        # 43. get the number of digits\n        # 44. get the number of digits\n        # 45. get the number of digits\n        # 46. get the number of digits\n        # 47. get the number of digits\n        # 48. get the number of digits\n        # 49. get the number of digits\n        # 50. get the number of digits\n        # 51. get the number of digits\n        # 52. get the number of digits\n        # 53. get the number of digits\n        # 54. get the number of digits\n        # 55. get the number of digits\n        # 56. get the number of digits\n        # 57. get the number of digits\n        # 58. get the number of digits\n        # 59. get the number of digits\n        # 60. get the number of digits\n        # 61. get the number of digits\n        # 62. get the number of digits\n        # 63. get the number of digits\n        # 64. get the number of digits\n        # 65. get the number of digits\n        # 66. get the number of digits\n        # 67. get the number of digits\n        # 68. get the number of digits\n        # 69. get the number of digits\n        # 70. get the number of digits\n        # 71. get the number of digits\n        # 72. get the number of digits\n        # 73. get the number of digits\n        # 74. get the number of digits\n        # 75. get the number of digits\n        # 76. get the number of digits\n        # 77. get the number of digits\n        # 78. get the number of digits\n        # 79. get the number of digits\n        # 80."}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n            \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n            \n        if rev > 2**31:\n            return 0\n        else:\n            return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n//2):\n            for j in range(i, n-i-1):\n                matrix[i][j], matrix[j][n-i-1], matrix[n-i-1][n-j-1], matrix[n-j-1][i] = matrix[n-j-1][i], matrix[i][j], matrix[j][n-i-1], matrix[n-i-1][n-j-1]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum product and the current maximum product\n        max_product = nums[0]\n        curr_max_product = nums[0]\n        \n        # Iterate through the array from the second element to the end\n        for i in range(1, len(nums)):\n            # If the current element is positive, update the current maximum product\n            if nums[i] > 0:\n                curr_max_product = max(nums[i], curr_max_product * nums[i])\n            # If the current element is negative, update the maximum product\n            else:\n                curr_max_product = max(nums[i], curr_max_product * nums[i])\n                # If the current maximum product is less than the current maximum product, update the maximum product\n                if curr_max_product < max_product:\n                    max_product = curr_max_product\n                # If the current maximum product is equal to the current maximum product, update the maximum product\n                elif curr_max_product == max_product:\n                    max_product = max(max_product, curr_max_product)\n                # If the current maximum product is greater than the current maximum product, update the maximum product\n                else:\n                    max_product = curr_max_product\n        \n        return max_product"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dict to map the score to the rank\n        score_rank = {}\n        for i, s in encompress(score_sorted):\n            score_rank[s] = i\n        \n        # map the score to the rank\n        return [score_rank[s] for s in score]"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            right = i\n            word_count_copy = word_dict.copy()\n            while right + word_len <= len(s):\n                word = s[right:right + word_len]\n                if word in word_dict:\n                    word_count_copy[word] -= 1\n                    if word_count_copy[word] >= 0:\n                        word_count -= 1\n                right += word_len\n                if word_count == 0:\n                    res.append(left)\n                    word_count_copy[s[left:left + word_len]] += 1\n                    if word_dict[s[left:left + word_len]] > 0:\n                        word_count += 1\n                left += word_len\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the max element in the array\n        # 3. find the max element in the sorted array\n        # 4. if the max element in the sorted array is equal to the max element in the array, then we have found the max chunk\n        # 5. else, we have to split the array into two chunks\n        \n        # 1. sort the array\n        arr.sort()\n        \n        # 2. find the max element in the array\n        max_element = arr[-1]\n        \n        # 3. find the max element in the sorted array\n        max_element_in_sorted_array = 0\n        for i in range(len(arr)):\n            if arr[i] > max_element_in_sorted_array:\n                max_element_in_sorted_array = arr[i]\n            if max_element_in_sorted_array == max_element:\n                return len(arr)\n        \n        return 1"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head\n        while cur:\n            if cur.next and cur.val > cur.next.val:\n                prev = dummy\n                while prev.next.val < cur.next.val:\n                    prev = prev.next\n                cur.next, prev.next, cur.next.next = cur.next.next, cur.next, prev.next.next\n            else:\n                cur = cur.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            while i <= mid:\n                while j <= right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n                i += 1\n            nums[left:right + 1] = sorted(nums[left:right + 1])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            return mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right) + merge(nums, left, mid, right)\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if i < len(v2):\n                    if v1[i] < v2[i]:\n                        return -1\n                    elif v1[i] > v2[i]:\n                        return 1\n                else:\n                    return 1\n            else:\n                if i < len(v2):\n                    return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for duration, end in courses:\n            # add course to priority queue\n            heapq.heappush(pq, -duration)\n            \n            # add course to total time\n            total += duration\n            \n            # if total time exceeds end date\n            if total > end:\n                # remove course from priority queue\n                total += heapq.heappop(pq)\n                \n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while True:\n            kth = prev\n            for i in range(k):\n                if not kth:\n                    break\n                kth = kth.next\n            if not kth:\n                break\n            start = prev.next\n            end = kth.next\n            for i in range(k-1):\n                tmp = start.next\n                start.next = end.next\n                end.next = end.next.next\n                start.next.next = tmp\n            prev.next = kth\n            prev = start\n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s+s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a dict to store the count of each number\n        # 2. iterate through the dict and return the number with count = 1\n        # 3. use bitwise XOR to find the number with count = 1\n        # 4. use bitwise XOR to find the number with count = 2\n        # 5. use bitwise XOR to find the number with count = 3\n        # 6. use bitwise XOR to find the number with count = 4\n        # 7. use bitwise XOR to find the number with count = 5\n        # 8. use bitwise XOR to find the number with count = 6\n        # 9. use bitwise XOR to find the number with count = 7\n        # 10. use bitwise XOR to find the number with count = 8\n        # 11. use bitwise XOR to find the number with count = 9\n        # 12. use bitwise XOR to find the number with count = 10\n        # 13. use bitwise XOR to find the number with count = 11\n        # 14. use bitwise XOR to find the number with count = 12\n        # 15. use bitwise XOR to find the number with count = 13\n        # 16. use bitwise XOR to find the number with count = 14\n        # 17. use bitwise XOR to find the number with count = 15\n        # 18. use bitwise XOR to find the number with count = 16\n        # 19. use bitwise XOR to find the number with count = 17\n        # 20. use bitwise XOR to find the number with count = 18\n        # 21. use bitwise XOR to find the number with count = 19\n        # 22. use bitwise XOR to find the number with count = 20\n        # 23. use bitwise XOR to find the number with count = 21\n        # 24. use bitwise XOR to find the number with count = 22\n        # 25. use bitwise XOR to find the number with count = 23\n        # 26. use bitwise XOR to find the number with count = 24\n        # 27. use bitwise XOR to find the number with count = 25\n        # 28. use bitwise XOR to find the number with count = 26\n        # 29. use bitwise XOR to find the number with count = 27\n        # 30. use bitwise XOR to find the number with count = 28\n        # 31. use bitwise XOR to find the number with count = 29\n        # 32. use bitwise XOR to find the number with count = 30\n        # 33. use bitwise XOR to find the number with count = 31\n        # 34. use bitwise XOR to find the number with count = 32\n        # 35. use bitwise XOR to find the number with count = 33\n        # 36. use bitwise XOR to find the number with count = 34\n        # 37. use bitwise XOR to find the number with count = 35\n        # 38. use bitwise XOR to find the number with count = 36\n        # 39. use bitwise XOR to find the number with count = 37\n        # 40. use bitwise XOR to find the number with count = 38\n        # 41. use bitwise XOR to find the number with count = 39\n        # 42. use bitwise XOR to find the number with count = 40\n        # 43. use bitwise XOR to find the number with count = 41\n        # 44. use bitwise XOR to find the number with count = 42\n        # 45. use bitwise XOR to find the number with count = 43\n        # 46. use bitwise XOR to find the number with count = 44\n        # 47. use bitwise XOR to find the number with count = 45\n        # 48. use bitwise XOR to find the number with count = 46\n        # 49. use bitwise XOR to find the number with count = 47\n        # 50. use bitwise XOR to find the number with count ="}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict for each sticker\n        # 2. build a dict for each letter in target\n        # 3. for each letter in target, check if it can be made by stickers\n        # 4. if it can, add 1 to the count\n        # 5. if it can't, check if it can be made by stickers with one less sticker\n        # 6. if it can't, return -1\n        \n        # build a dict for each sticker\n        sticker_dict = {}\n        for sticker in stickers:\n            sticker_dict[sticker] = set()\n            for letter in sticker:\n                sticker_dict[sticker].add(letter)\n        \n        # build a dict for each letter in target\n        target_dict = {}\n        for letter in target:\n            target_dict[letter] = 0\n        \n        # for each letter in target, check if it can be made by stickers\n        for letter in target_dict:\n            if letter not in sticker_dict:\n                return -1\n            else:\n                for sticker in sticker_dict[letter]:\n                    target_dict[sticker] += 1\n        \n        # if it can't, check if it can be made by stickers with one less sticker\n        for sticker in sticker_dict:\n            if sticker not in target_dict:\n                continue\n            else:\n                for letter in sticker_dict[sticker]:\n                    if target_dict[letter] == 0:\n                        return -1\n                    else:\n                        target_dict[letter] -= 1\n        \n        # if it can't, return -1\n        return sum(target_dict.values())"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i][j - 1]\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        prev = 0\n        total = 0\n        \n        for i in range(len(s)-1, -1, -1):\n            curr = roman_dict[s[i]]\n            if curr < prev:\n                total -= curr\n            else:\n                total += curr\n            prev = curr\n            \n        return total"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 3. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 4. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 5. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 6. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 7. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 8. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 9. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 10. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 11. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 12. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 13. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 14. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 15. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0\ub97c \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 16. \uc2ac\ub77c"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2.0\n        else:\n            return nums1[len(nums1) // 2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest, then the pivot point is the smallest\n        # if the pivot point is not the smallest, then the pivot point is the smallest\n        # if the pivot point is the smallest,"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,364,1001,2002,3003,3432,3003,2002,1001,364,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,441,1331,3003,5605,8225,10240,10240,8225,5605,3003,1331,441,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,495,1655,4165,8565,13565,18565,18565,13565,8565,4165,1655,495,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,555,2205,6135,12965,22330,34320,42965,42965,34320,22330,6135,12965,2205,555,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,666,3645,13315,40525,92405,177140,270505,343200,343200,270505,92405,177140,40525,6135,13315,3645,666,102,18,1]\n        if rowIndex == 19:\n            return [1,19,103,777,4862,21015,70525,160165,300305"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * (area ** 0.5)\n        # 2. 2 * (area ** 0.5) + 1\n        # 3. 2 * (area ** 0.5) + 1 - 1\n        # 4. 2 * (area ** 0.5) + 1 - 2\n        # 5. 2 * (area ** 0.5) + 1 - 3\n        # 6. 2 * (area ** 0.5) + 1 - 4\n        # 7. 2 * (area ** 0.5) + 1 - 5\n        # 8. 2 * (area ** 0.5) + 1 - 6\n        # 9. 2 * (area ** 0.5) + 1 - 7\n        # 10. 2 * (area ** 0.5) + 1 - 8\n        # 11. 2 * (area ** 0.5) + 1 - 9\n        # 12. 2 * (area ** 0.5) + 1 - 10\n        # 13. 2 * (area ** 0.5) + 1 - 11\n        # 14. 2 * (area ** 0.5) + 1 - 12\n        # 15. 2 * (area ** 0.5) + 1 - 13\n        # 16. 2 * (area ** 0.5) + 1 - 14\n        # 17. 2 * (area ** 0.5) + 1 - 15\n        # 18. 2 * (area ** 0.5) + 1 - 16\n        # 19. 2 * (area ** 0.5) + 1 - 17\n        # 20. 2 * (area ** 0.5) + 1 - 18\n        # 21. 2 * (area ** 0.5) + 1 - 19\n        # 22. 2 * (area ** 0.5) + 1 - 20\n        # 23. 2 * (area ** 0.5) + 1 - 21\n        # 24. 2 * (area ** 0.5) + 1 - 22\n        # 25. 2 * (area ** 0.5) + 1 - 23\n        # 26. 2 * (area ** 0.5) + 1 - 24\n        # 27. 2 * (area ** 0.5) + 1 - 25\n        # 28. 2 * (area ** 0.5) + 1 - 26\n        # 29. 2 * (area ** 0.5) + 1 - 27\n        # 30. 2 * (area ** 0.5) + 1 - 28\n        # 31. 2 * (area ** 0.5) + 1 - 29\n        # 32. 2 * (area ** 0.5) + 1 - 30\n        # 33. 2 * (area ** 0.5) + 1 - 31\n        # 34. 2 * (area ** 0.5) + 1 - 32\n        # 35. 2 * (area ** 0.5) + 1 - 33\n        # 36. 2 * (area ** 0.5) + 1 - 34\n        # 37. 2 * (area ** 0.5) + 1 - 35\n        # 38. 2 * (area ** 0.5) + 1 - 36\n        # 39. 2 * (area ** 0.5) + 1 - 37\n        # 40. 2 * (area ** 0.5) + 1 - 38\n        # 41. 2 * (area ** 0.5) + 1 - 39\n        # 42. 2 * (area ** 0.5) + 1 - 40\n        # 43. 2 * (area ** 0.5) + 1 - 41\n        # 44. 2 * (area ** 0.5) + 1 -"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build a queue and a set\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        \n        # build a dict to store the shortest path\n        shortest_path = {beginWord: [beginWord]}\n        \n        # BFS\n        while queue:\n            curr_len = len(queue)\n            for _ in range(curr_len):\n                curr_word = queue.popleft()\n                for i in range(len(curr_word)):\n                    for neighbor in graph[curr_word[:i] + '*' + curr_word[i+1:]]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n                            shortest_path[neighbor] = shortest_path[curr_word] + [neighbor]\n            if endWord in visited:\n                break\n        \n        # build the result\n        result = []\n        if endWord not in shortest_path:\n            return result\n        else:\n            result.append(shortest_path[endWord])\n            while result[-1][-1] != beginWord:\n                result.append(shortest_path[result[-1][-1]])\n            return result[::-1]"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]] + r for r in res]\n            else:\n                res += [nums[i]]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba70 \uc624\ub978\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 3. \uc624\ub978\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num = stack.pop()\n                stack.append(int(float(stack.pop()) / num))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        return area == (x_max - x_min) * (y_max - y_min)"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        # 4. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 5. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 6. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 7. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 8. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 9. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 10. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 11. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 12. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 13. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 14. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 15. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 16. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 17. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 18. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 19. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 20. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 21. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 22. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 23. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 24. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 25. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 26. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 27. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 28. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 29. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 30. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 31. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 32. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 33. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 34. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 35. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 36. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 37. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 38. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 39. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 40. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 41. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 42. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 43. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 44. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 45. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 46. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 47. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 48. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 49. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 50. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 51. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 52. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 53. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 54. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 55. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 56. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 57. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 58. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 59. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 60. 26\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 61. 26\u8fdb\u5236\u8f6c26\u8fdb"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        \n        for num in nums:\n            if cur_sum < 0:\n                cur_sum = 0\n            cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = [0] * 12\n        for i in range(2):\n            for j in range(3):\n                board_1d[i*3+j] = board[i][j]\n        \n        # convert board_1d to a string\n        board_str = ''.join(map(str, board_1d))\n        \n        # convert board_str to a 10-bit binary number\n        board_bin = int(board_str, 2)\n        \n        # convert board_bin to a list of 4-bit binary numbers\n        board_bin_list = [board_bin >> i & 15 for i in range(4)]\n        \n        # convert board_bin_list to a string\n        board_bin_str = ''.join(map(str, board_bin_list))\n        \n        # convert board_bin_str to a 10-bit binary number\n        board_bin_2 = int(board_bin_str, 2)\n        \n        # convert board_bin_2 to a list of 4-bit binary numbers\n        board_bin_2_list = [board_bin_2 >> i & 15 for i in range(4)]\n        \n        # convert board_bin_2_list to a string\n        board_bin_2_str = ''.join(map(str, board_bin_2_list))\n        \n        # convert board_bin_2_str to a 10-bit binary number\n        board_bin_3 = int(board_bin_2_str, 2)\n        \n        # convert board_bin_3 to a list of 4-bit binary numbers\n        board_bin_3_list = [board_bin_3 >> i & 15 for i in range(4)]\n        \n        # convert board_bin_3_list to a string\n        board_bin_3_str = ''.join(map(str, board_bin_3_list))\n        \n        # convert board_bin_3_str to a 10-bit binary number\n        board_bin_4 = int(board_bin_3_str, 2)\n        \n        # convert board_bin_4 to a list of 4-bit binary numbers\n        board_bin_4_list = [board_bin_4 >> i & 15 for i in range(4)]\n        \n        # convert board_bin_4_list to a string\n        board_bin_4_str = ''.join(map(str, board_bin_4_list))\n        \n        # convert board_bin_4_str to a 10-bit binary number\n        board_bin_5 = int(board_bin_4_str, 2)\n        \n        # convert board_bin_5 to a list of 4-bit binary numbers\n        board_bin_5_list = [board_bin_5 >> i & 15 for i in range(4)]\n        \n        # convert board_bin_5_list to a string\n        board_bin_5_str = ''.join(map(str, board_bin_5_list))\n        \n        # convert board_bin_5_str to a 10-bit binary number\n        board_bin_6 = int(board_bin_5_str, 2)\n        \n        # convert board_bin_6 to a list of 4-bit binary numbers\n        board_bin_6_list = [board_bin_6 >> i & 15 for i in range(4)]\n        \n        # convert board_bin_6_list to a string\n        board_bin_6_str = ''.join(map(str, board_bin_6_list))\n        \n        # convert board_bin_6_str to a 10-bit binary number\n        board_bin_7 = int(board_bin_6_str, 2)\n        \n        # convert board_bin_7 to a list of 4-bit binary numbers\n        board_bin_7_list = [board_bin_7 >> i & 15 for i in range(4)]\n        \n        # convert board_bin_7_list to a string\n        board_bin_7_str = ''.join(map(str, board_bin_7_list))\n        \n        # convert board_bin_7"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t and t[i] != s_to_t[s[i]]:\n                return False\n            if t[i] in t_to_s and s[i] != t_to_s[t[i]]:\n                return False\n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        if m == 1 and n == 1:\n            return 1\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        if len(s) == 2:\n            if s[1] == '0':\n                if s[0] == '1':\n                    return 1\n                else:\n                    return 0\n            else:\n                if int(s[0:2]) <= 26:\n                    return 2\n                else:\n                    return 1\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s-target) < abs(res-target):\n                    res = s\n                if s < target:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n                \n        prev = None\n        ans = float('inf')\n        for val in inorder(root):\n            if prev:\n                ans = min(ans, val - prev)\n            prev = val\n        return ans"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return [0, 0]\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left[0] == right[0]:\n                return [left[0] + 1, max(left[1], root.val)]\n            elif left[0] > right[0]:\n                return [left[0] + 1, left[1]]\n            else:\n                return [right[0] + 1, right[1]]\n        \n        return dfs(root)[1:]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        if needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the number of lowercase, uppercase, digit\n        # 3. check the number of repeating characters in a row\n        # 4. check the number of special characters\n        # 5. check the number of special characters\n        # 6. check the number of special characters\n        # 7. check the number of special characters\n        # 8. check the number of special characters\n        # 9. check the number of special characters\n        # 10. check the number of special characters\n        # 11. check the number of special characters\n        # 12. check the number of special characters\n        # 13. check the number of special characters\n        # 14. check the number of special characters\n        # 15. check the number of special characters\n        # 16. check the number of special characters\n        # 17. check the number of special characters\n        # 18. check the number of special characters\n        # 19. check the number of special characters\n        # 20. check the number of special characters\n        # 21. check the number of special characters\n        # 22. check the number of special characters\n        # 23. check the number of special characters\n        # 24. check the number of special characters\n        # 25. check the number of special characters\n        # 26. check the number of special characters\n        # 27. check the number of special characters\n        # 28. check the number of special characters\n        # 29. check the number of special characters\n        # 30. check the number of special characters\n        # 31. check the number of special characters\n        # 32. check the number of special characters\n        # 33. check the number of special characters\n        # 34. check the number of special characters\n        # 35. check the number of special characters\n        # 36. check the number of special characters\n        # 37. check the number of special characters\n        # 38. check the number of special characters\n        # 39. check the number of special characters\n        # 40. check the number of special characters\n        # 41. check the number of special characters\n        # 42. check the number of special characters\n        # 43. check the number of special characters\n        # 44. check the number of special characters\n        # 45. check the number of special characters\n        # 46. check the number of special characters\n        # 47. check the number of special characters\n        # 48. check the number of special characters\n        # 49. check the number of special characters\n        # 50. check the number of special characters\n        # 51. check the number of special characters\n        # 52. check the number of special characters\n        # 53. check the number of special characters\n        # 54. check the number of special characters\n        # 55. check the number of special characters\n        # 56. check the number of special characters\n        # 57. check the number of special characters\n        # 58. check the number of special characters\n        # 59. check the number of special characters\n        # 60. check the number of special characters\n        # 61. check the number of special characters\n        # 62. check the number of special characters\n        # 63. check the number of special characters\n        # 64. check the number of special characters\n        # 65. check the number of special characters\n        # 66. check the number of special characters\n        # 67. check the number of special characters\n        # 68. check the number of special characters\n        # 69. check the number of special characters\n        # 70. check the number of special characters\n        # 71. check the number of special characters\n        # 72. check the number of special characters\n        # 73. check the number of special characters\n        # 74. check the number of special characters\n        # 75. check the number of special characters\n        # 76. check the number of special characters\n        # 77. check the number of special characters\n        # 78. check the number of special characters\n        # 79. check the number of special characters"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 10 = 2 * 5\n        # 2 = 2 * 2\n        # 5 = 5 * 5\n        # 25 = 5 * 5\n        # 125 = 5 * 5 * 5\n        # 625 = 5 * 5 * 5 * 5\n        # 3125 = 5 * 5 * 5 * 5 * 5\n        # 15625 = 5 * 5 * 5 * 5 * 5 * 5\n        # 78125 = 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 390625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 1953125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 9765625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 48828125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 244140625 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 1220703125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 6103017578125 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 30517578125000 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 152587890625000 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 762939453125000 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 3814697265625000 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 19073486328125000 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 95367431640625000 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 476837158203125000 = 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5\n        # 2384185791015625000 = 5 *"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [''] * numRows\n        row = 0\n        down = True\n        for c in s:\n            res[row] += c\n            if row == 0:\n                down = True\n            elif row == numRows - 1:\n                down = False\n            if down:\n                row += 1\n            else:\n                row -= 1\n        return ''.join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers\n        # 3. 2 pointers\n        # 4. 2 pointers\n        # 5. 2 pointers\n        # 6. 2 pointers\n        # 7. 2 pointers\n        # 8. 2 pointers\n        # 9. 2 pointers\n        # 10. 2 pointers\n        # 11. 2 pointers\n        # 12. 2 pointers\n        # 13. 2 pointers\n        # 14. 2 pointers\n        # 15. 2 pointers\n        # 16. 2 pointers\n        # 17. 2 pointers\n        # 18. 2 pointers\n        # 19. 2 pointers\n        # 20. 2 pointers\n        # 21. 2 pointers\n        # 22. 2 pointers\n        # 23. 2 pointers\n        # 24. 2 pointers\n        # 25. 2 pointers\n        # 26. 2 pointers\n        # 27. 2 pointers\n        # 28. 2 pointers\n        # 29. 2 pointers\n        # 30. 2 pointers\n        # 31. 2 pointers\n        # 32. 2 pointers\n        # 33. 2 pointers\n        # 34. 2 pointers\n        # 35. 2 pointers\n        # 36. 2 pointers\n        # 37. 2 pointers\n        # 38. 2 pointers\n        # 39. 2 pointers\n        # 40. 2 pointers\n        # 41. 2 pointers\n        # 42. 2 pointers\n        # 43. 2 pointers\n        # 44. 2 pointers\n        # 45. 2 pointers\n        # 46. 2 pointers\n        # 47. 2 pointers\n        # 48. 2 pointers\n        # 49. 2 pointers\n        # 50. 2 pointers\n        # 51. 2 pointers\n        # 52. 2 pointers\n        # 53. 2 pointers\n        # 54. 2 pointers\n        # 55. 2 pointers\n        # 56. 2 pointers\n        # 57. 2 pointers\n        # 58. 2 pointers\n        # 59. 2 pointers\n        # 60. 2 pointers\n        # 61. 2 pointers\n        # 62. 2 pointers\n        # 63. 2 pointers\n        # 64. 2 pointers\n        # 65. 2 pointers\n        # 66. 2 pointers\n        # 67. 2 pointers\n        # 68. 2 pointers\n        # 69. 2 pointers\n        # 70. 2 pointers\n        # 71. 2 pointers\n        # 72. 2 pointers\n        # 73. 2 pointers\n        # 74. 2 pointers\n        # 75. 2 pointers\n        # 76. 2 pointers\n        # 77. 2 pointers\n        # 78. 2 pointers\n        # 79. 2 pointers\n        # 80. 2 pointers\n        # 81. 2 pointers\n        # 82. 2 pointers\n        # 83. 2 pointers\n        # 84. 2 pointers\n        # 85. 2 pointers\n        # 86. 2 pointers"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. mark the number as negative if it is present\n        ## 2. iterate over the array and return the numbers that are not marked as negative\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use a hashmap to store the number of smaller elements to the left\n        # 5. use a hashmap to store the number of smaller elements to the right\n        # 6. use a hashmap to store the number of smaller elements to the left\n        # 7. use a hashmap to store the number of smaller elements to the right\n        # 8. use a hashmap to store the number of smaller elements to the left\n        # 9. use a hashmap to store the number of smaller elements to the right\n        # 10. use a hashmap to store the number of smaller elements to the left\n        # 11. use a hashmap to store the number of smaller elements to the right\n        # 12. use a hashmap to store the number of smaller elements to the left\n        # 13. use a hashmap to store the number of smaller elements to the right\n        # 14. use a hashmap to store the number of smaller elements to the left\n        # 15. use a hashmap to store the number of smaller elements to the right\n        # 16. use a hashmap to store the number of smaller elements to the left\n        # 17. use a hashmap to store the number of smaller elements to the right\n        # 18. use a hashmap to store the number of smaller elements to the left\n        # 19. use a hashmap to store the number of smaller elements to the right\n        # 20. use a hashmap to store the number of smaller elements to the left\n        # 21. use a hashmap to store the number of smaller elements to the right\n        # 22. use a hashmap to store the number of smaller elements to the left\n        # 23. use a hashmap to store the number of smaller elements to the right\n        # 24. use a hashmap to store the number of smaller elements to the left\n        # 25. use a hashmap to store the number of smaller elements to the right\n        # 26. use a hashmap to store the number of smaller elements to the left\n        # 27. use a hashmap to store the number of smaller elements to the right\n        # 28. use a hashmap to store the number of smaller elements to the left\n        # 29. use a hashmap to store the number of smaller elements to the right\n        # 30. use a hashmap to store the number of smaller elements to the left\n        # 31. use a hashmap to store the number of smaller elements to the right\n        # 32. use a hashmap to store the number of smaller elements to the left\n        # 33. use a hashmap to store the number of smaller elements to the right\n        # 34. use a hashmap to store the number of smaller elements to the left\n        # 35. use a hashmap to store the number of smaller elements to the right\n        # 36. use a hashmap to store the number of smaller elements to the left\n        # 37. use a hashmap to store the number of smaller elements to the right\n        # 38. use a hashmap to store the number of smaller elements to the left\n        # 39. use a hashmap to store the number of smaller elements to the right\n        # 40. use a hashmap to store the number of smaller elements to the left\n        # 41. use a hashmap to store the number of smaller elements to the right\n        # 42. use a hashmap to store the number of smaller elements to the left\n        # 43. use a hashmap to store the number of smaller elements to the right\n        # 44. use a hashmap to store the number of smaller elements to the left\n        # 45. use a hashmap to store the number of smaller elements to the right\n        # 46. use a hashmap to store the number of smaller elements to the left\n        # 47. use a hashmap to store the number of smaller elements to the right\n        # 48. use a hashmap to store the number of smaller elements to the left\n        # 49. use a hashmap to store the number of smaller elements to the right\n        # 50. use a hashmap to store the number of smaller elements"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        \n        # initialize\n        ans = 0\n        prev = -1\n        curr = -1\n        \n        # iterate\n        for i in range(len(intervals)):\n            if intervals[i][0] > prev:\n                ans += 2\n                prev = intervals[i][1] - 1\n            else:\n                ans += 1\n                prev -= 1\n            curr = intervals[i][1]\n        \n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - i - 1):\n                    res.append('({}){}'.format(left, right))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. stack\n        # 6. stack\n        # 7. stack\n        # 8. stack\n        # 9. stack\n        # 10. stack\n        # 11. stack\n        # 12. stack\n        # 13. stack\n        # 14. stack\n        # 15. stack\n        # 16. stack\n        # 17. stack\n        # 18. stack\n        # 19. stack\n        # 20. stack\n        # 21. stack\n        # 22. stack\n        # 23. stack\n        # 24. stack\n        # 25. stack\n        # 26. stack\n        # 27. stack\n        # 28. stack\n        # 29. stack\n        # 30. stack\n        # 31. stack\n        # 32. stack\n        # 33. stack\n        # 34. stack\n        # 35. stack\n        # 36. stack\n        # 37. stack\n        # 38. stack\n        # 39. stack\n        # 40. stack\n        # 41. stack\n        # 42. stack\n        # 43. stack\n        # 44. stack\n        # 45. stack\n        # 46. stack\n        # 47. stack\n        # 48. stack\n        # 49. stack\n        # 50. stack\n        # 51. stack\n        # 52. stack\n        # 53. stack\n        # 54. stack\n        # 55. stack\n        # 56. stack\n        # 57. stack\n        # 58. stack\n        # 59. stack\n        # 60. stack\n        # 61. stack\n        # 62. stack\n        # 63. stack\n        # 64. stack\n        # 65. stack\n        # 66. stack\n        # 67. stack\n        # 68. stack\n        # 69. stack\n        # 70. stack\n        # 71. stack\n        # 72. stack\n        # 73. stack\n        # 74. stack\n        # 75. stack\n        # 76. stack\n        # 77. stack\n        # 78. stack\n        # 79. stack\n        # 80. stack\n        # 81. stack\n        # 82. stack\n        # 83. stack\n        # 84. stack\n        # 85. stack\n        # 86. stack\n        # 87. stack\n        # 88. stack\n        # 89. stack\n        # 90. stack\n        # 91. stack\n        # 92. stack\n        # 93. stack\n        # 94. stack\n        # 95. stack\n        # 96. stack\n        # 97. stack\n        # 98. stack\n        # 99. stack\n        # 100. stack\n        # 101. stack\n        # 102. stack\n        # 103. stack\n        # 104. stack\n        # 105. stack\n        # 106. stack\n        # 107. stack\n        # 108. stack\n        # 109. stack\n        # 110. stack\n        # 111. stack\n        # 112. stack\n        # 113. stack\n        # 114. stack\n        # 115. stack\n        # 116. stack\n        # 117. stack\n        # 118. stack\n        # 119. stack\n        # 120. stack\n        # 121. stack\n        # 122. stack\n        # 123. stack\n        # 124. stack\n        # 125. stack"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 == denominator < 0:\n            sign = \"\"\n        elif numerator < 0:\n            sign = \"-\"\n        else:\n            sign = \"+\"\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        quotient, remainder = divmod(numerator, denominator)\n        if remainder == 0:\n            return sign + str(quotient)\n        \n        seen = {}\n        res = [sign + str(quotient), \"(\"]\n        \n        while remainder != 0:\n            if remainder in seen:\n                res.insert(seen[remainder], \")\")\n                break\n            seen[remainder] = len(res)\n            quotient, remainder = divmod(remainder * 10, denominator)\n            res.append(str(quotient))\n        \n        return \"\".join(res)"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for e in envelopes:\n            if not dp or e[1] > dp[-1]:\n                dp.append(e[1])\n            else:\n                left, right = 0, len(dp) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if dp[mid] < e[1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                dp[left] = e[1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O("}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0, head)\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = head\n        \n        # move fast pointer n steps\n        for i in range(n):\n            fast = fast.next\n        \n        # move both pointers until fast pointer reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node\n        slow.next = slow.next.next\n        \n        # return the head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the sum of all the dresses\n        # 2. find the max dresses in a machine\n        # 3. find the min dresses in a machine\n        # 4. find the max dresses in a machine\n        # 5. find the min dresses in a machine\n        # 6. find the max dresses in a machine\n        # 7. find the min dresses in a machine\n        # 8. find the max dresses in a machine\n        # 9. find the min dresses in a machine\n        # 10. find the max dresses in a machine\n        # 11. find the min dresses in a machine\n        # 12. find the max dresses in a machine\n        # 13. find the min dresses in a machine\n        # 14. find the max dresses in a machine\n        # 15. find the min dresses in a machine\n        # 16. find the max dresses in a machine\n        # 17. find the min dresses in a machine\n        # 18. find the max dresses in a machine\n        # 19. find the min dresses in a machine\n        # 20. find the max dresses in a machine\n        # 21. find the min dresses in a machine\n        # 22. find the max dresses in a machine\n        # 23. find the min dresses in a machine\n        # 24. find the max dresses in a machine\n        # 25. find the min dresses in a machine\n        # 26. find the max dresses in a machine\n        # 27. find the min dresses in a machine\n        # 28. find the max dresses in a machine\n        # 29. find the min dresses in a machine\n        # 30. find the max dresses in a machine\n        # 31. find the min dresses in a machine\n        # 32. find the max dresses in a machine\n        # 33. find the min dresses in a machine\n        # 34. find the max dresses in a machine\n        # 35. find the min dresses in a machine\n        # 36. find the max dresses in a machine\n        # 37. find the min dresses in a machine\n        # 38. find the max dresses in a machine\n        # 39. find the min dresses in a machine\n        # 40. find the max dresses in a machine\n        # 41. find the min dresses in a machine\n        # 42. find the max dresses in a machine\n        # 43. find the min dresses in a machine\n        # 44. find the max dresses in a machine\n        # 45. find the min dresses in a machine\n        # 46. find the max dresses in a machine\n        # 47. find the min dresses in a machine\n        # 48. find the max dresses in a machine\n        # 49. find the min dresses in a machine\n        # 50. find the max dresses in a machine\n        # 51. find the min dresses in a machine\n        # 52. find the max dresses in a machine\n        # 53. find the min dresses in a machine\n        # 54. find the max dresses in a machine\n        # 55. find the min dresses in a machine\n        # 56. find the max dresses in a machine\n        # 57. find the min dresses in a machine\n        # 58. find the max dresses in a machine\n        # 59. find the min dresses in a machine\n        # 60. find the max dresses in a machine\n        # 61. find the min dresses in a machine\n        # 62. find the max dresses in a machine\n        # 63. find the min dresses in a machine\n        # 64. find the max dresses in a machine\n        # 65. find the min dresses in a machine\n        # 66. find the max dresses in a machine\n        # 67. find the min dresses in a machine\n        # 68. find the max dresses in a machine\n        # 69. find the min dresses in a machine\n        # 70. find the max dresses in a machine\n        # 71. find the min dresses in a machine\n        # 72. find the max dresses in a machine\n        # 73. find the min dresses in a machine\n        # 74. find the max dresses in"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            cnt = 0\n            for i in range(1, m + 1):\n                cnt += min(n, x // i)\n            return cnt\n        \n        lo, hi = 1, m * n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if count(mid) < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i, h in enumerate(heights + [0]):\n            while stack and heights[stack[-1]] > h:\n                top = stack.pop()\n                max_area = max(max_area, (i - stack[-1] - 1) * heights[top])\n            stack.append(i)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(nums, path, res, idx):\n            res.append(path)\n            for i in range(idx, len(nums)):\n                dfs(nums, path + [nums[i]], res, i + 1)\n        \n        res = [[]]\n        dfs(sorted(nums), [], res, 0)\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid] < nums[mid - 1]:\n                return nums[mid]\n            \n            if nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-' and (s[0] not in '0123456789' or len(s) == 1):\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n        if s and s[0] in '0123456789':\n            s = s[1:]\n        while s and s[0] == '0':\n            s = s[1:]\n        if not s or s[0] not in '123456789':\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s and s[0] == '.':\n            s = s[1:]\n        while s and s[0] == '0':\n            s = s[1:]\n        if s and s[0] in '123456789' and 'e' not in s:\n            s = s[1:]\n        while s and s[0] == '0':\n            s = s[1:]\n        if s and s[0] in '123456789' and 'e' in s:\n            s = s[1:]\n            if s and s[0] == '+' or s[0] == '-':\n                s = s[1:]\n            while s and s[0] == '0':\n                s = s[1:]\n            if s and s[0] in '123456789':\n                s = s[1:]\n            while s and s[0] == 'e':\n                s = s[1:]\n                if s and s[0] == '+' or s[0] == '-':\n                    s = s[1:]\n                while s and s[0] == '0':\n                    s = s[1:]\n                if s and s[0] in '123456789':\n                    s = s[1:]\n        return not s"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## time: O(n)\n        ## space: O(1)\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board, l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board, row, num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board, col, num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board, box_start_row, box_start_col, num):\n            for row in range(3):\n                for col in range(3):\n                    if board[row+box_start_row][col+box_start_col] == num:\n                        return True\n            return False\n        \n        def is_valid(board, row, col, num):\n            return not used_in_row(board, row, num) and not used_in_col(board, col, num) and not used_in_box(board, row - row % 3, col - col % 3, num)\n        \n        def solve_sudoku(board):\n            l = [0, 0]\n            if not find_empty_location(board, l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1, 10):\n                if is_valid(board, row, col, str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = second = None\n        prev = None\n        while root:\n            if root.left:\n                # find the first node\n                if prev and prev.val > root.val:\n                    first = root\n                prev = root\n                root = root.left\n            else:\n                # find the second node\n                if prev and prev.val > root.val:\n                    second = root\n                root = root.right\n        # swap the values\n        first.val, second.val = second.val, first.val"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        return i * i == num"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node, path):\n            if node not in node.children:\n                return 0\n            cnt = node.children[node]\n            if cnt:\n                res.append(path)\n                cnt -= 1\n                if cnt == 0:\n                    del node.children[node]\n                node = node.children[node]\n            else:\n                return 0\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return 0\n            c = board[i][j]\n            if c not in node.children:\n                return 0\n            node = node.children[c]\n            res = dfs(i + 1, j, node, path + c) + dfs(i - 1, j, node, path + c) + dfs(i, j + 1, node, path + c) + dfs(i, j - 1, node, path + c)\n            return res\n        \n        class TrieNode:\n            def __init__(self):\n                self.children = {}\n                self.word = None\n        \n        root = TrieNode()\n        for word in words:\n            node = root\n            for c in word:\n                if c not in node.children:\n                    node.children[c] = TrieNode()\n                node = node.children[c]\n            node.word = word\n        \n        res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, root, '')\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != 9:\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != 9:\n                return False\n        \n        # check 3x3 squares\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(square)) != 9:\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return ' '.join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. iterate over the list\n        # 4. for each character, multiply the character by 26^(index)\n        # 5. add the result to the total\n        # 6. return the total\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. iterate over the list\n        total = 0\n        for i, c in enumerate(columnTitle):\n            # 4. for each character, multiply the character by 26^(index)\n            total += (ord(c) - ord('A') + 1) * (26 ** i)\n            \n        # 5. return the total\n        return total"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            tmp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = tmp\n        \n        # merge the two halves\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first.next, first.next\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern and the length of the words are not the same, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for p, w in zip(pattern, words):\n            # if the pattern is not in the mapping, add it\n            if p not in mapping:\n                if w in mapping.values():\n                    return False\n                mapping[p] = w\n            # if the word is already in the mapping, check if it matches the pattern\n            elif mapping[p] != w:\n                return False\n        \n        # if we reach here, all the words are mapped correctly\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        res = []\n        backtrack()\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            carry //= 10\n            curr = curr.next\n            \n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip bits\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip bits\n        binary = binary.replace('1', '0')\n        binary = binary.replace('0', '1')\n        \n        # 3. convert back to decimal\n        return int(binary, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n                count += count\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word):\n            for i in range(1, len(word)):\n                if word[:i] in word_set and (word[i:] in word_set or is_concatenated(word[i:])):\n                    return True\n            return False\n        \n        word_set = set(words)\n        return [word for word in words if is_concatenated(word)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, pie, na, n):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in pie and row - col not in na:\n                    count += backtrack(row + 1, cols | {col}, pie | {row + col}, na | {row - col}, n)\n            return count\n        \n        return backtrack(0, set(), set(), set(), n)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                return [''.join(board[i]) for i in range(n)]\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    res = backtrack(board, row + 1)\n                    if res:\n                        return res\n                    board[row][col] = '.'\n            return []\n        \n        return backtrack([['.' for _ in range(n)] for _ in range(n)], 0)"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max\n        # 3. else return the third element\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}