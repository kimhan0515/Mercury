{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[i][0] = 1\n        # dp[0][j] = 0\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i] == t[j]\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers as 0\n        # 2. mark all numbers in the range [1, n] as 1\n        # 3. iterate through the array and mark the corresponding numbers as -1\n        # 4. iterate through the array again and return the first number that is not -1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        res = \"\"\n        nums = [i for i in range(1, n+1)]\n        for i in range(n-1, -1, -1):\n            fact //= i\n            idx = k // fact\n            k %= fact\n            res += str(nums[idx])\n            nums.remove(nums[idx])\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, op, res):\n            if i == len(num):\n                if curr == target and op == \"+\":\n                    res.append(curr)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == \"0\":\n                    break\n                curr_num = int(num[i:j+1])\n                if op == \"+\":\n                    backtrack(j+1, curr + curr_num, curr_num, \"+\", res)\n                elif op == \"-\":\n                    backtrack(j+1, curr - curr_num, -curr_num, \"-\", res)\n                else:\n                    backtrack(j+1, curr - prev + (curr_num * prev), curr_num * prev, \"*\", res)\n        \n        res = []\n        backtrack(0, 0, 0, \"+\", res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr * 10 + root.val\n            return dfs(root.left, curr * 10 + root.val) + dfs(root.right, curr * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        \n        res = []\n        i = n - 1\n        while i >= 0:\n            if len(res) == k:\n                res.append('-')\n            res.append(s[i])\n            i -= 1\n        \n        return ''.join(res[::-1])"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. check if the sum of gas is greater than the sum of cost\n        ## 2. if yes, then we can start from any station\n        ## 3. if no, then we can't start from any station\n        \n        ## 1.\n        if sum(gas) < sum(cost):\n            return -1\n        \n        ## 2.\n        start = 0\n        tank = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        ## 3.\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in en.umerate(nums):\n                while out and out[-1] < n and len(out) + len(nums) - i > k:\n                    out.pop()\n                if len(out) < k:\n                    out.append(n)\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    i += 1\n                else:\n                    j += 1\n                out.append(nums1[i] if i < len(nums1) else nums2[j])\n            return out\n        \n        m, n = len(nums1), len(nums2)\n        if m + n < k:\n            return []\n        if m < k:\n            return nums2\n        if n < k:\n            return nums1\n        if m == n == k:\n            return merge(nums1, nums2)\n        if m > n:\n            return merge(pick(nums1, k), nums2)\n        return merge(pick(nums2, k), nums1)"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if i == m - 1 and j == n - 1:\n                    dp[i][j] = max(1, 1 - dungeon[i][j])\n                elif i == m - 1:\n                    dp[i][j] = max(1, dp[i][j + 1] - dungeon[i][j])\n                elif j == n - 1:\n                    dp[i][j] = max(1, dp[i + 1][j] - dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        l, r = 0, len(s) - 1\n        while l < r:\n            while l < r and s[l] not in vowels:\n                l += 1\n            while l < r and s[r] not in vowels:\n                r -= 1\n            s[l], s[r] = s[r], s[l]\n            l += 1\n            r -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## sum(n) - sum(nums) = missing number\n        ## sum(n) = n * (n + 1) / 2\n        ## sum(nums) = n * (n + 1) / 2\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) - sum(n) = n\n        ## sum(nums) -"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        \n        queue = collections.deque([(beginWord, 1)])\n        visited = set([beginWord])\n        \n        while queue:\n            word, length = queue.popleft()\n            for i in range(len(word)):\n                for j in range(ord('a'), ord('z') + 1):\n                    new_word = word[:i] + chr(j) + word[i+1:]\n                    if new_word == endWord:\n                        return length + 1\n                    if new_word in wordList and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new_word, length + 1))\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a, b = list(a), list(b)\n        \n        carry = 0\n        for i in range(len(a)):\n            if i < len(b):\n                a[i] = str(int(a[i]) + int(b[i]) + carry)\n            else:\n                a[i] = str(int(a[i]) + carry)\n            carry = int(a[i] > '1')\n            if carry and i == len(a) - 1:\n                a.append('1')\n            elif carry and i < len(b):\n                a[i] = str(int(a[i]) + int(b[i]))\n            else:\n                a[i] = str(int(a[i]))\n        return ''.join(a)"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_left_index):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (find_left_index and nums[mid] == target):\n                    right = mid - 1\n                    index = mid\n                else:\n                    left = mid + 1\n            return index\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        \n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        step = 1\n        end = 0\n        \n        for i in range(1, n):\n            if i > end:\n                step += 1\n                end = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return step"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) / 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(len(prices) - 1))\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(len(prices)):\n            for j in range(1, k + 1):\n                if i == 0:\n                    dp[i][j] = prices[i]\n                else:\n                    dp[i][j] = max(dp[i - 1][j] - prices[i], dp[i - 1][j - 1])\n                    dp[i][j] = max(dp[i][j], prices[i] + dp[i - 1][j - 1])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = 2 ** 32 + num\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        \n        for i in range(len(hex_list)):\n            if hex_list[i] >= 10:\n                hex_list[i] = hex_dict[hex_list[i]]\n        \n        return ''.join(map(str, hex_list))"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is the first unique character, add its index to the list\n        # if the character is not the first unique character, remove it from the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first element in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is the first unique character, add its index to the list\n        # if the character is not the first unique character, remove it from the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first element in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is the first unique character, add its index to the list\n        # if the character is not the first unique character, remove it from the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first element in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is the first unique character, add its index to the list\n        # if the character is not the first unique character, remove it from the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first element in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is the first unique character, add its index to the list\n        # if the character is not the first unique character, remove it from the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first element in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is the first unique character, add its index to the list\n        # if the character is not the first unique character, remove it from the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first element in the list\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character is the first unique character, add its index to the list\n        # if the character is not the first unique character, remove it from the list\n        # if the list is empty, return -1\n        # if the list is not empty, return the first element in"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if valueDiff < 0:\n            return False\n        \n        if indexDiff < 0:\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff == 0:\n            return False\n        \n        if valueDiff == 0:\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. convert to int\n        ## 2. add\n        ## 3. convert to str\n        \n        ## 1. convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        ## 2. add\n        sum = num1 + num2\n        \n        ## 3. convert to str\n        return str(sum)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if s[i] in '+-' or i == len(s) - 1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    stack.append(int(stack.pop() / num))\n                sign = s[i]\n                num = 0\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # profits[i] - capital[i] > 0\n        # profits[i] - capital[i] < 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i] = 0\n        # profits[i] - capital[i]"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '[':\n                stack.append(']')\n            elif i == '{':\n                stack.append('}')\n            elif stack and i == stack[-1]:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the point\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2, -1, -1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1, i, -1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers after the point\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k == 0:\n            return False\n        \n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        \n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[0] == nums[2]\n        \n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[0] == nums[3]\n        \n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[0] == nums[4]\n        \n        if len(nums) == 6:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[0] == nums[5]\n        \n        if len(nums) == 7:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[0] == nums[6]\n        \n        if len(nums) == 8:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[0] == nums[7]\n        \n        if len(nums) == 9:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[0] == nums[8]\n        \n        if len(nums) == 10:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[0] == nums[9]\n        \n        if len(nums) == 11:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[9] == nums[10] or nums[0] == nums[10]\n        \n        if len(nums) == 12:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            level = []\n            for _ in range(len(q)):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        ans = 0\n        for i in range(0, n, 2):\n            if couples[i][0] / 2 != couples[i][1] / 2:\n                ans += 1\n                couples[i], couples[i+1] = couples[i+1], couples[i]\n        return ans"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        \n        res = []\n        for word in words:\n            if word[0] in row1:\n                r = row1\n            elif word[0] in row2:\n                r = row2\n            else:\n                r = row3\n            for c in word:\n                if c not in r:\n                    break\n            else:\n                res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        for i in range(left-1):\n            curr = curr.next\n        prev = curr\n        curr = curr.next\n        for i in range(right-left):\n            next = curr.next\n            curr.next = next.next\n            next.next = prev.next\n            prev.next = next\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome is itself\n        # if the string is not a palindrome, then the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest pal"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return t\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        for right in range(len(s)):\n            if s[right] in t_dict:\n                if s_dict[s[right]] > t_dict[s[right]]:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] -= 1\n                    while left < right and s_dict[s[left]] < t_dict[s[left]]:\n                        s_dict[s[left]] += 1\n                        left += 1\n                    if right - left < min_len:\n                        min_len = right - left\n                        min_left = left\n                        min_right = right\n                    s_dict[s[left]] += 1\n                    left += 1\n        \n        return s[min_left:min_right+1] if min_len < len(s) else \"\""}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] == distance[i+4] and distance[i] <= distance[i+2]:\n                return True\n            if i >= 4 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] + distance[i+2] >= distance[i+4] and distance[i] == distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 5 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] + distance[i+2] >= distance[i+4] and distance[i] + distance[i+2] >= distance[i+5] and distance[i+1] == distance[i+3] and distance[i+2] <= distance[i+4]:\n                return True\n            if i >= 6 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] + distance[i+2] >= distance[i+4] and distance[i] + distance[i+2] >= distance[i+5] and distance[i+1] + distance[i+3] >= distance[i+6] and distance[i+2] == distance[i+4] and distance[i+3] <= distance[i+5]:\n                return True\n            if i >= 7 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] + distance[i+2] >= distance[i+4] and distance[i] + distance[i+2] >= distance[i+5] and distance[i+1] + distance[i+3] >= distance[i+6] and distance[i+2] + distance[i+4] >= distance[i+7] and distance[i+3] == distance[i+5] and distance[i+4] <= distance[i+6]:\n                return True\n            if i >= 8 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] + distance[i+2] >= distance[i+4] and distance[i] + distance[i+2] >= distance[i+5] and distance[i+1] + distance[i+3] >= distance[i+6] and distance[i+2] + distance[i+4] >= distance[i+7] and distance[i+3] + distance[i+5] >= distance[i+8] and distance[i+4] == distance[i+6] and distance[i+5] <= distance[i+7]:\n                return True\n            if i >= 9 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] + distance[i+2] >= distance[i+4] and distance[i] + distance[i+2] >= distance[i+5] and distance[i+1] + distance[i+3] >= distance[i+6] and distance[i+2] + distance[i+4] >= distance[i+7] and distance[i+3] + distance[i+5] >= distance[i+8] and distance[i+4] + distance[i+6] >= distance[i+9] and distance[i+5] == distance[i+7] and distance[i+6] <= distance[i+8]:\n                return True\n            if i >= 10 and distance[i] + distance[i+1] >= distance[i+3] and distance[i+1] + distance[i+2] >= distance[i+4] and distance[i] + distance[i+2] >= distance[i+5] and distance[i+1] + distance[i+3] >= distance[i+6] and distance[i+2] + distance[i+4] >= distance[i+7] and distance[i+3] + distance[i+5] >= distance[i+8] and distance[i+4] + distance[i+6] >= distance[i+9] and distance[i"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                if q:\n                    steps += 1\n                for x, y in q:\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] > 0:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = [(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1]\n        trees.sort(key=lambda x: x[0])\n        start = (0, 0)\n        for tree, i, j in trees:\n            steps = bfs(start, (i, j))\n            if steps == -1:\n                return -1\n            start = (i, j)\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 3. \u4f7f\u7528\u54c8\u5e0c\u8868\n        # 4. \u4f7f\u7528\u53cc\u6307\u9488\n        # 5. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 6. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 7. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 8. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 9. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 10. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 11. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 12. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 13. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 14. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 15. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 16. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 17. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 18. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 19. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 20. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 21. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 22. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 23. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 24. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 25. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 26. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 27. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 28. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 29. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 30. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 31. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 32. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 33. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 34. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 35. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 36. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 37. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 38. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 39. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 40. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 41. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 42. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 43. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 44. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 45. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 46. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 47. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 48. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 49. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 50. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 51. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 52. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 53. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 54. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 55. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 56. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 57. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 58. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 59. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 60. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 61. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 62. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 63. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 64. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 65. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 66. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 67. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 68. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 69. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 70. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 71. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 72. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 73. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 74. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 75. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 76. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 77. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 78. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 79. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 80. \u4f7f\u7528"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the first row\n        # 4. Find the number of coins in the second row\n        # 5. Find the number of coins in the third row\n        # 6. Find the number of coins in the fourth row\n        # 7. Find the number of coins in the fifth row\n        # 8. Find the number of coins in the sixth row\n        # 9. Find the number of coins in the seventh row\n        # 10. Find the number of coins in the eighth row\n        # 11. Find the number of coins in the ninth row\n        # 12. Find the number of coins in the tenth row\n        # 13. Find the number of coins in the eleventh row\n        # 14. Find the number of coins in the twelfth row\n        # 15. Find the number of coins in the thirteenth row\n        # 16. Find the number of coins in the fourteenth row\n        # 17. Find the number of coins in the fifteenth row\n        # 18. Find the number of coins in the sixteenth row\n        # 19. Find the number of coins in the seventeenth row\n        # 20. Find the number of coins in the eighteenth row\n        # 21. Find the number of coins in the nineteenth row\n        # 22. Find the number of coins in the twentieth row\n        # 23. Find the number of coins in the twenty-first row\n        # 24. Find the number of coins in the twenty-second row\n        # 25. Find the number of coins in the twenty-third row\n        # 26. Find the number of coins in the twenty-fourth row\n        # 27. Find the number of coins in the twenty-fifth row\n        # 28. Find the number of coins in the twenty-sixth row\n        # 29. Find the number of coins in the twenty-seventh row\n        # 30. Find the number of coins in the twenty-eighth row\n        # 31. Find the number of coins in the twenty-ninth row\n        # 32. Find the number of coins in the thirty-first row\n        # 33. Find the number of coins in the thirty-second row\n        # 34. Find the number of coins in the thirty-third row\n        # 35. Find the number of coins in the thirty-fourth row\n        # 36. Find the number of coins in the thirty-fifth row\n        # 37. Find the number of coins in the thirty-sixth row\n        # 38. Find the number of coins in the thirty-seventh row\n        # 39. Find the number of coins in the thirty-eighth row\n        # 40. Find the number of coins in the thirty-ninth row\n        # 41. Find the number of coins in the forty-first row\n        # 42. Find the number of coins in the forty-second row\n        # 43. Find the number of coins in the forty-third row\n        # 44. Find the number of coins in the forty-fourth row\n        # 45. Find the number of coins in the forty-fifth row\n        # 46. Find the number of coins in the forty-sixth row\n        # 47. Find the number of coins in the forty-seventh row\n        # 48. Find the number of coins in the forty-eighth row\n        # 49. Find the number of coins in the forty-ninth row\n        # 50. Find the number of coins in the fifty-first row\n        # 51. Find the number of coins in the fifty-second row\n        # 52. Find the number of coins in the fifty-third row\n        # 53. Find the number of coins in the fifty-fourth row\n        # 54. Find the number of coins in the fifty-fifth row\n        # 55. Find the number of coins in the fifty-sixth row\n        # 56. Find the number of coins"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) > len(t):\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0, 1]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            res.append(res[-1] + (1 << i))\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first interval, insert it at the beginning\n        if newInterval[1] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last interval, insert it at the end\n        if newInterval[0] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first interval, merge it with the first interval\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0] = newInterval\n            return intervals\n        \n        # if the new interval overlaps with the last interval, merge it with the last interval\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1] = newInterval\n            return intervals\n        \n        # if the new interval overlaps with the middle interval, merge it with the middle interval\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = newInterval\n                return intervals\n            \n            # if the new interval overlaps with the interval before the middle interval, merge it with the middle interval\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i-1][1]:\n                intervals[i-1] = newInterval\n                return intervals\n            \n            # if the new interval overlaps with the interval after the middle interval, merge it with the middle interval\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i+1][1]:\n                intervals[i+1] = newInterval\n                return intervals\n            \n        # if the new interval does not overlap with any interval, insert it at the end\n        intervals.append(newInterval)\n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. use min heap to store the max of each list\n        # 3. use max heap to store the min of each list\n        # 4. compare the max of each list and the min of the max heap\n        # 5. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 6. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 7. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 8. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 9. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 10. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 11. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 12. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 13. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 14. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 15. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 16. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 17. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 18. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 19. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 20. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 21. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 22. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 23. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 24. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 25. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 26. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 27. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 28. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 29. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 30. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 31. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 32. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 33. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 34. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 35. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 36. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 37. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 38. if the max of the max heap is greater than the min of the min heap, update the min heap\n        # 39. if the max of the max"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set()\n        seen.add((0, 0))\n        res = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            res = max(res, t)\n            if i == j == n - 1:\n                return res\n            for ni, nj in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    seen.add((ni, nj))\n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # The number of unique paths to a cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # Initialize the first row and column with 1 because there is only 1 unique path to each cell\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus 1\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus 1\n        # The number of unique paths to the cell to the left is the number of unique paths to"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the max profit from left to right\n        ## 2. find the max profit from right to left\n        ## 3. return the max of the two\n        \n        ## 1. find the max profit from left to right\n        max_profit = 0\n        min_price = prices[0]\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            cnt = 0\n            for c in s:\n                if c == '(':\n                    cnt += 1\n                elif c == ')':\n                    if cnt > 0:\n                        cnt -= 1\n                    else:\n                        return False\n            return cnt == 0\n        \n        q = collections.deque([s])\n        seen = {s}\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] != '(' and s[i] != ')':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a min heap\n        heap = []\n        \n        # add all the head nodes to the heap\n        for l in lists:\n            if l:\n                heapq.heappush(heap, (l.val, l))\n        \n        # create a dummy node\n        dummy = ListNode()\n        curr = dummy\n        \n        # loop through the heap\n        while heap:\n            # get the smallest node\n            val, node = heapq.heappop(heap)\n            \n            # add the node to the list\n            curr.next = node\n            curr = curr.next\n            \n            # if the next node exists, add it to the heap\n            if curr.next:\n                heapq.heappush(heap, (curr.next.val, curr.next))\n        \n        # return the dummy node\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(n):\n            return n//5 + (n%5 > 0)\n        \n        lo, hi = 0, 10**18\n        while lo < hi:\n            mid = (lo + hi)//2\n            if f(mid) < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def is_palindrome(word):\n            return word == word[::-1]\n        \n        def get_index(word):\n            return [i for i, w in enumerate(words) if w == word][0]\n        \n        def get_pairs(word):\n            pairs = []\n            for i, w in enumerate(words):\n                if i == get_index(w):\n                    continue\n                if is_palindrome(w + word):\n                    pairs.append([i, get_index(w)])\n            return pairs\n        \n        return [p for word in words for p in get_pairs(word)]"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, r, c):\n            q = deque([(r, c)])\n            while q:\n                r, c = q.popleft()\n                for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                        isInfected[nr][nc] = 2\n                        q.append((nr, nc))\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for r in range(len(isInfected)):\n                    for c in range(len(isInfected[0])):\n                        if isInfected[r][c] == 1:\n                            infected.add((r, c))\n                if not infected:\n                    break\n                q = deque(infected)\n                while q:\n                    r, c = q.popleft()\n                    for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                        if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                            isInfected[nr][nc] = 2\n                            q.append((nr, nc))\n                walls += 1\n            return walls\n        \n        walls = build_walls(isInfected)\n        for r in range(len(isInfected)):\n            for c in range(len(isInfected[0])):\n                if isInfected[r][c] == 1:\n                    spread(isInfected, r, c)\n        return walls + build_walls(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += (n // i) * i + max(0, min(i - 1, n % i))\n            i *= 10\n        \n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        left_to_right = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            result.append(level)\n            left_to_right = not left_to_right\n            \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return str(h) + ':' + str(m).zfill(2)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m - 1), get_time(h + 2, m - 2), get_time(h + 3, m - 3), get_time(h + 4, m - 4), get_time(h + 5, m - 5), get_time(h + 6, m - 6), get_time(h + 7, m - 7), get_time(h + 8, m - 8), get_time(h + 9, m - 9)]\n        \n        def get_all_times(h, m):\n            if h > 11 or m > 59:\n                return []\n            return get_times(h, m) + get_all_times(h + 1, m) + get_all_times(h + 2, m)\n        \n        return get_all_times(0, turnedOn)"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, len(res[-1])):\n                temp.append(res[-1][j] + res[-1][j-1])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)]\n        heap.extend([(heightMap[i][n-1], i, n-1) for i in range(m)])\n        for i in range(n):\n            heap.extend([(heightMap[0][i], 0, i), (heightMap[m-1][i], m-1, i)])\n        \n        heapq.heapify(heap)\n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            seen.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                    ans += max(h - heightMap[ni][nj], 0)\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s)).lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uc911\uac04\uac12 \uacc4\uc0b0\n        if len(nums) % 2 == 0:\n            return [(nums[i] + nums[i+1]) / 2.0 for i in range(len(nums) - k + 1) if i % k == 0]\n        else:\n            return [nums[len(nums) // 2]]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        \n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                res = max(res, self.maxSubarray(sums, k))\n                if res == k:\n                    return k\n        \n        for r in range(m):\n            sums = [0] * n\n            for c in range(r, m):\n                for i in range(n):\n                    sums[i] += matrix[c][i]\n                res = max(res, self.maxSubarray(sums, k))\n                if res == k:\n                    return k\n        \n        return res\n    \n    def maxSubarray(self, sums, k):\n        s = set()\n        s.add(0)\n        res = float('-inf')\n        curr = 0\n        for i in sums:\n            curr += i\n            res = max(res, curr - k)\n            if res == k:\n                return k\n            if res in s:\n                return res\n            s.add(curr)\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend > 0 and divisor > 0:\n            return self.divide_positive(dividend, divisor)\n        else:\n            return -self.divide_positive(abs(dividend), abs(divisor))\n        \n    def divide_positive(self, dividend, divisor):\n        if dividend < divisor:\n            return 0\n        \n        if dividend == divisor:\n            return 1\n        \n        if dividend < divisor * 2:\n            return 1 + self.divide_positive(dividend - divisor, divisor)\n        \n        return 1 + self.divide_positive(dividend - divisor * 2, divisor * 2)"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # key: number\n        # value: index\n        nums_dict = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            # check if the complement is in the dictionary\n            if target - num in nums_dict:\n                # return the index of the complement and the current index\n                return [nums_dict[target - num], i]\n            # add the number to the dictionary\n            nums_dict[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        rest = [x for k, x in enumerate(cards) if k not in (i, j)]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_a, new_b = a + b, a - b\n                            elif op == '-':\n                                new_a, new_b = a - b, b - a\n                            elif op == '*':\n                                new_a, new_b = a * b, a / b\n                            else:\n                                new_a, new_b = b / a, a / b\n                            if new_b > 0 and new_a in rest:\n                                rest.remove(new_a)\n                                if backtrack(rest, new_b):\n                                    return True\n                            rest.append(a)\n                            rest.append(b)\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if not p:\n            return not s\n        \n        # if p is not empty, then s must not be empty\n        if not s:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] != '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] != '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] != '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] != '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] != '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] != '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] != '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*' and s[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p["}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://leetcode.com/problems/majority-element/discuss/144658/Python-O(n)-time-O(1)-space-with-explanation\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in sorted(tickets):\n            graph[from_city].append(to_city)\n        \n        # dfs\n        res = []\n        def dfs(from_city):\n            # if there is no connection, add to the result\n            if from_city not in graph:\n                return\n            # if there is no connection, add to the result\n            to_city = graph[from_city].pop()\n            dfs(to_city)\n            res.append(from_city)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l+1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r-1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. sort the buildings by left edge\n        # 2. use a priority queue to store the heights of the buildings\n        # 3. use a list to store the heights of the skyline\n        # 4. iterate through the buildings\n        # 5. if the current building is taller than the top of the priority queue, add it to the priority queue\n        # 6. if the current building is shorter than the top of the priority queue, remove it from the priority queue\n        # 7. if the current building is the same as the top of the priority queue, remove it from the priority queue\n        # 8. if the priority queue is empty, add [0, 0] to the skyline\n        # 9. if the priority queue is not empty, add the top of the priority queue to the skyline\n        # 10. if the current building is taller than the top of the skyline, remove it from the skyline\n        # 11. if the current building is shorter than the top of the skyline, add it to the skyline\n        # 12. if the current building is the same as the top of the skyline, remove it from the skyline\n        # 13. if the priority queue is empty, add [0, 0] to the skyline\n        # 14. if the priority queue is not empty, add the top of the priority queue to the skyline\n        # 15. if the current building is taller than the top of the skyline, remove it from the skyline\n        # 16. if the current building is shorter than the top of the skyline, add it to the skyline\n        # 17. if the current building is the same as the top of the skyline, remove it from the skyline\n        # 18. if the priority queue is empty, add [0, 0] to the skyline\n        # 19. if the priority queue is not empty, add the top of the priority queue to the skyline\n        # 20. if the current building is taller than the top of the skyline, remove it from the skyline\n        # 21. if the current building is shorter than the top of the skyline, add it to the skyline\n        # 22. if the current building is the same as the top of the skyline, remove it from the skyline\n        # 23. if the priority queue is empty, add [0, 0] to the skyline\n        # 24. if the priority queue is not empty, add the top of the priority queue to the skyline\n        # 25. if the current building is taller than the top of the skyline, remove it from the skyline\n        # 26. if the current building is shorter than the top of the skyline, add it to the skyline\n        # 27. if the current building is the same as the top of the skyline, remove it from the skyline\n        # 28. if the priority queue is empty, add [0, 0] to the skyline\n        # 29. if the priority queue is not empty, add the top of the priority queue to the skyline\n        # 30. if the current building is taller than the top of the skyline, remove it from the skyline\n        # 31. if the current building is shorter than the top of the skyline, add it to the skyline\n        # 32. if the current building is the same as the top of the skyline, remove it from the skyline\n        # 33. if the priority queue is empty, add [0, 0] to the skyline\n        # 34. if the priority queue is not empty, add the top of the priority queue to the skyline\n        # 35. if the current building is taller than the top of the skyline, remove it from the skyline\n        # 36. if the current building is shorter than the top of the skyline, add it to the skyline\n        # 37. if the current building is the same as the top of the skyline, remove it from the skyline\n        # 38. if the priority queue is empty, add [0, 0] to the skyline\n        # 39. if the priority queue is not empty, add the top of the priority queue to the skyline\n        # 40. if the current building is taller than the top of the skyline, remove it from the skyline\n        # 41. if the current building is shorter than the"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # reverse each word\n        for i in range(len(s)):\n            s[i] = s[i][::-1]\n        \n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 <= n <= 1000\n        # 2. 0 <= k <= 1000\n        # 3. n * (n - 1) / 2 <= k\n        # 4. n * (n - 1) / 2 - k <= n - 1\n        # 5. n * (n - 1) / 2 - k <= n - 1\n        # 6. n * (n - 1) / 2 - k <= n - 1\n        # 7. n * (n - 1) / 2 - k <= n - 1\n        # 8. n * (n - 1) / 2 - k <= n - 1\n        # 9. n * (n - 1) / 2 - k <= n - 1\n        # 10. n * (n - 1) / 2 - k <= n - 1\n        # 11. n * (n - 1) / 2 - k <= n - 1\n        # 12. n * (n - 1) / 2 - k <= n - 1\n        # 13. n * (n - 1) / 2 - k <= n - 1\n        # 14. n * (n - 1) / 2 - k <= n - 1\n        # 15. n * (n - 1) / 2 - k <= n - 1\n        # 16. n * (n - 1) / 2 - k <= n - 1\n        # 17. n * (n - 1) / 2 - k <= n - 1\n        # 18. n * (n - 1) / 2 - k <= n - 1\n        # 19. n * (n - 1) / 2 - k <= n - 1\n        # 20. n * (n - 1) / 2 - k <= n - 1\n        # 21. n * (n - 1) / 2 - k <= n - 1\n        # 22. n * (n - 1) / 2 - k <= n - 1\n        # 23. n * (n - 1) / 2 - k <= n - 1\n        # 24. n * (n - 1) / 2 - k <= n - 1\n        # 25. n * (n - 1) / 2 - k <= n - 1\n        # 26. n * (n - 1) / 2 - k <= n - 1\n        # 27. n * (n - 1) / 2 - k <= n - 1\n        # 28. n * (n - 1) / 2 - k <= n - 1\n        # 29. n * (n - 1) / 2 - k <= n - 1\n        # 30. n * (n - 1) / 2 - k <= n - 1\n        # 31. n * (n - 1) / 2 - k <= n - 1\n        # 32. n * (n - 1) / 2 - k <= n - 1\n        # 33. n * (n - 1) / 2 - k <= n - 1\n        # 34. n * (n - 1) / 2 - k <= n - 1\n        # 35. n * (n - 1) / 2 - k <= n - 1\n        # 36. n * (n - 1) / 2 - k <= n - 1\n        # 37. n * (n - 1) / 2 - k <= n - 1\n        # 38. n * (n - 1) / 2 - k <= n - 1\n        # 39. n * (n - 1) / 2 - k <= n - 1\n        # 40. n * (n - 1) / 2 - k <= n - 1\n        # 41. n * (n - 1) / 2 - k <= n - 1\n        # 42. n * (n - 1) / 2 - k <= n - 1\n        # 43."}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent = {}\n        child = {}\n        for edge in edges:\n            if edge[0] in parent:\n                child[edge[0]] = edge[1]\n            else:\n                parent[edge[0]] = edge[1]\n        \n        # find the node with only one parent\n        for edge in edges:\n            if edge[1] in parent:\n                if edge[0] in child:\n                    return [child[edge[0]], edge[1]]\n                else:\n                    return [edge[0], edge[1]]\n            else:\n                if edge[0] in child:\n                    return [child[edge[0]], edge[1]]\n                else:\n                    return [edge[0], edge[1]]\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            else:\n                for i in range(first, n):\n                    if nums[i] != nums[first]:\n                        nums[first], nums[i] = nums[i], nums[first]\n                        backtrack(first + 1)\n                        nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        nums.sort()\n        res = []\n        backtrack()\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use bit manipulation\n        ## 4. use XOR\n        ## 5. use math\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3."}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1] + grid[i][j2]\n                    if j1 > 0 and j2 > 0:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1 - 1][j2 - 1] + grid[i][j1] + grid[i][j2])\n                    if j1 < n - 1 and j2 < n - 1:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][j1 + 1][j2 + 1] + grid[i][j1] + grid[i][j2])\n        return max(dp[n - 1][j1][j2] for j1 in range(n) for j2 in range(n) if grid[n - 1][j1] == -1 or grid[n - 1][j2] == -1)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # edge case\n        if target < nums[0]:\n            return 0\n        if target > nums[-1]:\n            return len(nums)\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # return the index where it would be if it were inserted in order\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        #     else:\n        #         nums[i] = nums[i - 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        #     else:\n        #         nums[i] = nums[i - 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        #     else:\n        #         nums[i] = nums[i - 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        #     else:\n        #         nums[i] = nums[i - 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums[i] + i > nums[i - 1]:\n        #         nums[i] = nums[i - 1]\n        #     else:\n        #         nums[i] = nums[i - 1] - 1\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # for i in range(len(nums) - 2, -1, -1):\n        #     if nums[i] + i >= len(nums) - 1:\n        #         return True\n        #     if nums[i] == 0:\n        #         return False\n        #     if nums"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n        \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '11131221133112132132221'\n        \n        if n == 12:\n            return '311311222123213221131112311312211'\n        \n        if n == 13:\n            return '132113111231131122112131221131122211'\n        \n        if n == 14:\n            return '1113122113311213213222123132113312311312211211312211'\n        \n        if n == 15:\n            return '3113112221232132211311123113122112132132211331121322211'\n        \n        if n == 16:\n            return '1321131112311311221121312211311222112132132211331121322211211312211'\n        \n        if n == 17:\n            return '111312211331121321322212313211331231131221121321322113311213222112113122112132132211331121322211'\n        \n        if n == 18:\n            return '3113112221232132211311123113122112132132211331121322211213213221133112132221121131221121321322113311213222112113122112132132211331121322211'\n        \n        if n == 19:\n            return '13211311123113112211213122113112221121321322113311213222112132132211331121322211211312211213213221133112132221121131221121321322113311213222112113122112132132211331121322211'"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max sum of the subarray\n        # find the min sum of the subarray\n        # binary search the max sum\n        # binary search the min sum\n        # find the mid sum\n        # find the number of subarray with the mid sum\n        # if the number of subarray with the mid sum is less than k, then the mid sum is too big\n        # if the number of subarray with the mid sum is greater than k, then the mid sum is too small\n        # if the number of subarray with the mid sum is equal to k, then the mid sum is the answer\n        \n        # find the max sum of the subarray\n        def find_max_sum(nums, k):\n            max_sum = 0\n            curr_sum = 0\n            for num in nums:\n                curr_sum += num\n                if curr_sum > max_sum:\n                    max_sum = curr_sum\n                if curr_sum > k:\n                    curr_sum = num\n            return max_sum\n        \n        # find the min sum of the subarray\n        def find_min_sum(nums, k):\n            min_sum = sum(nums)\n            curr_sum = 0\n            for num in nums:\n                curr_sum += num\n                if curr_sum < min_sum:\n                    min_sum = curr_sum\n                if curr_sum > k:\n                    curr_sum = num\n            return min_sum\n        \n        # binary search the max sum\n        max_sum = find_max_sum(nums, k)\n        min_sum = find_min_sum(nums, k)\n        if k == 1:\n            return max_sum\n        if max_sum < min_sum:\n            return max_sum\n        \n        while min_sum < max_sum:\n            mid_sum = (max_sum + min_sum) // 2\n            num_subarrays = self.find_num_subarrays(nums, mid_sum, k)\n            if num_subarrays > k:\n                min_sum = mid_sum + 1\n            else:\n                max_sum = mid_sum\n        return min_sum\n    \n    def find_num_subarrays(self, nums, mid_sum, k):\n        num_subarrays = 1\n        curr_sum = 0\n        for num in nums:\n            curr_sum += num\n            if curr_sum > mid_sum:\n                num_subarrays += 1\n                curr_sum = num\n        return num_subarrays"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        pivot = self.find_pivot(nums)\n        \n        # if the pivot is not found, return -1\n        if pivot == -1:\n            return self.binary_search(nums, target)\n        \n        # if the target is less than the first element, search the right side\n        if target >= nums[0]:\n            return self.binary_search(nums[pivot:], target)\n        \n        # if the target is greater than the first element, search the left side\n        return self.binary_search(nums[:pivot], target)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return mid + 1\n            \n            if nums[mid] < nums[mid - 1]:\n                return mid\n            \n            if nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1\n    \n    def binary_search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}\n        \n        def backtrack(combination, next_digits, phone):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map the next available digit\n                for letter in phone[next_digits[0]]:\n                    # append the letter to the combination\n                    # and proceed to the next available digit\n                    backtrack(combination + letter, next_digits[1:], phone)\n        \n        output = []\n        backtrack(\"\", digits, phone)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of n\n        length = len(n)\n        \n        # 2. get the left and right part of n\n        left = n[:length//2]\n        right = n[length//2:]\n        \n        # 3. get the left and right part of n\n        left_list = [int(left), int(left)-1, int(left)+1]\n        right_list = [int(right), int(right)-1, int(right)+1]\n        \n        # 4. get the closest palindrome\n        closest_palindrome = self.get_closest_palindrome(left_list, right_list, n)\n        \n        # 5. return the closest palindrome\n        return str(closest_palindrome)\n    \n    def get_closest_palindrome(self, left_list, right_list, n):\n        # 1. get the closest palindrome\n        closest_palindrome = None\n        closest_diff = float('inf')\n        \n        # 2. get the closest palindrome\n        for left in left_list:\n            for right in right_list:\n                palindrome = str(left) + str(right)\n                diff = abs(int(palindrome) - int(n))\n                if diff < closest_diff:\n                    closest_palindrome = palindrome\n                    closest_diff = diff\n        \n        # 3. if the closest palindrome is n, return the closest palindrome in the left_list\n        if closest_palindrome == n:\n            closest_palindrome = min(left_list, key=lambda x: abs(x - int(n)))\n        \n        # 4. if the closest palindrome is 0, return 0\n        if closest_palindrome == '0':\n            closest_palindrome = '0'\n        \n        # 5. return the closest palindrome\n        return closest_palindrome"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        left, right = 0, n-1\n        top, bottom = 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        else:\n            return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        # transpose\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(n):\n            for j in range(n // 2):\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in encompress(score_sorted):\n            score_rank[s] = i\n        \n        # create a list of ranks\n        ranks = []\n        for s in score:\n            ranks.append(score_rank[s])\n        \n        # create a list of ranks\n        ranks = sorted(ranks, reverse=True)\n        \n        # create a list of ranks\n        ranks = [str(r + 1) for r in ranks]\n        \n        # create a list of ranks\n        ranks = [ranks[r - 1] if r <= len(ranks) else str(r) for r in ranks]\n        \n        # create a list of ranks\n        ranks = [r + \" Medal\" if r == \"1\" else r for r in ranks]\n        \n        # return the list of ranks\n        return ranks"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc788\ub294\uc9c0 \ud655\uc778\ud558\uace0 \uc788\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \uc804\uae4c\uc9c0\uc758 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 2. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 3. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 4. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 5. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 6. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 7. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 8. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 9. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 10. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 11. \uc911\ubcf5\ub418\ub294 \ubb38\uc790\uac00 \uc5c6\uc73c\uba74 \uc911\ubcf5\ub418\ub294 \ubb38\uc790 \ub4a4\ubd80\ud130 \uae38\uc774\ub97c \uad6c\ud55c\ub2e4.\n        # 12. \uc911\ubcf5\ub418\ub294"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_dict = {}\n        for word in word_dict:\n            word_dict_len_count_dict[word] = 0\n        \n        for i in range(0, len(s) - word_len * word_count + 1):\n            word_dict_len_count_dict[s[i:i+word_len]] += 1\n            if word_dict_len_count_dict[s[i:i+word_len]] > word_dict[s[i:i+word_len]]:\n                word_dict_len_count_dict[s[i:i+word_len]] = word_dict[s[i:i+word_len]]\n            if word_dict_len_count_dict[s[i:i+word_len]] == word_count:\n                word_dict_len_count_dict[s[i:i+word_len]] -= 1\n                word_dict_len_count_dict[s[i+word_len*(word_count-1):i+word_len*(word_count-1)+word_len]] += 1\n                if word_dict_len_count_dict[s[i+word_len*(word_count-1):i+word_len*(word_count-1)+word_len]] > word_dict[s[i+word_len*(word_count-1):i+word_len*(word_count-1)+word_len]]:\n                    word_dict_len_count_dict[s[i+word_len*(word_count-1):i+word_len*(word_count-1)+word_len]] = word_dict[s[i+word_len*(word_count-1):i+word_len*(word_count-1)+word_len]]\n                if word_dict_len_count_dict[s[i+word_len*(word_count-1):i+word_len*(word_count-1)+word_len]] == word_count:\n                    word_dict_len_count_dict[s[i+word_len*(word_count-1):i+word_len*(word_count-1)+word_len]] -= 1\n                    word_dict_len_count_dict[s[i+word_len*(word_count-2):i+word_len*(word_count-2)+word_len]] += 1\n                    if word_dict_len_count_dict[s[i+word_len*(word_count-2):i+word_len*(word_count-2)+word_len]] > word_dict[s[i+word_len*(word_count-2):i+word_len*(word_count-2)+word_len]]:\n                        word_dict_len_count_dict[s[i+word_len*(word_count-2):i+word_len*(word_count-2)+word_len]] = word_dict[s[i+word_len*(word_count-2):i+word_len*(word_count-2)+word_len]]\n                    if word_dict_len_count_dict[s[i+word_len*(word_count-2):i+word_len*(word_count-2)+word_len]] == word_count:\n                        word_dict_len_count_dict[s[i+word_len*(word_count-2):i+word_len*(word_count-2)+word_len]] -= 1\n                        word_dict_len_count_dict[s[i+word_len*(word_count-3):i+word_len*(word_count-3)+word_len]] += 1\n                        if word_dict_len_count_dict[s[i+word_len*(word_count-3):i+word_len*(word_count-3)+word_len]] > word"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = max(arr)\n        max_idx = arr.index(max_val)\n        max_val_count = 1\n        for i in range(max_idx):\n            if arr[i] == max_val:\n                max_val_count += 1\n        return max_val_count"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head\n        while cur:\n            if cur.next and cur.val > cur.next.val:\n                prev = dummy\n                while prev.next.val < cur.next.val:\n                    prev = prev.next\n                cur.next, cur.next.next, prev.next = cur.next.next, cur.next, prev.next\n            else:\n                cur = cur.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            while i <= mid:\n                while j <= right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n                i += 1\n            i = left\n            j = mid + 1\n            tmp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    tmp.append(nums[i])\n                    i += 1\n                else:\n                    tmp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                tmp.append(nums[i])\n                i += 1\n            while j <= right:\n                tmp.append(nums[j])\n                j += 1\n            nums[left:right + 1] = tmp\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return (sx == tx and sy <= ty and (ty - sy) % sx == 0) or (sy == ty and sx <= tx and (tx - sx) % sy == 0)"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if i < len(v2):\n                    if v1[i] < v2[i]:\n                        return -1\n                    elif v1[i] > v2[i]:\n                        return 1\n                else:\n                    if v1[i] > 0:\n                        return 1\n            else:\n                if i < len(v2):\n                    if v2[i] > 0:\n                        return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, end in courses:\n            # add to priority queue\n            heapq.heappush(pq, (-duration, end))\n            \n            # add to total time\n            total += duration\n            \n            # if total time exceeds end date, remove from priority queue\n            while total > end:\n                total -= heapq.heappop(pq)[0]\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr.next)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, end):\n        curr = prev.next\n        prev.next = None\n        while curr != end:\n            nxt = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = nxt\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        \n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set to store the numbers\n        # 2. use set to store the numbers\n        # 3. use set to store the numbers\n        # 4. use set to store the numbers\n        # 5. use set to store the numbers\n        # 6. use set to store the numbers\n        # 7. use set to store the numbers\n        # 8. use set to store the numbers\n        # 9. use set to store the numbers\n        # 10. use set to store the numbers\n        # 11. use set to store the numbers\n        # 12. use set to store the numbers\n        # 13. use set to store the numbers\n        # 14. use set to store the numbers\n        # 15. use set to store the numbers\n        # 16. use set to store the numbers\n        # 17. use set to store the numbers\n        # 18. use set to store the numbers\n        # 19. use set to store the numbers\n        # 20. use set to store the numbers\n        # 21. use set to store the numbers\n        # 22. use set to store the numbers\n        # 23. use set to store the numbers\n        # 24. use set to store the numbers\n        # 25. use set to store the numbers\n        # 26. use set to store the numbers\n        # 27. use set to store the numbers\n        # 28. use set to store the numbers\n        # 29. use set to store the numbers\n        # 30. use set to store the numbers\n        # 31. use set to store the numbers\n        # 32. use set to store the numbers\n        # 33. use set to store the numbers\n        # 34. use set to store the numbers\n        # 35. use set to store the numbers\n        # 36. use set to store the numbers\n        # 37. use set to store the numbers\n        # 38. use set to store the numbers\n        # 39. use set to store the numbers\n        # 40. use set to store the numbers\n        # 41. use set to store the numbers\n        # 42. use set to store the numbers\n        # 43. use set to store the numbers\n        # 44. use set to store the numbers\n        # 45. use set to store the numbers\n        # 46. use set to store the numbers\n        # 47. use set to store the numbers\n        # 48. use set to store the numbers\n        # 49. use set to store the numbers\n        # 50. use set to store the numbers\n        # 51. use set to store the numbers\n        # 52. use set to store the numbers\n        # 53. use set to store the numbers\n        # 54. use set to store the numbers\n        # 55. use set to store the numbers\n        # 56. use set to store the numbers\n        # 57. use set to store the numbers\n        # 58. use set to store the numbers\n        # 59. use set to store the numbers\n        # 60. use set to store the numbers\n        # 61. use set to store the numbers\n        # 62. use set to store the numbers\n        # 63. use set to store the numbers\n        # 64. use set to store the numbers\n        # 65. use set to store the numbers\n        # 66. use set to store the numbers\n        # 67. use set to store the numbers\n        # 68. use set to store the numbers\n        # 69. use set to store the numbers\n        # 70. use set to store the numbers\n        # 71. use set to store the numbers\n        # 72. use set to store the numbers\n        # 73. use set to store the numbers\n        # 74. use set to store the numbers\n        # 75. use set to store the numbers\n        # 76. use set to store the numbers\n        # 77. use set to store the numbers\n        # 78. use set to store the numbers\n        # 79. use set to store the numbers\n        # 80."}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict for each sticker\n        # 2. build a dict for each letter in target\n        # 3. build a dict for each letter in target\n        # 4. build a dict for each letter in target\n        # 5. build a dict for each letter in target\n        # 6. build a dict for each letter in target\n        # 7. build a dict for each letter in target\n        # 8. build a dict for each letter in target\n        # 9. build a dict for each letter in target\n        # 10. build a dict for each letter in target\n        # 11. build a dict for each letter in target\n        # 12. build a dict for each letter in target\n        # 13. build a dict for each letter in target\n        # 14. build a dict for each letter in target\n        # 15. build a dict for each letter in target\n        # 16. build a dict for each letter in target\n        # 17. build a dict for each letter in target\n        # 18. build a dict for each letter in target\n        # 19. build a dict for each letter in target\n        # 20. build a dict for each letter in target\n        # 21. build a dict for each letter in target\n        # 22. build a dict for each letter in target\n        # 23. build a dict for each letter in target\n        # 24. build a dict for each letter in target\n        # 25. build a dict for each letter in target\n        # 26. build a dict for each letter in target\n        # 27. build a dict for each letter in target\n        # 28. build a dict for each letter in target\n        # 29. build a dict for each letter in target\n        # 30. build a dict for each letter in target\n        # 31. build a dict for each letter in target\n        # 32. build a dict for each letter in target\n        # 33. build a dict for each letter in target\n        # 34. build a dict for each letter in target\n        # 35. build a dict for each letter in target\n        # 36. build a dict for each letter in target\n        # 37. build a dict for each letter in target\n        # 38. build a dict for each letter in target\n        # 39. build a dict for each letter in target\n        # 40. build a dict for each letter in target\n        # 41. build a dict for each letter in target\n        # 42. build a dict for each letter in target\n        # 43. build a dict for each letter in target\n        # 44. build a dict for each letter in target\n        # 45. build a dict for each letter in target\n        # 46. build a dict for each letter in target\n        # 47. build a dict for each letter in target\n        # 48. build a dict for each letter in target\n        # 49. build a dict for each letter in target\n        # 50. build a dict for each letter in target\n        # 51. build a dict for each letter in target\n        # 52. build a dict for each letter in target\n        # 53. build a dict for each letter in target\n        # 54. build a dict for each letter in target\n        # 55. build a dict for each letter in target\n        # 56. build a dict for each letter in target\n        # 57. build a dict for each letter in target\n        # 58. build a dict for each letter in target\n        # 59. build a dict for each letter in target\n        # 60. build a dict for each letter in target\n        # 61. build a dict for each letter in target\n        # 62. build a dict for each letter in target\n        # 63. build a dict for each letter in target\n        # 64. build a dict for each letter in target\n        # 65. build a dict for each letter in target\n        # 66. build a dict for each letter in target\n        # 67. build a dict for each letter in target\n        # 68. build a dict for each letter in target\n        # 69. build a dict for each letter in target"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = j + 1\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to map roman numerals to their integer values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # initialize the result to 0\n        result = 0\n        \n        # loop through the string in reverse order\n        for i in range(len(s) - 1):\n            # if the current character is less than the next character, subtract it from the result\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # otherwise, add the current character to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # add the last character to the result\n        result += roman_dict[s[-1]]\n        \n        # return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), max(nums[1], nums[0])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), max(nums[1], max(nums[0], nums[2])), max(nums[2], max(nums[0], nums[1]))]\n        \n        max_list = []\n        max_list.append(max(nums[0], nums[1]))\n        \n        for i in range(2, len(nums)):\n            if i >= k:\n                max_list.append(max(max_list[i-k:i]))\n            max_list.append(max(nums[i], max_list[i-1]))\n        \n        return max_list"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge nums1 and nums2 into nums\n        nums = nums1 + nums2\n        nums.sort()\n        \n        # find median\n        if len(nums) % 2 == 1:\n            return nums[len(nums) // 2]\n        else:\n            return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2.0"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * (area / 2)\n        # 2. 2 * (area // 2)\n        # 3. 2 * math.sqrt(area)\n        # 4. 2 * math.sqrt(area) + 1\n        # 5. 2 * math.sqrt(area) + 1\n        # 6. 2 * math.sqrt(area) + 2\n        # 7. 2 * math.sqrt(area) + 2\n        # 8. 2 * math.sqrt(area) + 3\n        # 9. 2 * math.sqrt(area) + 3\n        # 10. 2 * math.sqrt(area) + 4\n        # 11. 2 * math.sqrt(area) + 4\n        # 12. 2 * math.sqrt(area) + 5\n        # 13. 2 * math.sqrt(area) + 5\n        # 14. 2 * math.sqrt(area) + 6\n        # 15. 2 * math.sqrt(area) + 6\n        # 16. 2 * math.sqrt(area) + 7\n        # 17. 2 * math.sqrt(area) + 7\n        # 18. 2 * math.sqrt(area) + 8\n        # 19. 2 * math.sqrt(area) + 8\n        # 20. 2 * math.sqrt(area) + 9\n        # 21. 2 * math.sqrt(area) + 9\n        # 22. 2 * math.sqrt(area) + 10\n        # 23. 2 * math.sqrt(area) + 10\n        # 24. 2 * math.sqrt(area) + 11\n        # 25. 2 * math.sqrt(area) + 11\n        # 26. 2 * math.sqrt(area) + 12\n        # 27. 2 * math.sqrt(area) + 12\n        # 28. 2 * math.sqrt(area) + 13\n        # 29. 2 * math.sqrt(area) + 13\n        # 30. 2 * math.sqrt(area) + 14\n        # 31. 2 * math.sqrt(area) + 14\n        # 32. 2 * math.sqrt(area) + 15\n        # 33. 2 * math.sqrt(area) + 15\n        # 34. 2 * math.sqrt(area) + 16\n        # 35. 2 * math.sqrt(area) + 16\n        # 36. 2 * math.sqrt(area) + 17\n        # 37. 2 * math.sqrt(area) + 17\n        # 38. 2 * math.sqrt(area) + 18\n        # 39. 2 * math.sqrt(area) + 18\n        # 40. 2 * math.sqrt(area) + 19\n        # 41. 2 * math.sqrt(area) + 19\n        # 42. 2 * math.sqrt(area) + 20\n        # 43. 2 * math.sqrt(area) + 20\n        # 44. 2 * math.sqrt(area) + 21\n        # 45. 2 * math.sqrt(area) + 21\n        # 46. 2 * math.sqrt(area) + 22\n        # 47. 2 * math.sqrt(area) + 22\n        # 48. 2 * math.sqrt(area) + 23\n        # 49. 2 * math.sqrt(area) + 23\n        # 50. 2 * math.sqrt(area) + 24\n        # 51. 2 * math.sqrt(area) + 24\n        # 52. 2 * math.sqrt(area) + 25\n        # 53. 2 * math.sqrt(area) + 25\n        # 54. 2 * math.sqrt(area) + 26\n        # 55. 2 * math.sqrt(area) + 26\n        # 56. 2 * math.sqrt(area)"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"_\" + word[i+1:]].append(word)\n        \n        # build the queue\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        found = False\n        \n        # build the shortest path\n        shortest_path = {}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for j in range(26):\n                    neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                    if neighbor in graph:\n                        if neighbor == endWord:\n                            found = True\n                        for n in graph[neighbor]:\n                            if n not in shortest_path:\n                                shortest_path[n] = word + [n]\n                                queue.append(n)\n                        if found:\n                            break\n        if not found:\n            return []\n        \n        # build the shortest path\n        res = []\n        while endWord in shortest_path:\n            res.append(shortest_path[endWord][::-1])\n            endWord = shortest_path[endWord][0]\n        return res[::-1]"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n            else:\n                res += [r + [nums[i]] for r in res[len(res)-1:]]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num2 = stack.pop()\n                num1 = stack.pop()\n                stack.append(int(float(num1) / num2))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if (x_min, y_min) not in rectangles or (x_max, y_min) not in rectangles or (x_min, y_max) not in rectangles or (x_max, y_max) not in rectangles:\n            return False\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_flat = [board[i][j] for i in range(2) for j in range(3)]\n        \n        # convert board_flat to a string\n        board_flat_str = ''.join(str(x) for x in board_flat)\n        \n        # convert board_flat_str to a tuple\n        board_flat_tuple = tuple(board_flat_str)\n        \n        # convert board_flat_tuple to a set\n        board_flat_set = set(board_flat_tuple)\n        \n        # convert board_flat_set to a list\n        board_flat_list = list(board_flat_set)\n        \n        # convert board_flat_list to a dictionary\n        board_flat_dict = {board_flat_list[i]: i for i in range(len(board_flat_list))}\n        \n        # convert board_flat_dict to a tuple\n        board_flat_tuple = tuple(board_flat_dict)\n        \n        # convert board_flat_tuple to a set\n        board_flat_set = set(board_flat_tuple)\n        \n        # convert board_flat_set to a list\n        board_flat_list = list(board_flat_set)\n        \n        # convert board_flat_list to a dictionary\n        board_flat_dict = {board_flat_list[i]: i for i in range(len(board_flat_list))}\n        \n        # convert board_flat_dict to a tuple\n        board_flat_tuple = tuple(board_flat_dict)\n        \n        # convert board_flat_tuple to a set\n        board_flat_set = set(board_flat_tuple)\n        \n        # convert board_flat_set to a list\n        board_flat_list = list(board_flat_set)\n        \n        # convert board_flat_list to a dictionary\n        board_flat_dict = {board_flat_list[i]: i for i in range(len(board_flat_list))}\n        \n        # convert board_flat_dict to a tuple\n        board_flat_tuple = tuple(board_flat_dict)\n        \n        # convert board_flat_tuple to a set\n        board_flat_set = set(board_flat_tuple)\n        \n        # convert board_flat_set to a list\n        board_flat_list = list(board_flat_set)\n        \n        # convert board_flat_list to a dictionary\n        board_flat_dict = {board_flat_list[i]: i for i in range(len(board_flat_list))}\n        \n        # convert board_flat_dict to a tuple\n        board_flat_tuple = tuple(board_flat_dict)\n        \n        # convert board_flat_tuple to a set\n        board_flat_set = set(board_flat_tuple)\n        \n        # convert board_flat_set to a list\n        board_flat_list = list(board_flat_set)\n        \n        # convert board_flat_list to a dictionary\n        board_flat_dict = {board_flat_list[i]: i for i in range(len(board_flat_list))}\n        \n        # convert board_flat_dict to a tuple\n        board_flat_tuple = tuple(board_flat_dict)\n        \n        # convert board_flat_tuple to a set\n        board_flat_set = set(board_flat_tuple)\n        \n        # convert board_flat_set to a list\n        board_flat_list = list(board_flat_set)\n        \n        # convert board_flat_list to a dictionary\n        board_flat_dict = {board_flat_list[i]: i for i in range(len(board_flat_list))}\n        \n        # convert board_flat_dict to a tuple\n        board_flat_tuple = tuple(board_flat_dict)\n        \n        # convert board_flat_tuple to a set\n        board_flat_set = set(board_flat_tuple)\n        \n        # convert board_flat_set to a list\n        board_flat_list = list(board_flat_set)\n        \n        # convert board_flat_list to a dictionary\n        board_flat_dict = {board_"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in the first half\n        if nums[pivot] == target:\n            return True\n        \n        # if the target is in the second half of the array, search in the second half\n        if nums[len(nums)-1] == target:\n            return True\n        \n        # if the target is not in the first half of the array, search in the second half\n        if nums[pivot] < target:\n            return self.binary_search(nums[pivot:], target)\n        \n        # if the target is not in the second half of the array, search in the first half\n        return self.binary_search(nums[:pivot], target)\n        \n    def find_pivot(self, nums):\n        \"\"\"\n        Find the pivot in the rotated sorted array\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left\n    \n    def binary_search(self, nums, target):\n        \"\"\"\n        Binary search in the rotated sorted array\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n                \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        prev = None\n        min_diff = float('inf')\n        for n in inorder(root):\n            if prev:\n                min_diff = min(min_diff, n - prev)\n            prev = n\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if len(left) > len(right):\n                return [root.val] + left\n            elif len(left) < len(right):\n                return [root.val] + right\n            else:\n                return [root.val] + left + right\n        \n        return dfs(root)"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. add the remaining characters to the end of the password\n        # 5. repeat steps 2 and 3 until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        down = True\n        \n        for c in s:\n            res[i] += c\n            if i == 0:\n                down = True\n            elif i == numRows - 1:\n                down = False\n            if down:\n                i += 1\n            else:\n                i -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max height\n        max_height = max(height)\n        \n        # 2. find the left and right max height\n        left_max = [0] * len(height)\n        right_max = [0] * len(height)\n        \n        for i in range(1, len(height)):\n            left_max[i] = max(left_max[i-1], height[i-1])\n        \n        for i in range(len(height)-2, -1, -1):\n            right_max[i] = max(right_max[i+1], height[i+1])\n        \n        # 3. find the water\n        water = 0\n        for i in range(len(height)):\n            water += min(left_max[i], right_max[i]) - height[i]\n        \n        return water"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to result\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2. iterate over nums\n        ## 3. if nums[i] is not in set, add it to set\n        ## 4. return result\n        \n        ## O(1) space\n        ## O(n) time\n        ## 1. create a set of nums\n        ## 2"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. use binary search to find the number of smaller elements to the right of each element\n        # 3. use binary search to find the number of smaller elements to the left of each element\n        # 4. use binary search to find the number of smaller elements to the left of each element\n        # 5. use binary search to find the number of smaller elements to the right of each element\n        # 6. use binary search to find the number of smaller elements to the right of each element\n        # 7. use binary search to find the number of smaller elements to the left of each element\n        # 8. use binary search to find the number of smaller elements to the left of each element\n        # 9. use binary search to find the number of smaller elements to the right of each element\n        # 10. use binary search to find the number of smaller elements to the right of each element\n        # 11. use binary search to find the number of smaller elements to the left of each element\n        # 12. use binary search to find the number of smaller elements to the left of each element\n        # 13. use binary search to find the number of smaller elements to the right of each element\n        # 14. use binary search to find the number of smaller elements to the right of each element\n        # 15. use binary search to find the number of smaller elements to the left of each element\n        # 16. use binary search to find the number of smaller elements to the left of each element\n        # 17. use binary search to find the number of smaller elements to the right of each element\n        # 18. use binary search to find the number of smaller elements to the right of each element\n        # 19. use binary search to find the number of smaller elements to the left of each element\n        # 20. use binary search to find the number of smaller elements to the left of each element\n        # 21. use binary search to find the number of smaller elements to the right of each element\n        # 22. use binary search to find the number of smaller elements to the right of each element\n        # 23. use binary search to find the number of smaller elements to the left of each element\n        # 24. use binary search to find the number of smaller elements to the left of each element\n        # 25. use binary search to find the number of smaller elements to the right of each element\n        # 26. use binary search to find the number of smaller elements to the right of each element\n        # 27. use binary search to find the number of smaller elements to the left of each element\n        # 28. use binary search to find the number of smaller elements to the left of each element\n        # 29. use binary search to find the number of smaller elements to the right of each element\n        # 30. use binary search to find the number of smaller elements to the right of each element\n        # 31. use binary search to find the number of smaller elements to the left of each element\n        # 32. use binary search to find the number of smaller elements to the left of each element\n        # 33. use binary search to find the number of smaller elements to the right of each element\n        # 34. use binary search to find the number of smaller elements to the right of each element\n        # 35. use binary search to find the number of smaller elements to the left of each element\n        # 36. use binary search to find the number of smaller elements to the left of each element\n        # 37. use binary search to find the number of smaller elements to the right of each element\n        # 38. use binary search to find the number of smaller elements to the right of each element\n        # 39. use binary search to find the number of smaller elements to the left of each element\n        # 40. use binary search to find the number of smaller elements to the left of each element\n        # 41. use binary search to find the number of smaller elements to the right of each element\n        # 42. use binary search to find the number of smaller elements to the right of each element\n        # 43. use binary search to find the number of smaller elements to the left of each element\n        # 44. use binary search to find the number of smaller elements to the left of each element\n        # 45. use binary search to find the number of smaller elements to the right of each element\n        # 46. use binary search to find"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = [intervals[0][1]-1]\n        for i in range(1, len(intervals)):\n            if intervals[i][0] > ans[-1]:\n                ans.append(intervals[i][1]-1)\n            else:\n                ans.append(ans[-1]-1)\n        return len(ans)"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            left = self.generateParenthesis(i)\n            right = self.generateParenthesis(n - i - 1)\n            for l in left:\n                for r in right:\n                    res.append('({}){}'.format(l, r))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        nums_sum = 0\n        \n        # iterate\n        while nums_sum < n:\n            if i < len(nums) and nums[i] <= nums_sum + 1:\n                nums_sum += nums[i]\n                i += 1\n            else:\n                patches += 1\n                nums_sum += nums_sum + 1\n        \n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. stack\n        # 6. dp\n        # 7. greedy\n        # 8. stack\n        # 9. dp\n        # 10. greedy\n        # 11. stack\n        # 12. dp\n        # 13. greedy\n        # 14. stack\n        # 15. dp\n        # 16. greedy\n        # 17. stack\n        # 18. dp\n        # 19. greedy\n        # 20. stack\n        # 21. dp\n        # 22. greedy\n        # 23. stack\n        # 24. dp\n        # 25. greedy\n        # 26. stack\n        # 27. dp\n        # 28. greedy\n        # 29. stack\n        # 30. dp\n        # 31. greedy\n        # 32. stack\n        # 33. dp\n        # 34. greedy\n        # 35. stack\n        # 36. dp\n        # 37. greedy\n        # 38. stack\n        # 39. dp\n        # 40. greedy\n        # 41. stack\n        # 42. dp\n        # 43. greedy\n        # 44. stack\n        # 45. dp\n        # 46. greedy\n        # 47. stack\n        # 48. dp\n        # 49. greedy\n        # 50. stack\n        # 51. dp\n        # 52. greedy\n        # 53. stack\n        # 54. dp\n        # 55. greedy\n        # 56. stack\n        # 57. dp\n        # 58. greedy\n        # 59. stack\n        # 60. dp\n        # 61. greedy\n        # 62. stack\n        # 63. dp\n        # 64. greedy\n        # 65. stack\n        # 66. dp\n        # 67. greedy\n        # 68. stack\n        # 69. dp\n        # 70. greedy\n        # 71. stack\n        # 72. dp\n        # 73. greedy\n        # 74. stack\n        # 75. dp\n        # 76. greedy\n        # 77. stack\n        # 78. dp\n        # 79. greedy\n        # 80. stack\n        # 81. dp\n        # 82. greedy\n        # 83. stack\n        # 84. dp\n        # 85. greedy\n        # 86. stack\n        # 87. dp\n        # 88. greedy\n        # 89. stack\n        # 90. dp\n        # 91. greedy\n        # 92. stack\n        # 93. dp\n        # 94. greedy\n        # 95. stack\n        # 96. dp\n        # 97. greedy\n        # 98. stack\n        # 99. dp\n        # 100. greedy\n        # 101. stack\n        # 102. dp\n        # 103. greedy\n        # 104. stack\n        # 105. dp\n        # 106. greedy\n        # 107. stack\n        # 108. dp\n        # 109. greedy\n        # 110. stack\n        # 111. dp\n        # 112. greedy\n        # 113. stack\n        # 114. dp\n        # 115. greedy\n        # 116. stack\n        # 117. d"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        result = str(sign * quotient) + \".\"\n        \n        seen = {}\n        \n        while remainder != 0:\n            if remainder in seen:\n                result += \")\"\n                break\n            seen[remainder] = len(result)\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            result += str(quotient)\n        \n        if remainder == 0:\n            return result\n        else:\n            result += \"(\"\n            result += str(seen[remainder])\n            return result"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        dp = []\n        \n        for i in range(len(envelopes)):\n            if not dp or dp[-1] < envelopes[i][1]:\n                dp.append(envelopes[i][1])\n            else:\n                left, right = 0, len(dp) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid\n                dp[left] = envelopes[i][1]\n        \n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row_zero = False\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    if i == 0:\n                        row_zero = True\n                    else:\n                        matrix[i][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if matrix[0][0] == 0:\n            for i in range(m):\n                matrix[i][0] = 0\n        \n        if row_zero:\n            for i in range(m):\n                matrix[i][0] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0, head)\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = head\n        \n        # move the fast pointer n steps\n        for i in range(n):\n            fast = fast.next\n        \n        # move both the slow and fast pointers until fast reaches the end\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the nth node from the end\n        slow.next = slow.next.next\n        \n        # return the modified head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        ## 4. use set\n        ## 5. use dict\n        ## 6. use list\n        ## 7. use set\n        ## 8. use dict\n        ## 9. use list\n        ## 10. use set\n        ## 11. use dict\n        ## 12. use list\n        ## 13. use set\n        ## 14. use dict\n        ## 15. use list\n        ## 16. use set\n        ## 17. use dict\n        ## 18. use list\n        ## 19. use set\n        ## 20. use dict\n        ## 21. use list\n        ## 22. use set\n        ## 23. use dict\n        ## 24. use list\n        ## 25. use set\n        ## 26. use dict\n        ## 27. use list\n        ## 28. use set\n        ## 29. use dict\n        ## 30. use list\n        ## 31. use set\n        ## 32. use dict\n        ## 33. use list\n        ## 34. use set\n        ## 35. use dict\n        ## 36. use list\n        ## 37. use set\n        ## 38. use dict\n        ## 39. use list\n        ## 40. use set\n        ## 41. use dict\n        ## 42. use list\n        ## 43. use set\n        ## 44. use dict\n        ## 45. use list\n        ## 46. use set\n        ## 47. use dict\n        ## 48. use list\n        ## 49. use set\n        ## 50. use dict\n        ## 51. use list\n        ## 52. use set\n        ## 53. use dict\n        ## 54. use list\n        ## 55. use set\n        ## 56. use dict\n        ## 57. use list\n        ## 58. use set\n        ## 59. use dict\n        ## 60. use list\n        ## 61. use set\n        ## 62. use dict\n        ## 63. use list\n        ## 64. use set\n        ## 65. use dict\n        ## 66. use list\n        ## 67. use set\n        ## 68. use dict\n        ## 69. use list\n        ## 70. use set\n        ## 71. use dict\n        ## 72. use list\n        ## 73. use set\n        ## 74. use dict\n        ## 75. use list\n        ## 76. use set\n        ## 77. use dict\n        ## 78. use list\n        ## 79. use set\n        ## 80. use dict\n        ## 81. use list\n        ## 82. use set\n        ## 83. use dict\n        ## 84. use list\n        ## 85. use set\n        ## 86. use dict\n        ## 87. use list\n        ## 88. use set\n        ## 89. use dict\n        ## 90. use list\n        ## 91. use set\n        ## 92. use dict\n        ## 93. use list\n        ## 94. use set\n        ## 95. use dict\n        ## 96. use list\n        ## 97. use set\n        ## 98. use dict\n        ## 99. use list\n        ## 100. use set\n        ## 101. use dict\n        ## 102. use list\n        ## 103. use set"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines) % len(machines) != 0:\n            return -1\n        \n        avg = sum(machines) / len(machines)\n        ans = 0\n        curr = 0\n        for i in machines:\n            curr += i - avg\n            ans = max(ans, abs(curr))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.next.val)\n        slow.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1, list2 = list2, list1\n        \n        head = list1\n        \n        while list1.next is not None and list2 is not None:\n            if list1.next.val < list2.val:\n                list1 = list1.next\n            else:\n                temp = list1.next\n                list1.next = list2\n                list2 = list2.next\n                list1.next.next = temp\n                list1 = list1.next\n        \n        if list2 is not None:\n            list1.next = list2\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i, h in enumerate(heights):\n            while stack and h < heights[stack[-1]]:\n                top = stack.pop()\n                max_area = max(max_area, (i - stack[-1] - 1) * heights[top])\n            stack.append(i)\n        \n        while stack:\n            top = stack.pop()\n            max_area = max(max_area, (len(heights) - stack[-1] - 1) * heights[top])\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # add the current combination to the output\n            output.append(curr[:])\n            \n            for i in range(first, len(nums)):\n                # add nums[i] to the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack, remove the current integer\n                curr.pop()\n        \n        output = []\n        backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element\n        # 4. else, return the largest element\n        \n        # 1. find the index of the smallest element\n        # 2. find the index of the largest element\n        # 3. if the smallest element is larger than the largest element, return the smallest element"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        if s[0] in ('+', '-') and len(s) > 1:\n            s = s[1:]\n        \n        if not s or s"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C, XL, LXX, LXXX, XC, C"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. use a dict to store the count of each char in s\n        ## 2. iterate over t, if the char is not in the dict, return it\n        ## 3. if the char is in the dict, decrement the count\n        ## 4. if the count is 0, return the char\n        \n        ## 1.\n        s_dict = {}\n        for char in s:\n            if char not in s_dict:\n                s_dict[char] = 1\n            else:\n                s_dict[char] += 1\n        \n        ## 2.\n        for char in t:\n            if char not in s_dict:\n                return char\n            else:\n                s_dict[char] -= 1\n                if s_dict[char] == 0:\n                    del s_dict[char]\n        \n        ## 3.\n        return s_dict.popitem()[0]"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board, l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board, row, num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board, col, num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board, box_start_row, box_start_col, num):\n            for row in range(3):\n                for col in range(3):\n                    if board[row+box_start_row][col+box_start_col] == num:\n                        return True\n            return False\n        \n        def used(board, row, col, num):\n            return used_in_row(board, row, num) or used_in_col(board, col, num) or used_in_box(board, row - row%3, col - col%3, num)\n        \n        def solve(board):\n            l = [0, 0]\n            if not find_empty_location(board, l):\n                return True\n            \n            row = l[0]\n            col = l[1]\n            \n            for num in range(1, 10):\n                if not used(board, row, col, num):\n                    board[row][col] = num\n                    \n                    if solve(board):\n                        return True\n                    \n                    board[row][col] = '.'\n            \n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if head.val != prev.val:\n                return False\n            head = head.next\n            prev = prev.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 1\n        right = num\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        \n        ans = [0,1]\n        for i in range(2,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node, path):\n            if not node:\n                return\n            if node.word:\n                res.add(node.word)\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            if board[i][j] not in node.children:\n                return\n            c = board[i][j]\n            board[i][j] = '#'\n            dfs(i + 1, j, node.children[c], path + c)\n            dfs(i - 1, j, node.children[c], path + c)\n            dfs(i, j + 1, node.children[c], path + c)\n            dfs(i, j - 1, node.children[c], path + c)\n            board[i][j] = c\n        \n        class TrieNode:\n            def __init__(self):\n                self.children = {}\n                self.word = None\n        \n        root = TrieNode()\n        for word in words:\n            node = root\n            for c in word:\n                if c not in node.children:\n                    node.children[c] = TrieNode()\n                node = node.children[c]\n            node.word = word\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, root, '')\n        return list(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if len(set(box)) != len(box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. convert each character to its corresponding number\n        # 4. add the numbers together\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. convert each character to its corresponding number\n        # 3.1. convert the character to its corresponding number\n        # 3.2. add the number to the running total\n        # 3.3. convert the character to its corresponding number\n        # 3.4. add the number to the running total\n        # 3.5. repeat for each character in the list\n        # 3.6. return the running total\n        \n        # 3.1. convert the character to its corresponding number\n        # 3.1.1. convert the character to its corresponding number\n        # 3.1.2. add the number to the running total\n        # 3.1.3. convert the character to its corresponding number\n        # 3.1.4. add the number to the running total\n        # 3.1.5. repeat for each character in the list\n        # 3.1.6. return the running total\n        \n        # 3.2. convert the character to its corresponding number\n        # 3.2.1. convert the character to its corresponding number\n        # 3.2.2. add the number to the running total\n        # 3.2.3. convert the character to its corresponding number\n        # 3.2.4. add the number to the running total\n        # 3.2.5. repeat for each character in the list\n        # 3.2.6. return the running total\n        \n        # 3.3. convert the character to its corresponding number\n        # 3.3.1. convert the character to its corresponding number\n        # 3.3.2. add the number to the running total\n        # 3.3.3. convert the character to its corresponding number\n        # 3.3.4. add the number to the running total\n        # 3.3.5. repeat for each character in the list\n        # 3.3.6. return the running total\n        \n        # 3.4. convert the character to its corresponding number\n        # 3.4.1. convert the character to its corresponding number\n        # 3.4.2. add the number to the running total\n        # 3.4.3. convert the character to its corresponding number\n        # 3.4.4. add the number to the running total\n        # 3.4.5. repeat for each character in the list\n        # 3.4.6. return the running total\n        \n        # 3.5. convert the character to its corresponding number\n        # 3.5.1. convert the character to its corresponding number\n        # 3.5.2. add the number to the running total\n        # 3.5.3. convert the character to its corresponding number\n        # 3.5.4. add the number to the running total\n        # 3.5.5. repeat for each character in the list\n        # 3.5.6. return the running total\n        \n        # 3.6. convert the character to its corresponding number\n        # 3.6.1. convert the character to its corresponding number\n        # 3.6.2. add the number to the running total\n        # 3.6.3. convert the character to its corresponding number\n        # 3.6.4. add the number to the running total\n        # 3.6.5. repeat for each character in the list\n        # 3.6.6. return the running total\n        \n        # 3.7. convert the character to its corresponding number\n        # 3.7.1. convert the character to its corresponding number\n        # 3.7.2. add the number to the running total\n        # 3.7.3. convert the character to its corresponding number\n        # 3.7.4. add the number to the running total\n        # 3.7.5. repeat for each character in the list\n        # 3.7.6. return the running total\n        \n        # 3.8. convert the character to its corresponding number\n        #"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the length of pattern and words are equal\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for c, w in zip(pattern, words):\n            # if the word is not in the mapping, add it\n            if w not in mapping:\n                mapping[w] = c\n            # if the word is in the mapping, check if it matches the pattern\n            elif mapping[w] != c:\n                return False\n        \n        # if we reach here, all words are mapped\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            # we'll just need to add to output list.\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integer to complete the permutation\n                backtrack(first + 1)\n                # backtrack, by fixing the first integer\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        if target == matrix[0][0] or target == matrix[-1][-1]:\n            return True\n        \n        if target == matrix[m-1][n-1]:\n            return True\n        \n        if target == matrix[m-1][0]:\n            return True\n        \n        if target == matrix[0][n-1]:\n            return True\n        \n        if target == matrix[0][0] or target == matrix[0][n-1]:\n            return True\n        \n        if target == matrix[m-1][0] or target == matrix[m-1][n-1]:\n            return True\n        \n        if target == matrix[m-2][0] or target == matrix[m-2][n-1]:\n            return True\n        \n        if target == matrix[m-3][0] or target == matrix[m-3][n-1]:\n            return True\n        \n        if target == matrix[m-4][0] or target == matrix[m-4][n-1]:\n            return True\n        \n        if target == matrix[m-5][0] or target == matrix[m-5][n-1]:\n            return True\n        \n        if target == matrix[m-6][0] or target == matrix[m-6][n-1]:\n            return True\n        \n        if target == matrix[m-7][0] or target == matrix[m-7][n-1]:\n            return True\n        \n        if target == matrix[m-8][0] or target == matrix[m-8][n-1]:\n            return True\n        \n        if target == matrix[m-9][0] or target == matrix[m-9][n-1]:\n            return True\n        \n        if target == matrix[m-10][0] or target == matrix[m-10][n-1]:\n            return True\n        \n        if target == matrix[m-11][0] or target == matrix[m-11][n-1]:\n            return True\n        \n        if target == matrix[m-12][0] or target == matrix[m-12][n-1]:\n            return True\n        \n        if target == matrix[m-13][0] or target == matrix[m-13][n-1]:\n            return True\n        \n        if target == matrix[m-14][0] or target == matrix[m-14][n-1]:\n            return True\n        \n        if target == matrix[m-15][0] or target == matrix[m-15][n-1]:\n            return True\n        \n        if target == matrix[m-16][0] or target == matrix[m-16][n-1]:\n            return True\n        \n        if target == matrix[m-17][0] or target == matrix[m-17][n-1]:\n            return True\n        \n        if target == matrix[m-18][0] or target == matrix[m-18][n-1]:\n            return True\n        \n        if target == matrix[m-19][0] or target == matrix[m-19][n-1]:\n            return True\n        \n        if target == matrix[m-20][0] or target == matrix[m-20][n-1]:\n            return True\n        \n        if target == matrix[m-21][0] or target == matrix[m-21][n-1]:\n            return True\n        \n        if target == matrix[m-22][0] or target == matrix[m-22][n-1]:\n            return True\n        \n        if target == matrix[m-23][0] or target == matrix[m-23][n-1]:\n            return True\n        \n        if target == matrix[m-24][0] or target == matrix[m-24][n-1]:\n            return True\n        \n        if target == matrix[m-25][0] or target == matrix[m-25][n-1]:\n            return True\n        \n        if target == matrix[m-26][0] or target == matrix[m-26][n-1]:\n            return True"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            carry //= 10\n            curr = curr.next\n            \n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip bits\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip bits\n        flip_bits = \"\"\n        for bit in binary:\n            if bit == \"0\":\n                flip_bits += \"1\"\n            else:\n                flip_bits += \"0\"\n        \n        # 3. convert back to decimal\n        return int(flip_bits, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n                count = 0\n            count += i\n        \n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n            word_dict.remove(word)\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = -num\n            sign = -1\n        else:\n            sign = 1\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res if sign == 1 else '-' + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                self.count += 1\n                return\n            \n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    \n                    backtrack(row + 1, cols, diag1, diag2)\n                    \n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n                    \n        self.count = 0\n        backtrack(0, set(), set(), set())\n        return self.count"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max element\n        # 3. if the list has 3 elements, return the third element\n        # 4. if the list has more than 3 elements, return the third element\n        \n        nums = sorted(set(nums))\n        \n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}