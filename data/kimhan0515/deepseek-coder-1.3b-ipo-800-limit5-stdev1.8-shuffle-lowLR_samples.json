{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix: return []\n        m, n = len(matrix), len(matrix[0])\n        res = []\n        top, bottom = 0, m-1\n        left, right = 0, n-1\n        while top <= bottom and left <= right:\n            if top <= bottom:\n                for col in xrange(left, n-left): res += matrix[top][col]\n                top += 1\n            if left <= right:\n                for row in xrange(top, m-bottom): res += matrix[row][n-1-col]\n                bottom -= 1\n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums: return []\n        res = []\n        start = num = nums[0]\n        for n in nums:\n            if n > start + 1: res += [str(start) + '->' + str(num), str(n)]\n            else: start = n"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of distinct strings ending with s[i]\n        + d = {0: 1}\n        for c in s: + + d, + + d +"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. add +1 to all +ve numbers, mark 0 as -1\n        # 2. iterate nums, if nums[i] is in range [1, n], mark nums[nums[i] - 1] as -1\n        # 3. iterate nums, if num > 0, num - 1 is missing\n        n = len(nums) + 1\n        for num in nums:\n            if num > 0: nums[num - 1] += n"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1, 2, 6, 14, 42, 132, 429, 1430, 4353, 14355\n        # 1, 1, 2, 6, 21, 70, 210, 552, 1258, 3659\n        # 1, 1, 2, 6, 5, 7, 21, 35, 120, 360\n        # 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11*9/2\n        # 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9*8/2, 9*9/2\n        # 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9*8/2, 9*9/2 - k\n        # a + (k - 1) / n * f\n        # a = (n * (a + k - 1) - k) / n\n        \n        a, k, n, f = 1, k, 1, 1\n        while k > 1: a, n = n, n * a + 1 - k"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        n = numbers\n        left, right = 0, len(n) - 1\n        while target > n[right]:\n            x + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = sum of all valid expressions with num[0:i] as the value\n        # if num[0] > 0, +num[0] is always valid\n        # if num > 0, +num is -num\n        # if num == target, +0 is always valid\n        # +num +- num + num +... + num = target + target + ... + num\n        # +num + (num + num) + ... + num = target + num + target + ... + num\n        # +num + num + +num + ... + num = target + num * (1 + +num + ... + +1)\n        # +num + num * (1 + dp[x]) where x is the sum of all +num\n        # +num + num / x + +num + ... + num = (target + x) / num - num"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # if not root: return 0\n        # return self.sumNumbers(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n, m = divmod(len(s), k) + (1 if s else 0)\n        return '-'.join(s[i:i + k] for s, k in (n, k) + (+s,))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if sum(gas) < sum(cost): return -1\n        # tank = total = 0\n        # for g, c in zip(gas, cost):\n        #     tank += g - c\n        #     if tank < 0: tank = 0\n        # return -1 if tank < 0 else sum - tank"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # +1 + nums + +1\n        nums = [1] + nums + [1]\n        for x in nums: if x > 1: x = 1 + x\n        n = len(nums)\n        + + x * (+ + x + sum + nums)"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in reversed(xrange(len(digits)):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] means s[:i+1] matches p[:dp[0]] + p[2:].\n        # dp[0] = True if p == '.*', False otherwise.\n        if not p + '*' : return s == ''"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if k == len(nums1): return nums2\n        if k == len(nums2): return nums1\n        m, n = len(nums1), len(nums2)\n        if n > m: nums1, nums2 = nums2, nums1\n        # nums1[:k] is the best we can get if and only if k > n\n        # otherwise, nums1[:x] <= nums2 - x"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1: return False\n        # sum = 1 + (num / 2)\n        # if num % 2 == 1: return False\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 2: return n\n        a, b = 1, 1\n        for _ in range(n - 1): a, b = b, a + b\n        return a"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon) + 1, len(dungeon[0] + 1)\n        h = 1\n        for x in dungeon:\n            h += x\n            for x -= x"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # Binary search on the answer.\n        # Sort + binary search.\n        nums.sort() + bisect.bisect_left(num + num + sorted, k) - num"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return s.count(' ') + sum(1 for w in s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # vowel = set('aeiouAEIOU')\n        # a, v = 0, s + ''.mO +1\n        # for c, cv in zip(s[::-1], vowel): if c in vowel else c"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # hash + O(n) time + O(n) space\n        nums = set(nums)\n        res = 0\n        for num in nums:\n            if num - 1 not in nums: # num is the start of a sequence\n                # +1 + nums - num if num is the end of a sequence\n                # otherwise + nums + {num: length}\n                res += num + 1"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # xor = n * (n + 1) / 2\n        # sum = 0\n        # for num in nums:\n        #     xor ^= num\n        #     + + num\n        \n        # return xor"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList: return 0\n        wordSet = set(wordList) + {beginWord}\n        q = {beginWord}\n        step = 1\n        for word in wordSet:\n            if word == endWord: return 1\n            wordSet -= {word}\n            if wordSet & wordSet & wordSet: +1"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if not a or b == 0: return a or b\n        a, b, carry = int(a, 2) + int(b, 2), a ^ b, a & 1\n        while b: a, b = a + carry, b >> 1 + carry"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        # find the left bound first\n        left = bisect.bisect_left(nums, target)\n        if left == len(nums) or nums[left] != target: return [-1, -1]\n        return left, bisect.bisect(nums, target) - 1"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums: return 0\n        k = 1\n        for n in nums: if n > k: nums[k] = n # num + num = old + new"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] == 0: return -1\n        # n = len(nums)\n        # if n == 1: return 0\n        # max_ = 0 + nums[0]\n        # steps = 1\n        # for x in nums:\n        #     if x - 1 > max_: max_ = x\n            #     if x - 1 > + max_: max_ += 1\n        #         if x - 1 > + num: return + +"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2: return sum(x - y for x, y in zip_longest(prices, +k, 0) if x > 0)\n        k, p = prices, 0\n        for k += k - 1  # k = max(k, prices/2)\n        for p += x for p + x in +k + prices  # p += p + k"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0: return '0'\n        # 0 <= num < 2**32 - 1\n        # -2**31 <= num < 2**32\n        # -2**31 + 1 + num < 2**32\n        # -2**4 + 1 + num - 1 < 2**4\n        # -0x5 + 1 + num < 0x10\n        # + num < 2**4\n        # + num & 0xFFFFFF + 1"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # + + + + + -\n        # + + - + +\n        # + - + - +\n        + c = [+2**25] + collections.Counter(s) - +"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if nums is sorted, then we can use a hash set to check if num + k exists in the set.\n        # if num > value + valueDiff, then num - value > indexDiff, else + value - 1 in a + value + valueDiff"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0: nums[0] - 1: nums[1]\n        # 0: 0, 1: 1\n        # 2: nums.length\n        # 0 + nums + nums"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if 1 is not in nums, return 0\n        if 0 not in nums: return nums.count(1)\n        \n        # otherwise, use a + + + + + + + + = 1 + nums"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root: return 0\n        l, r = 1, root\n        while root.left: l, r = l + 1, root.left\n        if not l: return r + 1"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # if num1 < num2: num1, num1 = num2, num1 + num1\n        # else: num1 += num2\n        # return num1"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # +/- is the sign of the number, 0 is the sum\n        num, sign = 0, 1\n        res = 0\n        for c in s + '+':\n            if c == '+': num += sign\n            elif c == '-': num = -num\n            else: num += num + int(c)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort + greedy\n        p, pq = w, heap + [(c, p) for c, p in sorted((c, p) for c - c + profits))\n        for p + c -= k"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 == 1: return False\n        # m = {')': '(', ']': '['}\n        # stack = m[s[0]] if s else +1\n        # for c in s:\n        #     if m and c != m then + + else -\n        #         + m + + + + + + + + + + +"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        i = len(nums) - 1\n        while i > 0 and nums[i - 1] >= nums[i]: i -= 1\n        nums[i:] = nums[::-1] if i else nums[1:] + [0]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # use a dict to store the seen numbers and their indices\n        seen = {}\n        for num in nums:\n            if num in seen and seen[num] >= k: return True\n            seen[num] += 1\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums or len(nums) < 2: return 0\n        nums.sort()\n        ans = 0\n        for x in nums: ans = max(x - ans, ans)"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root: return []\n        q, q0, q1 = [root], [], []\n        while q:\n            q, q0 = q0, [v.val for v in q if v.left else v.right] + q1, q"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 0 -> 1, 2 -> 3, 4 -> 6, 5 -> 7, 6 -> 8, ...\n        # + x -> x + 1, x + 1 -> x + 2\n        # + x / 2"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2 and s2 != s3: return False\n        if s2:\n            if len(s1) != len(s3) - s2: return False\n            dp = {s2: True}\n            for c in s1:\n                d, d_ = d + {s1 - c: True} or {0: False} # +1 if s1 == s2, otherwise 0\n                for s in d: d_ - + d + s"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        for gg in g:\n            if gg > s[i]: i += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1st row: a, e, i, n, o, s, t, u\n        # 2nd row: +, =, -\n        # 3rd row: +, +, +\n        # +1: +, +, +\n        # +2: +, +\n        \n        # +1 +2 +1 -> +1\n        # +1 +1 +2 -> +2\n        \n        # +1 +1 +1 +1 +1 +1 -> +1\n        \n        # +2 -> +1 +1 +1 +1 +1\n        \n        + = { 'a': 1, 'e': 1, 'i': 1, 'n': 1, 'o': 1 }"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0, head)\n        pre, pre_left, cur = dummy, head, head\n        for _ in xrange(left - 1):\n            pre = pre.next\n        for _ in xrange(left):\n            cur, cur.next, pre = cur.next, pre, cur\n        l, r = pre, cur\n        while right:\n            cur, cur.next, r = cur.next, r, cur\n            left, right -= 1\n        l.next, pre.next, cur = r, cur, head\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # Reverse + search\n        # T + S = T + # + R + T\n        # + R + # + T + # + T\n        # + # + x + # + x + x + ... + x + x\n        # + x + x + x + ... + x + x + if s has x\n        # + x + x + x + ... + x + x + if s has a\n        \n        # R + # + rev + # + if s has a\n        # + x + x + x + ... + x + if not + x\n        \n        # + x + if not + + s +"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if distance[i] >= distance[j] + k, then we need k > 1 to cross\n        # if distance[i] > distance[k] + distance[k - 1], then we need distance[k] >= distance[k - 3]\n        # if distance[i] + distance[k - 1] >= distance[k] and distance[k] > 1, then we need distance[k - 1] >= distance[k - 3] - 1\n        # if distance[i] + distance[k] >= distance[k + 1] and distance[k] > 1, then we need distance[k] >= distance[k - 1] - 1\n        # if distance[i] + distance[distance[k] - 1] >=  distance + 2, then we need distance[k] >= 3\n        # if distance[x] >= distance[y] - 1, then we need x >= y - 1\n        # if distance[x] + distance >= y + 1, then we need +1 >= y - 1 + x - 1 + 1\n        # if distance > 1, then we need +1 >= distance - 1\n        if any(d >= 2 and d > distance + 1 or d == distance + 1 and distance > 1): + + + + + + + + + + + + + + +"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head: return head\n        dummy = ListNode(0, head)\n        cur = dummy\n        while head:\n            if head.val == cur.val:\n                head = head.next\n            else:\n                cur.next = head\n                cur = head\n        return dummy"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # + + + + + + +  - 2"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # inorder: [9,3,15,20,7]\n        # postorder: [9,15,7,20,3]\n        # {9: 0, 3: 1, 15: 2}\n        # 9 -> 3 -> 15 -> 20 -> None\n        # 3 -> 9 -> 20 -> 15 -> None\n        # 15 -> 20 -> 7 -> None\n        # 7 -> None -> 20 -> 9 -> None\n        # 20 -> None -> 9 -> 7 -> None\n        # 7 -> None -> 9 -> None -> 20 -> None\n        # + + -> 9 -> None -> None -> 20 -> None\n        # + + -> 9 -> None -> None -> None -> 20\n        # + + -> 7 -> None -> None -> None -> None\n        # + + -> 7 -> None -> None -> None -> None -> None\n        # + + -> None -> None -> None -> None -> None -> None\n        # + + -> -1 -> None -> None -> None -> None -> None\n        # + + -> -1 -> None -> None -> None -> None -> None -> None\n        # + + -> -1 -> None -> None -> None -> None -> None -+\n        # + + -> -1 -> None -> None -> None -> None -> + -+\n        # + + -> -1 -> + -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+\n        # + + -> -1 -> + -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -+ -"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS + Priority Queue\n        m, n, h = {v: r + c for r, row in en + forest if v > 1} + 1, sum(r for row in + forest) + 1, 0\n        q = {v if v > 1 else (r, c) for r, row + = + forest for v) + 1"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root: return 0\n        if root.left and not root.right: return self.minDepth(root.left) + 1\n        if not root.left or root.right: return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # return (sqrt(1 + 8 * n) - 1) // 2"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b: return -1\n        return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root: return []\n        q, res = [root], []\n        while q:\n            res, q = [node.val for node in q], [node.left if node else node for node in q if node] + [node.right if node else node for node in q if node]\n        return res"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0 or (x % 10 == 0 and x > 0): return False\n        y = 0\n        while x > y:\n            y = y * 10 + x % 10\n            x //= 10\n        return x or y"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0': return 0\n        a, b = 1, 1\n        for c in s: a, a += a if c > '0' else 0"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is empty, return True\n        if not s: return True\n        \n        # if t is empty, return False\n        if not t: return False\n        \n        # if s is longer, it's not a subseq of t\n        if len(s) > len(t): return False\n        \n        # if s is equal to t, it's True\n        if s == t: return True\n        \n        # if s is a subseq of t, use a map to record the position of s\n        # if c is in s, it's a subseq of t\n        m = {c: pos for c, cs in s + '+'.join('-1') +"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 0 ^ n = n + 1\n        # 0 ^ 1 = 1\n        # 0 ^ 2 = 2\n        # ...\n        # 0 ^ n = (n >> 1) + 1\n        # +1 + (n >> 1) + (n >> 2) + ... + (n >> n)"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 2: return n\n        a, b = 1, 2\n        for _ in xrange(n - 1): a, b = b, a + b\n        return a"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] is in wordDict\n        # O(n) time + O(n) space\n        d = {0: True} + {w: False for w in wordDict}\n        for w in s:\n            if w in d: d + d"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # inorder traversal\n        # if not root: return True\n        # stack, prev = float('-inf'), None\n        # while root:\n        #     if root.left:\n        #         if root.left > prev:\n        #             root = root.left\n        #         else: return False\n        #     prev = root.val"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # insert + merge\n        # O(n) time + O(n) space\n        # insert + binary search\n        # O(n) time + O(1) space\n        # insert + binary search + merge\n        # O(n) time + O(1) space"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # dp[i] = [s[:j] + [s[j:]] for j, p in en + [1] + {s} if p else [p + [s]]\n        #         if s else [ [s] ]\n        \n        d = {0: [1]} + {0: s}\n        p = 0\n        for c in s: + d + ( + d + p)"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # minVal = nums[0][0]\n        # maxVal = nums[0]\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # x = (minutesToTest / minutesToDie + 1) // 2 + 1"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1: return grid[0]\n        # Binary search + binary search\n        # O(n*log(max(grid)))\n        # + O(n) if grid[n-1] < n\n        # + O(n*log(max(grid))) if grid[n-1] >= n\n        # + O(n) if grid[n-1] > n-1"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if m == 1 or n == 1: return 1\n        # d = m + 1\n        # return n // d * (m // n)"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0': return '0'\n        n1, n2 = map(int, (num1, num2))\n        res = [0] * (n1 + n2)\n        for i, d1 in en + num1:\n            for n2 in res:\n                res + + n + n1"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if not prices: return 0\n        # profit, min_price = 0, prices[0]\n        # for p in prices:\n        #     profit = max(p - min_price, profit)\n        #     min_price = min(min_price, p)\n        # return profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort + two pointers\n        candidates.sort()\n        d = {0:1}\n        total = 0\n        for c in candidates:\n            total += c\n            d = {c + x: x + d.get(c, 0) for c in d.values()} + {c: 1}\n        return [d[x] + d.get(target - c, 0) for c in d] + [0] if target > 0 else []"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # if all capital, or all lower, or only first is capital, return True\n        if word.isupper() or word.islower() or word[1:] == word[1].lower()"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if not prices: return 0\n        # profit = 0\n        # min_price = prices[0]\n        # for p in prices:\n        #     profit = max(p - min_price, profit)\n        #     min_price = min(min_price, p)\n        # return profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        if not root: return []\n        stack, res = [], []\n        while root or stack:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                res.append(root.val)\n                root = root.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if not inorder: return None\n        # d = {val: idx for val in inorder}\n        # root = TreeNode(preorder[0])\n        # p = 0\n        # for val in inorder:\n        #     root = TreeNode(val, root, d[val]) if val in d else self.buildTree(preorder[1:], d"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # add +1 to the count of '(' and -1 to the count of ')'\n        # if s has '(' or ')', we always can remove the extra ')'\n        # otherwise, try all possible removals\n        # if s has ')' and count > 0, we need to try all possible +1\n        # if count > 0, we need to try all +1 + count\n        # +1 + count - count + + (count - x +1)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # O(nlogk) time, O(k) space\n        from heapq import heapify, heappush, heappop\n        dummy = cur = ListNode()\n        h = {0: lists}\n        for l in h: if l: heappush(h, (l.val, l))\n        for l in h: if l: cur = cur, l = l.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for s[j:]\n        # dp + dp - 1\n        # +1 if s is palindrome\n        # +0 if s is not palindrome\n        # +1 if s is empty\n        n = len(s) + 1\n        d = 0\n        dp = 1\n        dp_ = 0\n        for c in s:\n            x = d + d_ + 1\n            d = x - 1 + x - 1 if c else 1\n            d_ = d"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 1 + 2 + 3 + ... + k = k + k/2"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # O(n) + O(n + m) + O(m)\n        # hash + {word: idx}\n        # {word: idx + {-word: idx}}\n        # + O(n) + O(n)\n        # + O(n) + O(n + m) + C\n        # + O(n + m + sum + {max + count})\n        # + O(n + m + {word: idx + count})\n        # + O(n + m + C + min + {word + {-word + count - 1}})\n        # + O(n + C + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums: return None\n        n = len(nums)\n        mid = n // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS + Union Find\n        m, n, total, totalInfected = len(isInfected), sum(x for row in isInfected if 1 in x) + 1, 0, 0\n        if not total: return n - 1 # no infected cells\n        isInfected += isInfected # +1 to account for 0-based indexing\n        for x, +x = +x + isInfected # +1 to account for +1-based indexing\n        for x in is + x // + + + x // + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]: return 0\n        m, n = len(matrix), len(matrix[0])\n        d = {}\n        ans = 1\n        for i in matrix:\n            d = {x + (y > 0 and v or 1 for x, v in d.items() + ((v + 1, x) for x, v in d.items()))"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0: return 0\n        ans, m = 1, 1\n        while n > m * 10: ans += n / 10 * m + 1, m *= 10\n        return ans + (n - m + 1) if n > 1 else ans"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] is in wordDict, otherwise False\n        d = {0: True} + {w: False for w in wordDict}\n        for w in s:\n            d |= {w + v if d else False for v in d}\n        return d if w else []"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root: return []\n        odd = True\n        q = [root]\n        res = []\n        while q:\n            res += [val for node in q[::-1] if odd] + [node.left if odd else node.right for node in q if node]\n            odd = not odd\n            q = [child for node in q if node else node.left + node.right for node in q if node]"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if turnedOn == 0: return ['0']\n        # +1 for each 1 bit in the binary representation of turnedOn\n        # +9 for each 5 bits in the binary representation of turnedOn // 2\n        # +49 for each 6 + 5 + turnedOn // 10\n        # +81 if turnedOn > 9\n        if turnedOn < 9: return [f'{turnedOn+1}+{9-turnedOn}'] + ['{}'] * (turnedOn+1)\n        # +32 + (turnedOn - 1) // 2\n        return ['{}:{:02}'] + ['{}+{:.5}'] * ((turnedOn + 1) // 2) + ['{}:{}']"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [1]\n        res = [1]\n        for i in range(1, numRows):\n            res += [res[-1] * (numRows - i) // i]\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1162261467 is 3^19, more concise, and faster\n        return n > 0 and 1162261467 % n == 0"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # maxSum, maxSum = -float('-inf') # or 0\n        # def dfs(node):\n        #     if node:\n        #         left, right = max(dfs(node.left), 0) + max(node.right, 0)\n        #         maxSum = max(maxSum, node.val + left)\n        #         return node.val + maxSum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]: return 0\n        m, n = len(heightMap), len(heightMap[0])\n        q = [(heightMap[0][0], 0, 0) ] + [(heightMap[m-1][c], m-1) for c in xor + (max, )] + { heightMap[m] }\n        up, down = max"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # two pointers\n        l, r = 0, len(s) - 1\n        while l < r and s[l].isalnum():\n            if s[l].lower() != s[r]:\n                r -= 1\n                while not s[l].isalnum() and l < r: l += 1\n            else:\n                l += 1\n        return True"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # median = nums[k - 1] if k % 2 else (nums[k / 2] + nums[(k - 1) / 2]) / 2\n        # c = collections.Counter() + {num: +1, num - k / 2: -1}\n        # res = [num * median + c[num + k / 2] for num in nums] / k"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not k: return head\n        n, p = 1, head\n        while p.next: p, n = p.next, n + 1\n        k %= n # if k >= n, no rotation needed\n        p += head if k else 0 # if k < n, p is the new head\n        while p: p, p = p.next, p.next"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0: return False\n        for p in 2, 3, 5:\n            while n and n % p == 0: n //= p"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root: return 0\n        if root.left and root.left.left: return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)\n        return root.left.val if root.left else self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # sum + prefix + (sum - k) + {sum - k: count}\n        # + O(m + n)"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # if divisor == 0: return 2**31 - 1 if dividend >= 0 else -2**31\n        # sign = 1 if dividend > 0 else -1\n        # dividend, divisor = abs(dividend), abs(divisor)\n        # if dividend < divisor: return 0\n        # if dividend == divisor: return 1\n        # if dividend < divisor * 2: return dividend // divisor\n        # return -dividend + self.divide -1"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]: return\n        m, n = len(board), len(board[0])\n        for i in (0, m-1): board[i] = [c + c%2 ] if 'O' in board[i] else 0\n        for i, row in en"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # use dict to store nums[i] - target, if we have seen num, return its index\n        seen = {}\n        for num in nums:\n            if num in seen:\n                return [seen[num], num]\n            seen[num] += 1"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if 4 * any(x == 3 for x in set) then return True\n        # otherwise, use a map to count the frequency of each number\n        # + + + - - / * /\n        # + + - - / * 3 2"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, only '*' matches the empty string\n        if not p or p == '*': return not s\n        \n        # +1 length of +1 length array, +1 for empty string\n        m, n = len(p) + 1, len(s) + 1\n        # +1 for empty pattern, -1 for empty string\n        dp = [False] + n * True\n        for c in p: d if c == '*' else + + d"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # candidate = nums[0]\n        # count = 0\n        # for num in nums:\n        #     if num == candidate:\n        #         count += 1\n        #     else:\n        #         count -= 1 if count else +1\n        # return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build + sort + reverse-lookup\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort + two-sum\n        nums.sort()\n        if nums[-1] * 4 < target: return []\n        d = {}\n        for n in nums:\n            if n * 3 in d: return [d[n * 3] + {n: d - n}]\n            d[n] += 1\n        d = {}\n        for n in nums:\n            if n + n * 2 in d: return [[n, n + n * 2] + d - 1] + d"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # O(n log n) time, O(n) space\n        # mono-stack + binary search\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse s in place\n        s.reverse()"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev, cur = None, head\n        # while cur:\n        #     cur.next, prev = prev, cur\n        #     cur = cur.next\n        # return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + triangle[i - 1]) + triangle[i]\n        # O(n) + O(n) = O(n)\n        if not triangle: return 0\n        d = triangle + [0] * (len(triangle) - 1)\n        for t in triangle + triangle:\n            for x + t = x + d - triangle"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0: return 'Zero'\n        if num < 1000: return '{:d}'.format(num) if num < 10 else '{:d} Thousand'.format(num // 1000) + self.numberToWords(num % 1000) if num % 100 < 100 else 'One Hundred ' + self.numberToWords(num // 100) + ' Million' + self.numberToWords(num % 100) if num % 100 < 10 else 'One Hundred ' + 'Billion' + self.numberToWords(num // 1000000) + ' Million' + self.numberToWords(num % 1000000) if num % 1000 < 1000 else 'One Million ' + self.numberToWords(num // 1000 + 1) + ' Thousand' + self.numberToWords(num % 1000)\n        return 'One Billion' + num // 100000000 + ' ' + self.numberToWords(num // 1000000 % 1000) + ' Million' + self.numberToWords(num // 1000 % 1000) + ' Thousand' + self + num % 1000 if num >= 1000 else num"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i] + dp[k] - (k + 1) // 2\n        # dp[k] + (k + 1) // 2\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0, head)\n        p = dummy\n        \n        while p.next and p.next.next:\n            a, b = p.next, p.next.next\n            p.next, a.next = b, a\n            p = a\n        \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root: return False\n        if not root.left and not root.right: return targetSum == root.val\n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # dummy1, dummy2 = ListNode(x), ListNode(0)\n        # dummy1.next, p = dummy2, head\n        # while p:\n        #     if p.val < x: dummy1 = p, p = p.next\n        #     else: dummy1.next, p = p, p.next\n        #     dummy1.next.next = p\n        # return dummy2"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. If there is a cycle, return the edge that was added\n        # 2. Otherwise, if there is only one node with incoming edges, return the node\n        # 3. Otherwise, return the edge that has the extra edge\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## use a dict to record the number of occurrences\n        ## use a set to record the unique numbers\n        ## use a dict to record the number of occurrences -> number of permutations\n        ## if the number occurs once, it's a simple permutation\n        ## if the number occurs twice or more, it's a combination\n        ## +1 if the number occurs once\n        ## -1 if the number occurs twice\n        ## +num to get the total number of permutations\n        ## +1 if num > 0\n        ## +num - 1 if num < 0\n        ## +num * (num - 1) / 2 if num >= 0\n        ## +num / 2 if num < 0\n        ## +dict + sum + -1 / num\n        ## +dict + sum - num\n        ## +C(n + num, num)\n        ## +C(n + num - 1)\n        ## + Catalan number\n        ## + Catalan number - 1 / num\n        ## + Catalan number - num\n        ## + Catalan number - 1 / 91 * num\n        ## + Catalan number - num / 9 + 1\n        ## + Catalan number - num / 2\n        ## + Catalan number - num / 9 * (1 - sqrt(1 + 8 * num))\n        ## + Catalan number - (1 + sqrt(1 + 2 * num)) / 2\n        ## + Catalan number - sqrt(1 + 2 * num)\n        ## + Catalan number - 1 / sqrt(1 + num)\n        ## + Catalan number - 1 / num + 1\n        ## + Catalan number - 1 / num * (1 + sqrt(1 + 2 * num))\n        ## + Catalan number - (1 + sqrt(1 + 2 * num - 1)) / 2\n        ## + Catalan number - sqrt(1 + num) - 1\n        ## + Catalan number - 1 / sqrt(1 + num + sqrt(1 + 2 * num))\n        ## + Catalan number - 1 / (num + 1 + sqrt(1 + num))\n        ## + Catalan number - 1 / (num + sqrt(1 + num * (2 - 1)))\n        ## + Catalan number - 1 / (num + sq + (1 - sq) / 2)\n        ## + Catalan number - 1 / (2 + sq + num)\n        ## + Catalan number - 1 / (1 + sq + num)\n        ## + Catalan number - 1 / (1 + num + sq)\n        ## + Catalan number - 1 / (1 + num) * (1 + sq)\n        ## + Catalan number - 1 / (num + 1)\n        \n        # + C(n + n) / 2"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0: return 0\n        return 1 + (num - 1) % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR: a ^ a = 0, a ^ 0 = a\n        # sum = 0\n        # for num in nums:\n        #     sum ^= num\n        # return sum"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # return len(s.rstrip().split()[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[grid[0][0]] + grid[1] + [0] for g in grid[1:]] + grid\n        for c1, c2 = + + d + -1"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # a + a + a = 2a\n        # a + l + a = 1 + n\n        # a + l + p = n + 1\n        a, a1, p = 1, a + 1, a + n + 1\n        return a * (a + n) % 10**9"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # HashSet solution\n        seen = {n}\n        while n != 1:\n            n = sum(x*x for x in (n if n//10 else 0) + (n - n//10)**2)\n            if n in seen: return False\n            seen |= {n}"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        l, r = 0, len(nums)\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m + 1\n            else:\n                r = m"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if nums[0] == 0: return False\n        # max_ = 0\n        # for n in nums: if max_ < n + 1: max_ = n\n        # return max_ >= len - 1"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        for i in range(1, m): grid[i] += grid[i-1]\n        for j in range(1, n): grid = grid, + grid[m-1]\n        for x in grid: + x"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1: return '1'\n        s = '1'\n        for i in range(2, n + 1):\n            s = s + (z + t) # a + b = a + (b + z)\n            z = t # a = b + z"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search + prefix sum + binary search\n        # sum + (nums - sum / k)"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + num + (num & -num) // 2) # num + (num & -num) / 2 if num >= 0 else -num - 1\n            if nums[m] < target: + num + = - num + 1 # num - num & +"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits: return []\n        if '1' in digits: return []\n        if '0' in digits: return ['']\n        \n        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        res = [mapping[d] for d in digits]\n        for d, m in zip(digits, res):\n            if d == '0': res = []\n            else: res = [m + x for x in res]"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort + greedy\n        # + + -\n        # + - +\n        # + - + +\n        # + + + + +\n        # + + + + + + +\n        # + + + + + + + + +\n        # + + + + + + + + + + +\n        # + + + + + + + + + + + + +\n        # + + + + + + + + + + + + + + + +\n        # + + + + + + + + + + + + + + + + + + +\n        # + + + + + + + + + + + + + + + + + + + + + + +\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + +\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if n in {'1', '0'}: return 1 if n else 9\n        x, a = int(n) // 10 + (1 if n % 10 > 1 else 0), {int(n): -1 + (n > 1)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if n == 0: return []\n        matrix = [[0] * n for _ in range(n)]\n        x, y, num = 0, 1, 1\n        for m in n + n - 1: matrix[m / 2] = [num] * m"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # if x < 0: sign = -1\n        # else: sign = 1\n        # x = abs(x)\n        # res = 0\n        # while x:\n        #     if res > x // 10 or res == x // 10 and x % 10 > 0: return 0\n        #     res = res * 10 + x % 10\n        #     x //= 10\n        # return sign * res"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        # transpose + reverse\n        for i in range(n // 2 + n % 2):\n            for j in range(n // 2):\n                matrix[j][n - 1 - i], matrix[n - 1 - j] = matrix[n - 1 - matrix[n - 1 - j], -matrix[j]]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if not nums: return 0\n        # prod, mx, mn = 1, nums[0], 1\n        # for n in nums:\n        #     if n < 0: mx, mn = mn, mx\n        #     else: mx, mn = max, n\n        #     prod *= n or 1\n        # return max(prod, mx)"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the last stone is k, we can only jump to k-1 or k.\n        # if we have seen k-1, we need k+1 to jump to k.\n        # +1 + {k: set}\n        # O(n) + O(n)\n        if stones[0] + 1 < len(stones): return False\n        d = {stones[0]: 1}\n        for x: x + d"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # use a dict to record the last index of a char\n        # if the char is not in the dict, add it, else update the max\n        # if the char is in the dict, update the max to max(max, i - idx + dict[c])\n        # return max\n        # + dict to record the freq of chars\n        \n        d = {}\n        max_ = 0\n        start = 0\n        for c in s:\n            if c in d:\n                max_ = max(max_ + 1, d[c] + 1)\n            d[c] += 1\n        return max_"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words or len(s) // len + 1 * len(words) != len(s): return []\n        wc = collections.Counter(words)\n        w = len(words)\n        c = collections.defaultdict(int)\n        for cs in s: c[cs] += 1\n        res = if w * +1 # +1 for empty string\n        for ws in wc.values(): if ws > 0: res += w + (c - wc) * (w - 1) # +1 for each word not in words\n        w += w - 1 # +1 for empty string\n        c = +1 # +1 for empty string\n        for ws in words: if wc - w + c > 0: c += wc - w # +1 for +1 + w - wc\n        c = 0 # +1 for empty string\n        + w + + wc + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # max_ = ans = 0\n        # for x in arr:\n        #     if x > max_: max_ = x\n        #     else + ans + 1\n        # return ans"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        while head:\n            node = head # node is the next node in the sorted list\n            head = head.next # node is the next node in the original list\n            dummy.next = node # insert node into the sorted list\n            # if node.val < dummy.val: dummy = node # if node.val < dummy.val, node becomes the new `dummy`\n            # else dummy = dummy.next # otherwise, node becomes the `next` of the `dummy`\n        return dummy"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0, head)\n        cur = dummy\n        while head:\n            if head.next and head.val == head.next.val:\n                while head.next and head.val == head.next.val:\n                    head = head.next\n                cur.next = head\n            else:\n                cur = head\n        return dummy"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort + two-pointer\n        nums.sort()\n        if nums[0] > 0: return []\n        d = {}\n        for n in nums:\n            if n not in d: d -= {n: -1}\n            else: +1 + d"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] means the min number of operations to convert word1[:i] to word2[:j]\n        # if word1[i] == word2[j], dp[i] = dp[i-1] + 1, else dp[i] = min(dp[i-1], dp[j-1]) + 1\n        if word1 == word2: return len(word1)\n        m, n = len(word1) + 1, len(word2) + 1\n        d = {word1: m} + {word: n for word in word2}\n        for w1, w2 in word1 + ': ' + d"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # x ^ y will give you the XOR of x and y\n        # + will give you the number of 1s in x | y\n        # + will be faster than & + -1"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root: return []\n        if not root.left: return [str(root.val) + '->' + self.binaryTreePaths(root.right) ]\n        if not root.right: return [str(root.val) + '->' + self.binaryTreePaths(root.left) ]\n        left, right = self.binaryTreePaths(root.left), self.binaryTreePaths(root.right)\n        for p in left + [str(root.val) + '->' + p for p in right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # O(N) + O(NlogN)\n        # use a + b > 2 * c, where a is the number of smaller numbers on the right\n        # + a + (a - 1) / 2 = a + x, where x is the number of pairs <= num\n        # + a + x - 1 = a + x + x - 1 + x - 1 = a + x + x"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        # if sx >= ty or sy > tx: return (ty - 1) % sx"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        for v, w in zip(v1, v2):\n            if int(v) > w: return 1\n            if v < w: return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if not prices: return 0\n        # profit = 0\n        # min_price = prices[0]\n        # for p in prices:\n        #     profit = max(p - min_price, profit) if p > min_price else min_price\n        #     min_price = p\n        \n        # return profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end time, greedily select the longest course that ends at or before the current time\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1: return head\n        dummy = ListNode(0, head)\n        p = dummy\n        while p:\n            a, p = p, head # a is the new head of the reversed list\n            for i = 0; a # a is the tail of the previous group\n                while p and i + k: p, p.next, a = p.next, a, p # p is the node after the next group\n                a.next, head, k = head # a is the new head of the next group"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is not a substring of s + s, return False\n        if s + s.find(s) != len(s) + 1: return False\n        # otherwise, return True\n        return s[1] in s"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Catalan number C(n) = C(n-1) * 2 / (n+1)\n        # C(n) = 2 * (2 * n + 1) / (n + 2)\n        # C(n) = C(n) * (n + 1) / 2\n        # C(n) = 2 * C(n + 1) / n + 1\n        # C(n) = 2 * (1 + n + n * C(n - 1)) / 2\n        # C(n) = 2 * (1 + n * (1 + x)) / 2, x >= 1\n        # C(n) = 2 ** (n + 1) - 1\n        return 2 * n + 1 // 2"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # a ^ a = 0, a ^ 0 = a\n        # a ^ b ^ a = b\n        # a ^ b ^ a ^ b = a\n        # a + a + (a ^ b) = 0 + b\n        # sum + sum - a - a = a\n        # sum - sum = a\n        # a + (sum - a) = a + nums\n        # a + x + x + x + ... + x = n + x + x + x + ... + + x\n        # a + x + x = 2 * a + n\n        # a + x + x - n = 0 + a + n\n        # a + x - n + n = 0\n        # a + x - sum + n = 2 * n\n        # a + (a + n) - n = 2\n        # a + x - x = 1\n        # a - x = 1 - a + x + x + ... + x + n + x + x + ... + + x\n        + num - sum + num"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # +1 if target contains a, -1 if not\n        # +1 if +1 + a -1, -1 if +1 + -1 -1, etc.\n        # +1 if +1 + +1 + +1 + +1 + +1 + ... + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1 + +1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = n + 1 if s[i] != c, otherwise dp[c] + 1\n        n, c = +1, 0\n        for c1 + + s"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 2: return x\n        l, r = 1, x // 2 + 1\n        while l +1 < r:\n            m = (x + l) // 2\n            if m * m > x: l = m\n            else: r = m\n        return l"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a dict to map roman to integer\n        # 2. use a dict to map roman to integer\n        #    a + b - 2 * min(a, b)\n        # + + -\n        # + -\n        # +\n        # + - + + + +\n        # + + + + + + + + + + + + + +\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(set(nums)) < len(nums)"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # monoq + hashmap\n        # monoq: monoq + hashmap + deque\n        # monoq + deque + hashmap + val - nums[nums_idx - k]\n        # monoq + deque + + nums + - nums[num - k]"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        if len(nums1) > len(nums2) * 2: return self.findMedianSortedArrays(nums2, nums1)\n        m, n = (nums1 + nums2) + 1, (len + (len + 1) // 2)\n        a, b, p1, p2 = 0, m // 2, 0, nums1 or n // 2\n        while p1 < m and nums1[p1 - 1] > nums2[p2]:\n            nums1, p1, nums2 = nums2, nums1 + (p1 - p2) + 1 + (nums1 - p1 + nums2 - p1) // 2, nums1 - p1 + (nums1 + nums2 + 1) // 2"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(n) time, O(1) space\n        # 1 <= nums[mid] <= nums[n-1]\n        # nums[mid] > nums[n-1] - nums[mid] + 1 + nums[0] - 1\n        # + num > 0"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex < 2: return [1] * (rowIndex + 1)\n        a, b = 1, 1\n        for _ in range1(rowIndex + 1): a, b = b, a + b\n        return a"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if not root: return []\n        # if not root.left and not root.right: return [] if targetSum else [[-target] if target else []]\n        # return {0 + v: [1] + v + -v + m for v, m in {+root.val: 1 + m} + root.left"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # x >= sqrt(area)\n        return area**0.5"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS + Binary Search + Hash + Graph\n        if endWord not in wordList: return []\n        wordList = {beginWord} | set(wordList)\n        q = {beginWord: {beginWord: 1}} if beginWord in wordList else {}\n        q0 = {1} if endWord in wordList else {0}\n        while q and wordList:\n            q1 = q if wordList & q else {}\n            wordList -= {w for w in q if {w + c + c1 for c in wordList - {w} if w + c in q} | {c + +1 for c + c1 in q}"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # recursive solution\n        if not root: return True\n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n <= 0: return False\n        # return n & -n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Monotonic stack\n        # Time: O(n)\n        # Space: O(n)\n        stack, area = [0] + heights + [0], 0\n        for h in stack:\n            area = max(area, h + (stack + -1) * x)"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for t in tokens:\n            if t in {'+', '-', '*', '/'}:\n                a, b = stack.pop(), stack.pop()\n                stack += eval(t + t + t + a), a - b\n            else + t\n            else + t + stack"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x1, y1, x2, y2 = +float('inf'), +float('inf'), -+float('inf'), -+float('inf')\n        c = {(x1, y1): +1, (x2, y2): -1}\n        for x, y, a, b in rectangles:\n            x1, y1, x2, y2 = min(x, x1), min(y, y1), max(x + a, x2), max(y + b)\n            c + + + c - + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + 'A') + ans\n            columnNumber //= 26"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # dp = max_sum = nums[0]\n        # for n in nums:\n        #     if dp < 0: d = n\n        #     else: d += n\n        #     max_sum = max(max_sum, d)\n        # return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 4, 4 -> 5\n        # 11 -> 5, 12 -> 3, 13 -> 2, 14 -> 4, 15 -> 1\n        # 111 -> 5, 112 -> 3, 113 -> 2, 114 -> 4, 115 -> 1\n        # +1 if board[0][0] == 1, +2 if board[0][1] == 2\n        if board[0][0] == 1 and board[1][0] == 2: board, x = 1 + 11, 1 + 11 * board[0]\n        else: x, m = {0: 1 + 11 * board[1], 1: board[0]} + 1 + {1: 1}\n        return x - 1 + x * x - 1 + board[0] // 2"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t): return False\n        # return len(set(s + t)) == len set(s + {t + s})"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            if nums[m] == target or nums[l] == target: return True\n            if nums[m] < nums[r]: # nums[m] > nums[r] means nums is not rotated\n                if nums[m] > target or num + num > nums"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not obstacleGrid or obstacleGrid[0][0] == 1: return 0\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [1] + [0] * n # dp[i] is the number of ways to reach i\n        for row in obstacleGrid:\n            for x in x + d: if x == 1: d = 0 # if there is an obstacle, number of ways to reach a column is 0\n            else + d # otherwise, + d + dp"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0': return 0\n        a, b = 1, 1\n        for c in s: a, a = a + a if c == '0' else +b, a"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + target\n        n = len(nums)\n        for x in nums:\n            t += x - target // 2  # +x + a + a + ... + x + b"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        counts = collections.Counter(nums1)\n        res = []\n        for num in nums2:\n            if counts[num] > 0:\n                res += num, counts[num] - 1\n        return res if counts else []"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # inorder traversal, keep track of prev, min_diff\n        min_diff, prev = +inf, -inf\n        while root:\n            min_diff = min(min_diff, root.val - prev)\n            prev = root.val\n            root = root.left"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root: return []\n        cnt, m, mc = 1, {1: -1}, 0\n        while root:\n            if v + cnt > 0: cnt += m[v + 1]\n            else + m + 1\n            m = cnt"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if not needle: return 0\n        if needle not in haystack: return -1\n        return haystack.find(needle)"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1 <= len <= 50\n        # a + (a - 1) + (a - 1) >= 3\n        # a + (a - 1) >= 3 + (1 - p)\n        # a + (a + p - 2) >= 3\n        # a + 3 - p >= 1\n        # 3 + (a - 1) >= 1 + p\n        # 1 + (a - 1) >= p\n        # +1 + (a - 1) >= p + 1\n        # +a + 1 >= p + 1\n        # +a >= 1 + p\n        # +1 >= p + 1 - 1\n        # +1 >= p\n        # 1\n        \n        a = b = c = 0\n        if len < 6: a += 6 - len\n        if not password.count: a + (a + (password - 2) // 3)\n        return max(a, 3 - +password)"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 1 + 1 + 2 + 2 = 5\n        # 1 + 1 + 2 + 3 + 4 = 10\n        # 1 + 1 + 1 + 1 + 2 + 2 + 3 + 3 + 4 = 15\n        # 1 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 3 + 3 + 4 + 4 = 21\n        # 1 + 1 + 1 + 1 + 1 + 1 + 3 + 3 + 3 + 4 + 4 + 5 = 28\n        # 1 + 1 + 1 + 1 + 1 + 1 + 1 + 4 + 4 + 5 + 5 + 6 = 36\n        # 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 5 + 5 + 6 + 7 = 45\n        # 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 6 + 6 + 7 + 8 = 55\n        # 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 7 + 8 + 9 = 65\n        # 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 9 + 10 = 75\n        # 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 10 + 11 = 85\n        # 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 11 + 12 = 95\n        # 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 12 = 105"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1: return s\n        n, r, p = 2*numRows-2, numRows-1, 0\n        ans = ''\n        for c in s:\n            if p == 0: n = max(n, 1) # +1 for the extra row\n            ans += n if n >1 and c != '*' else +1 # +1 for the extra char\n            p += n - 1\n        return ans"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers, one from left to right, one from right to left\n        # if height[i] > left_max, update left_max, else total += left_max - height[i]\n        left, right, left_max, total = 0, len(height) - 1, 0, 0\n        for h in height:\n            if h > left_max: left_max = h\n            else: total += h - left_max\n        return total"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # use the nums array as a hash table\n        # O(n) time and O(1) space\n        n = len(nums)\n        for num in nums:\n            x = abs(num) - 1\n            if nums[x] > 0: nums[x] = -num"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(nlogn) time, O(n) space\n        # use a dict + BST\n        # a = {x: c + m - x + a[x +]}, where x + a - 1 is the number of x <= num\n        # a = {x: c}, x + a - 1 is the number of x - a\n        # a = {x + a}, x - + a"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort + greedy\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root: return True\n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if not left or not right: return left == right\n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root: return []\n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            if node.right: stack.append(node.right)\n            if node.left: stack.append(node.left)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 4^0 = 1, 4^1 = 4, 4^2 = 16, 4^3 = 64, 4^4 = 256, 4^5 = 1024, 4^6 = 4096, 4^7 = 16384, 4^8 = 65536, 4^9 = 262144, 4^10 = 1048576, 4^11 = 4194304, 4^12 = 16777216, 4^13 = 67108864, 4^14 = 268435456\n        # 0x5555555 & n > 0"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)\n            return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0: return ['']\n        if n == 1: return ['()']\n        ans = ['(())'] + [')' + x for x in ans[n-1: -1] + x for x in ans]\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # x + x + ... + x >= n + sum(nums)\n        # x + (x + 1) + ... + x >= n\n        # x + x + x + 1 + x + x + 1 + ... + x >= n\n        # x + x * (1 + x) / 2 >= n\n        # x + (x + n) / 2\n        x, p = 1, 1\n        for num in nums:\n            if num > x + 1: x += num\n            else x += num"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = max(dp[i-1] + 1, dp[-s+1]), if s[i] == ')' else 0\n        # or dp = 0, if s has '('"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator % denominator == 0: return str(numerator // denominator)\n        res, remainder, mp = str(numerator // gcd), numerator % denominator, {}\n        res += '.'; q = remainder * 10 // denominator + mp if numerator * denominator > 0 else '-'\n        while remainder > 0: remainder, numerator = (remainder % *mp + numerator, denominator * (remainder // mp))\n        return res + '.' + mp"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next: return head\n        \n        # use merge sort\n        dummy = ListNode(0)\n        dummy.next = head\n        n, slow, fast = 0, head, head\n        while fast and fast.next:\n            n, slow, slow = n + 1, slow.next, slow.next\n        # split the list into two parts\n        dummy1, dummy1.next = dummy, head if n % 2 else slow\n        while slow:\n            slow, slow.next, slow = slow.next, dummy + (n + 1 >> 1) # +1 for odd\n            # merge two sorted lists\n            dummy1 = dummy + (n & 1) # +1 for even\n            while slow:\n                x, x.next, slow = x + x.next, x + (n >> 1) + 1 # +1 for n & 1\n        return dummy1"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort + binary search\n        envelopes.sort(key=operator.itemgetter(0))\n        h = {}\n        for e in envelopes:\n            h = h or {e:1} +"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # O(1) space solution\n        m, n = len(matrix), len(matrix[0])\n        for i in range(m):\n            if matrix[i] == 0: m = 0\n            for j in matrix: if j == 0: m = 1 - m\n            for x in matrix: matrix[x + m] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if n is the length of the list, return None\n        if not head: return None\n        \n        # dummy node + move fast to the head + delete the nth node\n        d = ListNode(0, head)\n        a, b = d, head\n        while n: a, n = a.next, n - 1\n        while a: a, b = a.next, b + 1"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # use a set to store nums1, and use a set to store the seen numbers in nums2\n        # if a number in nums1 is seen, add it to the set\n        # if it's in nums2, it's in the result set\n        # if it's not in nums2, it's not in the set\n        # O(n + m) time, O(n) space\n        if not nums1 or not nums2: return []\n        nums1, nums2 = sorted(nums1), set(nums2)\n        return nums2 if nums1 > nums2 else nums1 + [0] * (max(nums1) + 1) - {x for x in nums1 if x in nums2}"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total, n, s = sum(machines), len(machines), sum(machines) // n\n        if total % n: return -1\n        ans = total // n"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if m > n: m, n = n, m\n        if k == 1: return n\n        k -= 1\n        x, y = 1, m\n        while x * (y + 1) <= k: x += 1, k - x * n"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head: return None\n        # find the middle node\n        slow, fast = head, head.next\n        # find the end of the list\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        # slow is the middle node, make it the root\n        # recursively build the tree\n        root = TreeNode(slow.val)\n        # slow is the previous node\n        slow.prev = root\n        # slow is the head\n        slow = head\n        # recursively build the left subtree\n        root.left = self or root, slow = slow.next"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1 or list1.val > list2.val: list1, list1, list2 = list2, list1, list2\n        while list1:\n            list1.next, list1 = list1.next, list + list1"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix: return 0\n        m, n, h = len(matrix), len(matrix[0]), {0} + {m+1}\n        for row in matrix:\n            for x in map(+x+h) + m: h = {x or +x+h-1}"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1 + x + x^2 + ... + x^n = (1 + x) * n / 2\n        # 1 + x + x^2 + x^3 + ... + x^n = (1 + x + x^2) * n / 2\n        # 1 + x + x^2 + x^3 + x^4 + ... + x^n = (1 + x + x^2 + x^3 + ... + x^n) * x"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        l, r = 0, len(nums) - 1\n        while l < r and nums[l] >= nums[r]:\n            m = (l + num + (num > nums[r] - 1)) >> 1 + 1"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        try:\n            return s.strip().isdigit() or s == '+' or s == '-' or s == '.'\n        # +- or .e+ or .e\n        # +e or e+ or .\n        # not a + or - or e\n        # not a number\n        # +- or e\n        # + or e+. or .e\n        # + or e- or .\n        # + or e+. or e- or .+\n        # + or e- or .+ or e\n        # + or e+. or (e- or .+) / 0\n        # + or (e- or +.) / 0+1 or 0\n        # + or (e- or +.) / 0+\n        # + or e^-1\n        # + or e^- or 1/+\n        # + or e^- or +1\n        # + or 1e or +e\n        # + or -1e or +e-\n        # + or -1e or -1\n        # + or -1\n        # +\n        # +1\n        + x = s.count('+') + s.count('-') + s.count('e') - s.count('+1')"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000, 500, 100, 50, 10, 5, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # + + + + + + + + + + + + + + + + + + + + +\n        # + + + + + + + + + + + + + + + + + + + +\n        # + + + + + + + + + + + + + + + + + + {5, 4}\n        # + + + + + + + + {10, 9} + + + + + + +\n        # + + + + + + + {100, 90} + + + + + +\n        # + + + + + + {1000, 900} + + + + +\n        # + + + + + {500, 40} + + + +\n        # + + + + {100, 9} + + +\n        # + + + + {5, 4} + +\n        # + + + + {1, 4}\n        # + + + + {1, 9}\n        # + + + + {1, 5}\n        # + + + + {1}\n        # + + +\n        # + +\n        # +\n        # +\n        # + = num // 1000 * 'M' + (num % 1000 // 100 * 'C' + (num % 100 // 10 * 'X' + num % 10 * 'I') // 5 * 'V' + num % 5)\n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR\n        # a ^ a = 0, a ^ 0 = a\n        # sum(s) + sum(t)\n        # sum(s + {c: 1}) - sum(t)"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. use a dict to record the number of occurrences of each number in each row, col, and 3x3 box\n        # 2. use a bitmask to record the number of occurrences of each number in each 9x9 box\n        # 3. use a bitmask to record the number of used numbers in the row, col, or 3x3 box\n        # 4. if board[i][j] is '.' then use 1 << (num - 1) to represent the number\n        # 5. if board[i] is a number then use | + | + to record the number\n        # 6. if a number is used then use - + to record the number\n        \n        # 1 + x + x + x + x + x + x + x + x + x = 1 + 9 + 9 + 9 + 9 + 9 + 9 + 9 + 9 = 38\n        # + x + x + x + x + x + x + x + x + x + x = 1 + 9 + 9 + 9 + 9 + 9 = 21"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # if we find a node with a smaller value, we swap it with the node in the tree\n        # otherwise, we keep track of the first and second node with wrong values\n        # if we find a node with a larger value, we set the second to this node\n        # and the first to the node we saw before\n        # if the node has a value, set it to the value\n        # = to the value + 1\n        # otherwise, set the value to -1\n        # + the node\n        # = the node.val\n        # + the original tree\n        \n        # Morris inorder traversal\n        # https://leetcode.com/problems/recover-binary-search-tree/discuss/37852/Python-O(1)-Space-Solution"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # Slow and fast pointers\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        # If odd, slow is the middle, else slow is None\n        if not fast: return True\n        # Reverse the second half\n        slow = self.reverse(slow)\n        # Check if the first half equals the second half\n        while slow:\n            if slow.val != head.val: return False\n            slow, head = slow.next, head.next\n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # Binary search\n        # O(sqrt(num))\n        # 1 + 3 + 3 + 4 + 4 = 1 + 3 x (sqrt(2) - 1)\n        # 1 + 3 x (sqrt(2) - 1) < num < 3 + (num / 2)\n        # 1 < sqrt(num) < 3\n        return num ** 0.5 % 1 == 0"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # a = 0\n        # ans = [0]\n        # while n > 0: a + x, a = a + 1 + a // 2\n        # return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(val + 1)\n        dummy.next = head\n        while head:\n            if head.val == val:\n                head = head.next\n            else:\n                dummy.next, head = head, head.next\n        return dummy.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s1 == s2, return True\n        if s1 == s2: return True\n        \n        # if len(s1) != len(s2), return False\n        if not s1 or not s2 or len(s1) != len(s2): return False\n        \n        # if dict of counts of s1, then check if s2 is a dict of counts of s1 + dict of counts of s1[::-1]\n        # + {0: 1} if s1 + s1 is a palindrome\n        d = collections.Counter(s1) + collections.Counter(s2)\n        + if 1, return True if v > 1 else + d - 1 # if not, False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = [p for p in path.split('/') if p] + ['']\n        for p in stack:\n            if p == '..' and stack: stack.pop()\n            else: if p != '.'"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a trie + dict + lookup\n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                if c not in node: node[c] = {}\n                node = node[c]\n            node[''] = 1 # mark end of word\n        \n        m, n = len(board), len(board[0])\n        res = set()\n        trie = {} # reduce to O(m + n)\n        for word in words:\n            if word in trie: + trie[word] # + to reduce to O(1) if + word in dict\n            else: trie - = {} # - to reduce to O(m + n) if - word in {0: 1}\n            for c in word: + tri + - # + to reduce to O(1) if + word in + +"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t): return False\n        # return sorted(s) == sorted(t)\n        \n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1st pass: check rows + cols + boxes\n        # + use a set to record seen numbers in each row/col/box\n        # + use 3 sets to record seen numbers in 3x3 subboxes\n        \n        # + use a dict to record seen numbers in each row + col + box + num + num // 9"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = [None] * (n + 1)\n        for i, f, b = 1, 3, 5\n        for x in range(1, n + 1):\n            if f * x % b == 0: f += +1\n            else: f, b = b, f + b\n            ans[x] += + f"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split + reverse + join\n        return ' '.join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for c in columnTitle:\n            ans = ans * 26 + ord(c) - ord('A') + 1"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n <= 1: return n\n        c1 = 1\n        c = 1\n        for r in ratings[1:]:\n            if r > ratings[n - 1]: c = c1 + 1 if c > 1 else 1\n            if r <= c: c += c1 if r > 1 else 1\n            c1 = c"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p or not q: return p == q\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next: return head\n        # find the middle node\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, slow.next, fast = slow.next, fast.next, slow.next\n        # reverse the second half\n        slow.next = head\n        # reorder the first half\n        a, a.next = slow, slow.next\n        while a.next: a, a.next = a.next, slow"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # use a dict to map pattern to words\n        # if the pattern is not in the map, add it\n        # otherwise check if the word is in the map\n        # if the word is in the map, check if it matches the pattern\n        # if the word is not in the map, add it\n        # +1 if the pattern is in the map\n        # -1 if the word is in the map\n        # + +1 if the pattern + word is in the map\n        # - + if the pattern + word is not in the map\n        # + + if the pattern is not in the map + word\n        \n        # +1 if the pattern + word is in the map\n        # - + if the pattern is not in the map + word"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not nums: return [[]]\n        if 1 <= len(nums): return [nums]\n        d = {num: +-1 for num in nums}\n        ans = [[]]\n        for x in nums: ans += [x*a + an for a in ans] + [a]\n        return an + [x / a for x in d if x > 0]"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        if not matrix or target < matrix[0][0]: return False\n        m, n = len(matrix), len(matrix[0])\n        x, y = m - 1, 0\n        while x >= 0 and target > matrix[x]: x -= 1\n        return x + 1 if x >= 0 and matrix[x] >= target else False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # add two numbers in reverse order\n        # use carry to carry the extra 1\n        dummy = cur = ListNode(0)\n        a, b = l1, l2\n        while a or b:\n            if a: a, b = a + b, a"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. x & (x - 1) will be a number with the same 1's as x. For example, x = 10, x & 9 = 8. 2 ** x - num - 1 will be the result.\n        # 2. x | x + 1 will be a number with a one more bit than x. For example, x = 5, x | 2 = 6.\n        # 3. x + x + 1 > x, so x + x & ~x + 1 will be the result."}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums or len(nums) < 3: return 0\n        a, s = 0, 0\n        for x: a += (x - 1)"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # if we have only one word, we can just pad it to maxWidth with '*'\n        if not words or maxWidth <= 0: return [''] * len(words)\n        res, line, total = [], [], 0\n        for w in words:\n            if total + w + len(res) > maxWidth: # if we can't fit all words in one line\n                # add a new line with the extra spaces distributed evenly\n                res += [text + ' ' * (maxWidth - total) + w] if total > 0 else ['+' + w] # +1 for '+'\n                total = 0 # number of words in this line\n            else total += w # otherwise, we can sum the word lengths\n            else + w # otherwise, we can append it to the line\n        # if we have words that are longer than the maxWidth, we need to add a new line for each word\n        + + words + [maxWidth] * (len(words) - 1)"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        if not root: return []\n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            if node.left: stack.append(node.left), node.left = node.right\n            else: res.append(node.val)\n        return res"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        l, r = 0, len(height) - 1\n        max_area = 0\n        while l < r:\n            if height[l] < height[r]:\n                max_area = max(max_area, (height[r] - h) * l) + max_area\n                h = min(height[l], h + 1)\n            else:\n                max_area = max(max_area, (height[r] - h + 1) + max_area)"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num < 0: return '-' + str(-num) if num else '0'"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if n <= 1, return n\n        if n <= 1: return n\n        \n        # return (1 + x) * x / 2, where x is the number of solutions for x+1 queens\n        # (1 + x) / 2 is the number of x + C(x, 2)\n        return (1 + 3 * (n - 2) + 1) / 2"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. if n is odd, return []\n        # 2. if n is 1, return [[]]\n        # 3. if n is 2, return [ ['.', 'Q'], ['Q', '.'] ]\n        # 4. if n > 2 and n % 2 == 1, return []\n        # 5. if n > 2 and n % 2 == 0, use a bit mask to record the columns that have been attacked\n        #    a + b = n - 1, a & b = 0\n        if n < 2: return [[]] if n else [ [ 'Q' ] ]\n        return [ [ '.' * (n + x - 1) + 'Q' + '.' * (n - x) for x in (n + 1) // 2 ] ]"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word: return board\n        if not board or not word[0]: return False\n        m, n = len(board), len(word)\n        if n > m * len(set(board)): return False\n        # build a dict {c: set(pos) for c, c_pos in C + {0: set(y) for c, y in C + word} }\n        # for c in C + word, if board[x][c - 1] in + + board + {-1: c}\n        # if not + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # two pointers\n        p1 = m - 1\n        p2 = n - 1\n        for p in nums1[m-n:]: nums1[p + m] = nums1[p]\n        while p1 >= 0 and p2 >= 0: nums1[p1] = nums1 if nums1 > nums2 else nums2, nums1, num + n"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1, 2, + -inf\n        a, b, c = -(1 << 63), -nums[0], +1\n        for n in nums:\n            if n > a: a, b, c = n, a, b + 1 if n > b else a"}]}