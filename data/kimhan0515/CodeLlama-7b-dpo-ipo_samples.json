{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right, top, bottom = 0, n - 1, 0, m - 1\n        res = []\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n            left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right, top, bottom = 0, n - 1, 0, m - 1\n        res = []\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            for i in range(top, bottom):\n                res.append(matrix[i][right])\n            right -= 1\n            if left <= right:\n                for i in range(right, top, -1):\n                    res.append(matrix[bottom][i])\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, left, -1):\n                    res.append(matrix[i][left])\n            left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right, top, bottom = 0, n - 1, 0, m - 1\n        res = []\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n            left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right, top, bottom = 0, n - 1, 0, m - 1\n        res = []\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n            left += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right, top, bottom = 0, n - 1, 0, m - 1\n        res = []\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n            left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                continue\n            if start == nums[i-1]:\n                res.append(str(start))\n            else:\n                res.append(str(start) + '->' + str(nums[i-1]))\n            start = nums[i]\n        if start == nums[-1]:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(nums[-1]))\n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                continue\n            if start == nums[i-1]:\n                res.append(str(start))\n            else:\n                res.append(str(start) + '->' + str(nums[i-1]))\n            start = nums[i]\n        if start == nums[-1]:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(nums[-1]))\n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                continue\n            if start == nums[i-1]:\n                res.append(str(start))\n            else:\n                res.append(str(start) + '->' + str(nums[i-1]))\n            start = nums[i]\n        if start == nums[-1]:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(nums[-1]))\n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                continue\n            if start == nums[i-1]:\n                res.append(str(start))\n            else:\n                res.append(str(start) + '->' + str(nums[i-1]))\n            start = nums[i]\n        if start == nums[-1]:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(nums[-1]))\n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                continue\n            if start == nums[i-1]:\n                res.append(str(start))\n            else:\n                res.append(str(start) + '->' + str(nums[i-1]))\n            start = nums[i]\n        if start == nums[-1]:\n            res.append(str(start))\n        else:\n            res.append(str(start) + '->' + str(nums[-1]))\n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the number of distinct subsequences of s[:i] that equals t\n        dp = [1] * (len(t) + 1)\n        for c in s:\n            if c == t[0]:\n                dp[1:] = dp[:-1]\n            else:\n                dp[1:] = dp[1:] + dp[:-1]\n        return dp[-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the number of distinct substrings of s[:i] that equals t\n        dp = [1] * (len(t) + 1)\n        for c in s:\n            if c == t[0]:\n                dp[1:] = dp[:-1]\n            else:\n                dp[1:] = dp[1:] + dp[:-1]\n        return dp[-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the number of distinct substrings of s[:i] that equals t\n        dp = [1] * (len(t) + 1)\n        for c in s:\n            if c == t[0]:\n                dp[1:] = dp[:-1]\n            else:\n                dp[1:] = dp[1:] + dp[:-1]\n        return dp[-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the number of distinct substrings of s[:i] that equals t\n        dp = [1] * (len(t) + 1)\n        for c in s:\n            if c == t[0]:\n                dp[1:] = dp[:-1]\n            else:\n                dp[1:] = dp[1:] + dp[:-1]\n        return dp[-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the number of distinct substrings of s[:i] that equals t\n        dp = [1] * (len(t) + 1)\n        for c in s:\n            if c == t[0]:\n                dp[1:] = dp[:-1]\n            else:\n                dp[1:] = dp[1:] + dp[:-1]\n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u628a\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5728\u6b63\u786e\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\n        # 3. \u5982\u679c\u627e\u5230\u4e86\uff0c\u8fd4\u56de\u5b83\n        # 4. \u5426\u5219\uff0c\u8fd4\u56de\u6570\u7ec4\u957f\u5ea6\u52a01\n        \n        # 1. \u628a\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\n        i = 0\n        while i < len(nums) and nums[i] <= len(nums):\n            j = nums[i] - 1\n            if nums[i] != nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n            else:\n                i += 1\n        \n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5728\u6b63\u786e\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # 3. \u5982\u679c\u627e\u5230\u4e86\uff0c\u8fd4\u56de\u5b83\n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u628a\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\n        # 2. \u4ece 1 \u5f00\u59cb\u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u9047\u5230 nums[i] != i + 1\uff0c\u8bf4\u660e\u7f3a\u5931\u7684\u6570\u5b57\u662f i + 1\n        # 3. \u5982\u679c\u904d\u5386\u5b8c\u6570\u7ec4\uff0c\u4ecd\u7136\u6ca1\u6709\u627e\u5230\u7f3a\u5931\u7684\u6570\u5b57\uff0c\u8bf4\u660e\u7f3a\u5931\u7684\u6570\u5b57\u662f len(nums) + 1\n        \n        # 1. \u628a\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\n        for i in range(len(nums)):\n            if nums[i] <= 0 or nums[i] > len(nums):\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\n        \n        # 2. \u4ece 1 \u5f00\u59cb\u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u9047\u5230 nums[i] != i + 1\uff0c\u8bf4\u660e\u7f3a\u5931\u7684\u6570\u5b57\u662f i + 1\n        for i in range(1, len(nums)):\n            if nums[i] > 0:\n                return i\n        \n        # 3. \u5982\u679c\u904d\u5386\u5b8c\u6570\u7ec4\uff0c\u4ecd\u7136\u6ca1\u6709\u627e\u5230\u7f3a\u5931\u7684\u6570\u5b57\uff0c\u8bf4\u660e\u7f3a\u5931\u7684\u6570\u5b57\u662f len(nums) + 1\n        return len(nums) + 1\n```\n\n## 2. C++\n\n```cpp\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] <= 0 || nums[i] > n) {\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]);\n            }\n        }\n        \n        for (int i = 1; i < n; ++i) {\n            if (nums[i] > 0) {\n                return i;\n            }\n        }\n        \n        return n + 1;\n    }\n};\n```\n\n## 3. Java\n\n```java\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] <= 0 || nums[i] > n) {\n                nums[Math.abs(nums[i]) - 1] = -Math.abs(nums[Math.abs(nums[i]) - 1]);\n            }\n        }\n        \n        for (int i = 1; i < n; ++i) {\n            if (nums[i] > 0) {\n                return i;\n            }\n        }\n        \n        return n + 1;\n    }\n}\n```\n\n## 4. \u5176\u4ed6\u8bed\u8a00\n\n**Python2**\n\n```python\nclass Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0 or nums[i] > n:\n                nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1])\n        \n        for i in range(1, n):\n            if nums[i] > 0:\n                return i\n        \n        return n + 1\n```\n\n**Go**\n\n```go\nfunc firstMissingPositive(nums []int) int {\n    n := len(nums)\n    for i := 0; i < n; i++ {\n        if nums[i] <= 0 || nums[i] > n {\n            nums[abs(nums[i]) - 1] = -abs(num"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u628a\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5728\u6b63\u786e\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\n        # 3. \u5982\u679c\u627e\u5230\u4e86\uff0c\u8fd4\u56de\u8fd9\u4e2a\u6570\u5b57\n        # 4. \u5982\u679c\u6ca1\u6709\u627e\u5230\uff0c\u8fd4\u56de\u6570\u7ec4\u957f\u5ea6\u52a0 1\n        \n        # 1. \u628a\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\n        i = 0\n        while i < len(nums) and nums[i] <= len(nums):\n            if nums[i] != i + 1:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n            else:\n                i += 1\n        \n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5728\u6b63\u786e\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # 3. \u5982\u679c\u627e\u5230\u4e86\uff0c\u8fd4\u56de\u8fd9\u4e2a\u6570\u5b57\n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u5230\u6700\u5927\u7684\u6b63\u6574\u6570\n        # 2. \u627e\u5230\u6700\u5c0f\u7684\u8d1f\u6574\u6570\n        # 3. \u5982\u679c\u6700\u5927\u7684\u6b63\u6574\u6570\u548c\u6700\u5c0f\u7684\u8d1f\u6574\u6570\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u6700\u5927\u7684\u6b63\u6574\u6570\n        # 4. \u5982\u679c\u6700\u5927\u7684\u6b63\u6574\u6570\u548c\u6700\u5c0f\u7684\u8d1f\u6574\u6570\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u6700\u5927\u7684\u6b63\u6574\u6570 + 1\n        # 5. \u5982\u679c\u6700\u5927\u7684\u6b63\u6574\u6570\u548c\u6700\u5c0f\u7684\u8d1f\u6574\u6570\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u6700\u5927\u7684\u6b63\u6574\u6570 + 2\n        \n        # 1. \u627e\u5230\u6700\u5927\u7684\u6b63\u6574\u6570\n        max_num = 0\n        for num in nums:\n            if num > max_num:\n                max_num = num\n        \n        # 2. \u627e\u5230\u6700\u5c0f\u7684\u8d1f\u6574\u6570\n        min_num = max_num + 1\n        for num in nums:\n            if num > 0 and num <= max_num:\n                min_num = num\n                max_num = max(max_num, num)\n            elif num < 0 and num < min_num:\n                min_num = num\n        \n        # 3. \u5982\u679c\u6700\u5927\u7684\u6b63\u6574\u6570\u548c\u6700\u5c0f\u7684\u8d1f\u6574\u6570\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u6700\u5927\u7684\u6b63\u6574\u6570\n        if min_num > max_num:\n            return max_num + 1\n        \n        # 4. \u5982\u679c\u6700\u5927\u7684\u6b63\u6574\u6570\u548c\u6700\u5c0f\u7684\u8d1f\u6574\u6570\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u6700\u5927\u7684\u6b63\u6574\u6570 + 1\n        if min_num == max_num:\n            return max_num + 2\n        \n        # 5. \u5982\u679c\u6700\u5927\u7684\u6b63\u6574\u6570\u548c\u6700\u5c0f\u7684\u8d1f\u6574\u6570\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u6700\u5927\u7684\u6b63\u6574\u6570 + 2\n        return min_num"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u628a\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5728\u6b63\u786e\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\n        # 3. \u5982\u679c\u627e\u5230\u4e86\uff0c\u8fd4\u56de\u5b83\n        # 4. \u5426\u5219\uff0c\u8fd4\u56de\u6570\u7ec4\u957f\u5ea6\u52a01\n        \n        # 1. \u628a\u6570\u5b57\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\n        i = 0\n        while i < len(nums) and nums[i] <= len(nums):\n            j = nums[i] - 1\n            if nums[i] != nums[j]:\n                nums[i], nums[j] = nums[j], nums[i]\n            else:\n                i += 1\n        \n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u5728\u6b63\u786e\u4f4d\u7f6e\u4e0a\u7684\u6570\u5b57\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # 3. \u5982\u679c\u627e\u5230\u4e86\uff0c\u8fd4\u56de\u5b83\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1 <= k <= n!\n        # k = 1 + 2 + 3 + ... + n - 1\n        # k = n * (n - 1) / 2\n        # n * k = n * (n - 1 + n - 2) / 2\n        # n * k = n * (n - 1)\n        # k = n * (n - 1 + 1) / 2\n        # k = n * (n + 1) / 2\n        # k - 1 = n * (n + 1) / 2 - 1\n        # k - 1 = n * (n + 1) / 2 - 1\n        # k - 1 = (n * (n + 1)) / 2 - 1\n        # k - 1 = (n * (n + 2)) / 2\n        # k - 1 = (n * (n + 2)) / 2 - n\n        # k - 1 = (n * (n + 2)) / 2 - n\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n + 2)) % 2\n        # k - 1 = (n * (n +"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1!, 2!, 3!, 4!, 5!, 6!, 7!, 8!, 9!, 10!\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        \n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        \n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8,"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # k = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # n = 1, 2"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return []"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if not num:\n            return []\n        \n        res = []\n        cur = 0\n        prev = 0\n        mul = 1\n        for i, c in enumerate(num):\n            cur = cur * 10 + int(c)\n            if i == 0:\n                prev = cur\n                continue\n            res.append(str(prev) + '+' + num[i:])\n            if cur != 0:\n                res.append(str(prev) + '-' + num[i:])\n            res.append(str(prev) + '*' + num[i:])\n            if cur"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        self.dfs(num, 0, 0, target, res)\n        return res\n        \n    def dfs(self, num, start, prev, target, res):\n        if start == len(num):\n            if prev == target:\n                res.append(str(prev))\n            return\n        \n        cur = prev * 10 + int(num[start])\n        if start == 0 or cur != prev * 10:\n            self.dfs(num, start + 1, cur, target, res)\n        self.dfs(num, start + 1, cur, target - cur, res)\n        self.dfs(num, start + 1, prev, target - cur, res)\n```\n\n### 2. DP\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        dp = [0] * (len(num) + 1)\n        dp[1] = int(num[0])\n        res = []\n        for i in range(2, len(num) + 1):\n            dp[i] = dp[i - 1] * 10 + int(num[i - 1])\n            if dp[i] - dp[i - i] == target:\n                res.append(str(dp[i - i]) + '+' + num[i - 1:i])\n            if dp[i] - 2 * dp[i - i] == target:\n                res.append(num[i - i:i] + '*' + num[i - 1])\n        return res if dp[-1] == target else []\n```\n\n### 3. DP + Memorization\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        dp = {0: 1}\n        res = []\n        prev = 0\n        for i in range(len(num)):\n            prev = (prev * 10 + int(num[i])) % target\n            if prev in dp:\n                res.append(str(dp[prev] * num[:i + 1]) if i + 1 else str(prev))\n            if prev == 0:\n                dp[prev] = 1\n            else:\n                dp[prev] = dp.get(target - prev, 0)\n        return res if dp.get(prev, False) else []\n```\n\n### 4. DP + Memorization + Optimization\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        prev, cur = 0, 0\n        res = []\n        for i in range(len(num)):\n            cur = 10 * cur + int(num[i]) - (i * '0' if i else 0)\n            if cur == target:\n                res.append('0' if not prev else '"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        self.dfs(num, 0, 0, target, res)\n        return res\n        \n    def dfs(self, num, start, prev, target, res):\n        if start == len(num):\n            if prev == target:\n                res.append(str(prev))\n            return\n        \n        cur = prev * 10 + int(num[start])\n        if start == 0 or cur != prev * 10:\n            self.dfs(num, start + 1, cur, target, res)\n        self.dfs(num, start + 1, cur, target - cur, res)\n        self.dfs(num, start + 1, prev, target - cur, res)\n```\n\n### 2. DP\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        dp = [0] * (len(num) + 1)\n        dp[1] = int(num[0])\n        res = []\n        for i in range(2, len(num) + 1):\n            dp[i] = dp[i - 1] * 10 + int(num[i - 1])\n            if dp[i] - dp[i - i] == target:\n                res.append(str(dp[i - i]) + '+' + num[i - 1:i])\n            if dp[i] - dp[i - i - 1] == target:\n                if i - 1 >= 1:\n                    res.append(num[i - 1 - 1] + str(target - dp[i - 1 - 1]) + num[i - 1:i])\n        return res\n```\n\n### 3. DP + Memorization\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        dp = {0: 1}\n        res = []\n        prev = 0\n        for i in range(len(num)):\n            prev = (prev * 10 + int(num[i])) % target\n            if prev in dp:\n                res.append(str(dp[prev] * num[:i + 1]) if i + 1 else str(prev))\n            if prev == 0:\n                dp[prev] = 1\n            else:\n                dp[prev] = dp.get(target - prev, 0)\n        return res\n```\n\n### 4. DP + Memorization + Optimization\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        prev, cur = 0, 0\n        res = []\n        for i in range(len(num)):\n            cur = 10 * cur + int(num[i]) - (i * '0' if i else 0)\n            if cur == target:\n                res.append('0' if not prev else '"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        self.dfs(num, 0, 0, target, res)\n        return res\n        \n    def dfs(self, num, start, prev, target, res):\n        if start == len(num):\n            if prev == target:\n                res.append(str(prev))\n            return\n        \n        cur = prev * 10 + int(num[start])\n        if start == 0 or cur != prev * 10:\n            self.dfs(num, start + 1, cur, target, res)\n        self.dfs(num, start + 1, cur, target - cur, res)\n        self.dfs(num, start + 1, prev, target - cur, res)\n```\n\n### 2. DP\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        dp = [0] * (len(num) + 1)\n        dp[1] = int(num[0])\n        res = []\n        for i in range(2, len(num) + 1):\n            dp[i] = dp[i - 1] * 10 + int(num[i - 1])\n            if dp[i] - dp[i - i] == target:\n                res.append(str(dp[i - i]) + '+' + num[i - 1:i])\n            if dp[i] - 2 * dp[i - i] == target:\n                res.append(num[i - i:i] + '*' + num[i - 1])\n        return res if dp[-1] == target else []\n```\n\n### 3. DP + Memoization\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        dp = {0: []}\n        res = []\n        prev = 0\n        for i in range(len(num)):\n            prev = prev * 10 + int(num[i])\n            if prev in dp:\n                res.extend(dp[prev][:])\n            dp[prev] = [num[:i + 1]] if prev == 0 else dp[prev] + [num[:i + 1]]\n            if prev - dp[prev - prev] == target:\n                res.append(dp[prev - target])\n        return res if prev == target else []\n```\n\n### 4. DP + Memoization + Trie\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        dp = 0\n        res = Trie()\n        res.val = 0\n        for i in range(len(num)):\n            dp = dp * 10 + int(num[i])\n            if dp - res.val in res:\n                res = res.next[dp - res.val]\n            else:\n                res.next[dp] = Trie()\n                res.next[dp].val = dp\n        if dp - res.val == target:\n            return [res.val]\n        return []\n        \nclass Trie:\n    def __init__(self):\n        self.val = 0\n        self.next = collections.defaultdict(Trie)\n```\n\n### 5. DP + Memoization + Trie + Hash\n\n```python\nclass Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        if not num:\n            return []\n        \n        dp = 0\n        res = {0: '#'}\n        for i in range(len(num)):\n            dp"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if not num:\n            return []\n        \n        res = []\n        cur = 0\n        prev = 0\n        mul = 1\n        for i, c in enumerate(num):\n            cur = cur * 10 + int(c)\n            if i == 0:\n                prev = cur\n                continue\n            res.append(str(prev) + '+' + num[i:])\n            if cur != 0:\n                res.append(str(prev) + '-' + num[i:])\n            res.append(str(prev) + '*' + num[i:])\n            if cur"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return self.sumNumbers(root.left, root.val) + self.sumNumbers(root.right, root.val * 10)\n        \n    def sumNumbers(self, node, val):\n        if not node:\n            return 0\n        \n        val = val * 10 + node.val\n        return val + self.sumNumbers(node.left, val) + self.sumNumbers(node.right, val)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return self.sumNumbers(root.left, root.val) + self.sumNumbers(root.right, root.val * 10)\n        \n    def sumNumbers(self, node, val):\n        if not node:\n            return 0\n        \n        val = val * 10 + node.val\n        return val + self.sumNumbers(node.left, val) + self.sumNumbers(node.right, val)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return self.sumNumbers(root.left, root.val) + self.sumNumbers(root.right, root.val * 10)\n        \n    def sumNumbers(self, node, val):\n        if not node:\n            return 0\n        \n        return val * 10 + node.val + self.sumNumbers(node.left, val * 10) + self.sumNumbers(node.right, val * 10)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return self.sumNumbers(root.left, root.val) + self.sumNumbers(root.right, root.val * 10)\n        \n    def sumNumbers(self, node, val):\n        if not node:\n            return 0\n        \n        val = val * 10 + node.val\n        return val + self.sumNumbers(node.left, val) + self.sumNumbers(node.right, val)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return self.sumNumbers(root.left, root.val) + self.sumNumbers(root.right, root.val * 10)\n        \n    def sumNumbers(self, node, val):\n        if not node:\n            return 0\n        \n        val = val * 10 + node.val\n        return val + self.sumNumbers(node.left, val) + self.sumNumbers(node.right, val)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        return s[:(k-1)*(len(s)//k)] + (s[(k-1)*(len(s)//k):] if len(s)%k else '')"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        return s[:(k-1)*(len(s)//k)] + s[(k-1)*(len(s)//k):]."}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        return s[:(k-1)*(len(s)//k)] + s[(k-1)*(len(s)//k):]."}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        return s[:(k-1)*(len(s)//k)] + (s[(k-1)*(len(s)//k):] if len(s)%k else '')"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        return s[:(k-1)*(len(s)//k)] + (s[(k-1)*(len(s)//k):] if len(s)%k else '')"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5047\u8bbe\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u7740\u8def\u5f84\u8d70\u5230\u7ec8\u70b9\uff0c\u6cbf\u8def\u8d70\u7684\u603b\u8ddd\u79bb\u4e3a S\uff0c\u6cbf\u8def\u8d70\u7684\u603b\u6cb9\u91cf\u4e3a G\n        # 2. \u5982\u679c S > G\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf\u8def\u8d70\u7684\u8ddd\u79bb\u5927\u4e8e\u6cb9\u91cf\uff0c\u8bf4\u660e\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u6cbf"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5047\u8bbe\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\n        # 2. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u7ee7\u7eed\u5f80\u4e0b\u8d70\uff0c\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 3. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u5219\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i] + gas[0] - cost[0]\n        # 4. \u5982\u679c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u7ee7\u7eed\u5f80\u4e0b\u8d70\uff0c\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 5. \u5982\u679c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i] + gas[0] - cost[0]\uff0c\n        #    \u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\n        #    \u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\n        #    \u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\n        #    \u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\n        #    \u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\n        #    \u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas[0] - cost[0]\uff0c\n        #    \u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u7684\u5269\u4f59\u6cb9\u91cf\u4e3agas["}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u603b\u7684\u51cf\u53bb\u6bcf\u4e2a\u52a0\u6cb9\u7ad9\u7684\u6210\u672c\uff0c\u5982\u679c\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4e0d\u80fd\u4ece\u8fd9\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\n        # 2. \u5982\u679c\u603b\u7684\u5927\u4e8e0\uff0c\u5219\u4ece\u8fd9\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\uff0c\u5982\u679c\u52a0\u6cb9\u7ad9\u7684\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e\u5269\u4f59\u6cb9\u91cf\uff0c\u5219\u8bf4\u660e\u4ece\u8fd9\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\u53ef\u4ee5\u5230\u8fbe\u7ec8\u70b9\n        # 3. \u5982\u679c\u603b\u7684\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u8fd9\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\u65e0\u6cd5\u5230\u8fbe\u7ec8\u70b9\uff0c\u5219\u4ece\u8fd9\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u5269\u4f59\u6cb9\u91cf\u52a0\u4e0a\u52a0\u6cb9\u7ad9\u7684\u6cb9\u91cf\uff0c\u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e\u5269\u4f59\u6cb9\u91cf\uff0c\u5219\u8bf4\u660e\u4ece\u8fd9\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\u53ef\u4ee5\u5230\u8fbe\u7ec8\u70b9\n        # 4. \u5982\u679c\u603b\u7684\u5927\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u8fd9\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\u53ef\u4ee5\u5230\u8fbe\u7ec8\u70b9\uff0c\u5219\u8fd4\u56de\u8fd9\u4e2a\u52a0\u6cb9\u7ad9\u7684\u4e0b\u6807\n        total = sum(gas) - sum(cost)\n        if total < 0:\n            return -1\n        start = 0\n        remain = total\n        for i in range(len(gas)):\n            remain += gas[i] - cost[i]\n            if remain < 0:\n                start = i + 1\n                remain = 0\n        return start if remain >= 0 else -1"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u603b\u7684\u51cf\u53bb\u6bcf\u4e2a\u7ad9\u70b9\u7684\u82b1\u8d39\uff0c\u5982\u679c\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u4e0d\u80fd\u4ece\u8fd9\u4e2a\u7ad9\u70b9\u51fa\u53d1\n        # 2. \u5982\u679c\u603b\u7684\u5927\u4e8e0\uff0c\u5219\u4ece\u8fd9\u4e2a\u7ad9\u70b9\u5f00\u59cb\uff0c\u5982\u679c\u5269\u4f59\u7684\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e\u5269\u4f59\u7684\u82b1\u8d39\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u4ece\u8fd9\u4e2a\u7ad9\u70b9\u51fa\u53d1\n        # 3. \u5982\u679c\u603b\u7684\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u8fd9\u4e2a\u7ad9\u70b9\u5f00\u59cb\uff0c\u5982\u679c\u5269\u4f59\u7684\u6cb9\u91cf\u5c0f\u4e8e\u5269\u4f59\u7684\u82b1\u8d39\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u4ece\u8fd9\u4e2a\u7ad9\u70b9\u51fa\u53d1\n        # 4. \u5982\u679c\u603b\u7684\u5927\u4e8e0\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u4ece\u8fd9\u4e2a\u7ad9\u70b9\u51fa\u53d1\uff0c\u5219\u8fd4\u56de\u8fd9\u4e2a\u7ad9\u70b9\u7684\u4e0b\u6807\n        total = 0\n        for i in range(len(gas)):\n            total += gas[i] - cost[i]\n            if total < 0:\n                total = 0\n            else:\n                return i\n        return -1"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5047\u8bbe\u4ece\u7b2c\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u7684\u6cb9\u91cf\u4e3agas[0] - cost[0]\n        # 2. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u7ee7\u7eed\u5f80\u4e0b\u8d70\uff0c\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 3. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i-1\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\n        # \u5219\u4ecei+1\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 4. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\n        # \u5219\u4ecei\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 5. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\n        # \u5219\u4ecei+1\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 6. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\n        # \u5219\u4ecei\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 7. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\n        # \u5219\u4ecei+1\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 8. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\n        # \u5219\u4ecei\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 9. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\n        # \u5219\u4ecei+1\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 10. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\n        # \u5219\u4ecei\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 11. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0\u6cb9\u7ad9\u8d77\uff0c\u5230\u52a0\u6cb9\u7ad9i\u65f6\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u5c0f\u4e8e0\uff0c\n        # \u5219\u4ecei+1\u5f00\u59cb\uff0c\u603b\u5269\u4f59\u6cb9\u91cf\u4e3agas[i] - cost[i]\n        # 12. \u5982\u679c\u5269\u4f59\u6cb9\u91cf\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u4ece\u5f53\u524d\u52a0"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [0] * n\n        for i in range(2, n):\n            left, right = i - 2, i + 2\n            while left >= 0 and right < n and nums[left]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [0] * n\n        \n        for i in range(2, n):\n            left, right = i - 1, i + 1\n            while left >= 1 and right < n and nums[left]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [0] * n\n        \n        for i in range(2, n):\n            left, right = i - 1, i + 1\n            while left >= 1 and right < n and nums[left]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [0] * n\n        for i in range(2, n):\n            left, right = i - 2, i + 2\n            while left >= 0 and right < n and nums[left]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [0] * n\n        \n        for i in range(2, n):\n            left, right = i - 1, i + 1\n            while left >= 1 and right < n and nums[left]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] != 9:\n                digits[i] += 1\n                return digits\n        digits.insert(0, 1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        carry = 1\n        for i in range(len(digits)-1, -1, -1):\n            digits[i] += carry\n            carry = digits[i] // 10\n            digits[i] %= 10\n        if carry:\n            digits.insert(0, 1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        carry = 1\n        for i in range(len(digits)-1, -1, -1):\n            digits[i] += carry\n            carry = digits[i] // 10\n            digits[i] %= 10\n        if carry:\n            digits.insert(0, 1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        carry = 1\n        for i in range(len(digits)-1, -1, -1):\n            digits[i] += carry\n            carry = digits[i] // 10\n            digits[i] %= 10\n        if carry:\n            digits.insert(0, carry)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] != 9:\n                digits[i] += 1\n                return digits\n        digits.insert(0, 1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u5982\u679cp\u4e3a\u7a7a\uff0c\u5219s\u4e5f\u5fc5\u987b\u4e3a\u7a7a\n        # 2. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f'*'\uff0c\u5219p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u4efb\u610f\u5b57\u7b26\u5339\u914d\uff0c\u6216\u8005p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\n        # 3. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\uff0c\u5219p\u548cs\u7684\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u5206\u522b\u5339\u914d\n        # 4. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u5339\u914d\uff0c\u5219p\u4e0d\u4e3a\u7a7a\uff0c\u5219p\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5fc5\u987b\u4e3a'*'\uff0c\u6b64\u65f6p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u4efb\u610f\u5b57\u7b26\u5339\u914d\uff0c\u6216\u8005p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\n        # 5. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\uff0c\u5219p\u548cs\u7684\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u5206\u522b\u5339\u914d\n        # 6. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u5339\u914d\uff0c\u5219p\u4e0d\u4e3a\u7a7a\uff0c\u5219p\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5fc5\u987b\u4e3a'*'\uff0c\u6b64\u65f6p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u4efb\u610f\u5b57\u7b26\u5339\u914d\uff0c\u6216\u8005p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\n        # 7. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\uff0c\u5219p\u548cs\u7684\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u5206\u522b\u5339\u914d\n        # 8. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u5339\u914d\uff0c\u5219p\u4e0d\u4e3a\u7a7a\uff0c\u5219p\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5fc5\u987b\u4e3a'*'\uff0c\u6b64\u65f6p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u4efb\u610f\u5b57\u7b26\u5339\u914d\uff0c\u6216\u8005p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\n        # 9. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\uff0c\u5219p\u548cs\u7684\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u5206\u522b\u5339\u914d\n        # 10. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u5339\u914d\uff0c\u5219p\u4e0d\u4e3a\u7a7a\uff0c\u5219p\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5fc5\u987b\u4e3a'*'\uff0c\u6b64\u65f6p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u4efb\u610f\u5b57\u7b26\u5339\u914d\uff0c\u6216\u8005p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\n        # 11. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\uff0c\u5219p\u548cs\u7684\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u5206\u522b\u5339\u914d\n        # 12. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u5339\u914d\uff0c\u5219p\u4e0d\u4e3a\u7a7a\uff0c\u5219p\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5fc5\u987b\u4e3a'*'\uff0c\u6b64\u65f6p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u4efb\u610f\u5b57\u7b26\u5339\u914d\uff0c\u6216\u8005p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\n        # 13. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\uff0c\u5219p\u548cs\u7684\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u5206\u522b\u5339\u914d\n        # 14. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u5339\u914d\uff0c\u5219p\u4e0d\u4e3a\u7a7a\uff0c\u5219p\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5fc5\u987b\u4e3a'*'\uff0c\u6b64\u65f6p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u4efb\u610f\u5b57\u7b26\u5339\u914d\uff0c\u6216\u8005p\u7684\u4e0b\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\n        # 15. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5339\u914d\uff0c\u5219p\u548cs\u7684\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u5206\u522b\u5339\u914d\n        # 16. \u5982\u679cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548cs\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u5339\u914d\uff0c\u5219p\u4e0d\u4e3a\u7a7a"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u5982\u679cp\u4e3a\u7a7a\uff0c\u5219s\u4e5f\u4e3a\u7a7a\uff0c\u8fd4\u56deTrue\n        # 2. \u5982\u679cp\u4e3a\u7a7a\uff0c\u4f46s\u4e0d\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        # 3. \u5982\u679cp[0] == s[0] or p[0] == '.'\uff0c\u5219s[0] == s[1] or p[1] == '*' and s[0] == p[0]\n        # 4. \u5982\u679cp[0] != s[0] and p[0] != '.'\uff0c\u5219p[1] == '*' and s[0] == p[0]\n        # 5. \u5982\u679cp[0] == '*'\uff0c\u5219p[1] == '.' or p[1] == s[0]\n        # 6. \u5982\u679cp[0] != '*'\uff0c\u5219p = p[1:]\n        # 7. \u5982\u679cs = s[1:]\n        # 8. \u5982\u679cp == p[1:], \u5219s = s[1:]\n        # 9. \u5982\u679cp != p[1:], \u5219p = p[1:]\n        # 10. \u5982\u679cp == '*'\uff0c\u5219p = p[2:]\n        # 11. \u5982\u679cp != '*'\uff0c\u5219p = p[1:]\n        # 12. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 13. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 14. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 15. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 16. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 17. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 18. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 19. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 20. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 21. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 22. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 23. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 24. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 25. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 26. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 27. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 28. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 29. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 30. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 31. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 32. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 33. \u5982\u679cp != '*'\uff0c\u5219s = s[1:] or p = p[1:]\n        # 34. \u5982\u679cp == '*'\uff0c\u5219s = s[1:] or p = p[2:]\n        # 35. \u5982\u679cp != '*'\uff0c\u5219"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # s = s + '#'\n        # p = p + '#'\n        # i, j = len(s) - 1, len(p) - 1\n        # while i >= 0 and j >= 0:\n        #     if p[j] == '*':\n        #         while i >= 0 and (s[i] != p[j - 1] or (s[i] == p[j - 1] and p[j - 1] != '*')):\n        #             i -= 1\n        #         j -= 2\n        #     elif s[i] == p[j] or p[j] == '.':\n        #         i -= 1\n        #         j -= 1\n        #     else:\n        #         return False\n        # return j < 0\n        \n        i, j = len(s) - 1, len(p) - 1\n        while i >= 0:\n            if j >= 0 and (p[j] == '.' or s[i] == p[j]):\n                i, j = i - 1, j - 1\n            elif j >= 1 and p[j - 1] == '*':\n                i, j = i - p[j] - 1, j - 2\n            else:\n                return False\n        return True"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # s = s + '#'\n        # p = p + '#'\n        # i = 0\n        # j = 0\n        # while i < len(s) and j < len(p):\n        #     if p[j] == '.' or p[j] == s[i]:\n        #         i += 1\n        #         j += 1\n        #     elif p[j] == '*':\n        #         if j + 1 < len(p) and p[j + 1] == s[i]:\n        #             j += 1\n        #         else:\n        #             i += 1\n        #     else:\n        #         return False\n        # return j == len(p)\n        \n        i, j = 0, 0\n        while i < len(s) and j < len(p):\n            if p[j] == '.' or s[i] == p[j]:\n                i += 1\n                j += 1\n            elif p[j] == '*':\n                if p[j - 1] == s[i] or p[j - 1] == '.':\n                    i += 1\n                else:\n                    j += 1\n            else:\n                return False\n        return j == len(p)"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u5982\u679cp\u662f\u7a7a\u5b57\u7b26\u4e32\uff0c\u90a3\u4e48s\u4e5f\u5fc5\u987b\u662f\u7a7a\u5b57\u7b26\u4e32\n        # 2. \u5982\u679cp\u975e\u7a7a\uff0c\u4e14\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f'*'\uff0c\u90a3\u4e48p\u524d\u9762\u7684\u5b57\u7b26\u548cs\u5339\u914d\u6216\u8005\u4e3a\u7a7a\uff0cp\u540e\u9762\u7684\u5b57\u7b26\u548cs\u5339\u914d\u6216\u8005\u4e3a\u7a7a\n        # 3. \u5982\u679cp\u975e\u7a7a\uff0c\u4e14\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u662f'*'\uff0c\u90a3\u4e48p\u524d\u9762\u7684\u5b57\u7b26\u548cs\u5339\u914d\n        # 4. \u5982\u679cp\u975e\u7a7a\uff0c\u4e14\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f'*'\uff0c\u90a3\u4e48p\u524d\u9762\u7684\u5b57\u7b26\u548cs\u5339\u914d\u6216\u8005\u4e3a\u7a7a\uff0cp\u540e\u9762\u7684\u5b57\u7b26\u548cs\u5339\u914d\n        # 5. \u5982\u679cp\u975e\u7a7a\uff0c\u4e14\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e0d\u662f'*'\uff0c\u90a3\u4e48p\u524d\u9762\u7684\u5b57\u7b26\u548cs\u5339\u914d\n        if not p:\n            return not s\n        first_match, pre_star = p[0] == '*', False\n        for i in range(len(s)):\n            if first_match:\n                if p[0] == '.' or s[i] == p[0]:\n                    first_match, pre_star = False, False\n                elif p[0] == '*':\n                    pre_star = True\n            elif pre_star:\n                if p[0] == s[i] or p[0] == '.':\n                    first_match = False\n                else:\n                    first_match, pre_star = True, True\n            else:\n                return False\n            p = p[1:] if p else p\n        return not first_match or pre_star"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1 = [0] + nums1\n        nums2 = [0] + nums2\n        \n        return nums1[:k] + nums2[:k] - max(nums1[:k-"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # nums1 + nums2\n        # nums1 + nums2 < k\n        # nums1 + nums2 >= k\n        # nums1 + nums2 - k\n        # nums1 + nums2 - k >= 0\n        # nums1 >= k - nums2\n        # nums2 >= k - nums1\n        \n        # nums1 >= nums2\n        if len(nums1) >= len(nums2) and k > len(nums2):\n            return self.maxNumber(nums2, nums1, k)\n        \n        # nums1 < nums2\n        if len(nums1) + len(nums2) < k:\n            return [0] * (k - len(nums1) - len(nums2)) + nums1 + nums2\n        \n        # nums1 >= nums2\n        i, j = len(nums1) - 1, len(nums2) - 1\n        res = []\n        carry = 0\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += nums1[i]\n                i -= 1\n            if j >= 0:\n                carry += nums2[j]\n                j -= 1\n            res.append(carry % 10)\n            carry //= 10\n        res.reverse()\n        return res[:k]"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # nums1 + nums2\n        # nums1 + nums2 > k\n        # nums1 + nums2 < k\n        # nums1 + nums2 == k\n        \n        # nums1 + nums2 > k\n        # nums1 + nums2 - k > nums2\n        # nums1 + nums2 - k <= nums1\n        # nums1 >= nums2 - (nums1 + nums2 - k)\n        # nums1 >= nums2 - (k - m)\n        # nums1 >= k - m\n        # nums1 >= k - (m - n)\n        # nums1 >= n\n        if len(nums1) < k - len(nums2):\n            return nums2[:k]\n        \n        # nums1 + nums2 < k\n        # nums1 + nums2 - k < nums1\n        # nums1 + nums2 - k >= nums2\n        # nums1 + nums2 - k <= nums1 + nums2 - k\n        # nums1 + nums2 - k <= k\n        # nums1 + nums2 - k <= k - n\n        # nums1 + nums2 - k <= k - (n - m)\n        # nums1 + nums2 - k <= k - (k - m)\n        # nums1 + nums2 - k <= m\n        if len(nums1) > k:\n            return nums1[:k]\n        \n        # nums1 + nums2 == k\n        # nums1 + nums2 - k == 0\n        # nums1 + nums2 - k == nums1\n        # nums1 + nums2 - k == nums2\n        # nums1 + nums2 - k == k - n\n        # nums1 + nums2 - k == k - (n - m)\n        # nums1 + nums2 - k == k - (k - m)\n        # nums1 + nums2 - k == m\n        # nums1 + nums2 - k == n\n        # nums1 + nums2 - k == m - n\n        # nums1 + nums2 - k == k - (m - n)\n        # nums1 + nums2 - k == k - (k - m)\n        # nums1 + nums2 - k == 0\n        # nums1 + nums2 - k == k\n        return nums1 + nums2[:k - len(nums1)]"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # nums1 + nums2\n        # nums1 + nums2 < k\n        # nums1 + nums2 >= k\n        # nums1 + nums2 - k\n        # nums1 + nums2 - k >= 0\n        # nums1 >= k - nums2\n        # nums1 >= nums2\n        # nums1 >= nums2 - (k - nums1)\n        # nums1 >= nums2 - (k - nums1 + 1)\n        # nums1 >= nums2 - (k - nums1 + 1) + 1\n        # nums1 >= nums2 - k + 1\n        # nums1 >= nums2 - k + 1 + 1\n        # nums1 >= nums2 - k + 2\n        # nums1 >= nums2 - (k - 2)\n        # nums1 >= nums2 - (k - 2) + 1\n        # nums1 >= nums2 - (k - 2) + 2\n        # nums1 >= nums2 - (k - 2) + 2 + 1\n        # nums1 >= nums2 - k + 2 + 1\n        # nums1 >= nums2 - k + 1\n        # nums1 >= nums2 - k + 1 + 1\n        # nums1 >= nums2 - k + 1 + 1 + 1\n        # nums1 >= nums2 - k + 3\n        # nums1 >= nums2 - k + 3 + 1\n        # nums1 >= nums2 - k + 3 + 1 + 1\n        # nums1 >= nums2 - k + 3 + 2\n        # nums1 >= nums2 - k + 3 + 2 + 1\n        # nums1 >= nums2 - k + 3 + 2 + 1 + 1\n        # nums1 >= nums2 - k + 3 + 3\n        # nums1 >= nums2 - k + 3 + 3 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 1 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 2\n        # nums1 >= nums2 - k + 3 + 3 + 2 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 2 + 1 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 1 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 2\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 2 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 2 + 1 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3 + 1 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3 + 2\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3 + 2 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3 + 2 + 1 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3 + 3\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3 + 3 + 1\n        # nums1 >= nums2 - k + 3 + 3 + 3 + 3 + 3 + 1 + 1\n        # nums1 >= nums2 - k +"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # nums1 + nums2 = (nums1[0] + nums2[0]) * 10^0 + (nums1[1] + nums2[1]) * 10^1 + ...\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers to find the largest number\n        # if nums1[i] > nums2[j], we can use nums1[i] to fill the number\n        # if nums1[i] <= nums2[j], we can use nums2[j] to fill the number\n        # so we can use two pointers"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num <= 1:\n            return False\n        \n        i = 2\n        sum = 1\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                sum += i\n                num //= i\n        \n        return sum == num + 1"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num <= 1:\n            return False\n        \n        # 1 + 2 + 3 + ... + num / 2 = num * (num + 1) / 2\n        # so if num * (num + 1) is even, num must be perfect number\n        return num * (num + 1) % 2 == 0"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num <= 1:\n            return False\n        \n        i = 2\n        sum = 1\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                sum += i\n                num //= i\n        \n        return num == sum or num == sum + 1"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num <= 1:\n            return False\n        \n        i = 2\n        sum_divisors = 1 + num\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                sum_divisors += i\n                i += 1\n        \n        return sum_divisors == num * 2"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num <= 1:\n            return False\n        \n        i = 2\n        sum_divisors = 1 + num\n        while i * i <= num:\n            if num % i:\n                i += 1\n            else:\n                sum_divisors += i\n                i += 1\n        \n        return sum_divisors == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return a"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return a"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return a"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return a"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return a"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + dungeon[i][j]\n        # dp[0][0] = 1\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [1] * (n + 1)\n        for i in range(1, m + 1):\n            dp[i % n] = max(dp[(i - 1) % n] - dungeon[i - 1][i % n], 1)\n        return dp[n - 1]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [0] * (n + 1)\n        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n        \n        for i in range(m - 1, -1, -1):\n            dp[i] = max(1, dp[i + 1] - dungeon[i][n - 1])\n            \n        for i in range(n - 1):\n            dp[i] = max(1, dp[i] - dungeon[m - 1][i])\n            \n        return dp[0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [0] * (n + 1)\n        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n        \n        for i in range(m - 1, -1, -1):\n            dp[i] = max(1, dp[i + 1] - dungeon[i][n - 1])\n            \n        for i in range(n - 1):\n            dp[i] = max(1, dp[i] - dungeon[m - 1][i])\n            \n        return dp[0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + dungeon[i][j]\n        # dp[0][0] = 1\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [1] * (n + 1)\n        for i in range(1, m + 1):\n            dp[i % n] = max(dp[(i - 1) % n] - dungeon[i - 1][i % n], 1)\n        return dp[n - 1]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [0] * (n + 1)\n        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1])\n        \n        for i in range(m - 1, -1, -1):\n            dp[i] = max(1, dp[i + 1] - dungeon[i][n - 1])\n            \n        for i in range(n - 1):\n            dp[i] = max(1, dp[i] - dungeon[m - 1][i])\n            \n        return dp[0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = nums[0], nums[-1]\n        count = 0\n        while left < right:\n            if nums[right] - nums[left] <= k:\n                count += right - left\n                right -= 1\n            else:\n                k -= right - left\n                left += 1\n        return count if k == 0 else -1"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        i, j = 0, len(nums) - 1\n        while i < j:\n            if nums[i] + nums[j] <= 2 * nums[k]:\n                k -= j - i\n                i += 1\n            else:\n                j -= 1\n        return 2 * nums[k] if k > 0 else 0"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = nums[0], nums[-1]\n        count = 0\n        while left < right:\n            if nums[right] - nums[left] > right - left:\n                right -= right - left\n            else:\n                count += right - left\n                left += 1\n            k -= 1\n            if k == 0:\n                return count\n        return count"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = nums[0], nums[-1]\n        count = 0\n        while left < right:\n            if nums[right] - nums[left] > right - left:\n                right -= (right - left)\n            else:\n                count += right - left\n                left += 1\n        return count if count <= k else k"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = nums[0], nums[-1]\n        count = 0\n        while left < right:\n            if nums[right] - nums[left] <= k:\n                count += right - left\n                right -= 1\n            else:\n                k -= right - left\n                left += 1\n        return count if k == 0 else -1"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # count the number of non-space characters\n        return s.count(' ') + 1 if s else 0"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Count the number of spaces\n        # 2. Add 1 to the number of spaces\n        # 3. Return the number of spaces + 1\n        return s.count(' ') + 1"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                if i == 0 or s[i-1] == ' ':\n                    count += 1\n        return count"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                if i == 0 or s[i-1] == ' ':\n                    count += 1\n        return count"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                if i == 0 or s[i-1] == ' ':\n                    count += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set('aeiouAEIOU')\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and s[left] not in vowels:\n                left += 1\n            while left < right and s[right] not in vowels:\n                right -= 1\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        return s"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set('aeiouAEIOU')\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and s[left] not in vowels:\n                left += 1\n            while left < right and s[right] not in vowels:\n                right -= 1\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        return s"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set('aeiouAEIOU')\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and s[left] not in vowels:\n                left += 1\n            while left < right and s[right] not in vowels:\n                right -= 1\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        return s"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set('aeiouAEIOU')\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and s[left] not in vowels:\n                left += 1\n            while left < right and s[right] not in vowels:\n                right -= 1\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        return s"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = set('aeiouAEIOU')\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and s[left] not in vowels:\n                left += 1\n            while left < right and s[right] not in vowels:\n                right -= 1\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        return s"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # M1. HashSet\n        # M2. HashSet + 2 pointers\n        # M3. Sort + 2 pointers\n        # M4. Sort + 2 pointers + Set\n        # M5. Binary Search\n        \n        # M1. HashSet\n        # Time: O(N)\n        # Space: O(N)\n        nums = set(nums)\n        return len(nums) - len(nums & {nums.pop() - 1}) if nums else 0\n        \n        # M2. HashSet + 2 pointers\n        # Time: O(N)\n        # Space: O(N)\n        nums = set()\n        ans = 0\n        for num in nums:\n            if num in nums: continue\n            if num - 1 in nums: nums.add(num)\n            else: ans += 1\n        return ans\n        \n        # M3. Sort + 2 pointers\n        # Time: O(NlogN)\n        # Space: O(1)\n        nums.sort()\n        ans, prev = 1, nums[0]\n        for num in nums[1:]:\n            if num == prev: continue\n            ans += 1 if num == prev + 1 else 1\n            prev = num\n        return ans\n        \n        # M4. Sort + 2 pointers + Set\n        # Time: O(NlogN)\n        # Space: O(N)\n        nums.sort()\n        ans, prev = 1, nums[0]\n        for num in nums[1:]:\n            if num == prev: prev = num\n            else: ans += 1\n            prev = num\n        return ans\n        \n        # M5. Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        nums.sort()\n        ans = 1\n        prev = nums[0]\n        for num in nums[1:]:\n            if num == prev: prev = num\n            else: prev = num - ans\n            ans = max(ans, num - prev)\n        return ans + 1\n        \n        # M6. Binary Search + Set\n        # Time: O(NlogN)\n        # Space: O(N)\n        nums.sort()\n        ans, prev = 1, nums[0]\n        for num in nums[1:]:\n            if num == prev: prev = num\n            else: prev = num - ans\n            ans = max(ans, num - prev)\n        return ans + 1\n        \n        # M7. Binary Search + Set\n        # Time: O(NlogN)\n        # Space: O(1)\n        nums.sort()\n        ans, prev = 1, nums[0]\n        for num in nums[1:]:\n            if num == prev: prev = num\n            else: prev = num - ans\n            ans = max(ans, num - prev)\n        return ans + 1\n        \n        # M8. Binary Search + Set\n        # Time: O(NlogN)\n        # Space: O(1)\n        nums.sort()\n        ans, prev = 1, nums[0]\n        for num in nums[1:]:\n            if num == prev: prev = num\n            else: prev = num - ans\n            ans = max(ans, num - prev)\n        return ans + 1\n        \n        # M9. Binary Search + Set\n        # Time: O(NlogN)\n        # Space: O(1)\n        nums.sort()\n        ans, prev = 1, nums[0]\n        for num in nums[1:]:\n            if num == prev: prev = num\n            else: prev = num - ans\n            ans = max(ans, num - prev)\n        return ans + 1\n        \n        # M10. Binary Search + Set\n        # Time: O(NlogN)\n        # Space: O(1)\n        nums.sort()\n        ans, prev = 1, nums[0]\n        for num in nums[1:]:\n            if num == prev: prev = num\n            else: prev = num - ans\n            ans = max(ans, num - prev)\n        return ans + 1\n        \n        # M11."}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        nums = set(nums)\n        max_len = 1\n        for num in nums:\n            if num - 1 in nums:\n                continue\n            else:\n                num_next = num + 1\n                while num_next in nums:\n                    num_next += 1\n                max_len = max(max_len, num_next - num)\n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        nums = set(nums)\n        max_len = 1\n        for num in nums:\n            if num - 1 in nums:\n                continue\n            else:\n                num_next = num + 1\n                while num_next in nums:\n                    num_next += 1\n                max_len = max(max_len, num_next - num)\n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        nums = set(nums)\n        max_len = 1\n        for num in nums:\n            if num - 1 in nums:\n                continue\n            else:\n                num_next = num + 1\n                while num_next in nums:\n                    num_next += 1\n                max_len = max(max_len, num_next - num)\n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # M1. HashSet\n        # M2. \u54c8\u5e0c\u8868 + \u53cc\u6307\u9488\n        # M3. \u6392\u5e8f + \u53cc\u6307\u9488\n        # M4. \u6392\u5e8f + \u4e8c\u5206\u67e5\u627e\n        \n        # M1. HashSet\n        # \u4f7f\u7528\u4e00\u4e2aHashSet\u6765\u8bb0\u5f55\u6bcf\u4e2a\u6570\u5b57\u662f\u5426\u51fa\u73b0\u8fc7\uff0c\u5982\u679c\u51fa\u73b0\u8fc7\uff0c\u5219\u8df3\u8fc7\uff0c\u5982\u679c\u6ca1\u6709\u51fa\u73b0\u8fc7\uff0c\u5219\u5c06\u8be5\u6570\u5b57\u52a0\u5165\u5230\u7ed3\u679c\u4e2d\uff0c\u5e76\u4e14\u5c06\u8be5\u6570\u5b57\u52a0\u5165\u5230HashSet\u4e2d\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf 0\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u91cd\u590d\u5143\u7d20\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf\u8d1f\u6570\uff0c\u5219\u7ed3\u679c\u4f1a\u9519\u8bef\u3002\n        # \u5982\u679c\u6570\u7ec4\u4e2d\u6709\u5927\u91cf"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sum of all numbers from 0 to n is n(n+1)/2\n        # sum of all numbers in nums is sum(nums)\n        # so missing number is (n(n+1)/2 - sum(nums))\n        return (len(nums) * (len(nums) + 1) // 2) - sum(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sum of all numbers from 0 to n is n(n+1)/2\n        # sum of all numbers in nums is sum(nums)\n        # so missing number is (n(n+1)/2 - sum(nums))\n        return (len(nums) * (len(nums) + 1) // 2) - sum(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sum of all numbers from 0 to n is n(n+1)/2\n        # sum of all numbers in nums is sum(nums)\n        # so missing number is (n(n+1)/2 - sum(nums))\n        return (len(nums) * (len(nums) + 1) // 2) - sum(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sum of all numbers from 0 to n is n(n+1)/2\n        # sum of all numbers in nums is sum(nums)\n        # so missing number is (n(n+1)/2 - sum(nums))\n        return (len(nums) * (len(nums) + 1) // 2) - sum(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sum of all numbers from 0 to n is n(n+1)/2\n        # sum of all numbers in nums is sum(nums)\n        # so missing number is (n(n+1)/2 - sum(nums))\n        return (len(nums) * (len(nums) + 1) // 2) - sum(nums)"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        wordList.add(beginWord)\n        queue = collections.deque([beginWord])\n        step = 1\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    new_word = word[:i] + '*' + word[i+1:]\n                    if new_word in wordList:\n                        if new_word == endWord:\n                            return step + 1\n                        queue.append(new_word)\n                        wordList.remove(new_word)\n            step += 1\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        wordList.add(beginWord)\n        queue = collections.deque([beginWord])\n        step = 1\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                cur = queue.popleft()\n                for i in range(len(cur)):\n                    new_word = cur[:i] + '*' + cur[i+1:]\n                    if new_word in wordList:\n                        if new_word == endWord:\n                            return step + 1\n                        queue.append(new_word)\n                        wordList.remove(new_word)\n            step += 1\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        wordList.add(beginWord)\n        queue = collections.deque([beginWord])\n        step = 1\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    new_word = word[:i] + '*' + word[i+1:]\n                    if new_word in wordList:\n                        if new_word == endWord:\n                            return step + 1\n                        queue.append(new_word)\n                        wordList.remove(new_word)\n            step += 1\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        wordList.add(beginWord)\n        queue = collections.deque([beginWord])\n        step = 1\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    new_word = word[:i] + '*' + word[i+1:]\n                    if new_word in wordList:\n                        if new_word == endWord:\n                            return step + 1\n                        queue.append(new_word)\n                        wordList.remove(new_word)\n            step += 1\n        \n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        wordList.add(beginWord)\n        queue = collections.deque([beginWord])\n        step = 1\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                cur = queue.popleft()\n                for i in range(len(cur)):\n                    new_word = cur[:i] + '*' + cur[i+1:]\n                    if new_word in wordList:\n                        if new_word == endWord:\n                            return step + 1\n                        queue.append(new_word)\n                        wordList.remove(new_word)\n            step += 1\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.97% of Python online submissions for Add Binary.\n        # Memory Usage: 12.9 MB, less than 99.97% of Python online submissions for Add Binary.\n        \n        # Reverse the strings\n        a, b = a[::-1], b[::-1]\n        \n        # Add the strings\n        result = ''\n        carry = 0\n        while a or b or carry:\n            if a:\n                carry += int(a[-1])\n                a = a[:-1]\n            if b:\n                carry += int(b[-1])\n                b = b[:-1]\n            result = str(carry % 2) + result\n            carry //= 2\n        return result"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty\n        # a and b are both non-empty"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.95% of Python online submissions for Add Binary.\n        # Memory Usage: 12.9 MB, less than 99.56% of Python online submissions for Add Binary.\n        \n        # Reverse the strings\n        a, b = a[::-1], b[::-1]\n        \n        # Add the strings\n        carry, res = 0, ''\n        for i in range(max(len(a), len(b))):\n            val = carry\n            if i < len(a):\n                val += int(a[i])\n            if i < len(b):\n                val += int(b[i])\n            carry, val = val // 2, val % 2\n            res = str(val) + res\n        if carry:\n            res = '1' + res\n        return res"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.56% of Python online submissions for Add Binary.\n        # Memory Usage: 12.9 MB, less than 99.56% of Python online submissions for Add Binary.\n        \n        # Reverse the strings\n        a, b = a[::-1], b[::-1]\n        \n        # Add the strings\n        carry, res = 0, ''\n        for i in range(max(len(a), len(b))):\n            val = carry\n            if i < len(a):\n                val += int(a[i])\n            if i < len(b):\n                val += int(b[i])\n            carry, val = val // 2, val % 2\n            res = str(val) + res\n        if carry:\n            res = '1' + res\n        return res"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # a and b are both non-empty\n        if a and b:\n            return bin(int(a, 2) + int(b, 2))[2:]\n        \n        # a is empty\n        if not a:\n            return b\n        \n        # b is empty\n        return a"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        left = self.binarySearch(nums, target, True)\n        right = self.binarySearch(nums, target, False) - 1\n        \n        return [-1, -1] if left == len(nums) or nums[left] != target else [left, right]\n    \n    def binarySearch(self, nums, target, left):\n        left_bound, right_bound = 0, len(nums) - 1\n        while left_bound <= right_bound:\n            mid = left_bound + (right_bound - left_bound) // 2\n            if nums[mid] == target:\n                if left:\n                    right_bound = mid - 1\n                else:\n                    left_bound = mid + 1\n            elif nums[mid] < target:\n                left_bound = mid + 1\n            else:\n                right_bound = mid - 1\n        \n        return left_bound"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        left = self.binarySearch(nums, target, True)\n        right = self.binarySearch(nums, target, False) - 1\n        \n        return [-1, -1] if left == len(nums) or nums[left] != target else [left, right]\n        \n    def binarySearch(self, nums, target, left):\n        left_bound, right_bound = 0, len(nums) - 1\n        while left_bound <= right_bound:\n            mid = left_bound + (right_bound - left_bound) // 2\n            if nums[mid] == target:\n                if left:\n                    right_bound = mid - 1\n                else:\n                    left_bound = mid + 1\n            elif nums[mid] < target:\n                left_bound = mid + 1\n            else:\n                right_bound = mid - 1\n        return left_bound"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        left = self.binarySearch(nums, target, True)\n        right = self.binarySearch(nums, target, False) - 1\n        \n        return [-1, -1] if left == len(nums) or nums[left] != target else [left, right]\n        \n    def binarySearch(self, nums, target, left):\n        left_bound, right_bound = 0, len(nums) - 1\n        while left_bound <= right_bound:\n            mid = left_bound + (right_bound - left_bound) // 2\n            if nums[mid] == target:\n                if left:\n                    right_bound = mid - 1\n                else:\n                    left_bound = mid + 1\n            elif nums[mid] < target:\n                left_bound = mid + 1\n            else:\n                right_bound = mid - 1\n        return left_bound"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        left = self.binarySearch(nums, target, True)\n        right = self.binarySearch(nums, target, False) - 1\n        \n        return [-1, -1] if left == len(nums) or nums[left] != target else [left, right]\n        \n    def binarySearch(self, nums, target, left):\n        left_bound, right_bound = 0, len(nums) - 1\n        while left_bound <= right_bound:\n            mid = left_bound + (right_bound - left_bound) // 2\n            if nums[mid] == target:\n                if left:\n                    right_bound = mid - 1\n                else:\n                    left_bound = mid + 1\n            elif nums[mid] < target:\n                left_bound = mid + 1\n            else:\n                right_bound = mid - 1\n        return left_bound"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        left = self.binarySearch(nums, target, True)\n        right = self.binarySearch(nums, target, False) - 1\n        \n        return [-1, -1] if left == len(nums) or nums[left] != target else [left, right]\n    \n    def binarySearch(self, nums, target, left):\n        left_bound, right_bound = 0, len(nums) - 1\n        while left_bound <= right_bound:\n            mid = left_bound + (right_bound - left_bound) // 2\n            if nums[mid] == target:\n                if left:\n                    right_bound = mid - 1\n                else:\n                    left_bound = mid + 1\n            elif nums[mid] < target:\n                left_bound = mid + 1\n            else:\n                right_bound = mid - 1\n        \n        return left_bound"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        i = 1\n        for num in nums[1:]:\n            if num != nums[i-1]:\n                nums[i] = num\n                i += 1\n        \n        return i"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        i = 1\n        for num in nums[1:]:\n            if num != nums[i-1]:\n                nums[i] = num\n                i += 1\n        \n        return i"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        i = 1\n        for num in nums[1:]:\n            if num != nums[i-1]:\n                nums[i] = num\n                i += 1\n        \n        return i"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        i = 1\n        for num in nums[1:]:\n            if num != nums[i-1]:\n                nums[i] = num\n                i += 1\n        \n        return i"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        i = 1\n        for num in nums[1:]:\n            if num != nums[i-1]:\n                nums[i] = num\n                i += 1\n        \n        return i"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u6700\u540e\u4e00\u4e2a\u8df3\u8dc3\u7684\u4f4d\u7f6e\n        last = 0\n        # 2. \u5f53\u524d\u6700\u8fdc\u80fd\u8df3\u8dc3\u7684\u4f4d\u7f6e\n        far = 0\n        # 3. \u8df3\u8dc3\u6b21\u6570\n        steps = 0\n        \n        for i in range(len(nums) - 1):\n            if i > far:\n                steps += 1\n                far = last\n            last = max(last, i + nums[i])\n            \n        return steps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if not nums:\n        #     return 0\n        # \n        # last_reachable_index = 0\n        # steps = 0\n        # for i in range(len(nums) - 1):\n        #     if i > last_reachable_index:\n        #         steps += 1\n        #         last_reachable_index = max(last_reachable_index, i + nums[i])\n        # \n        # return steps\n        \n        # if not nums:\n        #     return 0\n        \n        # last_reachable_index = nums[0]\n        # steps = 1\n        # for i in range(1, len(nums)):\n        #     if i > last_reachable_index:\n        #         steps += 1\n        #         last_reachable_index = max(last_reachable_index, i + nums[i])\n        \n        # return steps\n        \n        # if not nums:\n        #     return 0\n        \n        # last_reachable_index = nums[0]\n        # steps = 1\n        # for i in range(1, len(nums)):\n        #     if i > last_reachable_index:\n        #         steps += 1\n        #     last_reachable_index = max(last_reachable_index, i + nums[i])\n        \n        # return steps\n        \n        # if not nums:\n        #     return 0\n        \n        # last_reachable_index = nums[0]\n        # steps = 1\n        # for i in range(1, len(nums)):\n        #     if i > last_reachable_index:\n        #         steps += 1\n        #         last_reachable_index = i + nums[i]\n        #     else:\n        #         last_reachable_index = max(last_reachable_index, i + nums[i])\n        \n        # return steps\n        \n        # if not nums:\n        #     return 0\n        \n        # last_reachable_index = nums[0]\n        # steps = 1\n        # for i in range(1, len(nums)):\n        #     if i > last_reachable_index:\n        #         steps += 1\n        #         last_reachable_index = i + nums[i]\n        #     else:\n        #         last_reachable_index = max(last_reachable_index, i + nums[i])\n        \n        # return steps\n        \n        # if not nums:\n        #     return 0\n        \n        # last_reachable_index = nums[0]\n        # steps = 1\n        # for i in range(1, len(nums)):\n        #     if i > last_reachable_index:\n        #         steps += 1\n        #         last_reachable_index = i + nums[i]\n        #     else:\n        #         last_reachable_index = max(last_reachable_index, i + nums[i])\n        \n        # return steps\n        \n        # if not nums:\n        #     return 0\n        \n        # last_reachable_index = nums[0]\n        # steps = 1\n        # for i in range(1, len(nums)):\n        #     if i > last_reachable_index:\n        #         steps += 1\n        #         last_reachable_index = i + nums[i]\n        #     else:\n        #         last_reachable_index = max(last_reachable_index, i + nums[i])\n        \n        # return steps\n        \n        # if not nums:\n        #     return 0\n        \n        # last_reachable_index = nums[0]\n        # steps = 1\n        # for i in range(1, len(nums)):\n        #     if i > last_reachable_index:\n        #         steps += 1\n        #         last_reachable_index = i + nums[i]\n        #     else:\n        #         last_re"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u6700\u540e\u4e00\u4e2a\u8df3\u8dc3\u7684\u4f4d\u7f6e\n        last = 0\n        # 2. \u5f53\u524d\u6700\u8fdc\u53ef\u4ee5\u8df3\u8dc3\u7684\u4f4d\u7f6e\n        far = 0\n        # 3. \u8df3\u8dc3\u6b21\u6570\n        steps = 0\n        \n        for i in range(len(nums) - 1):\n            if i > far:\n                steps += 1\n                far = last\n            last = max(last, i + nums[i])\n            \n        return steps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u6700\u540e\u4e00\u4e2a\u8df3\u8dc3\u7684\u4f4d\u7f6e\n        last = 0\n        # 2. \u5f53\u524d\u6700\u8fdc\u53ef\u4ee5\u8df3\u8dc3\u7684\u4f4d\u7f6e\n        far = 0\n        # 3. \u8df3\u8dc3\u6b21\u6570\n        steps = 0\n        \n        for i in range(len(nums) - 1):\n            if i > far:\n                steps += 1\n                far = last\n            last = max(last, i + nums[i])\n            \n        return steps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u6700\u540e\u4e00\u4e2a\u8df3\u8dc3\u7684\u4f4d\u7f6e\n        last = 0\n        # 2. \u5f53\u524d\u6700\u8fdc\u53ef\u4ee5\u8df3\u8dc3\u7684\u4f4d\u7f6e\n        far = 0\n        # 3. \u8df3\u8dc3\u6b21\u6570\n        steps = 0\n        \n        for i in range(len(nums) - 1):\n            if i > far:\n                steps += 1\n                far = last\n            last = max(last, i + nums[i])\n            \n        return steps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        buy1, sell1 = prices[0], 0\n        buy2, sell2 = prices[0], -prices[0]\n        \n        for price in prices[1:]:\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, price + buy1)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, price + buy2)\n            \n        return sell2 if k > 1 else sell1"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        buy1, buy2 = prices[0], prices[0]\n        sell1, sell2 = 0, 0\n        \n        for price in prices[1:]:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2 if k > 1 else sell1"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        buy1, sell1 = prices[0], 0\n        buy2, sell2 = prices[0], -prices[0]\n        \n        for price in prices[1:]:\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2 if k > 1 else sell1"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        buy1, buy2 = prices[0], prices[0]\n        sell1, sell2 = 0, 0\n        \n        for price in prices[1:]:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2 if k > 1 else sell1"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        buy1, sell1 = prices[0], 0\n        buy2, sell2 = prices[0], -prices[0]\n        \n        for price in prices[1:]:\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, price + buy1)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, price + buy2)\n            \n        return sell2 if k > 1 else sell1"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            num = (1 << 32) + num\n        res = ''\n        while num:\n            res = str(num & 15) + res\n            num >>= 4\n        if res[0] == '0':\n            res = res[1:]\n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        res = ''\n        sign = 1 if num >= 0 else -1\n        num = abs(num)\n        while num:\n            res += hex(num & 15)[2:]\n            num >>= 4\n        if sign == -1:\n            res = '-' + res\n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            num = (1 << 32) + num\n        res = ''\n        while num:\n            res = str(num & 15) + res\n            num >>= 4\n        if res[0] == '0':\n            res = res[1:]\n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            num = (1 << 32) + num\n        res = ''\n        while num:\n            res += str(num & 15)\n            num >>= 4\n        return res[::-1] if num < 0 else res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        res = ''\n        sign = '-' if num < 0 else ''\n        num = abs(num)\n        while num:\n            res += hex(num & 15)[2:]\n            num >>= 4\n        return sign + res[::-1] if res else '0'"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32 s \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u8be5\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e 1\uff0c\u5219\u8bf4\u660e\u8be5\u5b57\u7b26\u5728\u5b57\u7b26\u4e32\u4e2d\u91cd\u590d\u51fa\u73b0\uff0c\u8fd4\u56de -1\u3002\n        # \u6ce8\u610f\uff0c\u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        #"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32 s \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u5219\u8fd4\u56de\u8be5\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e 1 \u5219\u8bf4\u660e\u8be5\u5b57\u7b26\u5728\u5b57\u7b26\u4e32\u4e2d\u91cd\u590d\u51fa\u73b0\uff0c\u8fd4\u56de -1\u3002\n        # \u6ce8\u610f\uff1a\u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u5927\u4e8e 1\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u5927\u4e8e 1\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u7b26\u7684\u7d22\u5f15\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\u4e14\u51fa\u73b0\u6b21\u6570\u4e3a 1\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u51fa\u73b0"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\n        # \u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a1\uff0c\u5219\u8fd4\u56de\u8be5\u5b57\u7b26\u7684\u7d22\u5f15\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e1\uff0c\u5219\u8bf4\u660e\u8be5\u5b57\u7b26\u5728\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u4e86\u591a\u6b21\uff0c\u8fd4\u56de-1\n        # \u6ce8\u610f\uff1a\u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u9700\u8981 O(1) \u7684\u7a7a\u95f4\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\u4e0d\u4f1a\u8d85\u8fc7 26\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u591a\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de -1\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de 0\u3002\n        # \u5982\u679c\u5b57\u7b26\u4e32"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\n        # \u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570, \u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a1, \u5219\u8fd4\u56de\u8be5\u5b57\u7b26\u7684\u7d22\u5f15\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e1, \u5219\u8bf4\u660e\u8be5\u5b57\u7b26\u5728\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u4e86\u591a\u6b21, \u8fd4\u56de-1\n        # \u6ce8\u610f: \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26, \u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26, \u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\n        # \u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # \u904d\u5386\u5b57\u7b26\u4e32\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a1\uff0c\u5219\u8fd4\u56de\u4e0b\u6807\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e1\uff0c\u5219\u8df3\u8fc7\n        # \u5982\u679c\u904d\u5386\u5b8c\uff0c\u6ca1\u6709\u627e\u5230\uff0c\u5219\u8fd4\u56de-1\n        # \u6ce8\u610f\uff1a\u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5219\u8fd4\u56de0\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6ca1\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u6709\u91cd\u590d\u5b57\u7b26\uff0c\u5219\u8fd4\u56de-1\n        # \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if valueDiff == 0:\n            return len(set(nums)) < len(nums)\n        \n        left, right = 0, valueDiff\n        while right < len(nums):\n            if nums[left] <= nums[right]:\n                if right - left <= indexDiff:\n                    return True\n                left = nums[left]\n            else:\n                if nums[right] <= nums[left] + valueDiff:\n                    return True\n                right = nums[right]\n            right += 1\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if valueDiff == 0:\n            return len(set(nums)) < len(nums)\n        \n        left, right = 0, valueDiff\n        while right < len(nums):\n            if nums[left] <= nums[right]:\n                if right - left <= indexDiff:\n                    return True\n                left = nums[left]\n            else:\n                if nums[right] <= nums[left] + valueDiff:\n                    return True\n                right = nums[right]"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if valueDiff == 0:\n            return len(set(nums)) < len(nums)\n        \n        left, right = 0, valueDiff\n        while right < len(nums):\n            if nums[left] <= nums[right]:\n                if right - left <= indexDiff:\n                    return True\n                left = nums[left]\n            else:\n                if nums[right] <= nums[left] + valueDiff:\n                    return True\n                right = nums[right]\n            right += 1\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if valueDiff == 0:\n            return len(set(nums)) < len(nums)\n        \n        left, right = 0, valueDiff\n        while right < len(nums):\n            if nums[left] <= nums[right]:\n                if right - left <= indexDiff:\n                    return True\n                left = nums[left]\n            else:\n                if nums[right] <= nums[left] + valueDiff:\n                    return True\n                right = nums[right]"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if valueDiff == 0:\n            return len(set(nums)) < len(nums)\n        \n        left, right = 0, valueDiff\n        while right < len(nums):\n            if nums[left] <= nums[right]:\n                if right - left <= indexDiff:\n                    return True\n                left = nums[left]\n            else:\n                if nums[right] <= nums[left] + valueDiff:\n                    return True\n                right = nums[right]\n            right += 1\n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2, 3, 4, 5\n        # 0, 1, 1, 2, 2, 3\n        # 0, 0, 1, 1, 2, 2\n        # 0, 0, 0, 1, 1, 2\n        # 0, 0, 0, 0, 1, 1\n        # 0, 0, 0, 0, 0, 1\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2, 3, 4, 5\n        # 0, 1, 1, 2, 2, 3\n        # 0, 0, 1, 1, 2, 2\n        # 0, 0, 0, 1, 1, 2\n        # 0, 0, 0, 0, 1, 1\n        # 0, 0, 0, 0, 0, 1\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2, 3, 4, 5\n        # 0, 1, 1, 2, 2, 3\n        # 0, 0, 1, 1, 2, 2\n        # 0, 0, 0, 1, 1, 2\n        # 0, 0, 0, 0, 1, 1\n        # 0, 0, 0, 0, 0, 1\n        # 0, 0, 0, 0, 0, 0\n        \n        # 0, 1, 2, 3, 4, 5\n        # 0, 0, 1, 1, 2, 2\n        # 0, 0, 0, 1, 1, 2\n        # 0, 0, 0, 0, 1, 1\n        # 0, 0, 0, 0, 0, 1\n        # 0, 0, 0, 0, 0, 0\n        \n        # 0, 1, 2, 3, 4, 5\n        # 0, 0, 0, 1, 1, 2\n        # 0, 0, 0, 0, 1, 1\n        # 0, 0, 0, 0, 0, 1\n        # 0, 0, 0, 0, 0, 0\n        \n        # 0, 1, 2, 3, 4, 5\n        # 0, 0, 0, 0, 1, 1\n        # 0, 0, 0, 0, 0, 1\n        # 0, 0, 0, 0, 0, 0\n        \n        # 0, 1, 2, 3, 4, 5\n        # 0, 0, 0, 0, 0, 0\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4, 5\n        \n        # 0, 1, 2, 3, 4,"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2, 3, 4, 5\n        # 0, 1, 1, 2, 2, 3\n        # 0, 0, 1, 1, 2, 2\n        # 0, 0, 0, 1, 1, 2\n        # 0, 0, 0, 0, 1, 1\n        # 0, 0, 0, 0, 0, 1\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2, 3, 4, 5\n        # 0, 1, 1, 2, 2, 3\n        # 0, 0, 1, 1, 2, 2\n        # 0, 0, 0, 1, 1, 2\n        # 0, 0, 0, 0, 1, 1\n        # 0, 0, 0, 0, 0, 1\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0, 0, 0\n        # 0, 0, 0, 0"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a count of consecutive 1s\n        count = 0\n        \n        # Maintain the maximum count of consecutive 1s\n        max_count = 0\n        \n        for num in nums:\n            if num == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a count of consecutive 1s\n        count = 0\n        \n        # Maintain the maximum count of consecutive 1s\n        max_count = 0\n        \n        for num in nums:\n            if num == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a count of consecutive 1s\n        count = 0\n        \n        # Maintain the maximum count of consecutive 1s\n        max_count = 0\n        \n        for num in nums:\n            if num == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a count of consecutive 1s\n        count = 0\n        \n        # Maintain the maximum count of consecutive 1s\n        max_count = 0\n        \n        for num in nums:\n            if num == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a count of consecutive 1s\n        count = 0\n        \n        # Maintain a count of consecutive 0s\n        zeroes = 0\n        \n        # Keep track of the maximum count\n        max_count = 0\n        \n        for num in nums:\n            if num == 1:\n                count += 1\n            else:\n                max_count = max(max_count, count)\n                zeroes += 1\n                count = zeroes\n                \n        return max_count + zeroes"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = root.left\n        right = root.right\n        \n        if not left:\n            return 1 + self.countNodes(right)\n        if not right:\n            return 1 + self.countNodes(left)\n        \n        return 1 + self.countNodes(left) + self.countNodes(right)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = root.left\n        right = root.right\n        \n        if not left:\n            return 1 + self.countNodes(right)\n        if not right:\n            return 1 + self.countNodes(left)\n        \n        return 1 + self.countNodes(left) + self.countNodes(right)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = root.left\n        right = root.right\n        \n        if not left:\n            return 1 + self.countNodes(right)\n        if not right:\n            return 1 + self.countNodes(left)\n        \n        return 1 + self.countNodes(left) + self.countNodes(right)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = root.left\n        right = root.right\n        \n        if not left:\n            return 1 + self.countNodes(right)\n        if not right:\n            return 1 + self.countNodes(left)\n        \n        return 1 + self.countNodes(left) + self.countNodes(right)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = root.left\n        right = root.right\n        \n        if not left:\n            return 1 + self.countNodes(right)\n        if not right:\n            return 1 + self.countNodes(left)\n        \n        return 1 + self.countNodes(left) + self.countNodes(right)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        res = ''\n        \n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            res = str(carry % 10) + res\n            carry //= 10\n            \n        return res"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        res = ''\n        \n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            res = str(carry % 10) + res\n            carry //= 10\n        return res"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        res = ''\n        \n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            res = str(carry % 10) + res\n            carry //= 10\n        return res"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        res = ''\n        \n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            res = str(carry % 10) + res\n            carry //= 10\n        return res"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        res = ''\n        \n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            res = str(carry % 10) + res\n            carry //= 10\n            \n        return res"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        sign = 1\n        num = 0\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                num *= sign\n                sign = 1\n            elif c == '-':\n                num *= sign\n                sign = -1\n            elif c == '(':\n                stack.append(num * sign)\n                sign = 1\n                num = 0\n            elif c == ')':\n                num += stack.pop() * sign\n                sign = 1\n                \n        num += sign * stack.pop() if stack else 0\n        \n        return num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        sign = 1\n        num = 0\n        for c in s:\n            if c == ' ':\n                continue\n            if c == '+':\n                num += sign\n            elif c == '-':\n                num -= sign\n                sign = -sign\n            elif c == '(':\n                stack.append(num)\n                stack.append(sign)\n                sign = 1\n                num = 0\n            elif c == ')':\n                num *= stack.pop()\n                sign = stack.pop()\n            else:\n                num = num * 10 + int(c)\n        num *= sign\n        return num + stack.pop() if stack else num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        sign = 1\n        num = 0\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                num *= sign\n                sign = 1\n            elif c == '-':\n                num *= sign\n                sign = -1\n            elif c == '(':\n                stack.append(num * sign)\n                sign = 1\n                num = 0\n            elif c == ')':\n                num += stack.pop() * sign\n                sign = 1\n                \n        num += sign * stack.pop() if stack else 0\n        \n        return num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        sign = 1\n        num = 0\n        \n        for c in s:\n            if c == ' ':\n                continue\n            elif c == '+':\n                num += sign\n                sign = 1\n            elif c == '-':\n                num += sign\n                sign = -1\n            elif c == '(':\n                stack.append(num)\n                stack.append(sign)\n                num = 0\n                sign = 1\n            elif c == ')':\n                num += sign * stack.pop()\n                sign = stack.pop()\n                \n        num += sign * stack.pop() if stack else num\n        \n        return num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        sign = 1\n        num = 0\n        \n        for c in s:\n            if c == ' ':\n                continue\n            if c == '+':\n                num += sign\n            elif c == '-':\n                num -= sign\n                sign = -sign\n            elif c == '(':\n                stack.append(num)\n                stack.append(sign)\n                sign = 1\n                num = 0\n            elif c == ')':\n                num *= stack.pop()\n                sign = stack.pop()\n            else:\n                num = num * 10 + int(c)\n                \n        num *= sign\n        return num"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u6392\u5e8f\n        # 2. \u4ece\u540e\u5f80\u524d\u627e\uff0c\u627e\u5230\u7b2c k \u5927\u7684\u8d44\u672c\n        # 3. \u5982\u679c\u8d44\u672c\u5927\u4e8e\u7b49\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u8d44\u672c\uff0c\u7d2f\u52a0\u6536\u76ca\n        # 4. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 5. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 6. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 7. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 8. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 9. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 10. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 11. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 12. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 13. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 14. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 15. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 16. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 17. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 18. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 19. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 20. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 21. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 22. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 23. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 24. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 25. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 26. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 27. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 28. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 29. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 30. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 31. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 32. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 33. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219\u8d44\u672c\u51cf\u53bb\u6536\u76ca\n        # 34. \u5982\u679c\u8d44\u672c\u5c0f\u4e8e w\uff0c\u5219"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        pq = []\n        for i, p in enumerate(profits):\n            if p > w:\n                w += p\n                k -= 1\n                if k == 0:\n                    return w\n            else:\n                heapq.heappush(pq, -capital[i])\n                if len(pq) > k:\n                    w -= -heapq.heappop(pq)\n        \n        return w + sum(heapq.heappop(pq) for _ in range(k))"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # greedy\n        # sort by profit, then capital\n        profits.sort()\n        capital.sort()\n        \n        i, j = 0, len(capital) - 1\n        total = w\n        while i <= j and k > 0:\n            if profits[i] <= capital[j]:\n                total += profits[i]\n                i += 1\n            else:\n                total += capital[j]\n                j -= 1\n                k -= 1\n        \n        return total if k == 0 else -1"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # greedy\n        # sort by profit\n        profits.sort()\n        capital.sort()\n        \n        i, j = 0, len(capital) - 1\n        total = w\n        while i <= j and k:\n            if profits[i] <= capital[j]:\n                total += profits[i]\n                i += 1\n            else:\n                total += capital[j]\n                j -= 1\n                k -= 1\n        \n        return total if k == 0 else -1"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort by profit\n        # 2. add capital to w\n        # 3. if w >= capital[i], add profit to w\n        # 4. if w < capital[i], break\n        # 5. k -= 1\n        # 6. if k == 0, return w\n        profits.sort()\n        w += sum(capital)\n        for i in range(len(profits)):\n            if w >= capital[i]:\n                w += profits[i]\n            else:\n                break\n            k -= 1\n        return w if k == 0 else w - profits[k - 1]"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(')')\n            elif c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif not stack or c != stack.pop():\n                return False\n        return not stack"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(')')\n            elif c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif not stack or stack.pop() != c:\n                return False\n        return not stack"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(')')\n            elif c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif not stack or stack.pop() != c:\n                return False\n        return not stack"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(')')\n            elif c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif not stack or c != stack.pop():\n                return False\n        return not stack"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(')')\n            elif c == '[':\n                stack.append(']')\n            elif c == '{':\n                stack.append('}')\n            elif not stack or c != stack.pop():\n                return False\n        return not stack"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i + 1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # if no such index, then nums is already the largest permutation\n        if i >= 0:\n            # find the first index j > i such that nums[i] < nums[j]\n            j = len(nums) - 1\n            while nums[i] >= nums[j]:\n                j -= 1\n            \n            # swap nums[i] and nums[j]\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the suffix starting from nums[i + 1]\n        nums[i + 1:] = nums[i + 1:][::-1]"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i + 1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # if no such index, then nums is already the largest permutation\n        if i >= 0:\n            # find the first index j > i such that nums[i] < nums[j]\n            j = len(nums) - 1\n            while nums[i] >= nums[j]:\n                j -= 1\n            \n            # swap nums[i] and nums[j]\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the suffix starting from nums[i + 1]\n        nums[i + 1:] = nums[i + 1:][::-1]"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index, then nums is already the largest permutation\n        if i >= 0:\n            # find the first index j > i such that nums[i] < nums[j]\n            j = len(nums) - 1\n            while nums[i] >= nums[j]:\n                j -= 1\n            \n            # swap nums[i] and nums[j]\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the suffix\n        nums[i+1:] = nums[i+1:][::-1]"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i + 1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # if no such index, then nums is the last permutation\n        if i < 0:\n            nums.sort()\n            return\n        \n        # find the first index j > i such that nums[i] < nums[j]\n        j = len(nums) - 1\n        while i < j and nums[i] >= nums[j]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the suffix starting from nums[i + 1]\n        nums[i + 1:] = nums[i + 1:][::-1]"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index, then nums is already the largest permutation\n        if i >= 0:\n            # find the first index j > i such that nums[i] < nums[j]\n            j = len(nums) - 1\n            while nums[i] >= nums[j]:\n                j -= 1\n            \n            # swap nums[i] and nums[j]\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the suffix starting from i+1\n        nums[i+1:] = nums[i+1:][::-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # M1. Hash Table\n        # O(n) time, O(n) space\n        # hash table to store the number and its index\n        # if the number is already in the hash table, check if the index is within the range\n        # otherwise, add the number to the hash table\n        # time complexity: O(N), space complexity: O(N)\n        # 160 / 160 test cases passed.\n        # beats 99.77% of python3 submissions\n        if not nums or k < 1: return False\n        seen = {}\n        for i, num in enumerate(nums):\n            if num in seen and i - seen[num] <= k: return True\n            seen[num] = i\n        return False\n        \n        \n        # M2. Two Pointers\n        # O(n) time, O(1) space\n        # use two pointers, one at the beginning and the other at the end\n        # if the difference between the two pointers is larger than k, move the beginning pointer\n        # otherwise, move the end pointer\n        # time complexity: O(N), space complexity: O(1)\n        # 160 / 160 test cases passed.\n        # beats 99.77% of python3 submissions\n        if not nums or k < 1: return False\n        left, right = 0, 1\n        while right < len(nums):\n            if nums[right] == nums[left]:\n                if right - left <= k: return True\n                left += 1\n            else:\n                right += 1\n        return False\n        \n        \n        # M3. Two Pointers + Set\n        # O(n) time, O(n) space\n        # use a set to store the numbers\n        # if the number is already in the set, move the beginning pointer\n        # otherwise, move the end pointer\n        # time complexity: O(N), space complexity: O(N)\n        # 160 / 160 test cases passed.\n        # beats 99.77% of python3 submissions\n        if not nums or k < 1: return False\n        left, right = 0, 1\n        seen = set()\n        while right < len(nums):\n            if nums[right] in seen:\n                left = max(left, seen[nums[right]] + 1)\n            else:\n                seen[nums[right]] = right\n            if right - left > k:\n                seen.pop(nums[left])\n                left += 1"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u8fd4\u56de True\uff0c\u5426\u5219\u8fd4\u56de False\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u8fd4\u56de True\uff0c\u5426\u5219\u8fd4\u56de False\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u8fd4\u56de True\uff0c\u5426\u5219\u8fd4\u56de False\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        d = {}\n        for num in nums:\n            if num in d and d[num] > k:\n                return True\n            d[num] = d.get(num, 0) + 1\n        return False\n        \n        # M2. \u53cc\u6307\u9488\n        # \u4f7f\u7528\u4e24\u4e2a\u6307\u9488 i \u548c j\uff0c\u5206\u522b\u6307\u5411\u6570\u7ec4\u7684\u5f00\u5934\u548c\u672b\u5c3e\u3002\n        # \u5982\u679c nums[i] == nums[j] \u4e14 i - j <= k\uff0c\u5219 i \u548c j \u5411\u4e2d\u95f4\u79fb\u52a8\uff0c\u5426\u5219 i \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n        i, j = 0, len(nums) - 1\n        while i < j:\n            if nums[i] == nums[j]:\n                if j - i <= k:\n                    return True\n                i += 1\n            else:\n                j -= 1\n        return False\n        \n        # M3. \u53cc\u6307\u9488 + \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219 i \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\uff0c\u5426\u5219 j \u5411\u5de6\u79fb\u52a8\u4e00\u4f4d\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        d = {}\n        i, j = 0, 0\n        for num in nums:\n            if num in d and i <= d[num]:\n                i = d[num] + 1\n            else:\n                d[num] = j\n            j += 1\n        return j - i <= k\n        \n        # M4. \u6ed1\u52a8\u7a97\u53e3\n        # \u4f7f\u7528\u4e00\u4e2a\u54c8\u5e0c\u8868\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u7a97\u53e3\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\uff0c\u5426\u5219\u7a97\u53e3\u5411\u53f3\u79fb\u52a8 k \u4f4d\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(min(k, n))\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\uff0ck \u662f\u7a97\u53e3\u5927\u5c0f\u3002\n        d = {}\n        left, right = 0, 0\n        for num in nums:\n            if num in d and d[num] >= left:\n                left = d[num] + 1"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u8fd4\u56de True\uff0c\u5426\u5219\u8fd4\u56de False\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u4e00\u6b21\u6570\u7ec4\u5373\u53ef\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u9700\u8981\u5b58\u50a8\u54c8\u5e0c\u8868\uff0c\u5176\u4e2d\u7684\u503c\u4e0d\u4f1a\u8d85\u8fc7 10^5\uff0c\u56e0\u6b64\u603b\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1)\u3002\n        # \n        # \u5982\u679c k \u4e3a 0\uff0c\u5219\u8fd4\u56de False\u3002\n        # \u5982\u679c k \u5927\u4e8e 0\uff0c\u5219\u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u8fd4\u56de True\uff0c\u5426\u5219\u8fd4\u56de False\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u4e00\u6b21\u6570\u7ec4\u5373\u53ef\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u9700\u8981\u5b58\u50a8\u54c8\u5e0c\u8868\uff0c\u5176\u4e2d\u7684\u503c\u4e0d\u4f1a\u8d85\u8fc7 10^5\uff0c\u56e0\u6b64\u603b\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1)\u3002\n        if k == 0:\n            return False\n        seen = {}\n        for num in nums:\n            if num in seen and seen[num] >= k:\n                return True\n            seen[num] = seen.get(num, 0) + 1\n        return False\n        \n        \n        # M2. \u53cc\u6307\u9488\n        # \u4f7f\u7528\u4e24\u4e2a\u6307\u9488 i \u548c j\uff0c\u5206\u522b\u6307\u5411\u6570\u7ec4\u7684\u5f00\u5934\u548c\u672b\u5c3e\u3002\n        # \u5982\u679c nums[i] == nums[j] \u4e14 j - i \u5c0f\u4e8e\u7b49\u4e8e k\uff0c\u5219 i \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\uff0c\u5426\u5219 j \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u3002\n        # \u5982\u679c nums[i] != nums[j]\uff0c\u5219 i \u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u4e00\u6b21\u6570\u7ec4\u5373\u53ef\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n        i, j = 0, 1\n        while j < len(nums):\n            if nums[i] == nums[j]:\n                if j - i <= k:\n                    j += 1\n                else:\n                    i += 1\n            else:\n                i += 1\n                j += 1\n        return i < j - k\n        \n        \n        # M3. \u6ed1\u52a8\u7a97\u53e3\n        # \u4f7f\u7528\u4e00\u4e2a\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u8fd4\u56de True\uff0c\u5426\u5219\u8fd4\u56de False\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u4e00\u6b21\u6570\u7ec4\u5373\u53ef\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(min(k, n))\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\uff0ck \u662f\u7a97\u53e3\u5927\u5c0f\u3002\n        # \u5982\u679c k \u5927\u4e8e n\uff0c\u5219\u8fd4\u56de False\u3002\n        # \u5982\u679c k \u5c0f\u4e8e\u7b49\u4e8e n\uff0c\u5219\u4f7f\u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u8fd4\u56de True\uff0c\u5426\u5219\u8fd4\u56de False\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u4e00\u6b21\u6570\u7ec4\u5373\u53ef\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(min"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # M1. Hash Table\n        # O(n) time, O(n) space\n        # hash_set = set()\n        # for num in nums:\n        #     if num in hash_set and len(hash_set) < k + 1:\n        #         return True\n        #     hash_set.add(num)\n        # return False\n        \n        # M2. Two Pointers\n        # O(n) time, O(1) space\n        # Use two pointers, one points to the start of the window, the other points to the end of the window.\n        # If the number at the end of the window is not in the set, add it to the set.\n        # If the number at the start of the window is in the set and it's not the same as the number at the end of the window,\n        # remove the number at the start of the window from the set.\n        # If the number at the start of the window is in the set and it's the same as the number at the end of the window,\n        # the answer is true.\n        # If the number at the start of the window is not in the set and the length of the window is greater than k,\n        # remove the number at the start of the window from the set.\n        # Return False if the length of the window is greater than k.\n        if not nums or k < 1:\n            return False\n        \n        start, end = 0, 0\n        seen = set()\n        while end < len(nums):\n            if nums[end] in seen:\n                if end - start <= k:\n                    return True\n                else:\n                    seen.remove(nums[start])\n                    start += 1\n            else:\n                seen.add(nums[end])\n                end += 1\n        return False\n        \n        \n        # M3. Two Pointers + Set\n        # O(n) time, O(k) space\n        # Use a set to store the last k numbers.\n        # If the number at the end of the window is in the set, the answer is true.\n        # If the number at the end of the window is not in the set, add it to the set.\n        # If the set has more than k elements, remove the number at the start of the window from the set.\n        # Return False if the length of the set is more than k.\n        if not nums or k < 1:\n            return False\n        \n        seen = set()\n        for num in nums:\n            if num in seen and len(seen) == k:\n                return True\n            seen.add(num)\n            if len(seen) > k:\n                seen.remove(nums["}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e k \u5219\u8fd4\u56de True\uff0c\u5426\u5219\u8fd4\u56de False\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u4e00\u6b21\u6570\u7ec4\u5373\u53ef\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u9700\u8981\u5b58\u50a8\u54c8\u5e0c\u8868\uff0c\u5176\u4e2d\u7684\u503c\u4e0d\u4f1a\u8d85\u8fc7 10^5\uff0c\u56e0\u6b64\u603b\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(1)\u3002\n        # \n        # \u7531\u4e8e\u9898\u76ee\u9650\u5236\u4e86 k \u7684\u5927\u5c0f\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u5927\u5c0f\u4e3a k + 1 \u7684\u6ed1\u52a8\u7a97\u53e3\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\n        # \u7a97\u53e3\u4e2d\u5b58\u50a8\u7684\u662f\u5143\u7d20\u7684\u503c\uff0c\u7a97\u53e3\u53f3\u8fb9\u754c\u7684\u4e0b\u6807\u5b58\u50a8\u7684\u662f\u5143\u7d20\u7684\u9891\u6b21\u3002\n        # \u5982\u679c\u9891\u6b21\u5927\u4e8e k + 1\uff0c\u8bf4\u660e\u7a97\u53e3\u5185\u6709\u91cd\u590d\u5143\u7d20\uff0c\u76f4\u63a5\u8fd4\u56de True\u3002\n        # \u5982\u679c\u9891\u6b21\u5c0f\u4e8e\u7b49\u4e8e k + 1\uff0c\u7a97\u53e3\u53f3\u8fb9\u754c\u5411\u53f3\u79fb\u52a8\uff0c\u5e76\u5c06\u7a97\u53e3\u5185\u9891\u6b21\u52a0 1\u3002\n        # \u5982\u679c\u9891\u6b21\u4e3a 1\uff0c\u7a97\u53e3\u53f3\u8fb9\u754c\u5411\u53f3\u79fb\u52a8\uff0c\u5e76\u5c06\u7a97\u53e3\u5185\u9891\u6b21\u51cf 1\u3002\n        # \u5982\u679c\u7a97\u53e3\u53f3\u8fb9\u754c\u79fb\u52a8\u5230\u7a97\u53e3\u5185\u9891\u6b21\u4e3a 0 \u7684\u5143\u7d20\uff0c\u7a97\u53e3\u5de6\u8fb9\u754c\u5411\u53f3\u79fb\u52a8\uff0c\u7a97\u53e3\u5185\u9891\u6b21\u52a0 1\u3002\n        # \n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u4e00\u6b21\u6570\u7ec4\u5373\u53ef\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(k)\uff0c\u5176\u4e2d k \u662f\u7a97\u53e3\u5927\u5c0f\u3002\u9700\u8981\u5b58\u50a8\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u3002\n        # \n        # \u5982\u679c\u7a97\u53e3\u5927\u5c0f\u4e3a k + 1\uff0c\u5219\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a k + 1\u3002\n        # \u5982\u679c\u7a97\u53e3\u5927\u5c0f\u4e3a k\uff0c\u5219\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a k\u3002\n        # \n        # \u5982\u679c\u7a97\u53e3\u5927\u5c0f\u4e3a k + 1\uff0c\u5219\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a k + 1\u3002\n        # \u5982\u679c\u7a97\u53e3\u5927\u5c0f\u4e3a k\uff0c\u5219\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a k - 1\u3002\n        # \n        # \u56e0\u6b64\uff0c\u7a97\u53e3\u5927\u5c0f\u4e3a k + 1 \u65f6\uff0c\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a k + 1\uff0c\u7a97\u53e3\u5927\u5c0f\u4e3a k \u65f6\uff0c\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a k - 1\u3002\n        # \u56e0\u6b64\uff0c\u7a97\u53e3\u5927\u5c0f\u4e3a k + 1 \u65f6\uff0c\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a O(k)\uff0c\u7a97\u53e3\u5927\u5c0f\u4e3a k \u65f6\uff0c\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a O(k)\u3002\n        # \n        # \u56e0\u6b64\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a O(k)\u3002\n        # \n        # \u5f53 k \u5f88\u5927\u65f6\uff0c\u7a97\u53e3\u5927\u5c0f\u4e3a k + 1 \u65f6\uff0c\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a O(k)\uff0c\u7a97\u53e3\u5927\u5c0f\u4e3a k \u65f6\uff0c\u7a97\u53e3\u5185\u9891\u6b21\u7684\u8ba1\u6570\u5668\u7684\u5927\u5c0f\u4e3a O(k)\u3002\n        # \u56e0\u6b64\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num, max_num = nums[0], nums[0]\n        for num in nums:\n            min_num = min(min_num, num)\n            max_num = max(max_num, num)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = (max_num - min_num) // (len(nums) - 1)\n        last_bucket_index = min_num\n        max_diff = 0\n        for num in nums:\n            if num"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num, max_num = nums[0], nums[0]\n        for num in nums:\n            min_num = min(min_num, num)\n            max_num = max(max_num, num)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = (max_num - min_num) // (len(nums) - 1)\n        last_bucket_index = min_num\n        max_diff = 0\n        for num in nums:\n            if num > last_bucket_index:\n                max_diff = max(max_diff, num - last_bucket_index)\n            else:\n                last_bucket_index = num\n        \n        if last_bucket_index < max_num:\n            max_diff = max(max_diff, max_num - last_bucket_index)\n        \n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num, max_num = nums[0], nums[0]\n        for num in nums:\n            min_num = min(min_num, num)\n            max_num = max(max_num, num)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = (max_num - min_num) // (len(nums) - 1)\n        last_idx = min_num\n        max_diff = 0\n        for num in nums:\n            if num > last_idx:\n                max_diff = max(max_diff, num - last_idx)\n            else:\n                last_idx = num + bucket_size\n        \n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num, max_num = nums[0], nums[0]\n        for num in nums:\n            min_num = min(min_num, num)\n            max_num = max(max_num, num)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = (max_num - min_num) // (len(nums) - 1)\n        last_idx = min_num\n        max_gap = 0\n        for num in nums:\n            if num > last_idx:\n                max_gap = max(max_gap, num - last_idx)\n            else:\n                last_idx = num\n        \n        return max_gap if last_idx < max_num else max_gap - bucket_size"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        min_num, max_num = nums[0], nums[0]\n        for num in nums:\n            min_num = min(min_num, num)\n            max_num = max(max_num, num)\n        \n        if min_num == max_num:\n            return 0\n        \n        bucket_size = (max_num - min_num) // (len(nums) - 1)\n        last_idx = min_num\n        max_gap = 0\n        for num in nums:\n            if num > last_idx:\n                max_gap = max(max_gap, num - last_idx)\n            else:\n                last_idx = num\n        \n        return max_gap if last_idx < max_num else max_gap - bucket_size"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 0, 2, 1, 3\n        # 0, 1, 2, 3\n        # 0, 3, 1, 2\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        \n        # 0, 1, 2, 3\n        # 0, 2, 1, 3\n        # 0, 3, 1, 2\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        \n        # 0, 1, 2, 3\n        # 0, 2, 1, 3\n        # 0, 3, 1, 2\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        \n        # 0, 1, 2, 3\n        # 0, 2, 1, 3\n        # 0, 3, 1, 2\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        \n        # 0, 1, 2, 3\n        # 0, 2, 1, 3\n        # 0, 3, 1, 2\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 1, 3, 0, 2\n        # 1, 0,"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 0, 2, 1, 3\n        # 0, 1, 2, 3\n        # 0, 3, 1, 2\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 3, 0, 1, 2\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 1, 0, 2, 3\n        # 0, 1, 2, 3\n        # 0, 3, 1, 2\n        # 0, 2, 3, 1\n        # 0, 1, 3, 2\n        # 0, 2, 1, 3\n        # 0, 1, 2, 3\n        # 2, 0, 1, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 2, 0, 3, 1\n        # 2, 1, 0, 3\n        # 2, 3, 1, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 3, 0, 1, 2\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 1, 0, 2, 3\n        # 0, 1, 2, 3\n        # 0, 3, 1, 2\n        # 0, 2, 3, 1\n        # 0, 1, 3, 2\n        # 0, 2, 1, 3\n        # 0, 1, 2, 3\n        # 2, 0, 1, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 2, 0, 3, 1\n        # 2, 1, 0, 3\n        # 2, 3, 1, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 3, 0, 1, 2\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 1, 0, 2, 3\n        # 0, 1, 2, 3\n        # 0, 3, 1, 2\n        # 0, 2, 3, 1\n        # 0, 1, 3, 2\n        # 0, 2, 1, 3\n        # 0, 1, 2, 3\n        # 2, 0, 1, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 2, 0, 3, 1\n        # 2, 1, 0, 3\n        # 2, 3, 1, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        #"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 0, 2, 1, 3\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 2, 0\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 0, 1, 2, 3\n        \n        # 0, 2, 1, 3\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 2, 0\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 0, 1, 2, 3\n        \n        # 0, 2, 1, 3\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 2, 0\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 0, 1, 2, 3\n        \n        # 0, 2, 1, 3\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 2, 0\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 0, 1, 2, 3\n        \n        # 0, 2, 1, 3\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 2, 0\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 0, 1, 2, 3\n        \n        # 0, 2, 1, 3\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3,"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 0, 2, 1, 3\n        # 0, 1, 2, 3\n        # 0, 3, 1, 2\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 3, 0, 1\n        # 2, 1, 3, 0\n        # 3, 2, 0, 1\n        # 3, 0, 2, 1\n        # 3, 1, 0, 2\n        # 1, 3, 0, 2\n        # 1, 0, 3, 2\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        \n        # 0, 1, 2, 3\n        # 0, 2, 1, 3\n        # 0, 2, 3, 1\n        # 0, 3, 1, 2\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 1, 3, 0, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 0, 1, 2\n        # 3, 1, 0, 2\n        \n        # 0, 1, 2, 3\n        # 0, 2, 1, 3\n        # 0, 2, 3, 1\n        # 0, 3, 1, 2\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 1, 3, 0, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 0, 1, 2\n        # 3, 1, 0, 2\n        \n        # 0, 1, 2, 3\n        # 0, 2, 1, 3\n        # 0, 2, 3, 1\n        # 0, 3, 1, 2\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 1, 3, 0, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 0, 1, 2\n        # 3, 1, 0, 2\n        \n        # 0, 1, 2, 3\n        # 0, 2, 1, 3\n        # 0, 2, 3, 1\n        # 0, 3, 1, 2\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 2, 3, 0\n        # 1, 3, 0, 2\n        # 2, 0, 1, 3\n        # 2, 1, 0, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 0, 1, 2\n        # 3, 1, 0, 2\n        \n        # 0, 1, 2, 3\n        # 0,"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 0, 2, 1, 3\n        # 0, 1, 3, 2\n        # 2, 0, 1, 3\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 0, 1, 2\n        # 0, 3, 1, 2\n        # 0, 1, 2, 3\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 3, 0, 2\n        # 3, 1, 0, 2\n        # 3, 0, 1, 2\n        # 0, 1, 3, 2\n        # 0, 2, 1, 3\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 3, 0, 2\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 1, 2, 0\n        # 0, 3, 1, 2\n        # 0, 2, 1, 3\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 3, 0, 2\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 1, 2, 0\n        # 0, 1, 2, 3\n        # 0, 3, 1, 2\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 3, 0, 2\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 1, 2, 0\n        # 0, 1, 3, 2\n        # 0, 2, 1, 3\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 3, 0, 2\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 1, 2, 0\n        # 0, 3, 1, 2\n        # 0, 2, 1, 3\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 3, 0, 2\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 1, 2, 0\n        # 0, 1, 2, 3\n        # 0, 3, 1, 2\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 3, 0, 2\n        # 2, 1, 3, 0\n        # 2, 3, 0, 1\n        # 3, 2, 0, 1\n        # 3, 1, 2, 0\n        # 0, 1, 3, 2\n        # 0, 2, 1, 3\n        # 1, 0, 2, 3\n        # 1, 2, 0, 3\n        # 1, 3, 0, 2\n        #"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        i, j, k = 0, 0, 0\n        while i < len(s1) and j < len(s2):\n            if s1[i] == s3[k]:\n                i += 1\n            if s2[j] == s3[k]:\n                j += 1\n            k += 1\n        return i == len(s1) and j == len(s2)"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        i, j, k = 0, 0, 0\n        while i < len(s1) and j < len(s2):\n            if s1[i] == s3[k]:\n                i += 1\n            if s2[j] == s3[k]:\n                j += 1\n            k += 1\n        return i == len(s1) and j == len(s2)"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        i, j, k = 0, 0, 0\n        while i < len(s1) and j < len(s2):\n            if s1[i] == s3[k]:\n                i += 1\n            if s2[j] == s3[k]:\n                j += 1\n            k += 1\n        return i == j"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        i, j, k = 0, 0, 0\n        while i < len(s1) and j < len(s2):\n            if s1[i] == s3[k]:\n                i += 1\n            if s2[j] == s3[k]:\n                j += 1\n            k += 1\n        return i == len(s1) and j == len(s2)"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        i, j, k = 0, 0, 0\n        while i < len(s1) and j < len(s2):\n            if s1[i] == s3[k]:\n                i += 1\n            if s2[j] == s3[k]:\n                j += 1\n            k += 1\n        return i == j"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u7531\u4e8e\u5b57\u6bcd\u53ea\u6709 26 \u4e2a\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a 26 \u7684\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u7531\u4e8e\u5b57\u6bcd\u53ea\u6709 26 \u4e2a\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a 26 \u7684\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u7531\u4e8e\u5b57\u6bcd\u53ea\u6709 26 \u4e2a\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a 26 \u7684\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u7531\u4e8e\u5b57\u6bcd\u53ea\u6709 26 \u4e2a\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a 26 \u7684\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u7531\u4e8e\u5b57\u6bcd\u53ea\u6709 26 \u4e2a\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a 26 \u7684\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u7531\u4e8e\u5b57\u6bcd\u53ea\u6709 26 \u4e2a\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a 26 \u7684\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u7531\u4e8e\u5b57\u6bcd\u53ea\u6709 26 \u4e2a\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a 26 \u7684\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u7531\u4e8e\u5b57\u6bcd\u53ea\u6709 26 \u4e2a\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5ea6\u4e3a 26 \u7684\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u624d\u4f1a\u5f71\u54cd\u7ed3\u679c\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5148\u7edf\u8ba1\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\n        # \u7136\u540e\u518d\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\uff0c\u6700\u540e\u518d\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u7684\u4e2a\u6570\uff0c\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u7684\u4e2a\u6570\u5c0f\u4e8e\u7b49\u4e8e 6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u653e\u5728\u540c\u4e00\u884c\uff0c\u5426\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u624d\u4f1a\u5f71\u54cd\u7ed3\u679c\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5148\u7edf\u8ba1\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\n        # \u7136\u540e\u518d\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\uff0c\u6700\u540e\u518d\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u7684\u4e2a\u6570\uff0c\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u7684\u4e2a\u6570\u5c0f\u4e8e\u7b49\u4e8e 6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u653e\u5728\u540c\u4e00\u884c\uff0c\u5426\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u624d\u4f1a\u5f71\u54cd\u7ed3\u679c\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5148\u7edf\u8ba1\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\n        # \u7136\u540e\u518d\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\uff0c\u6700\u540e\u518d\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u7684\u4e2a\u6570\uff0c\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u7684\u4e2a\u6570\u5c0f\u4e8e\u7b49\u4e8e 6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u653e\u5728\u540c\u4e00\u884c\uff0c\u5426\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u624d\u4f1a\u5f71\u54cd\u7ed3\u679c\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5148\u7edf\u8ba1\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\n        # \u7136\u540e\u518d\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\uff0c\u6700\u540e\u518d\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u7684\u4e2a\u6570\uff0c\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\u7684\u5b57\u6bcd\u7684\u4e2a\u6570\u5c0f\u4e8e\u7b49\u4e8e 6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u653e\u5728\u540c\u4e00\u884c\uff0c\u5426\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\ufffd"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u624d\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u76f4\u63a5\u8fd4\u56de\u7a7a\u5217\u8868\u5373\u53ef\u3002\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u90fd\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u5219\u8fd4\u56de\u6240\u6709\u5b57\u6bcd\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u624d\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u76f4\u63a5\u8fd4\u56de\u7a7a\u5217\u8868\u5373\u53ef\u3002\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u90fd\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u5219\u8fd4\u56de\u6240\u6709\u5b57\u6bcd\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u624d\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u76f4\u63a5\u8fd4\u56de\u7a7a\u5217\u8868\u5373\u53ef\u3002\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u90fd\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u5219\u8fd4\u56de\u6240\u6709\u5b57\u6bcd\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u624d\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u76f4\u63a5\u8fd4\u56de\u7a7a\u5217\u8868\u5373\u53ef\u3002\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u90fd\u80fd\u653e\u5728\u540c\u4e00\u884c\uff0c\u5219\u8fd4\u56de\u6240\u6709\u5b57\u6bcd\u51fa\u73b0\u6b21\u6570\u4e3a 1 \u7684\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        #"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u4e00\u884c\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u4e00\u884c\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u4e00\u884c\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u4e00\u884c\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u4e00\u884c\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u8868\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u56e0\u4e3a\u53ea\u6709\u4e00\u884c\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u7528\u54c8\u5e0c\u8868\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\uff0c\u5176\u4e2d N \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u4e4b\u548c\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(26)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\n        # \n        # \u5bf9\u4e8e\u6bcf\u4e2a\u5b57\u7b26\uff0c\u6211\u4eec\u7edf\u8ba1\u5176\u5728\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u6b21\uff0c\u5219\u4e0d\u80fd\u653e\u5728\u540c\u4e00\u884c\u3002\n        # \u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a 0 \u6216 1\uff0c\u5219\u53ef\u4ee5\u653e\u5728\u540c\u4e00\u884c\u3002\n        # \n        # \u7531\u4e8e\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1 26 \u4e2a\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u5b57\u7b26\u4e32\u52a0\u5165\u7ed3\u679c\u3002\n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u6ca1\u6709\u51fa\u73b0\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u4e0d\u4f1a\u51fa\u73b0\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8df3\u8fc7\u8fd9\u4e2a\u5b57\u7b26\u4e32\u3002\n        # \n        # \u7531\u4e8e\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1 26 \u4e2a\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u5b57\u7b26\u4e32\u52a0\u5165\u7ed3\u679c\u3002\n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u6ca1\u6709\u51fa\u73b0\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u4e0d\u4f1a\u51fa\u73b0\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8df3\u8fc7\u8fd9\u4e2a\u5b57\u7b26\u4e32\u3002\n        # \n        # \u7531\u4e8e\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1 26 \u4e2a\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u5b57\u7b26\u4e32\u52a0\u5165\u7ed3\u679c\u3002\n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u6ca1\u6709\u51fa\u73b0\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u4e0d\u4f1a\u51fa\u73b0\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8df3\u8fc7\u8fd9\u4e2a\u5b57\u7b26\u4e32\u3002\n        # \n        # \u7531\u4e8e\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1 26 \u4e2a\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u5b57\u7b26\u4e32\u52a0\u5165\u7ed3\u679c\u3002\n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u6ca1\u6709\u51fa\u73b0\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u4e0d\u4f1a\u51fa\u73b0\u5728\u54c8\u5e0c\u8868\u4e2d\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8df3\u8fc7\u8fd9\u4e2a\u5b57\u7b26\u4e32\u3002\n        # \n        # \u7531\u4e8e\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u662f\u5c0f\u5199\u5b57\u6bcd\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1 26 \u4e2a\u5b57\u6bcd\u5373\u53ef\u3002\n        # \n        # \u5982\u679c\u4e00\u4e2a\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u90fd\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\u5219\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e5f\u5728\u54c8\u5e0c\u8868\u4e2d\u51fa\u73b0\u8fc7\uff0c\n        # \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u5b57\u7b26\u4e32"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(left - 1):\n            prev = prev.next\n        for _ in range(right - left):\n            next = prev.next\n            prev.next = next.next\n            next.next = head\n            head = next\n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(left - 1):\n            prev = prev.next\n        for _ in range(right - left):\n            next = prev.next\n            prev.next = next.next\n            next.next = head\n            head = next\n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(left - 1):\n            prev = prev.next\n        for _ in range(right - left):\n            next = prev.next\n            prev.next = next.next\n            next.next = head\n            head = next\n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(left - 1):\n            prev = prev.next\n        for _ in range(right - left):\n            next = prev.next\n            prev.next = next.next\n            next.next = head\n            head = next\n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(left - 1):\n            prev = prev.next\n        for _ in range(right - left):\n            next_node = prev.next\n            prev.next = next_node.next\n            next_node.next = head\n            head = next_node\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the string\n        rev = s[::-1]\n        \n        # find the first mismatch\n        i = 0\n        while i < len(s) and s[i] == rev[i]:\n            i += 1\n        \n        # if the first mismatch is at the end, return the original string plus the reversed string\n        if i == len(s):\n            return rev + s\n        \n        # otherwise, return the first mismatch character plus the reversed string plus the rest of the original string\n        return s[i] + rev[:i] + s"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the string\n        rev = s[::-1]\n        \n        # find the first mismatch\n        i = 0\n        while i < len(s) and s[i] == rev[i]:\n            i += 1\n        \n        # if the mismatch is at the end, return the original string with the reversed part\n        if i == len(s):\n            return rev\n        \n        # return the reversed part + the original string + the first mismatch\n        return rev[i:] + s"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. reverse the string\n        # 2. append the original string to the reversed string\n        # 3. check if the reversed string is a prefix of the original string\n        # 4. if it is, return the reversed string + original string\n        # 5. otherwise, return the reversed string + original string + 1 char\n        # 6. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 7. otherwise, return the reversed string + original string + 1 char\n        # 8. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 9. otherwise, return the reversed string + original string + 1 char\n        # 10. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 11. otherwise, return the reversed string + original string + 1 char\n        # 12. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 13. otherwise, return the reversed string + original string + 1 char\n        # 14. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 15. otherwise, return the reversed string + original string + 1 char\n        # 16. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 17. otherwise, return the reversed string + original string + 1 char\n        # 18. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 19. otherwise, return the reversed string + original string + 1 char\n        # 20. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 21. otherwise, return the reversed string + original string + 1 char\n        # 22. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 23. otherwise, return the reversed string + original string + 1 char\n        # 24. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 25. otherwise, return the reversed string + original string + 1 char\n        # 26. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 27. otherwise, return the reversed string + original string + 1 char\n        # 28. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 29. otherwise, return the reversed string + original string + 1 char\n        # 30. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 31. otherwise, return the reversed string + original string + 1 char\n        # 32. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 33. otherwise, return the reversed string + original string + 1 char\n        # 34. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 35. otherwise, return the reversed string + original string + 1 char\n        # 36. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 37. otherwise, return the reversed string + original string + 1 char\n        # 38. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 39. otherwise, return the reversed string + original string + 1 char\n        # 40. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 41. otherwise, return the reversed string + original string + 1 char\n        # 42. if the reversed string is a prefix of the original string, return the reversed string + original string\n        # 43. otherwise, return the reversed string + original string + 1 char\n        # 44. if the reversed string is a prefix of the"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. reverse the string\n        # 2. append the original string to the reversed string\n        # 3. check if the reversed string is a prefix of the original string\n        # 4. if it is, return the original string + the reversed string\n        # 5. otherwise, return the reversed string + the original string\n        # 6. if the original string is a palindrome, return the original string\n        \n        # time complexity: O(n), space complexity: O(1)\n        \n        # if the string is a palindrome, return the string\n        if s == s[::-1]:\n            return s\n        \n        # find the first character that is different in the reversed string and the original string\n        i = 0\n        for i in range(len(s) // 2):\n            if s[i] != s[len(s) - 1 - i]:\n                break\n        \n        # return the reversed string + the original string\n        return s[len(s) - 1 - i:] + s[:i + 1]"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the string\n        rev = s[::-1]\n        \n        # find the first mismatch\n        i = 0\n        while i < len(s) and s[i] == rev[i]:\n            i += 1\n        \n        # if the mismatch is at the end, return the original string + the reversed string\n        if i == len(s):\n            return s + rev\n        \n        # otherwise, return the reversed string from the mismatched character to the end\n        return rev[i:] + s"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # sliding window\n        # use a dict to store the count of each char in t\n        # use a dict to store the count of each char in s\n        # if the count of each char in t is in the dict of s, then update the right pointer\n        # if the count of each char in t is not in the dict of s, then update the left pointer\n        # if the count of each char in t is in the dict of s and the right pointer - left pointer is smaller than the length of t, then update the result\n        # if the count of each char in t is not in the dict of s and the right pointer - left pointer is larger than the length of t, then update the left pointer\n        # return the result\n        \n        need = collections.Counter(t)\n        left = 0\n        right = 0\n        count = 0\n        res_left = res_right = float('inf')\n        \n        for char in s:\n            if char in need:\n                count += 1\n                if count == need[char]:\n                    res_left = min(res_left, left)\n            else:\n                if char not in need or count < need[char]:\n                    left += 1\n            right += 1\n            \n            if right - left >= len(t):\n                if count == need[char]:\n                    res_right = min(res_right, right)\n                else:\n                    count -= 1\n                    if count < need[char]:\n                        left += 1\n        \n        return s[res_left:res_right] if res_right - res_left < len(s) else ''"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # sliding window\n        # use a hashmap to store the count of each character in t\n        # use two pointers to slide the window\n        # if the character count in s is less than the count in t, move the left pointer\n        # if the character count in s is equal to the count in t, move the right pointer\n        # update the result if the right pointer moves\n        # if the character count in s is greater than the count in t, move the right pointer\n        # if the character count in s is equal to the count in t, move the left pointer\n        \n        # initialize the count of each character in t\n        count = collections.Counter(t)\n        # initialize the left and right pointers\n        left = right = 0\n        # initialize the minimum length and the start index\n        min_length = len(s)\n        start = 0\n        # use a hashmap to store the count of each character in s\n        # if the character count in s is less than the count in t, move the left pointer\n        # if the character count in s is equal to the count in t, move the right pointer\n        # update the result if the right pointer moves\n        # if the character count in s is greater than the count in t, move the right pointer\n        # if the character count in s is equal to the count in t, move the left pointer\n        for char in s:\n            if count[char] > 0:\n                count[char] -= 1\n            else:\n                # if the character count in s is less than the count in t, move the left pointer\n                if left < right and count[char] == count[char - s[left]]:\n                    count[char] += 1\n                    left += 1\n            # update the result if the right pointer moves\n            if right - left + 1 < min_length:\n                min_length = right - left + 1\n                start = left\n        # if the character count in s is greater than the count in t, return an empty string\n        if min_length > len(t):\n            return \"\"\n        return s[start:start + min_length]"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # sliding window\n        # use a hashmap to store the count of each character in t\n        # use two pointers, one for the sliding window, the other for the target string\n        # if the character in the sliding window is not in the hashmap, move the left pointer\n        # if the character in the sliding window is in the hashmap, decrease the count in the hashmap\n        # if the count in the hashmap is zero, increase the count in the hashmap\n        # if the count in the hashmap is not zero, decrease the count in the hashmap\n        # if the count in the hashmap is zero and the right pointer - left pointer + 1 is smaller than the length of the target string, update the result\n        # if the count in the hashmap is zero and the right pointer - left pointer + 1 is larger than the length of the target string, move the left pointer\n        # return the result\n        \n        left, right, count = 0, 0, len(t)\n        res_left, res_right = float('inf'), -1\n        char_count = collections.Counter(t)\n        \n        while right < len(s):\n            if char_count[s[right]] > 0:\n                count -= 1\n            char_count[s[right]] -= 1\n            right += 1\n            \n            if count == 0:\n                if res_right == float('inf') or right - left < res_right - res_left:\n                    res_left, res_right = left, right\n            \n            if char_count[s[left]] >= 0:\n                char_count[s[left]] += 1\n                if char_count[s[left]] == 0:\n                    count += 1\n            left += 1\n        \n        return res_left == float('inf') and res_right == -1"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # sliding window\n        # use a hashmap to store the characters in t\n        # if the character in s is in the hashmap, decrement the count\n        # if the count is zero, decrement the window size\n        # if the count is not zero, increment the window size\n        # if the window size is larger than the required size, update the result\n        # if the character in s is not in the hashmap, increment the count\n        # if the count is larger than the required count, increment the window size\n        # if the window size is larger than the required size, decrement the count\n        \n        required = len(t)\n        required_count = collections.Counter(t)\n        left = 0\n        window_size = len(s)\n        start = 0\n        count = 0\n        for right, char in enumerate(s):\n            if char in required_count:\n                required_count[char] -= 1\n                if required_count[char] >= 0:\n                    count += 1\n            if count == required:\n                window_size = min(window_size, right - left + 1)\n            else:\n                if required_count[char] >= 0:\n                    count -= 1\n                required_count[char] += 1\n                left += 1\n        return s[start:start + window_size] if window_size == required else \"\""}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # sliding window\n        # use a hashmap to store the count of each character in t\n        # use two pointers to slide the window\n        # if the count of a character in s is less than the count in t, move the left pointer\n        # if the count of a character in s is equal to the count in t, move the right pointer\n        # update the result if the right pointer - left pointer + 1 is smaller than the current result\n        \n        # initialize the count of each character in t\n        count = collections.Counter(t)\n        left, right = 0, 0\n        required = len(count)\n        start, end = 0, -1\n        res = float('inf')\n        \n        while right < len(s):\n            if count[s[right]] > 0:\n                required -= 1\n            count[s[right]] -= 1\n            right += 1\n            \n            if required == 0:\n                if end == -1 or right - left < res:\n                    res = right - left\n                    start = left\n            else:\n                count[s[left]] += 1\n                if count[s[left]] > 0:\n                    required += 1\n                left += 1\n        \n        return s[start:start + res] if res != float('inf') else ''"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the distance is less than 4, we can't cross\n        if len(distance) < 4:\n            return False\n        \n        # if the first 3 elements are positive, we can't cross\n        if distance[0] < distance[1] and distance[1] < distance[2]:\n            return False\n        \n        # if the first 4 elements are positive, we can't cross\n        if distance[0] < distance[2] and distance[1] + distance[3] >= distance[2]:\n            return False\n        \n        # if the first 5 elements are positive, we can't cross\n        if distance[0] < distance[3] and distance[1] + distance[4] >= distance[3]:\n            return False\n        \n        # if the first 6 elements are positive, we can't cross\n        if distance[0] + distance[5] >= distance[3] + distance[1]:\n            return False\n        \n        # if the first 7 elements are positive, we can't cross\n        return distance[1] + distance[6] >= distance[5] + distance[0]"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the distance is less than 4, we can't cross\n        if len(distance) < 4:\n            return False\n        \n        # if the first 3 elements are positive, we can't cross\n        if distance[0] >= 0 and distance[1] >= 0 and distance[2] >= distance[0] + distance[1]:\n            return False\n        \n        # if the 4th element is positive and the 3rd element is negative, we can't cross\n        if distance[3] >= 0 and distance[2] < distance[3] - distance[0]:\n            return False\n        \n        # if the 4th element is negative and the 3rd element is positive, we can't cross\n        if distance[3] < 0 and distance[2] >= -distance[3] + distance[1]:\n            return False\n        \n        # if the 4th element is negative and the 3rd element is negative, we need to check the 2nd element\n        return distance[3] <= distance[2] + distance[1]"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the distance is less than 4, we can't cross\n        if len(distance) < 4:\n            return False\n        \n        # if the first 3 elements are positive, we can't cross\n        if distance[0] < distance[1] and distance[1] < distance[2]:\n            return False\n        \n        # if the first 4 elements are positive, we can't cross\n        if distance[0] < distance[2] and distance[1] + distance[3] < distance[2]:\n            return False\n        \n        # if the first 5 elements are positive, we can't cross\n        if distance[0] < distance[3] and distance[1] + distance[4] < distance[3]:\n            return False\n        \n        # if the first 4 elements are negative, we can't cross\n        if distance[1] > distance[3] + distance[2]:\n            return False\n        \n        # if the first 5 elements are negative, we can't cross\n        if distance[2] > distance[4] + distance[3]:\n            return False\n        \n        # if the first 6 elements are negative, we can't cross\n        if distance[3] > distance[5] + distance[4]:\n            return False\n        \n        return True"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the distance is less than 4, we can't cross\n        if len(distance) < 4:\n            return False\n        \n        # if the first 3 elements are positive, we can't cross\n        if distance[0] >= 0 and distance[1] >= 0 and distance[2] >= distance[0] + distance[1]:\n            return False\n        \n        # if the 4th element is positive and the 3rd element is negative, we can't cross\n        if distance[3] >= 0 and distance[2] < distance[3] - distance[0]:\n            return False\n        \n        # if the 4th element is negative and the 3rd element is positive, we can't cross\n        if distance[3] < 0 and distance[2] >= -distance[3] + distance[1]:\n            return False\n        \n        # if the 4th element is negative and the 3rd element is negative, we need to check the 2nd element\n        return distance[3] <= distance[2] + distance[1]"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the distance is less than 4, we can't cross\n        if len(distance) < 4:\n            return False\n        \n        # if the first 3 elements are positive, we can't cross\n        if distance[0] >= 0 and distance[1] >= 0 and distance[2] >= distance[0] + distance[1]:\n            return False\n        \n        # if the last 3 elements are positive, we can't cross\n        if distance[-1] >= 0 and distance[-2] >= 0 and distance[-3] >= distance[-2] - distance[-1]:\n            return False\n        \n        # if the 4th element is positive, we can't cross\n        if distance[3] >= distance[0] + distance[1] + distance[2]:\n            return False\n        \n        # if the 4th element is negative, we can't cross\n        if distance[3] <= distance[1] - distance[0]:\n            return False\n        \n        # if the 5th element is negative, we can't cross\n        if distance[4] <= distance[2] - distance[1]:\n            return False\n        \n        # if the 5th element is positive, we can't cross\n        return distance[4] + distance[3] >= distance[2] + distance[1]"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        prev = head\n        cur = head.next\n        \n        while cur:\n            if prev.val != cur.val:\n                prev.next = cur\n                prev = cur\n            else:\n                cur = cur.next"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u7edf\u8ba1\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u6700\u957f\u56de\u6587\u5b50\u4e32\u957f\u5ea6\u4e3a\u5947\u6570\uff0c\u5426\u5219\u4e3a\u5076\u6570\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\u4e0d\u4f1a\u8d85\u8fc7 26\u3002\n        odd = 0\n        for c in s:\n            odd += 1 if c.lower() in 'aeiou' else -1\n        return len(s) - odd if odd > 0 else len(s)\n        \n        # M2. \u4e2d\u5fc3\u6269\u5c55\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u6bcf\u4e2a\u5b57\u7b26\u6700\u591a\u4f1a\u88ab\u6269\u5c55\u5230\u957f\u5ea6\u4e3a n \u7684\u56de\u6587\u4e32\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        for i in range(len(s)):\n            start, end = max(start, i - end), end + 1 if s[i] == s[start] else start + 1\n        return end\n        \n        # M3. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        for i in range(len(s)):\n            if i == end:\n                start, end = i, i\n            else:\n                start, end = start + 1 if s[start] == s[end] else start, end\n        return end - start + 1\n        \n        # M4. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488 + \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        d = {c: -1 for c in s}\n        d[s[0]] = 0\n        for i in range(1, len(s)):\n            if d[s[i]] >= start:\n                start = d[s[i]]\n            else:\n                end = i\n            d[s[i]] = i\n        return end - start + 1\n        \n        # M5. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488 + \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        d = {c: -1 for c in s}\n        d[s[0]] = 0\n        for i in range(1, len(s)):\n            if d[s[i]] >= start:\n                start = d[s[i]]\n            else:\n                end -= d[s[start]]\n                d[s[i]] = i\n            end += 1\n        return end - start\n        \n        # M6. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488 + \u54c8\u5e0c"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u7edf\u8ba1\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u957f\u5ea6\u4e3a\u5947\u6570\u7684\u56de\u6587\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u5947\u6570\uff0c\u5426\u5219\u4e3a\u5076\u6570\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\u4e0d\u4f1a\u8d85\u8fc7 26\u3002\n        odd = 0\n        for c in s:\n            odd += 1 if c.lower() in 'aeiou' else -1\n        return len(s) - odd if odd > 0 else"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u7edf\u8ba1\u5b57\u7b26\u51fa\u73b0\u7684\u9891\u7387\uff0c\u5982\u679c\u51fa\u73b0\u9891\u7387\u4e3a\u5947\u6570\uff0c\u5219\u6700\u957f\u7684\u56de\u6587\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u5b57\u7b26\u4e32\u957f\u5ea6\u51cf\u53bb\u8fd9\u4e2a\u5947\u6570\u5b57\u7b26\u7684\u6570\u91cf\uff0c\u5426\u5219\u4e3a\u5b57\u7b26\u4e32\u957f\u5ea6\u51cf\u53bb 1\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\uff0c\u53ea\u9700\u8981\u5e38\u6570\u7684\u7a7a\u95f4\u5b58\u653e\u54c8\u5e0c\u8868\u3002\n        odd = 0\n        for c in s:\n            odd += 1 if c in 'aeiou' else -1\n        return len(s) - odd if odd % 2 == 0 else len(s) - odd - 1\n        \n        \n        # M2. \u4e2d\u5fc3\u6269\u5c55\n        # \u4f7f\u7528\u4e24\u4e2a\u6307\u9488\uff0c\u5206\u522b\u6307\u5411\u5b57\u7b26\u4e32\u7684\u4e24\u7aef\uff0c\u5982\u679c\u4e24\u4e2a\u6307\u9488\u6307\u5411\u7684\u5b57\u7b26\u76f8\u540c\uff0c\u5219\u4e24\u6307\u9488\u4e4b\u95f4\u7684\u5b57\u7b26\u4e32\u662f\u56de\u6587\uff0c\u5e76\u4e14\u4e2d\u5fc3\u6269\u5c55\u7684\u957f\u5ea6\u52a0 2\u3002\n        # \u5982\u679c\u4e24\u4e2a\u6307\u9488\u6307\u5411\u7684\u5b57\u7b26\u4e0d\u540c\uff0c\u5219\u5224\u65ad\u662f\u5426\u4e3a\u56de\u6587\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u662f\u5426\u5927\u4e8e\u7b49\u4e8e\u4e2d\u5fc3\u6269\u5c55\u7684\u957f\u5ea6\uff0c\u5982\u679c\u662f\uff0c\u5219\u4e2d\u5fc3\u6269\u5c55\u7684\u957f\u5ea6\u51cf\u53bb 2\uff0c\u5e76\u5c06\u5de6\u6307\u9488\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                res = right - left + 1\n                left += 1\n            else:\n                if res == left:\n                    left += 1\n                else:\n                    res -= 1\n                    right -= 1\n        return res\n        \n        \n        # M3. \u4e2d\u5fc3\u6269\u5c55 + \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u7edf\u8ba1\u5b57\u7b26\u51fa\u73b0\u7684\u9891\u7387\uff0c\u5982\u679c\u51fa\u73b0\u9891\u7387\u4e3a\u5947\u6570\uff0c\u5219\u6700\u957f\u7684\u56de\u6587\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u5b57\u7b26\u4e32\u957f\u5ea6\u51cf\u53bb\u8fd9\u4e2a\u5947\u6570\u5b57\u7b26\u7684\u6570\u91cf\uff0c\u5426\u5219\u4e3a\u5b57\u7b26\u4e32\u957f\u5ea6\u51cf\u53bb 1\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\uff0c\u53ea\u9700\u8981\u5e38\u6570\u7684\u7a7a\u95f4\u5b58\u653e\u54c8\u5e0c\u8868\u3002\n        odd = 0\n        for c in s:\n            odd += 1 if c in 'aeiou' else -1\n        return len(s) - odd if odd % 2 == 0 else len(s) - odd - 1\n        \n        \n        # M4. \u4e2d\u5fc3\u6269\u5c55 + \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u7edf\u8ba1\u5b57\u7b26\u51fa\u73b0\u7684\u9891\u7387\uff0c\u5982\u679c\u51fa\u73b0\u9891\u7387\u4e3a\u5947\u6570\uff0c\u5219\u6700\u957f\u7684\u56de\u6587\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a\u5b57\u7b26\u4e32\u957f\u5ea6\u51cf\u53bb\u8fd9\u4e2a\u5947\u6570\u5b57\u7b26\u7684\u6570\u91cf\uff0c\u5426\u5219\u4e3a\u5b57\u7b26\u4e32\u957f\u5ea6\u51cf\u53bb 1\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\uff0c\u53ea\u9700\u8981\u5e38\u6570\u7684\u7a7a\u95f4\u5b58\u653e\u54c8\u5e0c\u8868\u3002\n        odd = 0\n        for c in s:\n            odd += 1 if c in 'aeiou' else -1\n        return len"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u7edf\u8ba1\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u6700\u957f\u56de\u6587\u5b50\u4e32\u957f\u5ea6\u4e3a\u5947\u6570\uff0c\u5426\u5219\u4e3a\u5076\u6570\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\u4e0d\u4f1a\u8d85\u8fc7 26\u3002\n        odd = 0\n        for c in s:\n            odd += 1 if c.lower() in 'aeiou' else -1\n        return len(s) - odd if odd > 0 else len(s)\n        \n        \n        # M2. \u4e2d\u5fc3\u6269\u5c55\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u6bcf\u4e2a\u5b57\u7b26\u6700\u591a\u4f1a\u88ab\u6269\u5c55\u5230\u957f\u5ea6\u4e3a n \u7684\u56de\u6587\u4e32\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        for i in range(len(s)):\n            start, end = max(start, i - end), end + 1 if s[i] == s[start] else start + 1\n        return end\n        \n        \n        # M3. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        for i in range(len(s)):\n            if i == end:\n                start, end = i, i\n            else:\n                start, end = start + 1 if s[start] == s[end] else start, end\n        return end - start + 1\n        \n        \n        # M4. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488 + \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        d = {c: -1 for c in s}\n        d[s[0]] = 0\n        for i in range(1, len(s)):\n            if d[s[i]] >= start:\n                start = d[s[i]]\n            else:\n                end = i\n            d[s[i]] = i\n        return end - start + 1\n        \n        \n        # M5. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        for i in range(len(s)):\n            if i == end:\n                end += 1\n            else:\n                start, end = end, end"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u7edf\u8ba1\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u6700\u957f\u56de\u6587\u5b50\u4e32\u957f\u5ea6\u4e3a\u5947\u6570\uff0c\u5426\u5219\u4e3a\u5076\u6570\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\uff0c\u54c8\u5e0c\u8868\u7684\u5927\u5c0f\u4e0d\u4f1a\u8d85\u8fc7 26\u3002\n        odd = 0\n        for c in s:\n            odd += 1 if c.lower() in 'aeiou' else -1\n        return len(s) - odd if odd > 0 else len(s)\n        \n        # M2. \u4e2d\u5fc3\u6269\u5c55\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u6bcf\u4e2a\u5b57\u7b26\u6700\u591a\u4f1a\u88ab\u6269\u5c55\u5230\u957f\u5ea6\u4e3a n \u7684\u56de\u6587\u4e32\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        for i in range(len(s)):\n            start, end = max(start, i - end), end + 1 if s[i] == s[start] else start + 1\n        return end\n        \n        # M3. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        for i in range(len(s)):\n            if i == end:\n                start, end = i, i\n            else:\n                start, end = start + 1 if s[start] == s[end] else start, end\n        return end - start + 1\n        \n        # M4. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488 + \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        d = {c: -1 for c in s}\n        d[s[0]] = 0\n        for i in range(1, len(s)):\n            if d[s[i]] >= start:\n                start = d[s[i]]\n            else:\n                end = i\n            d[s[i]] = i\n        return end - start + 1\n        \n        # M5. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488 + \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\u53ea\u9700\u8981\u904d\u5386\u5b57\u7b26\u4e32\u4e00\u6b21\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\u53ea\u9700\u8981\u5e38\u6570\u7684\u989d\u5916\u7a7a\u95f4\u3002\n        if not s:\n            return 0\n        start, end = 0, 0\n        d = {c: -1 for c in s}\n        d[s[0]] = 0\n        for i in range(1, len(s)):\n            if d[s[i]] >= start:\n                start = d[s[i]]\n            else:\n                end -= d[s[start]]\n                d[s[i]] = i\n            end += 1\n        return end - start\n        \n        # M6. \u4e2d\u5fc3\u6269\u5c55 + \u5feb\u6162\u6307\u9488 + \u54c8\u5e0c"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_idx = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_idx], postorder[:root_idx])\n        root.right = self.buildTree(inorder[root_idx+1:], postorder[root_idx:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_idx = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_idx], postorder[:root_idx])\n        root.right = self.buildTree(inorder[root_idx+1:], postorder[root_idx:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not forest:\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        max_height = max(forest[0])\n        if max_height == 1:\n            return m * n - 1\n        \n        left, right = 0, max_height\n        res = m * n - 1 - left\n        \n        while left < right:\n            if forest[left][left] <= right:\n                left += 1\n            else:\n                res += right - left\n                right -= 1\n        \n        return res"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not forest:\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        max_height = max(forest[0])\n        if max_height == 1:\n            return m * n - 1\n        \n        left, right = 0, max_height\n        res = m * n - 1 - left\n        while left < right:\n            if forest[left][left] <= right:\n                left += 1\n            else:\n                res += right - left\n                right -= 1\n        \n        return res"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not forest:\n            return 0\n        \n        m, n = len(forest), len(forest[0])\n        max_height = max(forest[0])\n        if max_height == 1:\n            return m * n - 1\n        \n        left, right = 0, max_height\n        res = m * n - 1\n        \n        while left <= right:\n            if forest[left][right] <= right - left:\n                res += right - left\n                left += forest[left][right]\n            else:\n                right -= forest[left][right]\n                \n        return res if left == max_height else -1"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not forest:\n            return 0\n        \n        m, n = len(forest), len(forest[0])\n        max_height = max(forest[0])\n        if max_height == 1:\n            return m * n - 1\n        \n        left, right = 0, max_height\n        res = m * n - 1\n        \n        while left <= right:\n            if forest[left][right] <= right - left:\n                res -= right - left\n                right -= forest[left][right]\n            else:\n                left += 1\n                \n        return res if left == m else -1"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not forest:\n            return 0\n        \n        m, n = len(forest), len(forest[0])\n        max_height = max(forest[0])\n        if max_height == 1:\n            return m * n - 1\n        \n        left, right = 0, max_height\n        res = m * n - 1 - left\n        \n        while left < right:\n            if forest[left][left] <= right:\n                left += 1\n            else:\n                res += right - left\n                right -= 1\n                \n        return res"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(NlogN)\n        # Space: O(1)\n        if not nums:\n            return 0\n        \n        nums.sort()\n        left, right = 0, 0\n        res = 0\n        sum = nums[0]\n        while right < len(nums):\n            if sum <= upper:\n                if sum >= lower:\n                    res += right - left\n            if sum <= nums[right]:\n                sum += nums[right]\n            else:\n                sum -= nums[left]\n                left += 1\n            right += 1\n        return res\n        \n        \n        # M2. Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        if not nums:\n            return 0\n        \n        sum = 0\n        res = 0\n        left, right = 0, nums[0]\n        for num in nums[1:]:\n            sum += num\n            if sum < lower:\n                left = num\n            elif sum <= upper:\n                res += right - left\n            else:\n                sum -= left\n        return res\n        \n        \n        # M3. Two Pointers + Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        if not nums:\n            return 0\n        \n        left, right = 0, nums[0]\n        res = 1 if lower <= right <= upper else 0\n        sum = left + right\n        for num in nums[1:]:\n            if sum > upper:\n                sum -= nums[left]\n                left += 1\n            else:\n                res += right - left\n            right += num\n        return res\n        \n        \n        # M4. Two Pointers + Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        if not nums:\n            return 0\n        \n        left, right = 0, nums[0]\n        res = 1 if lower <= right <= upper else 0\n        sum = left + right\n        while right < len(nums):\n            if sum > upper:\n                sum -= nums[left]\n                left += 1\n            else:\n                res += right - left\n            right += nums[right]\n        return res\n        \n        \n        # M5. Two Pointers + Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        if not nums:\n            return 0\n        \n        left, right = 0, nums[0]\n        res = 1 if lower <= right <= upper else 0\n        sum = left + right\n        while right < len(nums):\n            if sum > upper:\n                sum -= nums[left]\n                left += 1\n            else:\n                res += right - left\n            right += nums[right] - nums[left]\n        return res\n        \n        \n        # M6. Two Pointers + Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        if not nums:\n            return 0\n        \n        left, right = 0, nums[0]\n        res = 1 if lower <= right <= upper else 0\n        sum = left + right\n        while right < len(nums):\n            if sum > upper:\n                sum -= nums[left]\n                left += 1\n            else:\n                res += right - left\n            right += nums[right]\n            if right - left > upper - sum:\n                sum -= nums[left]\n                left += 1\n        return res\n        \n        \n        # M7. Two Pointers + Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        if not nums:\n            return 0\n        \n        left, right = 0, nums[0]\n        res = 1 if lower <= right <= upper else 0\n        sum = left + right\n        while right < len(nums):\n            if sum > upper:\n                sum -= nums[left]\n                left += 1\n            else:\n                res += right - left\n            right += nums[right]"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u524d\u7f00\u548c\n        # \u5148\u6c42\u51fa\u524d\u7f00\u548c\uff0c\u7136\u540e\u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        if not nums:\n            return 0\n        nums.append(0)\n        nums.sort()\n        res = 0\n        pre = 0\n        for i in range(len(nums) - 1):\n            res += bisect.bisect_right(nums, nums[i] + upper) - bisect.bisect_left(nums, nums[i] - lower)\n            pre += nums[i]\n            if pre > upper:\n                pre -= nums[i - 1]\n        return res\n        \n        # M2. \u524d\u7f00\u548c + \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        if not nums:\n            return 0\n        pre = 0\n        res = 0\n        d = {0: 1}\n        for num in nums:\n            pre += num\n            res += d.get(pre - lower, 0)\n            d[pre - upper] = d.get(pre - upper, 0) + 1\n        return res\n        \n        # M3. \u524d\u7f00\u548c + \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if not nums:\n            return 0\n        pre = 0\n        res = 0\n        lower, upper = lower + nums[0], upper + nums[0]\n        for num in nums[1:]:\n            if num <= lower:\n                pre += num\n            else:\n                res += upper - lower\n                lower, upper = lower + num, upper + num\n        return res + upper - lower\n        \n        # M4. \u524d\u7f00\u548c + \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if not nums:\n            return 0\n        pre, res = nums[0], 0\n        lower, upper = nums[0], nums[0]\n        for num in nums[1:]:\n            pre += num\n            if pre > upper:\n                res += upper - lower\n                upper = pre\n            elif pre < lower:\n                lower = pre\n        return res + (upper - lower) * 2\n        \n        # M5. \u524d\u7f00\u548c + \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if not nums:\n            return 0\n        pre, res = nums[0], 0\n        lower, upper = nums[0], nums[0]\n        for num in nums[1:]:\n            pre += num\n            if pre - lower > upper - pre:\n                res += upper - lower\n                upper = pre\n            else:\n                lower = pre - upper\n                upper = pre\n        return res + (upper - lower) * 2\n        \n        # M6. \u524d\u7f00\u548c + \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if not nums:\n            return 0\n        pre, res = nums[0], 0\n        lower, upper = nums[0], nums[0]\n        for num in nums[1:]:\n            pre += num\n            if pre - lower > upper - pre:\n                res += upper - lower\n                upper = pre\n            else:\n                lower = lower - upper + pre\n                upper = pre\n        return res + (upper - lower) * 2\n        \n        # M7. \u524d\u7f00\u548c + \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # \n        # Use two pointers to scan the array, and maintain the sum of the subarray.\n        # If the sum is in the range, we add 1 to the result.\n        # If the sum is less than lower, we need to add lower - sum to the result.\n        # If the sum is greater than upper, we need to subtract upper - sum from the result.\n        # \n        # Note that the sum can be negative, so we need to use long to avoid overflow.\n        # \n        # Note that the result can be greater than the range, so we need to return 0 if the sum is less than lower.\n        # \n        # Time complexity: O(N)\n        # Space complexity: O(1)\n        if not nums:\n            return 0\n        \n        sum_lower, sum_upper = 0, nums[0]\n        result = 1 if lower <= sum_upper <= upper else 0 if sum_upper < lower else upper - lower + 1\n        \n        for num in nums[1:]:\n            sum_lower += num\n            sum_upper += num\n            if sum_lower > lower:\n                result += sum_lower - lower\n            if sum_upper > upper:\n                result -= sum_upper - upper\n            if lower <= sum_upper <= upper:\n                result += 1\n        \n        return result\n        \n        \n        # M2. Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        # \n        # Use binary search to find the range sum that is less than or equal to lower.\n        # Then use the same method to find the range sum that is less than or equal to upper.\n        # The result is the difference between the two.\n        # \n        # Time complexity: O(NlogN)\n        # Space complexity: O(1)\n        if not nums:\n            return 0\n        \n        sum_lower, sum_upper = 0, nums[0]\n        result = 1 if lower <= sum_upper <= upper else 0 if sum_upper < lower else upper - lower + 1\n        \n        for num in nums[1:]:\n            sum_lower += num\n            sum_upper += num\n            if sum_lower > lower:\n                sum_lower -= lower\n            elif sum_lower < lower:\n                result += lower - sum_lower\n            if sum_upper > upper:\n                sum_upper -= upper\n            elif sum_upper > upper:\n                result -= sum_upper - upper\n        \n        return result\n        \n        \n        # M3. Two Pointers + Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        # \n        # Use two pointers to scan the array, and maintain the sum of the subarray.\n        # If the sum is less than lower, we need to add lower - sum to the result.\n        # If the sum is greater than upper, we need to subtract upper - sum from the result.\n        # \n        # Note that the sum can be negative, so we need to use long to avoid overflow.\n        # \n        # Note that the result can be greater than the range, so we need to return 0 if the sum is less than lower.\n        # \n        # Time complexity: O(NlogN)\n        # Space complexity: O(1)\n        if not nums:\n            return 0\n        \n        sum_lower, sum_upper = 0, nums[0]\n        result = 1 if lower <= sum_upper <= upper else 0 if sum_upper < lower else upper - lower + 1\n        \n        left, right = 1, sum_upper - lower\n        while left < right:\n            mid = left + (right - left) // 2\n            if mid <= sum_upper - mid:\n                sum_upper -= mid\n                right = mid\n            else:\n                sum_lower += mid\n                left = mid + 1\n            result += left\n        \n        return result\n        \n        \n        # M4. Two Pointers + Binary Search\n        # Time: O(NlogN)\n        # Space: O(1)\n        # \n        # Use two pointers to scan the array, and maintain the sum of the subarray"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(nlogn)\n        # Space: O(1)\n        # M2. Binary Search\n        # Time: O(nlogn)\n        # Space: O(n)\n        if not nums:\n            return 0\n        \n        # M1\n        nums.sort()\n        left, right, res = 0, 0, 0\n        sum = nums[0]\n        while right < len(nums):\n            if sum <= upper:\n                if sum >= lower:\n                    res += right - left\n                if nums[right] == nums[left]:\n                    right += 1\n                else:\n                    left += 1\n            else:\n                sum -= nums[left]\n                left += 1\n        return res\n        \n        # M2\n        # Time: O(nlogn)\n        # Space: O(n)\n        # M2.1\n        # Time: O(nlogn)\n        # Space: O(1)\n        if not nums:\n            return 0\n        nums.sort()\n        res = 0\n        left, sum = 0, 0\n        for right in nums:\n            if sum < lower:\n                sum += right\n            elif sum <= upper:\n                res += right - left\n            else:\n                sum -= nums[left]\n                left += 1\n        return res\n        \n        # M2.2\n        # Time: O(nlogn)\n        # Space: O(1)\n        if not nums:\n            return 0\n        left, right, sum = 0, 1, nums[0]\n        res = 0 if sum >= lower else 1\n        while right < len(nums):\n            if sum <= upper:\n                res += right - left\n            if nums[right] == nums[left]:\n                right += 1\n            else:\n                sum -= nums[left]\n                left += 1\n            right += 1\n        return res\n        \n        # M2.3\n        # Time: O(nlogn)\n        # Space: O(1)\n        if not nums:\n            return 0\n        left, right, sum = 0, 0, nums[0]\n        res = (sum <= upper)\n        while right < len(nums):\n            if sum <= upper:\n                res += right - left\n            if nums[right]"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # \n        # Use two pointers to scan the array, and maintain a sum.\n        # If the sum is in the range, we add 1 to the result.\n        # If the sum is larger than the upper bound, we subtract the sum of the first number from the sum.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        # \n        # Note that the sum of the first number is not included in the range, so we need to subtract it.\n        #"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 22"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 22"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        while queue:\n            res.append([node.val for node in queue])\n            queue = [child for node in queue for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        while queue:\n            res.append([node.val for node in queue])\n            queue = [child for node in queue for child in (node.left, node.right) if child]\n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        while queue:\n            res.append([node.val for node in queue])\n            queue = [child for node in queue for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        # reverse the number\n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x //= 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        if x < 10:\n            return True\n        if x % 10 == x // 100:\n            return True\n        return False"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        # reverse the number\n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x //= 10\n        \n        # check if the reversed number is equal to the original number\n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        # reverse the number\n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x //= 10\n        \n        return x == reverse or x == reverse // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        if x < 10:\n            return True\n        if x % 10 == 0:\n            return False\n        half = x // 10\n        while half > 0:\n            if x % 10 != half:\n                return False\n            x //= 10\n            half //= 10\n        return True"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = 1\n        prev = 1 if s[0] != '0' else 0\n        \n        for i in range(1, len(s)):\n            if s[i] == '0':\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                else:\n                    return 0\n            else:\n                dp = prev\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                \n        return dp"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = 1\n        prev = 1 if s[0] != '0' else 0\n        \n        for i in range(1, len(s)):\n            if s[i] == '0':\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                else:\n                    return 0\n            else:\n                dp = prev\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                \n        return dp"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = 1\n        prev = 1 if s[0] != '0' else 0\n        \n        for i in range(1, len(s)):\n            if s[i] == '0':\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                else:\n                    return 0\n            else:\n                dp = prev\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                else:\n                    prev = dp\n                    \n        return dp"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = 1\n        prev = 1 if s[0] != '0' else 0\n        \n        for i in range(1, len(s)):\n            if s[i] == '0':\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                else:\n                    return 0\n            else:\n                dp = prev\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                else:\n                    prev = dp\n        \n        return dp"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = 1\n        prev = 1 if s[0] != '0' else 0\n        \n        for i in range(1, len(s)):\n            if s[i] == '0':\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                else:\n                    return 0\n            else:\n                dp = prev\n                if s[i-1] == '1' or s[i-1] == '2' and prev > 0:\n                    prev = dp\n                else:\n                    prev = dp\n        \n        return dp"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for c in t:\n            if i < len(s) and s[i] == c:\n                i += 1\n        return i == len(s)"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for c in t:\n            if i < len(s) and s[i] == c:\n                i += 1\n        return i == len(s)"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for c in t:\n            if i < len(s) and c == s[i]:\n                i += 1\n        return i == len(s)"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for c in t:\n            if i < len(s) and s[i] == c:\n                i += 1\n        return i == len(s)"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for c in t:\n            if i < len(s) and s[i] == c:\n                i += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0]\n        for i in range(n):\n            res.extend([i + 2**i for i in res])\n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            res += [res[i] + 2**i]\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            res += [res[i] + 2**i]\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            res += [res[i] + 2**i]\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        res = [0, 1]\n        for i in range(2, n):\n            res += [res[i - 1] + 2 ** (i - 1)]\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        first, second = 1, 2\n        for i in range(3, n+1):\n            first, second = second, first + second\n        return second"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a, b = 1, 2\n        for i in range(3, n+1):\n            a, b = b, a + b\n        return b"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        first, second = 1, 2\n        for i in range(3, n + 1):\n            first, second = second, first + second\n        return second"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        first, second = 1, 2\n        for i in range(3, n+1):\n            first, second = second, first + second\n        return second"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        first, second = 1, 2\n        for i in range(3, n+1):\n            first, second = second, first + second\n        return second"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        return dp[-1]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        if root.left and root.val <= root.left.val:\n            return False\n        if root.right and root.val >= root.right.val:\n            return False\n        \n        return self.isValidBST(root.left) and self.isValidBST(root.right)"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        if root.left and root.val <= root.left.val:\n            return False\n        if root.right and root.val >= root.right.val:\n            return False\n        \n        return self.isValidBST(root.left) and self.isValidBST(root.right)"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        if root.left and root.val <= root.left.val:\n            return False\n        if root.right and root.val >= root.right.val:\n            return False\n        \n        return self.isValidBST(root.left) and self.isValidBST(root.right)"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        if root.left and root.val <= root.left.val:\n            return False\n        if root.right and root.val >= root.right.val:\n            return False\n        \n        return self.isValidBST(root.left) and self.isValidBST(root.right)"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        if root.left and root.val <= root.left.val:\n            return False\n        if root.right and root.val >= root.right.val:\n            return False\n        \n        return self.isValidBST(root.left) and self.isValidBST(root.right)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty, return newInterval\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is before the first interval, return newInterval + intervals\n        if newInterval[0] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if newInterval is after the last interval, return intervals + newInterval\n        if newInterval[1] < intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval overlaps with the first interval, update the first interval\n        intervals[0][0] = min(intervals[0][0], newInterval[0])\n        intervals[0][1] = max(intervals[0][1], newInterval[1])\n        \n        # if newInterval overlaps with the last interval, update the last interval\n        intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n        \n        return intervals"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty, return newInterval\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is before the first interval, return newInterval + intervals\n        if newInterval[0] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if newInterval is after the last interval, return intervals + newInterval\n        if newInterval[1] < intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval overlaps with the first interval, update the first interval\n        intervals[0][0] = min(intervals[0][0], newInterval[0])\n        intervals[0][1] = max(intervals[0][1], newInterval[1])\n        \n        # if newInterval overlaps with the last interval, update the last interval\n        intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n        \n        return intervals"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty, return newInterval\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is before the first interval, return newInterval + intervals\n        if newInterval[0] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if newInterval is after the last interval, return intervals + newInterval\n        if newInterval[1] < intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval overlaps with the first interval, update the first interval\n        intervals[0][0] = min(intervals[0][0], newInterval[0])\n        intervals[0][1] = max(intervals[0][1], newInterval[1])\n        \n        # if newInterval overlaps with the last interval, update the last interval\n        intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n        \n        return intervals"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty, return newInterval\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is before the first interval, return newInterval + intervals\n        if newInterval[0] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if newInterval is after the last interval, return intervals + newInterval\n        if newInterval[1] < intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval overlaps with the first interval, update the start of the first interval\n        intervals[0][0] = min(intervals[0][0], newInterval[0])\n        \n        # if newInterval overlaps with the last interval, update the end of the last interval\n        intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n        \n        # if newInterval is in the middle of intervals, return intervals\n        return intervals"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty, return newInterval\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is before the first interval, return newInterval + intervals\n        if newInterval[0] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if newInterval is after the last interval, return intervals + newInterval\n        if newInterval[1] < intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval overlaps with the first interval, update the first interval\n        intervals[0][0] = min(intervals[0][0], newInterval[0])\n        intervals[0][1] = max(intervals[0][1], newInterval[1])\n        \n        # if newInterval overlaps with the last interval, update the last interval\n        intervals[-1][1] = max(intervals[-1][1], newInterval[1])\n        \n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # dp[i] represents the length of the longest palindrome substring ending at index i\n        dp = [1] * len(s)\n        max_len, start = 1, 0\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n            if dp[i] > max_len:\n                max_len = dp[i]\n                start = i - dp[i] + 1\n        res = []\n        i = len(s) - 1\n        while i >= start:\n            res.append(s[start:i + 1])\n            if i - start + 1 == dp[i]:\n                i -= dp[i]\n            else:\n                i -= dp[i] - 1\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # dp[i] represents the length of the longest palindrome substring ending at index i\n        dp = [1] * len(s)\n        max_len, start = 1, 0\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n            if dp[i] > max_len:\n                max_len = dp[i]\n                start = i - dp[i] + 1\n        res = []\n        i = len(s) - 1\n        while i >= start:\n            res.append(s[start:i + 1])\n            if i - start + 1 == dp[i]:\n                i -= dp[i]\n            else:\n                i -= dp[i] - 1\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # dp[i] represents the length of the longest palindrome substring ending at index i\n        dp = [1] * len(s)\n        max_len, start = 1, 0\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n            if dp[i] > max_len:\n                max_len = dp[i]\n                start = i - dp[i] + 1\n        res = []\n        i = len(s) - 1\n        while i >= start:\n            res.append(s[start:i + 1])\n            if i - start + 1 == dp[i]:\n                i -= dp[i]\n            else:\n                i -= dp[i] - 1\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # dp[i] represents the length of the longest palindrome substring ending at index i\n        dp = [1] * len(s)\n        max_len, start = 1, 0\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 1\n            if dp[i] > max_len:\n                max_len = dp[i]\n                start = i - dp[i] + 1\n        res = []\n        i = len(s) - 1\n        while i >= start:\n            res.append(s[start:i + 1])\n            if i - start + 1 == dp[i]:\n                i -= dp[i]\n            else:\n                i -= dp[i] - 1\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        if not s:\n            return [[]]\n        \n        res = []\n        self.backtrack(s, 0, [], res)\n        return res\n        \n    def backtrack(self, s, start, path, res):\n        if start == len(s):\n            res.append(path[:])\n            return\n        \n        for i in range(start, len(s)):\n            if s[start] == s[i] and (i - start < 2 or s[start + 1] == s[i - 1]):\n                path.append(s[start:i + 1])\n                self.backtrack(s, i + 1, path, res)\n                path.pop()"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums or not nums[0]:\n            return []\n        \n        left, right = nums[0][0], nums[-1][-1]\n        for nums_i in nums:\n            left = max(left, nums_i[0])\n            right = min(right, nums_i[-1])\n            if left < right:\n                return [left, right]\n        return [left, right]"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        left, right = nums[0][0], nums[-1][-1]\n        for i in nums[1:]:\n            left = max(left, i[0])\n            right = min(right, i[-1])\n            if left <= right:\n                return [left, right]\n        return [left, right]"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        start, end = nums[0][0], nums[-1][-1]\n        for i in nums[1:]:\n            if i[0] > start:\n                start = i[0]\n            elif i[-1] < end:\n                end = i[-1]\n            else:\n                start = min(start, i[0])\n                end = max(end, i[-1])\n        return [start, end]"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        start, end = nums[0][0], nums[-1][-1]\n        for i in nums[1:]:\n            if i[0] > start:\n                start = i[0]\n            elif i[-1] < end:\n                end = i[-1]\n            else:\n                start = min(start, i[0])\n                end = max(end, i[-1])\n        return [start, end]"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        left, right = nums[0][0], nums[-1][-1]\n        for nums_i in nums:\n            left = max(left, nums_i[0])\n            right = min(right, nums_i[-1])\n            if left < right:\n                return [left, right]\n        return [left, right]"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs\n        \n        pigs = minutesToTest // minutesToDie + 1\n        return (buckets - 1) // pigs if pigs * minutesToDie >= buckets else pigs - 1"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs\n        \n        pigs = minutesToTest // minutesToDie + 1\n        return (buckets - 1) // pigs if pigs * minutesToDie >= buckets else pigs - 1"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie * pigs) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // (minutesToDie ** 0.5) + 1"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs\n        \n        pigs = minutesToTest // minutesToDie + 1\n        return (buckets - 1) // pigs if pigs * minutesToDie >= buckets else pigs - 1"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs + 1\n        \n        # pigs = minutesToTest // minutesToDie + 1\n        # return (buckets - 1) // pigs\n        \n        pigs = minutesToTest // minutesToDie + 1\n        return (buckets - 1) // pigs if pigs * minutesToDie >= buckets else pigs - 1"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        left, right = 0, n*n - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if grid[mid // n][mid % n] > mid:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        left, right = 0, n*n - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if grid[mid // n][mid % n] > mid:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        left, right = 0, n*n - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if grid[mid // n][mid % n] > mid:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        left, right = 0, n*n - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if grid[mid // n][mid % n] > mid:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        left, right = 0, n*n - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if grid[mid // n][mid % n] > mid:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        dp = [1] * (n + 1)\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[j] += dp[j - 1]\n        return dp[n]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[0][j] = 1\n        # dp[i][0] = 1\n        dp = [1] * (n + 1)\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[j] += dp[j - 1]\n        return dp[n]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[0][j] = 1\n        # dp[i][0] = 1\n        dp = [1] * (n + 1)\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[j] += dp[j - 1]\n        return dp[n]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[0][j] = 1\n        # dp[i][0] = 1\n        dp = [1] * (n + 1)\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[j] += dp[j - 1]\n        return dp[n]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        dp = [1] * (n + 1)\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[j] += dp[j - 1]\n        return dp[n]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if not num1 or not num2:\n            return \"\"\n        \n        m, n = len(num1), len(num2)\n        res = [0] * (m + n)\n        for i in range(m - 1, -1, -1):\n            carry, cur = 0, ord(num1[i]) - ord('0') * (n if i == m - 1 else 1)\n            for j in range(n - 1, -1, -1):\n                mul, sum = res[i + j + 1], cur * (ord(num2[j]) - ord('0')) + carry\n                res[i + j] = sum % 10\n                carry = mul + sum // 10\n            res[i] += carry\n        \n        i = 0\n        while res[i] == 0 and i < len(res) - 1:\n            i += 1\n        return ''.join(map(chr, res[i:])) if i < len(res) else '0'"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if not num1 or not num2:\n            return '0'\n        \n        m, n = len(num1), len(num2)\n        res = [0] * (m + n)\n        for i in range(m - 1, -1, -1):\n            carry, cur = 0, ord(num1[i]) - ord('0')\n            for j in range(n - 1, -1, -1):\n                mul, sum = res[i + j + 1], cur * ord(num2[j]) + carry\n                res[i + j] += mul + sum // 10\n                carry = sum % 10\n            res[i] += carry\n        \n        i = 0\n        while res[i] == 0 and i < len(res) - 1:\n            i += 1\n        return ''.join(map(chr, res[i:])) if i < len(res) else '0'"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if not num1 or not num2:\n            return ''\n        \n        n1, n2 = len(num1), len(num2)\n        res = [0] * (n1 + n2)\n        \n        for i in range(n1):\n            carry, cur = 0, ord(num1[n1 - i - 1]) - ord('0')\n            for j in range(n2 + i):\n                p = res[i + j] + cur * (j + 1) + carry\n                res[i + j], carry = p % 10, p // 10\n            if carry:\n                res[i + n2] += carry\n        \n        i = 0\n        while res[i] == 0 and i < len(res) - 1:\n            i += 1\n        return ''.join(map(str, res[i:])) if i < len(res) else '0'"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if not num1 or not num2:\n            return '0'\n        \n        m, n = len(num1), len(num2)\n        res = [0] * (m + n)\n        for i in range(m - 1, -1, -1):\n            carry, cur = 0, ord(num1[i]) - ord('0')\n            for j in range(n - 1, -1, -1):\n                mul, sum = res[i + j + 1], cur * ord(num2[j]) + carry\n                res[i + j] += mul + sum\n                carry = mul // 10 + (sum >= 10)\n            res[i] += carry\n        \n        i = 0\n        while res[i] == 0 and i < len(res) - 1:\n            i += 1\n        return ''.join(map(chr, res[i:])) if i < len(res) else '0'"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if not num1 or not num2:\n            return '0'\n        \n        m, n = len(num1), len(num2)\n        res = [0] * (m + n)\n        \n        for i in range(m - 1, -1, -1):\n            carry, cur = 0, ord(num1[i]) - ord('0')\n            for j in range(n - 1, -1, -1):\n                mul, sum = res[i + j + 1], cur * ord(num2[j]) + carry\n                res[i + j] += mul + sum // 10\n                carry = sum % 10\n            res[i] += carry\n        \n        i = 0\n        while res[i] == 0 and i < len(res) - 1:\n            i += 1\n        return ''.join(map(chr, res[i:])) if i < len(res) else '0'"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        buy1 = prices[0]\n        buy2 = prices[0]\n        sell1 = 0\n        sell2 = 0\n        \n        for price in prices[1:]:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n        \n        return sell2"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        buy1 = prices[0]\n        buy2 = prices[0]\n        sell1 = 0\n        sell2 = 0\n        \n        for price in prices[1:]:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n            \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        buy1, buy2 = prices[0], prices[0]\n        sell1, sell2 = 0, 0\n        \n        for price in prices[1:]:\n            buy1 = min(buy1, price)\n            sell1 = max(sell1, price - buy1)\n            buy2 = min(buy2, price - sell1)\n            sell2 = max(sell2, price - buy2)\n            \n        return sell2"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            path.append(candidates[i])\n            self.dfs(candidates, target - candidates[i], i + 1, path, res)\n            path.pop()"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            path.append(candidates[i])\n            self.dfs(candidates, target - candidates[i], i + 1, path, res)\n            path.pop()"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            path.append(candidates[i])\n            self.dfs(candidates, target - candidates[i], i + 1, path, res)\n            path.pop()"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            path.append(candidates[i])\n            self.dfs(candidates, target - candidates[i], i + 1, path, res)\n            path.pop()"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            path.append(candidates[i])\n            self.dfs(candidates, target - candidates[i], i + 1, path, res)\n            path.pop()"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(word) <= 1:\n            return True\n        \n        if word[0].isupper() and word[1:].islower():\n            return True\n        \n        if word[0].islower() and word[1:].isupper():\n            return False\n        \n        return word[1:].islower()"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(word) <= 1:\n            return True\n        \n        if word[0].isupper() and word[1:].islower():\n            return True\n        \n        if word[0].islower() and word[1:].isupper():\n            return False\n        \n        return word[1:].islower()"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(word) <= 1:\n            return True\n        \n        if word[0].isupper() and word[1:].islower():\n            return True\n        \n        if word[0].islower() and word[1:].isupper():\n            return False\n        \n        return word[1:].islower()"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(word) <= 1:\n            return True\n        \n        if word[0].isupper() and word[1:].islower():\n            return True\n        \n        if word[0].islower() and word[1:].isupper():\n            return False\n        \n        return word[1:].islower()"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n            \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n            \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [], []\n        while stack or root:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                res.append(root.val)\n                root = root.right\n        return res\n\n# Time: O(N)\n# Space: O(N)\n# Difficulty: medium\n\n# Iterative solution using stack.\n#\n# Iterate through the tree using stack.\n# Whenever we encounter a node, push it to the stack.\n# Whenever we encounter a null node, pop the stack and append the node's value to the result.\n# Whenever we encounter a node with a right child, push the right child to the stack.\n#\n# Time complexity: O(N) where N is the number of nodes in the tree.\n# Space complexity: O(N) where N is the number of nodes in the tree."}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                node = node.left\n                \n        return res\n\n# Time: O(N)\n# Space: O(N)\n# Difficulty: medium\n\n# Iterative solution using stack.\n#\n# Iterate through the tree using stack.\n# Whenever we see a node, we push its right child to the stack.\n# Whenever we see a node without a right child, we pop the stack and append its value to the result.\n#\n# Time complexity: O(N) where N is the number of nodes in the tree.\n# Space complexity: O(N) where N is the number of nodes in the tree."}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [], []\n        while stack or root:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                res.append(root.val)\n                root = root.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                node = node.left\n                \n        return res\n\n# Time: O(N)\n# Space: O(N)\n# Difficulty: medium\n\n# Iterative solution using stack.\n#\n# Iterate through the tree using stack.\n# Every time we pop a node from the stack, we append its value to the result.\n# If the node has a left child, we push its left child to the stack.\n# If the node has a right child, we push its right child to the stack.\n#\n# Time complexity: O(N) where N is the number of nodes in the tree.\n# Space complexity: O(N) where N is the number of nodes in the tree."}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                node = node.left\n                \n        return res\n\n# Time: O(N)\n# Space: O(N)\n# Difficulty: medium\n\n# Iterative solution using stack.\n#\n# Iterate through the tree using stack.\n# Whenever we encounter a node, we push its right child to the stack.\n# Whenever we pop a node from the stack, we append its value to the result.\n# Then we push its left child to the stack.\n#\n# Time complexity: O(N) where N is the number of nodes in the tree.\n# Space complexity: O(N) where N is the number of nodes in the tree.\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            if node:\n                stack.append(node)\n                node = node.left\n            else:\n                node = stack.pop()\n                res.append(node.val)\n                node = node.right\n        \n        return res\n\n# Time: O(N)\n# Space: O(N)\n# Difficulty: medium\n\n# Recursive solution.\n#\n# Inorder traversal of a binary tree is to traverse the left subtree, then root, then right subtree.\n#\n# So we can use recursion to traverse the left subtree, then root, then right subtree.\n#\n# Time complexity: O(N) where N is the number of nodes in the tree.\n# Space complexity: O(N) where N is the number of nodes in the tree.\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        \n        res = []\n        self.inorderTraversal(root.left, res)\n        res.append(root.val)\n        self.inorderTraversal(root.right, res)\n        \n        return res\n\n# Time: O(N)\n# Space: O(N)\n# Difficulty: medium\n\n# Recursive solution.\n#\n# Inorder traversal of a binary tree is to traverse the left subtree, then root, then right subtree.\n#\n# So we can use recursion to traverse the left subtree, then root, then right subtree.\n#\n# Time complexity: O(N) where N is the number of nodes in the tree.\n# Space complexity: O(N) where N is the number of nodes in the tree.\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        \n        res = []\n        self.inorderTraversal(root.left, res)\n        res.append(root.val)\n        res.extend(self.inorderTraversal(root.right))\n        \n        return res\n\n# Time: O(N)\n# Space: O(N)\n#"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # Validate the string\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(c)\n        \n        # If stack is empty, the string is valid\n        if not stack:\n            return [s]\n        \n        # Remove invalid parentheses\n        res = []\n        start, end = 0, 1\n        while end <= len(s):\n            if stack and s[start] == stack[-1]:\n                stack.pop()\n                start += 1\n            elif stack or s[start] != ')':\n                end += 1\n            else:\n                stack.append(s[start])\n                start += 1\n        \n        # Generate all valid strings\n        while start < end:\n            res.append(s["}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # Validate the string\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(c)\n        \n        # If stack is empty, the string is valid\n        if not stack:\n            return [s]\n        \n        # Remove invalid parentheses\n        res = []\n        start, end = 0, 1\n        while end <= len(s):\n            if stack and s[start] == stack[-1]:\n                stack.pop()\n                start += 1\n            elif stack or s[start] != ')':\n                end += 1\n            else:\n                stack.append(s[start])\n                start += 1\n        \n        # Generate all valid strings\n        while start < end:\n            res.append(s["}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # Validate the string\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(c)\n        \n        # If the stack is empty, the string is valid\n        if not stack:\n            return [s]\n        \n        # Remove invalid parentheses\n        start, end = 0, len(s) - 1\n        while start < end and s[start] == '(':\n            start += 1\n        while start < end and s[end] == ')':\n            end -= 1\n        if start >= end:\n            return [s[start:end+1]]\n        \n        # Remove invalid parentheses from the start and end\n        res = []\n        while start <= end:\n            if s[start] == s[end]:\n                start += 1\n                end -= 1\n            else:\n                res.append(s[start] + res.pop() if res else '')\n                end -= 1\n        return res + s[start:]"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # Validate the string\n        left, right = 0, 0\n        for c in s:\n            if c == '(':\n                left += 1\n            elif c == ')':\n                if left == 0:\n                    right += 1\n                else:\n                    left -= 1\n        \n        # If the number of left and right parentheses are not equal, return empty list\n        if left != right:\n            return []\n        \n        # Use a stack to keep track of the valid parentheses\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            else:\n                if stack and stack[-1] == '(':\n                    stack.pop()\n                else:\n                    stack.append(c)\n        \n        # Remove the invalid parentheses\n        res = []\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                if not stack:\n                    res.append(c)\n        \n        # Add the remaining valid parentheses to the result\n        while stack:\n            res.append(stack.pop())\n        \n        return res"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # Validate the string\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(c)\n        \n        # If the stack is empty, the string is valid\n        if not stack:\n            return [s]\n        \n        # Remove invalid parentheses\n        res = []\n        start, end = 0, 1\n        while end <= len(s):\n            if stack and s[start] == stack[-1]:\n                stack.pop()\n                start += 1\n            elif stack or s[start] != ')':\n                end += 1\n            else:\n                stack.append(s[start])\n                start += 1\n        \n        # Generate all valid strings\n        while start < end:\n            res.append(s["}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Maintain a dummy head node\n        head = p = ListNode(0)\n        \n        # Maintain a pointer to the smallest node\n        smallest = min(lists, key=lambda x: x.val) if lists else None\n        \n        # Iterate until smallest is None\n        while smallest:\n            p.next = smallest\n            p = p.next\n            smallest = smallest.next if smallest.next else min(lists, key=lambda x: x.val) if x else None\n        \n        return head.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Merge two sorted lists\n        def mergeTwoLists(l1, l2):\n            dummy = head = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    head.next = l1\n                    l1 = l1.next\n                else:\n                    head.next = l2\n                    l2 = l2.next\n                head = head.next\n            head.next = l1 if l1 else l2\n            return dummy.next\n        \n        # Merge k sorted lists\n        head = None\n        for l in lists:\n            head = mergeTwoLists(head, l)\n        return head"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Maintain a dummy head node\n        dummy = ListNode(0)\n        curr = dummy\n        \n        # Maintain a pointer to the smallest node\n        smallest = min(lists, key=lambda x: x and x.val)\n        \n        while smallest:\n            curr.next = smallest\n            curr = curr.next\n            smallest = smallest.next if smallest.next else lists.pop(0)\n        \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Time: O(nlogk)\n        # Space: O(k)\n        # Merge sort\n        if not lists:\n            return None\n        \n        head = ListNode(0)\n        tail = head\n        while lists:\n            min_node = min(lists, key=lambda x: x.val)\n            tail.next = min_node\n            tail = tail.next\n            min_node = min_node.next\n            if min_node:\n                lists.remove(min_node)\n        return head.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Merge two sorted lists\n        def mergeTwoLists(l1, l2):\n            dummy = head = ListNode(0)\n            while l1 and l2:\n                if l1.val < l2.val:\n                    head.next = l1\n                    l1 = l1.next\n                else:\n                    head.next = l2\n                    l2 = l2.next\n                head = head.next\n            head.next = l1 if l1 else l2\n            return dummy.next\n        \n        # Merge k sorted lists\n        head = None\n        for l in lists:\n            head = mergeTwoLists(head, l)\n        return head"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the minimum cuts needed for a palindrome partitioning of s[:i]\n        dp = [0] * (len(s) + 1)\n        for i in range(1, len(s) + 1):\n            # if s[i - 1] == s[i - 1 - dp[i - 1]], we can extend the previous palindrome\n            if s[i - 1] == s[dp[i - 1]]:\n                dp[i] = dp[i - 1] + 1\n            else:\n                dp[i] = 0\n        \n        # the minimum cuts needed for a palindrome partitioning of s is the maximum value in dp\n        return dp[len(s)] - 1"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the minimum cuts needed for a palindrome partitioning of s[:i+1]\n        dp = [0] * (len(s) + 1)\n        for i in range(len(s)):\n            if s[i] == s[~i]:\n                dp[i + 1] = dp[i]\n            else:\n                dp[i + 1] = dp[i] + 1\n        \n        return dp[len(s)] - 1"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        n = len(s)\n        is_palindrome = [True] * n\n        is_palindrome[0] = True\n        \n        for i in range(1, n):\n            if s[i] == s[i - 1]:\n                is_palindrome[i] = is_palindrome[i - 1]\n            else:\n                is_palindrome[i] = is_palindrome[i - 1] and s[i - 1] == s[n - i]\n        \n        if is_palindrome[n - 1]:\n            return 0\n        \n        cuts = [0] * n\n        left, right = 0, 1\n        while right < n:\n            if is_palindrome[right]:\n                cuts[right] = left\n                right += 1\n            else:\n                left = max(left, right - cuts[left - 1])\n                right += 1\n        \n        return cuts[n - 1]"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the minimum cuts needed for a palindrome partitioning of s[:i+1]\n        dp = [0] * (len(s) + 1)\n        for i in range(len(s)):\n            if s[i] == s[~i]:\n                dp[i + 1] = dp[i]\n            else:\n                dp[i + 1] = dp[i] + 1\n        \n        return dp[len(s)] - 1"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(i):\n                if s[j] == s[i - 1] and dp[j]:\n                    dp[i] = True\n                    break\n            if dp[i]:\n                continue\n            else:\n                return i - 1\n        \n        return 0"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # f(x) = k => x! % 10**k == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # f(x) = k => x! % 10**k == 0\n        # f(x) != k => x! % 10**k != 0\n        # x! % 10**k == 0 => x % (10**k) == 0\n        # x % (10**k) == 0 => x % 5**k == 0\n        # x % 5**k == 0 => x % 5 == 0 or x % 5 == 1 or x % 5 == 2 or x % 5 == 3 or x % 5 == 4\n        # x % 5 == 0 => x % 2 == 0\n        # x % 5 == 1 => x % 2 == 1 or x % 2 == 3 or x % 2 == 4\n        # x % 5 == 2 => x % 2 == 2\n        # x % 5 == 3 => x % 2 == 1 or x % 2 == 3\n        # x % 5 == 4 => x % 2 == 1\n        # x % 2 == 0 => x % 2 == 0 or x % 2 == 1\n        # x % 2 == 1 => x % 2 == 1 or x % 2 == 3\n        # x % 2 == 3 => x % 2 == 1\n        # x % 2 == 4 => x % 2 == 1\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x % 2 == 3\n        # x % 2 == 1 => x % 2 == 1\n        # x % 2 == 3 => x %"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # f(x) = k => x! % 10**k == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 10**k == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x %"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # f(x) = k => x! % 10**k == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0\n        # f(x) = k => x % 2 == 0\n        # f(x) = k => x % 5 == 0\n        # f(x) = k => x % 3 == 0"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000007 is the modulo\n        # 1000000007 is the largest number that can be represented by 31 bits\n        # 1000000007 is the largest number that can be represented by 32 bits\n        # 1000000007 is the largest number that can be represented by 33 bits\n        # 1000000007 is the largest number that can be represented by 34 bits\n        # 1000000007 is the largest number that can be represented by 35 bits\n        # 1000000007 is the largest number that can be represented by 36 bits\n        # 1000000007 is the largest number that can be represented by 37 bits\n        # 1000000007 is the largest number that can be represented by 38 bits\n        # 1000000007 is the largest number that can be represented by 39 bits\n        # 1000000007 is the largest number that can be represented by 40 bits\n        # 1000000007 is the largest number that can be represented by 41 bits\n        # 1000000007 is the largest number that can be represented by 42 bits\n        # 1000000007 is the largest number that can be represented by 43 bits\n        # 1000000007 is the largest number that can be represented by 44 bits\n        # 1000000007 is the largest number that can be represented by 45 bits\n        # 1000000007 is the largest number that can be represented by 46 bits\n        # 1000000007 is the largest number that can be represented by 47 bits\n        # 1000000007 is the largest number that can be represented by 48 bits\n        # 1000000007 is the largest number that can be represented by 49 bits\n        # 1000000007 is the largest number that can be represented by 50 bits\n        # 1000000007 is the largest number that can be represented by 51 bits\n        # 1000000007 is the largest number that can be represented by 52 bits\n        # 1000000007 is the largest number that can be represented by 53 bits\n        # 1000000007 is the largest number that can be represented by 54 bits\n        # 1000000007 is the largest number that can be represented by 55 bits\n        # 1000000007 is the largest number that can be represented by 56 bits\n        # 1000000007 is the largest number that can be represented by 57 bits\n        # 1000000007 is the largest number that can be represented by 58 bits\n        # 1000000007 is the largest number that can be represented by 59 bits\n        # 1000000007 is the largest number that can be represented by 60 bits\n        # 1000000007 is the largest number that can be represented by 61 bits\n        # 1000000007 is the largest number that can be represented by 62 bits\n        # 1000000007 is the largest number that can be represented by 63 bits\n        # 1000000007 is the largest number that can be represented by 64 bits\n        # 1000000007 is the largest number that can be represented by 65 bits\n        # 1000000007 is the largest number that can be represented by 66 bits\n        # 1000000007 is the largest number that can be represented by 67 bits\n        # 1000"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a hashmap of word -> index\n        # if the word is a palindrome, add it to the list of palindromes\n        # if the word is not a palindrome, add it to the hashmap with the reverse word as the key\n        # if the reverse word is in the hashmap, add the pair to the result\n        # if the reverse word is not in the hashmap, add the word to the hashmap with the word as the key\n        # return the result\n        \n        # if there is only one word, return the pair of index 0\n        if len(words) == 1:\n            return [[0, 0]]\n        \n        # build the hashmap\n        hashmap = {word: i for i, word in enumerate(words)}\n        result = []\n        \n        for i, word in enumerate(words):\n            # if the word is a palindrome, add it to the result\n            if word == word[::-1]:\n                result.append([i, i])\n            # if the reverse word is in the hashmap, add the pair to the result\n            if word[::-1] in hashmap and hashmap[word] != i:\n                result.append([hashmap[word], i])\n            # add the word to the hashmap with the word as the key\n            else:\n                hashmap[word[::-1]] = i\n        \n        return result"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a map of word to its index\n        # if the word is a palindrome, we can use it as a key\n        # if the word is not a palindrome, we can use its reverse as a key\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a palindrome, we can use its index as the value\n        # if the word is not a palindrome, we can use its reverse index as the value\n        # the value of the map is the index of the word\n        # if the word is a"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a hash table to store the index of each word\n        # if the word is a palindrome, store the index in the hash table\n        # if the word is not a palindrome, store the reverse of the word in the hash table\n        # if the reverse of the word is in the hash table, store the index in the hash table\n        # if the reverse of the word is not in the hash table, check if the word itself is in the hash table\n        # if the word is in the hash table, store the index in the hash table\n        # return the result\n        \n        # build a hash table to store the index of each word\n        # if the word is a palindrome, store the index in the hash table\n        # if the word is not a palindrome, store the reverse of the word in the hash table\n        # if the reverse of the word is in the hash table, store the index in the hash table\n        # if the reverse of the word is not in the hash table, check if the word itself is in the hash table\n        # if the word is in the hash table, store the index in the hash table\n        # return the result\n        if not words:\n            return []\n        \n        hash_table = {word: i for i, word in enumerate(words)}\n        result = []\n        for i, word in enumerate(words):\n            if word in hash_table and i != hash_table[word]:\n                result.append([i, hash_table[word]])\n            reverse_word = word[::-1]\n            if reverse_word in hash_table and hash_table[reverse_word] != i:\n                result.append([i, hash_table[reverse_word]])\n            else:\n                if reverse_word not in hash_table:\n                    hash_table[reverse_word] = i\n        return result"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a hashmap of word -> index\n        # if a word is a palindrome, add it to the hashmap\n        # if a word is not a palindrome, add its reverse to the hashmap\n        # if a word is in the hashmap, add the pair to the result\n        # if a word is not in the hashmap, check if its reverse is in the hashmap\n        # if so, add the pair to the result\n        # if not, continue\n        # return the result\n        \n        # build a hashmap of word -> index\n        # if a word is a palindrome, add it to the hashmap\n        # if a word is not a palindrome, add its reverse to the hashmap\n        # if a word is in the hashmap, add the pair to the result\n        # if a word is not in the hashmap, check if its reverse is in the hashmap\n        # if so, add the pair to the result\n        # if not, continue\n        # return the result\n        if not words:\n            return []\n        \n        hashmap = {word: i for i, word in enumerate(words)}\n        result = []\n        for i, word in enumerate(words):\n            if word not in hashmap:\n                if word[::-1] in hashmap:\n                    result.append([hashmap[word], hashmap[word[::-1]]])\n            else:\n                if word[::-1] != word:\n                    if word[::-1] in hashmap:\n                        result.append([i, hashmap[word[::-1]]])\n                else:\n                    result.append([i, i])\n        return result"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a map of word -> index\n        # if the word is a palindrome, we can use it as a key\n        # if the word is not a palindrome, we can use its reverse as a key\n        # if the word is a palindrome, we can use its index as a value\n        # if the word is not a palindrome, we can use its index as a value\n        # if the word is in the map, we can use its index as a value\n        # if the word is not in the map, we can use its reverse as a key\n        # if the reverse is in the map, we can use its index as a value\n        # if the reverse is not in the map, we can use its index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the index is the same, we can use the index as a value\n        # if the index is not the same, we can use the index as a value\n        # if the"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not isInfected:\n            return 0\n        \n        m, n = len(isInfected), len(isInfected[0])\n        infected = set()\n        for i in range(m):\n            if isInfected[i][0]:\n                infected.add((i, 0))\n            if isInfected[i][-1]:\n                infected.add((i, n - 1))\n        for j in range(1, n - 1):\n            if isInfected[0][j]:\n                infected.add((0, j))\n            if isInfected[-1][j]:\n                infected.add((m - 1, j))\n        \n        walls = 4 * (m + n - 2)\n        for i, j in infected:\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                walls -= 2\n            else:\n                walls -= 4\n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not isInfected:\n            return 0\n        \n        m, n = len(isInfected), len(isInfected[0])\n        infected = set()\n        for i in range(m):\n            if isInfected[i][0]:\n                infected.add((i, 0))\n            if isInfected[i][-1]:\n                infected.add((i, n - 1))\n        for j in range(1, n - 1):\n            if isInfected[0][j]:\n                infected.add((0, j))\n            if isInfected[-1][j]:\n                infected.add((m - 1, j))\n        \n        walls = 4 * (m + n - 2)\n        for i, j in infected:\n            if i == 0 or j == 0:\n                walls -= 2\n            elif i == m - 1 or j == n - 1:\n                walls -= 1\n        \n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not isInfected:\n            return 0\n        \n        m, n = len(isInfected), len(isInfected[0])\n        infected = set()\n        for i in range(m):\n            if isInfected[i][0]:\n                infected.add((i, 0))\n            if isInfected[i][-1]:\n                infected.add((i, n - 1))\n        for j in range(1, n - 1):\n            if isInfected[0][j]:\n                infected.add((0, j))\n            if isInfected[-1][j]:\n                infected.add((m - 1, j))\n        \n        walls = 4 * (m + n - 2)\n        for i, j in infected:\n            if i == 0 or j == 0:\n                walls -= 2\n            elif i == m - 1 or j == n - 1:\n                walls -= 1\n        \n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not isInfected:\n            return 0\n        \n        m, n = len(isInfected), len(isInfected[0])\n        infected = set()\n        for i in range(m):\n            if isInfected[i][0]:\n                infected.add((i, 0))\n            if isInfected[i][-1]:\n                infected.add((i, n - 1))\n        for j in range(1, n - 1):\n            if isInfected[0][j]:\n                infected.add((0, j))\n            if isInfected[-1][j]:\n                infected.add((m - 1, j))\n        \n        walls = 4 * (m + n - 2)\n        for i, j in infected:\n            if i == 0 or j == 0 or i == m - 1 or j == n - 1:\n                walls -= 2\n            else:\n                walls -= 4\n        \n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not isInfected:\n            return 0\n        \n        m, n = len(isInfected), len(isInfected[0])\n        infected = set()\n        for i in range(m):\n            if isInfected[i][0]:\n                infected.add((i, 0))\n            if isInfected[i][-1]:\n                infected.add((i, n - 1))\n        for j in range(1, n - 1):\n            if isInfected[0][j]:\n                infected.add((0, j))\n            if isInfected[-1][j]:\n                infected.add((m - 1, j))\n        \n        walls = 4 * (m + n - 2)\n        for i, j in infected:\n            if i == 0 or j == 0:\n                walls -= 2\n            elif i == m - 1 or j == n - 1:\n                walls -= 1\n        \n        return walls"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = 1 if matrix[i][j] == matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]]\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = 1 if matrix[i][j] == matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]]\n        \n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = 1 if matrix[i][j] == matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]]\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = 1 if matrix[i][j] == matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]]\n        \n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = 1 if matrix[i][j] == matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]]\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = 1 if matrix[i][j] == matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]]\n        \n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = 1 if matrix[i][j] == matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]]\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = 1 if matrix[i][j] == matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]]\n        \n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = dp[i][j] if matrix[i][j] <= matrix[i][j - dp[i][j]] else dp[i][j - dp[i][j]] + 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n):\n                res = max(res, dp[i][j] + 1)\n                dp[i][j] = dp[i][j] if matrix[i][j] <= matrix[i - dp[i][j]][j] else dp[i - dp[i][j]][j] + 1\n        \n        return res"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        count = 0\n        while n:\n            count += n % 10 // 10\n            n //= 10\n            n += n // 10\n        \n        return count"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        count = 0\n        while n:\n            count += n % 10 // 10\n            n //= 10\n            n += n // 10\n        \n        return count"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        count = 0\n        while n:\n            count += n % 10 // 10\n            n //= 10\n            n += n // 10\n        \n        return count"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        count = 0\n        while n:\n            count += n % 10 // 10\n            n //= 10\n            n += n // 10\n        \n        return count"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        count = 0\n        while n:\n            count += n % 10 // 10\n            n //= 10\n            n += n // 10\n        \n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP solution\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        return dp[-1]\n        \n        # DP solution with memorization\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            if dp[i - len(word)] and word in wordDict:\n                dp[i] = True\n        return dp[-1]\n        \n        # DP solution with memorization and pruning\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            if dp[i - len(word)] and word in wordDict:\n                dp[i] = True\n            else:\n                dp[i] = dp[i - 1]\n        return dp[-1]\n        \n        # DP solution with memorization and pruning\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [True] * (len(s) + 1)\n        for i in range(len(s)):\n            if dp[i + len(word)] and word in wordDict:\n                dp[i] = True\n            else:\n                dp[i] = dp[i] and word in wordDict\n        return dp[0]\n        \n        # DP solution with memorization and pruning\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [True]\n        for word in wordDict:\n            if len(word) > len(s):\n                continue\n            dp.append(dp[-len(word):] or word == s[:len(word)])\n        return dp[-1]\n        \n        # DP solution with memorization and pruning\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [True]\n        for i in range(len(s)):\n            if dp[i] and s[i] in wordDict:\n                dp.append(True)\n            else:\n                dp.append(dp[i - len(wordDict[s[i:]])] if s[i] in wordDict else False)\n        return dp[-1]\n        \n        # DP solution with memorization and pruning\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [True]\n        for i in range(len(s)):\n            if dp[i] and s[i] in wordDict:\n                dp[i + len(wordDict[s[i:]])] = True\n        return dp[-1]\n        \n        # DP solution with memorization and pruning\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [True] * len(s)\n        for i in range(len(s)):\n            if dp[i] and s[i] in wordDict:\n                dp[i + len(wordDict[s[i:]])] = True\n        return dp[-1]\n        \n        # DP solution with memorization and pruning\n        # dp[i] represents whether s[:i] can be segmented into a sentence using the words in wordDict\n        dp = [True]\n        for i in range(len(s)):\n            if d"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP solution\n        # dp[i] = True if s[:i] can be segmented into a sequence of words in wordDict\n        # dp[i] = dp[j] and s[j:i] in wordDict for j in range(i)\n        # base case: dp[0] = True\n        dp = [True] + [False] * len(s)\n        for i in range(1, len(s)):\n            for j in range(i):\n                if dp[j] and s[j:i+1] in wordDict:\n                    dp[i] = True\n                    break\n        return dp[-1]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of dictionary words\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        if not dp[len(s)]:\n            return []\n        \n        res = []\n        self.dfs(s, 0, res, dp, wordDict)\n        return res\n    \n    def dfs(self, s, start, res, dp, wordDict):\n        if start == len(s):\n            res.append('')\n            return\n        \n        if dp[start]:\n            if start > 0:\n                res.append(s[start])\n            self.dfs(s, start + 1, res, dp, wordDict)\n            res.pop()\n        else:\n            for i in range(start, len(s)):\n                if s[start:i + 1] in wordDict:\n                    self.dfs(s, i + 1, res, dp, wordDict)\n                    if res:\n                        res.append(' ')\n                    res.append(s[start:i + 1])\n                    res.pop()\n                    break"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP solution\n        # dp[i] = True if s[:i] can be segmented into a sequence of words in wordDict\n        # dp[i] = dp[j] and s[j:i] in wordDict for j < i\n        # base case: dp[0] = True\n        dp = [True] + [False] * len(s)\n        for i in range(1, len(s)):\n            for j in range(i):\n                if dp[j] and s[j:i+1] in wordDict:\n                    dp[i] = True\n                    break\n        return dp[-1]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of dictionary words\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        return dp[-1]"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        is_left_to_right = True\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                if is_left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n            is_left_to_right = not is_left_to_right\n        \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        is_left_to_right = True\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                if is_left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            res.append(level)\n            is_left_to_right = not is_left_to_right\n        \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        is_left_to_right = True\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                if is_left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            res.append(level)\n            is_left_to_right = not is_left_to_right\n        \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        is_left_to_right = True\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                if is_left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            res.append(level)\n            is_left_to_right = not is_left_to_right\n        \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        queue = [root]\n        is_left_to_right = True\n        \n        while queue:\n            size = len(queue)\n            level = []\n            for _ in range(size):\n                node = queue.pop(0)\n                if is_left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n            is_left_to_right = not is_left_to_right\n        \n        return res"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if turnedOn > 8:\n            return []\n        \n        res = []\n        if turnedOn >= 4:\n            res.append(str(turnedOn // 4) + ':00')\n            turnedOn %= 4\n        \n        if turnedOn >= 2:\n            res.append(str(turnedOn // 2) + ':30')\n        \n        if turnedOn:\n            res.append('0:' + str(turnedOn * 5))\n        \n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        if turnedOn <= 4:\n            res.append('{:02d}:{:02d}'.format(turnedOn, 60 - turnedOn))\n        if turnedOn <= 9:\n            res.append('{:02d}:{:02d}'.format(turnedOn - 4, 15))\n        if turnedOn <= 10:\n            res.append('{:02d}:{:02d}'.format(10, turnedOn - 6))\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        if turnedOn <= 4:\n            res.append('%d:%02d' % (turnedOn, 60 - turnedOn))\n        if turnedOn <= 9:\n            res.append('%d:%02d' % (turnedOn - 4, 15))\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        if turnedOn <= 4:\n            res.append('%d:%02d' % (turnedOn, 60 - turnedOn))\n        if turnedOn <= 9:\n            res.append('%d:%02d' % (turnedOn - 4, 15))\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        if turnedOn <= 4:\n            res.append('{:02d}:{:02d}'.format(turnedOn, 60 - turnedOn))\n        if turnedOn <= 9:\n            res.append('{:02d}:{:02d}'.format(turnedOn - 4, 15))\n        if turnedOn <= 10:\n            res.append('{:02d}:{:02d}'.format(10, turnedOn - 6))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        \n        triangle = [[1]]\n        for i in range(1, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            row.append(1)\n            triangle.append(row)\n        \n        return triangle"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        \n        triangle = [[1]]\n        for i in range(1, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            row.append(1)\n            triangle.append(row)\n        \n        return triangle"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        \n        triangle = [[1]]\n        for i in range(1, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            row.append(1)\n            triangle.append(row)\n        \n        return triangle"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        \n        triangle = [[1]]\n        for i in range(1, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            row.append(1)\n            triangle.append(row)\n        \n        return triangle"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        \n        triangle = [[1]]\n        for i in range(1, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            row.append(1)\n            triangle.append(row)\n        \n        return triangle"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        max_sum = root.val\n        left_sum = max(0, left_sum)\n        right_sum = max(0, right_sum)\n        \n        return max(max_sum, left_sum + right_sum)"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        max_sum = root.val\n        left_sum = max(0, root.left.val) if root.left else 0\n        right_sum = max(0, root.right.val) if root.right else 0\n        \n        max_sum = max(max_sum, left_sum + right_sum + root.val)\n        \n        return max(max_sum, left_sum, right_sum)"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        max_sum = root.val\n        left_max = max(root.left, 0) if root.left else 0\n        right_max = max(root.right, 0) if root.right else 0\n        \n        max_sum = max(max_sum, left_max + right_max + root.val)\n        \n        return max(max_sum, left_max, right_max)"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        max_sum = root.val\n        left_sum = max(0, left_sum)\n        right_sum = max(0, right_sum)\n        \n        return max(max_sum, left_sum + right_sum)"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        max_sum = root.val\n        left_max = max(root.left, 0) if root.left else 0\n        right_max = max(root.right, 0) if root.right else 0\n        \n        max_sum = max(max_sum, left_max + right_max + root.val)\n        \n        return max(max_sum, left_max, right_max)"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        left, right = [0] * n, [0] * n\n        \n        for i in range(m):\n            left[i] = heightMap[i][0]\n            right[n - 1 - i] = heightMap[i][n - 1]\n        \n        left_max, right_max = left[0], right[n - 1]\n        water = 0\n        \n        for i in range(1, n):\n            left_max = max(left_max, heightMap[i][0])\n            water += left_max - heightMap[i][0]\n        \n        for i in range(n - 2, -1, -1):\n            right_max = max(right_max, heightMap[i][n - 1])\n            water += right_max - heightMap[i][n - 1]\n        \n        return water"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        left, right = [0] * n, [0] * n\n        \n        for i in range(m):\n            left[i] = heightMap[i][0]\n            right[n - 1 - i] = heightMap[i][n - 1]\n        \n        left_max, right_max = left[0], right[n - 1]\n        water = 0\n        \n        for i in range(1, n):\n            left_max = max(left_max, heightMap[i][0])\n            water += left_max - heightMap[i][0]\n            \n        for i in range(n - 2, -1, -1):\n            right_max = max(right_max, heightMap[i][n - 1])\n            water += right_max - heightMap[i][n - 1]\n            \n        return water"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        left, right = [0] * n, [0] * n\n        \n        for i in range(m):\n            left[i] = heightMap[i][0]\n            right[n - 1 - i] = heightMap[i][n - 1]\n        \n        left_max, right_max = left[0], right[n - 1]\n        water = 0\n        \n        for i in range(1, n):\n            left_max = max(left_max, heightMap[i][0])\n            water += left_max - heightMap[i][0]\n            \n        for i in range(n - 2, -1, -1):\n            right_max = max(right_max, heightMap[i][n - 1])\n            water += right_max - heightMap[i][n - 1]\n            \n        return water"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        left, right = [0] * n, [0] * n\n        \n        for i in range(m):\n            left[i], right[m - i - 1] = heightMap[i][0], heightMap[m - i - 1][n - 1]\n            for j in range(1, n):\n                left[i], right[m - i - 1] = max(left[i], heightMap[i][j]), max(right[m - i - 1], heightMap[m - i - 1][n - 1 - j])\n        \n        water = left[0] + right[m - 1] - min(left[m - 1], right[0])\n        \n        for i in range(1, m):\n            water += min(left[i], right[i]) - heightMap[i][n - 1]\n        \n        return water"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        left, right = [0] * n, [0] * n\n        \n        for i in range(m):\n            left[i] = heightMap[i][0]\n            right[n - 1 - i] = heightMap[i][n - 1]\n        \n        left_max, right_max = left[0], right[n - 1]\n        water = 0\n        \n        for i in range(1, n):\n            left_max = max(left_max, heightMap[i][0])\n            water += left_max - heightMap[i][0]\n            \n        for i in range(n - 2, -1, -1):\n            right_max = max(right_max, heightMap[i][n - 1])\n            water += right_max - heightMap[i][n - 1]\n            \n        return water"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(c.lower() for c in s if c.isalnum())\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        left, right = 0, k - 1\n        left_max, right_max = nums[left], nums[right]\n        \n        res = [left_max] if k % 2 == 1 else [left_max, right_max]\n        \n        for i in range(k, len(nums)):\n            if nums[i] <= left_max:\n                left_max = nums[i - k]\n            else:\n                right_max = nums[i]\n            \n            if left_max == right_max:\n                res.append(left_max)\n            elif i - left == k:\n                res.append(right_max)\n            else:\n                res.append((left_max + right_max) / 2.0)\n        \n        return res"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        left, right = 0, k - 1\n        left_max, right_max = nums[left], nums[right]\n        res = [left_max] if k % 2 == 1 else [left_max, right_max]\n        \n        for i in range(k, len(nums)):\n            if nums[i] <= left_max:\n                left_max = nums[i - k]\n            else:\n                right_max = nums[i]\n            if left_max == right_max:\n                res.append(left_max)\n            elif i - k + 1 == right:\n                res.append(right_max)\n            else:\n                res.append((left_max + right_max) / 2.0)\n        \n        return res"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        left, right = 0, k - 1\n        left_max, right_max = nums[left], nums[right]\n        res = [left_max] if k % 2 else (left_max + right_max) / 2.0\n        \n        for i in range(k, len(nums)):\n            if nums[i] <= left_max:\n                left_max = nums[i - k]\n            else:\n                res.append(nums[i] if k % 2 else (left_max + nums[i]) / 2.0)\n                if nums[i] >= right_max:\n                    right_max = nums[i]\n                elif i - k >= left:\n                    right_max = nums[i - k]\n                    \n        return res"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        left, right = 0, k - 1\n        left_max, right_max = nums[left], nums[right]\n        res = [left_max] if k % 2 else (left_max + right_max) / 2.0\n        \n        for i in range(k, len(nums)):\n            if nums[i] <= left_max:\n                left_max = nums[i - k]\n            else:\n                res.append(nums[i] if k % 2 else (left_max + nums[i]) / 2.0)\n                if nums[i] >= right_max:\n                    right_max = nums[i]\n                elif i - k >= left:\n                    right_max = nums[i - k]\n                    \n        return res"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        left, right = 0, k - 1\n        left_max, right_max = nums[left], nums[right]\n        res = [left_max] if k % 2 == 1 else [left_max, right_max]\n        \n        for i in range(k, len(nums)):\n            if nums[i] <= left_max:\n                left_max = nums[i - k]\n            else:\n                right_max = nums[i]\n            \n            if left_max == right_max:\n                res.append(left_max)\n            elif i - left == k:\n                res.append(right_max)\n            else:\n                res.append((left_max + right_max) / 2.0)\n        \n        return res"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 0:\n            return head\n        \n        # find the length of the list\n        length = 1\n        cur = head\n        while cur.next:\n            length += 1\n            cur = cur.next\n        \n        # k %= length\n        k %= length\n        if k == 0:\n            return head\n        \n        # reverse the first k nodes\n        prev = None\n        cur = head\n        for _ in range(k):\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        \n        # connect the first k nodes to the end\n        head.next = cur\n        \n        # return the new head\n        return prev"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 0:\n            return head\n        \n        # find the length of the list\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n        \n        # k %= length\n        k %= length\n        if k == 0:\n            return head\n        \n        # reverse the first k nodes\n        prev = None\n        cur = head\n        for _ in range(k):\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        \n        # connect the first k nodes to the end\n        head.next = cur\n        \n        # return the new head\n        return prev"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 0:\n            return head\n        \n        # find the length of the list\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n        \n        # k %= length\n        k %= length\n        if k == 0:\n            return head\n        \n        # reverse the first k nodes\n        prev = None\n        cur = head\n        for _ in range(k):\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        \n        # connect the first k nodes to the end\n        head.next = cur\n        \n        # return the new head\n        return prev"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 0:\n            return head\n        \n        # find the length of the list\n        length = 1\n        cur = head\n        while cur.next:\n            length += 1\n            cur = cur.next\n        \n        # k %= length\n        k %= length\n        if k == 0:\n            return head\n        \n        # reverse the first k nodes\n        prev = None\n        cur = head\n        for _ in range(k):\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        \n        # connect the first k nodes to the end\n        head.next = cur\n        \n        # return the new head\n        return prev"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 0:\n            return head\n        \n        # find the length of the list\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length += 1\n        \n        # k %= length\n        k %= length\n        if k == 0:\n            return head\n        \n        # reverse the first k nodes\n        prev = None\n        cur = head\n        for _ in range(k):\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        \n        # connect the first k nodes to the end\n        head.next = cur\n        \n        # return the new head\n        return prev"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        while n % 3 == 0:\n            n /= 3\n        while n % 5 == 0:\n            n /= 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        while n % 3 == 0:\n            n /= 3\n        while n % 5 == 0:\n            n /= 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        while n % 3 == 0:\n            n /= 3\n        while n % 5 == 0:\n            n /= 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n //= 2\n        while n % 3 == 0:\n            n //= 3\n        while n % 5 == 0:\n            n //= 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n //= 2\n        while n % 3 == 0:\n            n //= 3\n        while n % 5 == 0:\n            n //= 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * len(positions)\n        max_right = 0\n        for i, (left, side) in enumerate(positions):\n            if left > max_right:\n                res[i] = side + (left - max_right)\n            else:\n                res[i] = min(res[i - 1], side + (left - max_right))\n            max_right = max(max_right, left + side)\n        return res"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * len(positions)\n        max_right = 0\n        for i, (left, side) in enumerate(positions):\n            if left > max_right:\n                max_right = left + side\n            else:\n                max_right = max(max_right, left + side)\n            res[i] = max_right\n        return res"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * len(positions)\n        max_right = 0\n        for i, (left, side) in enumerate(positions):\n            if left > max_right:\n                res[i] = side + (left - max_right)\n            else:\n                res[i] = min(res[i - 1], side + (left - max_right))\n            max_right = max(max_right, left + side)\n        return res"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * len(positions)\n        max_right = 0\n        for i, (left, side) in enumerate(positions):\n            if left > max_right:\n                res[i] = side + (left - max_right)\n            else:\n                res[i] = min(res[i - 1], side + (left - max_right))\n            max_right = max(max_right, left + side)\n        return res"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * len(positions)\n        max_right = 0\n        for i, (left, side) in enumerate(positions):\n            if left > max_right:\n                res[i] = side + (left - max_right)\n            else:\n                res[i] = min(res[i - 1], side + (left - max_right))\n            max_right = max(max_right, left + side)\n        return res"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return root.val\n        \n        return root.left.val if root.left and not root.left.left and not root.left.right else self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return root.val\n        \n        return root.left.val + self.sumOfLeftLeaves(root.right) if root.left else self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return root.val\n        \n        return root.left.val + self.sumOfLeftLeaves(root.right) if root.left else self.sumOfLeftLeaves(root.left)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return root.val\n        \n        return root.left.val + self.sumOfLeftLeaves(root.right) if root.left else self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return root.val\n        \n        return root.left.val + self.sumOfLeftLeaves(root.right) if root.left else self.sumOfLeftLeaves(root.left)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left = [0] * n\n        max_sum = float('-inf')\n        \n        for i in range(m):\n            curr_sum = left[0] + matrix[i][0]\n            for j in range(1, n):\n                curr_sum = max(curr_sum, left[j] + matrix[i][j])\n                if curr_sum > k:\n                    curr_sum = left[j]\n                else:\n                    max_sum = max(max_sum, curr_sum)\n                left[j] = curr_sum\n        \n        if max_sum <= k:\n            return max_sum\n        \n        left_max = float('-inf')\n        for i in range(m):\n            left_max = max(left_max, matrix[i][0])\n            if left_max > k:\n                left_max = matrix[i][0]\n            else:\n                max_sum = max(max_sum, left_max + left[i])\n        \n        return max_sum"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left = [0] * n\n        max_sum = float('-inf')\n        \n        for i in range(m):\n            curr_sum = left[0] + matrix[i][0]\n            for j in range(1, n):\n                curr_sum = max(curr_sum, left[j] + matrix[i][j])\n                if curr_sum > k:\n                    curr_sum = left[j]\n                else:\n                    max_sum = max(max_sum, curr_sum)\n                left[j] = curr_sum\n        \n        if max_sum <= k:\n            return max_sum\n        \n        left_max = float('-inf')\n        for i in range(m):\n            left_max = max(left_max, matrix[i][0])\n            if left_max > k:\n                left_max = matrix[i][0]\n            else:\n                max_sum = max(max_sum, left_max + left[i])\n        \n        return max_sum"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left = [0] * n\n        max_sum = float('-inf')\n        \n        for i in range(m):\n            curr_sum = left[0] + matrix[i][0]\n            for j in range(1, n):\n                curr_sum = max(curr_sum, left[j] + matrix[i][j])\n                if curr_sum > k:\n                    curr_sum = left[j]\n                else:\n                    max_sum = max(max_sum, curr_sum)\n                left[j] = curr_sum\n        \n        if max_sum <= k:\n            return max_sum\n        \n        left_max = float('-inf')\n        for i in range(m):\n            left_max = max(left_max, matrix[i][0])\n            if left_max > k:\n                left_max = matrix[i][0]\n            else:\n                max_sum = max(max_sum, left_max + left[i])\n        \n        return max_sum"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left = [0] * n\n        max_sum = float('-inf')\n        \n        for i in range(m):\n            curr_sum = left[0] + matrix[i][0]\n            for j in range(1, n):\n                curr_sum = max(curr_sum, left[j] + matrix[i][j])\n                if curr_sum > k:\n                    curr_sum = left[j]\n                else:\n                    max_sum = max(max_sum, curr_sum)\n                left[j] = curr_sum\n        \n        if max_sum <= k:\n            return max_sum\n        \n        left_max = float('-inf')\n        for i in range(m):\n            left_max = max(left_max, matrix[i][0])\n            if left_max > k:\n                left_max = matrix[i][0]\n            else:\n                max_sum = max(max_sum, left_max + left[i])\n        \n        return max_sum"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left = [0] * n\n        max_sum = float('-inf')\n        \n        for i in range(m):\n            curr_sum = left[0] + matrix[i][0]\n            for j in range(1, n):\n                curr_sum = max(curr_sum, left[j] + matrix[i][j])\n                if curr_sum > k:\n                    curr_sum = left[j]\n                else:\n                    max_sum = max(max_sum, curr_sum)\n                left[j] = curr_sum\n        \n        if max_sum <= k:\n            return max_sum\n        \n        left_max = float('-inf')\n        for i in range(m):\n            left_max = max(left_max, matrix[i][0])\n            if left_max > k:\n                left_max = matrix[i][0]\n            else:\n                max_sum = max(max_sum, left_max + left[i])\n        \n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        if dividend == 2**31 - 1 and divisor == -1:\n            return -2**31\n        \n        sign = 1 if (dividend > 0) ^ (divisor > 0) else -1\n        dividend, divisor = abs(dividend), abs(divisor)\n        result = 0\n        while dividend >= divisor:\n            temp = divisor\n            multiple = 1\n            while dividend >= temp << 1:\n                temp <<= 1\n                multiple <<= 1\n            result += multiple\n            dividend -= temp\n        result *= sign\n        if result > 2**31 - 1:\n            result = 2**31 - 1\n        return result"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        if dividend == 2**31 - 1 and divisor == -1:\n            return -2**31\n        \n        sign = 1 if (dividend > 0) ^ (divisor > 0) else -1\n        dividend, divisor = abs(dividend), abs(divisor)\n        result = 0\n        while dividend >= divisor:\n            temp = divisor\n            multiple = 1\n            while dividend >= (temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            result += multiple\n            dividend -= temp\n        result *= sign\n        if result > 2**31 - 1:\n            result = 2**31 - 1\n        return result"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            if dividend > 0:\n                return -dividend\n            else:\n                return -(-dividend)\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        if dividend > 0 and divisor > 0 or dividend < 0 and divisor < 0:\n            sign = 1\n        else:\n            sign = -1\n        dividend, divisor = abs(dividend), abs(divisor)\n        res = 0\n        while dividend >= divisor:\n            temp = divisor\n            times = 1\n            while dividend >= temp << 1:\n                temp <<= 1\n                times <<= 1\n            res += times\n            dividend -= temp\n        res *= sign\n        if res > 2**31 - 1:\n            res = 2**31 - 1\n        return res"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        \n        if dividend > 0 and divisor < 0 or dividend < 0 and divisor > 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        dividend, divisor = abs(dividend), abs(divisor)\n        \n        result = 0\n        while dividend >= divisor:\n            temp = divisor\n            multiple = 1\n            while dividend >= temp << 1:\n                temp <<= 1\n                multiple <<= 1\n            result += multiple\n            dividend -= temp\n        \n        result *= sign\n        \n        if result > 2**31 - 1:\n            result = 2**31 - 1\n        \n        return result"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if divisor == 1:\n            return dividend\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        if dividend == 2**31 - 1 and divisor == -1:\n            return -2**31\n        \n        sign = 1 if (dividend > 0) ^ (divisor > 0) else -1\n        dividend, divisor = abs(dividend), abs(divisor)\n        result = 0\n        while dividend >= divisor:\n            temp = divisor\n            multiple = 1\n            while dividend >= (temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            result += multiple\n            dividend -= temp\n        result *= sign\n        if result > 2**31 - 1:\n            result = 2**31 - 1\n        return result"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            if board[i][0] == 'O' and not visited[i][0]:\n                self.dfs(board, visited, i, 0)\n            if board[i][n - 1] == 'O' and not visited[i][n - 1]:\n                self.dfs(board, visited, i, n - 1)\n        \n        for j in range(1, n - 1):\n            if board[0][j] == 'O' and not visited[0][j]:\n                self.dfs(board, visited, 0, j)\n            if board[m - 1][j] == 'O' and not visited[m - 1][j]:\n                self.dfs(board, visited, m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and not visited[i][j]:\n                    board[i][j] = 'X'\n                elif board[i][j] == 'X':\n                    board[i][j] = 'O'\n        \n    def dfs(self, board, visited, i, j):\n        if visited[i][j]:\n            return\n        visited[i][j] = True\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < len(board) and 0 <= y < len(board[0]) and not visited[x][y]:\n                self.dfs(board, visited, x, y)"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            if board[i][0] == 'O' and not visited[i][0]:\n                self.dfs(board, visited, i, 0)\n            if board[i][n - 1] == 'O' and not visited[i][n - 1]:\n                self.dfs(board, visited, i, n - 1)\n        \n        for j in range(1, n - 1):\n            if board[0][j] == 'O' and not visited[0][j]:\n                self.dfs(board, visited, 0, j)\n            if board[m - 1][j] == 'O' and not visited[m - 1][j]:\n                self.dfs(board, visited, m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and not visited[i][j]:\n                    board[i][j] = 'X'\n                elif board[i][j] == 'X':\n                    board[i][j] = 'O'\n        \n    def dfs(self, board, visited, i, j):\n        if visited[i][j]:\n            return\n        visited[i][j] = True\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < len(board) and 0 <= y < len(board[0]) and not visited[x][y]:\n                self.dfs(board, visited, x, y)"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            if board[i][0] == 'O' and not visited[i][0]:\n                self.dfs(board, visited, i, 0)\n            if board[i][n - 1] == 'O' and not visited[i][n - 1]:\n                self.dfs(board, visited, i, n - 1)\n        \n        for i in range(n):\n            if board[0][i] == 'O' and not visited[0][i]:\n                self.dfs(board, visited, 0, i)\n            if board[m - 1][i] == 'O' and not visited[m - 1][i]:\n                self.dfs(board, visited, m - 1, i)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and not visited[i][j]:\n                    board[i][j] = 'X'\n                elif board[i][j] == 'X':\n                    board[i][j] = 'O'\n        \n\n    def dfs(self, board, visited, i, j):\n        if visited[i][j]:\n            return\n        visited[i][j] = True\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < len(board) and 0 <= y < len(board[0]) and not visited[x][y]:\n                self.dfs(board, visited, x, y)"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            if board[i][0] == 'O' and not visited[i][0]:\n                self.dfs(board, visited, i, 0)\n            if board[i][n - 1] == 'O' and not visited[i][n - 1]:\n                self.dfs(board, visited, i, n - 1)\n        \n        for j in range(1, n - 1):\n            if board[0][j] == 'O' and not visited[0][j]:\n                self.dfs(board, visited, 0, j)\n            if board[m - 1][j] == 'O' and not visited[m - 1][j]:\n                self.dfs(board, visited, m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and not visited[i][j]:\n                    board[i][j] = 'X'\n                elif board[i][j] == 'X':\n                    board[i][j] = 'O'\n        \n    def dfs(self, board, visited, i, j):\n        if visited[i][j]:\n            return\n        visited[i][j] = True\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < len(board) and 0 <= y < len(board[0]) and not visited[x][y]:\n                self.dfs(board, visited, x, y)"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            if board[i][0] == 'O' and not visited[i][0]:\n                self.dfs(board, visited, i, 0)\n            if board[i][-1] == 'O' and not visited[i][-1]:\n                self.dfs(board, visited, i, n - 1)\n        \n        for j in range(1, n - 1):\n            if board[0][j] == 'O' and not visited[0][j]:\n                self.dfs(board, visited, 0, j)\n            if board[-1][j] == 'O' and not visited[-1][j]:\n                self.dfs(board, visited, m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and not visited[i][j]:\n                    board[i][j] = 'X'\n                elif board[i][j] == 'X':\n                    board[i][j] = 'O'\n        \n\n    def dfs(self, board, visited, i, j):\n        if visited[i][j]:\n            return\n        visited[i][j] = True\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < len(board) and 0 <= y < len(board[0]) and not visited[x][y]:\n                self.dfs(board, visited, x, y)"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time and O(n) space\n        # nums = {num: i for i, num in enumerate(nums)}\n        # for i, num in enumerate(nums):\n        #     if nums[target - num] != num:\n        #         return [i, nums[target - num]]\n        \n        # O(n) time and O(1) space\n        nums_dict = {}\n        for i, num in enumerate(nums):\n            if num in nums_dict:\n                return [nums_dict[num], i]\n            nums_dict[target - num] = i\n```\n\n### 2. Two Sum - Hash Table\n\n```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        nums_dict = {}\n        for i, num in enumerate(nums):\n            if num in nums_dict:\n                return [nums_dict[num], i]\n            nums_dict[target - num] = i\n```\n\n### 3. Two Sum - Two Pointers\n\n```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] + nums[right] == target:\n                return [left, right]\n            elif nums[left] + nums[right] < target:\n                left += 1\n            else:\n                right -= 1\n```\n\n### 4. Two Sum - Two Pointers (Optimized)\n\n```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] + nums[right] == target:\n                return [left, right]\n            elif nums[left] + nums[right] < target:\n                left += 1\n            else:\n                right -= 1\n```\n\n### 5. Two Sum - Two Pointers (Optimized)\n\n```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] + nums[right] == target:\n                return [left, right]\n            elif nums[left] + nums[right] < target:\n                left += 1\n            else:\n                right -= 1\n```\n\n### 6. Two Sum - Two Pointers (Optimized)\n\n```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] + nums[right] == target:\n                return [left, right]\n            elif nums[left] + nums[right] < target:\n                left += 1\n            else:\n                right -= 1\n```\n\n### 7. Two Sum - Two Pointers (Optimized)\n\n```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] + nums["}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time and O(n) space\n        # nums = {num: i for i, num in enumerate(nums)}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in nums and nums[complement] != i:\n        #         return [i, nums[complement]]\n        \n        # O(n) time and O(1) space\n        nums_to_idx = {num: idx for idx, num in enumerate(nums)}\n        complement = target - nums[0]\n        if complement in nums_to_idx and nums_to_idx[complement] != 0:\n            return [0, nums_to_idx[complement]]\n        for idx, num in enumerate(nums[1:], 1):\n            complement = target - num\n            if complement in nums_to_idx and nums_to_idx[complement] != idx:\n                return [nums_to_idx[complement], idx]\n            nums_to_idx[num] = idx\n        \n        return []"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time | O(n) space\n        # # hashmap\n        # num_to_idx = {}\n        # for idx, num in enumerate(nums):\n        #     if target - num in num_to_idx:\n        #         return [num_to_idx[target - num], idx]\n        #     num_to_idx[num] = idx\n        \n        # O(n) time | O(1) space\n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # O(n) time | O(1) space\n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # O(n) time | O(1) space\n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # O(n) time | O(1) space\n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # O(n) time | O(1) space\n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # O(n) time | O(1) space\n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # O(n) time | O(1) space\n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # O(n) time | O(1) space\n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time and O(n) space\n        # nums_dict = {nums[i]: i for i in range(len(nums))}\n        # for i in range(len(nums)):\n        #     complement = target - nums[i]\n        #     if complement in nums_dict and nums_dict[complement] != i:\n        #         return [i, nums_dict[complement]]\n        # return []\n        \n        # O(n) time and O(1) space\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] + nums[right] == target:\n                return [left, right]\n            elif nums[left] + nums[right] < target:\n                left += 1\n            else:\n                right -= 1\n        return []"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time | O(n) space\n        # # hashmap\n        # num_to_idx = {}\n        # for idx, num in enumerate(nums):\n        #     if target - num in num_to_idx:\n        #         return [num_to_idx[target - num], idx]\n        #     num_to_idx[num] = idx\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # # two pointers\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] + nums[right] == target:\n        #         return [left, right]\n        #     elif nums[left] + nums[right] < target:\n        #         left += 1\n        #     else:\n        #         right -="}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(nums):\n            if len(nums) == 1:\n                return nums[0] == 24\n            if len(nums) == 2:\n                return abs(nums[0] - nums[1]) <= 1\n            return any(dfs([nums[i] - nums[j] for i in range(2)]) or dfs([nums[i], nums[j] / nums[k]]) or dfs([nums[i] * nums[j]]) for j in range(1, len(nums)) for k in range(j))\n        \n        return dfs(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(nums):\n            if len(nums) == 1:\n                return nums[0] == 24\n            if len(nums) == 2:\n                return abs(nums[0] - nums[1]) <= 1\n            if nums[0] == 24:\n                return True\n            if nums[1] == 24:\n                return dfs([nums[0], nums[2] - nums[0]])\n            if abs(nums[0] - nums[1]) <= 1:\n                return dfs([nums[0], nums[2] - nums[1]]) or dfs([nums[1], nums[2] - nums[0]])\n            return False\n        \n        return dfs(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(nums):\n            if len(nums) == 1:\n                return nums[0] == 24\n            if len(nums) == 2:\n                return abs(nums[0] - nums[1]) <= 1\n            return any(abs(nums[i] - 24) <= 1 and dfs(nums[:i] + nums[i+1:]) for i in range(len(nums) - 1))\n        \n        return dfs(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # DFS\n        # Time Limit Exceeded\n        # return self.dfs(cards, 0, 0, 0)\n        \n        # DFS + Memoization\n        # Time Limit Exceeded\n        # memo = {(0, 0, 0): 24}\n        # return self.dfs(cards, 0, 0, 0, memo)\n        \n        # DFS + Memoization + Trie\n        # Runtime: 20 ms, faster than 99.96% of Python online submissions for 24 Game.\n        # Memory Usage: 13.8 MB, less than 100.00% of Python online submissions for 24 Game.\n        if sum(cards) == 24:\n            return True\n        if sum(cards) > 24 or min(cards) > 24:\n            return False\n        if cards[0] == 24:\n            return True\n        trie = collections.defaultdict(int)\n        trie[0] = 1\n        for card in cards:\n            trie[card] += trie[card - 24]\n            if trie[24 - card] > 0:\n                return True\n        return False\n        \n        \n        # DFS + Memoization + Trie + Optimization\n        # Runtime: 16 ms, faster than 99.96% of Python online submissions for 24 Game.\n        # Memory Usage: 13.8 MB, less than 100.00% of Python online submissions for 24 Game.\n        if sum(cards) == 24:\n            return True\n        if sum(cards) > 24 or min(cards) > 24:\n            return False\n        if cards[0] == 24:\n            return True\n        trie = {0: 1}\n        for card in cards:\n            if card - 24 in trie:\n                trie[card + 24] += trie[card - 24]\n            else:\n                trie[card - 24] = trie.get(24 - card, 0)\n            if trie.get(24 - card, 0):\n                return True\n        return False\n        \n        \n        # DFS + Memoization + Trie + Optimization\n        # Runtime: 16 ms, faster than 99.96% of Python online submissions for 24 Game.\n        # Memory Usage: 13.8 MB, less than 100.00% of Python online submissions for 24 Game.\n        if sum(cards) == 24:\n            return True\n        if sum(cards) > 24 or min(cards) > 24:\n            return False\n        if cards[0] == 24:\n            return True\n        trie = {0: 1}\n        for card in cards:\n            trie[card + 24] += trie.get(card - 24, 0)\n            if trie.get(24 - card, 0):\n                return True\n        return False\n        \n        \n        # DFS + Memoization + Trie + Optimization\n        # Runtime: 16 ms, faster than 99.96% of Python online submissions for 24 Game.\n        # Memory Usage: 13.8 MB, less than 100.00% of Python online submissions for 24 Game.\n        if sum(cards) == 24:\n            return True\n        if sum(cards) > 24 or min(cards) > 24:\n            return False\n        if cards[0] == 24:\n            return True\n        trie = {0: 1}\n        for card in cards:\n            trie[card + 24] += trie.get(card - 24, 0)\n            trie[card - 24] = trie.get(24 - card, 0)\n            if trie[24 - card]:\n                return True\n        return False\n        \n        \n        # DFS + Memoization + Trie + Optimization\n        # Runtime: 16 ms, faster than 99.96%"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(nums):\n            if len(nums) == 1:\n                return nums[0] == 24\n            if len(nums) == 2:\n                return abs(nums[0] - nums[1]) <= 1\n            return any(abs(nums[i] - 24) <= 1 and dfs(nums[:i] + nums[i+1:]) for i in range(len(nums) - 1))\n        \n        return dfs(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # s = s + '#'\n        # p = p + '#'\n        # i = 0\n        # j = 0\n        # while i < len(s) and j < len(p):\n        #     if p[j] == '?' or p[j] == s[i]:\n        #         i += 1\n        #         j += 1\n        #     elif p[j] == '*':\n        #         j += 1\n        #         i = i - (p[j-1] != s[i])\n        #     else:\n        #         return False\n        # return j == len(p)\n        \n        i, j = 0, 0\n        while i < len(s) and j < len(p):\n            if p[j] == '?' or s[i] == p[j]:\n                i += 1\n                j += 1\n            elif p[j] == '*':\n                j += 1\n                i = i - (s[i] != p[j-1])\n            else:\n                return False\n        return j == len(p)"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # s = s + '#'\n        # p = p + '#'\n        # i = 0\n        # j = 0\n        # while i < len(s) and j < len(p):\n        #     if p[j] == '?' or p[j] == s[i]:\n        #         i += 1\n        #         j += 1\n        #     elif p[j] == '*':\n        #         j += 1\n        #         i = i - (p[j - 1] != s[i - 1])\n        #     else:\n        #         return False\n        # return j == len(p)\n        \n        i, j = 0, 0\n        while i < len(s) and j < len(p):\n            if p[j] == '?' or s[i] == p[j]:\n                i += 1\n                j += 1\n            elif p[j] == '*':\n                j += 1\n                i = i - (s[i - 1] != p[j - 1])\n            else:\n                return False\n        return j == len(p)"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u5982\u679cp\u4e2d\u6709*\uff0c\u5219\u628a*\u548c\u540e\u9762\u7684\u5b57\u7b26\u653e\u5230\u4e00\u8d77\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u65b0\u7684pattern\n        # 2. \u5982\u679cp\u4e2d\u6ca1\u6709*\uff0c\u5219\u76f4\u63a5\u6bd4\u8f83s\u548cp\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u76f8\u7b49\n        # 3. \u5982\u679cs\u548cp\u90fd\u6ca1\u6709\u5339\u914d\u5b8c\uff0c\u5219\u8fd4\u56deFalse\n        # 4. \u5982\u679cs\u548cp\u90fd\u5339\u914d\u5b8c\uff0c\u5219\u8fd4\u56deTrue\n        # 5. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fs\u4e2d\u8fd8\u6709\u5b57\u7b26\uff0c\u5219\u8fd4\u56deFalse\n        # 6. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deTrue\n        # 7. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deTrue\n        # 8. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 9. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 10. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deTrue\n        # 11. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 12. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 13. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 14. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deTrue\n        # 15. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 16. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 17. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 18. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deTrue\n        # 19. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 20. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 21. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 22. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 23. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 24. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 25. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 26. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 27. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 28. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 29. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 30. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709*\uff0c\u5219\u8fd4\u56deFalse\n        # 31. \u5982\u679cs\u548cp\u5339\u914d\u5b8c\uff0c\u4f46\u662fp\u4e2d\u8fd8\u6709?\uff0c\u5219\u8fd4\u56deFalse\n        # 32. \u5982\u679cs\u548cp\u5339\u914d\u5b8c"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # s = s + '#'\n        # p = p + '#'\n        # i = 0\n        # j = 0\n        # while i < len(s) and j < len(p):\n        #     if p[j] == '?' or p[j] == s[i]:\n        #         i += 1\n        #         j += 1\n        #     elif p[j] == '*':\n        #         j += 1\n        #         i = i - (p[j-1] != s[i])\n        #     else:\n        #         return False\n        # return j == len(p)\n        \n        i, j = 0, 0\n        while i < len(s) and j < len(p):\n            if p[j] == '?' or s[i] == p[j]:\n                i += 1\n                j += 1\n            elif p[j] == '*':\n                j += 1\n                i = i - (s[i] != p[j-1])\n            else:\n                return False\n        return j == len(p)"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u5982\u679cp\u4e2d\u6709*\uff0c\u5219\u628a*\u548c\u540e\u9762\u7684\u5b57\u7b26\u653e\u5230\u4e00\u8d77\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u65b0\u7684pattern\n        # 2. \u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 3. \u5982\u679cs\u548cpattern\u4e0d\u5339\u914d\uff0c\u5219\u5982\u679cpattern\u4e2d\u6709*\uff0c\u5219\u628a*\u548c\u540e\u9762\u7684\u5b57\u7b26\u653e\u5230\u4e00\u8d77\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u65b0\u7684pattern\uff0c\u5426\u5219\u8fd4\u56deFalse\n        # 4. \u5982\u679cpattern\u4e2d\u6709*\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 5. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\uff0c\u5426\u5219\u8fd4\u56deFalse\n        # 6. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 7. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 8. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 9. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 10. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 11. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 12. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 13. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 14. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 15. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 16. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 17. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 18. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 19. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 20. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 21. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 22. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 23. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 24. \u5982\u679cpattern\u4e2d\u6ca1\u6709*\uff0c\u5219\u5982\u679cs\u548cpattern\u5339\u914d\uff0c\u5219\u7ee7\u7eed\u5339\u914d\u4e0b\u4e00\u4e2a\u5b57\u7b26\n        # 25. \u5982"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore majority vote algorithm\n        # Time: O(N)\n        # Space: O(1)\n        majority, count = nums[0], 1\n        for num in nums[1:]:\n            if count == 0:\n                majority, count = num, 1\n            elif num == majority:\n                count += 1\n            else:\n                count -= 1\n        return majority"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore majority vote algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        majority, count = nums[0], 1\n        for i in nums[1:]:\n            if count == 0:\n                majority, count = i, 1\n            elif i == majority:\n                count += 1\n            else:\n                count -= 1\n        return majority"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore majority vote algorithm\n        # Time: O(N)\n        # Space: O(1)\n        majority, count = nums[0], 1\n        for num in nums[1:]:\n            if count == 0:\n                majority, count = num, 1\n            elif num == majority:\n                count += 1\n            else:\n                count -= 1\n        return majority"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore majority vote algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        majority, count = nums[0], 1\n        for i in nums[1:]:\n            if count == 0:\n                majority, count = i, 1\n            elif i == majority:\n                count += 1\n            else:\n                count -= 1\n        return majority"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore majority vote algorithm\n        # Time: O(N)\n        # Space: O(1)\n        majority, count = nums[0], 1\n        for i in range(1, len(nums)):\n            if nums[i] == majority:\n                count += 1\n            else:\n                count -= 1\n            if count == 0:\n                majority, count = nums[i], 1\n        return majority"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Mapping from destination to the list of origin airports\n        graph = collections.defaultdict(list)\n        \n        # Add all the origin airports to the graph\n        for origin, destination in tickets:\n            graph[destination].append(origin)\n        \n        # Use a stack to store the itinerary\n        itinerary = []\n        \n        # Start from the destination airport with the most direct flights\n        # and keep popping the origin airports until the stack is empty\n        destination = \"JFK\"\n        while graph[destination]:\n            origin = graph[destination].pop()\n            itinerary.append(origin)\n            destination = origin\n        \n        return itinerary[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Mapping from destination to a list of origin airports\n        graph = collections.defaultdict(list)\n        \n        # Add all the origin airports to the graph\n        for origin, destination in tickets:\n            graph[destination].append(origin)\n        \n        # Start from JFK and keep going until we can't go any further\n        route = [\"JFK\"]\n        while route[-1] != \"JFK\":\n            route.append(graph[route[-1]].pop(0))\n        \n        return route"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Mapping from destination to the list of origin airports\n        graph = collections.defaultdict(list)\n        \n        # Add all the origin airports to the graph\n        for origin, destination in tickets:\n            graph[destination].append(origin)\n        \n        # Start from JFK and keep going\n        route = [\"JFK\"]\n        while route[-1] != \"JFK\":\n            route.append(graph[route[-1]].pop(0))\n        \n        return route"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Mapping from destination to a list of origin airports\n        graph = collections.defaultdict(list)\n        for origin, destination in tickets:\n            graph[destination].append(origin)\n        \n        # Use a stack to store the itinerary\n        itinerary = []\n        while graph:\n            # Pick the first airport in the graph\n            origin = graph.pop()\n            # Add it to the itinerary\n            itinerary.append(origin)\n            # Remove the origin from the graph\n            # and add the destination to the graph\n            graph[origin[1:]].append(origin[:1])\n        \n        return itinerary[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Mapping from departure to arrivals\n        graph = collections.defaultdict(list)\n        for fromi, toi in tickets:\n            graph[fromi].append(toi)\n        \n        # BFS\n        queue = [\"JFK\"]\n        res = []\n        while queue:\n            fromi = queue.pop()\n            while graph[fromi]:\n                queue.append(graph[fromi].pop())\n            res.append(fromi)\n        \n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        if n < 4 or nums[0]*4 > target or nums[n-1]*4 < target:\n            return []\n        \n        res = []\n        i = 0\n        j = n-1\n        while i < j:\n            if nums[i] + nums[j] + nums[j+1] + nums[j-1] > target:\n                j -= 1\n            elif nums[i] + nums[j] + nums[j+1] + nums[j-1] < target:\n                i += 1\n            else:\n                if i+1 < j-1 and nums[i] == nums[i+1]:\n                    i += 1\n                elif nums[j] == nums[j-1]:\n                    j -= 1\n                else:\n                    res.append([nums[i], nums[i+1], nums[j], nums[j-1]])\n                    i += 1\n                    j -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        if n < 4 or nums[0] * 4 > target or nums[n - 1] * 4 < target:\n            return []\n        \n        if nums[0] * 4 == target:\n            if nums[1] * 3 == target:\n                return [[nums[0], nums[0], nums[0], nums[1]]] if nums[1] != nums[2] else []\n            low, high = 2, n - 3\n            while low < high:\n                four_sum = nums[low] + nums[high] + nums[low + 1] + nums[high - 1]\n                if four_sum == target:\n                    result = [[nums[low], nums[low + 1], nums[high], nums[high - 1]]]\n                    while low + 1 < high and nums[low] == nums[low + 1]:\n                        low += 1\n                    while low + 1 < high and nums[high] == nums[high - 1]:\n                        high -= 1\n                    low += 1\n                    high -= 1\n                    result += [[nums[low], nums[low + 1], nums[high], nums[high - 1]]]\n                elif four_sum < target:\n                    low += 1\n                else:\n                    high -= 1\n            return result\n        \n        left, right = 1, n - 1\n        while left < right:\n            four_sum = nums[left] + nums[right]\n            if four_sum == target:\n                result = [[nums[left - 1], nums[left], nums[right], nums[right + 1]]]\n                while left < right and nums[left] == nums[left - 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right + 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n                result += [[nums[left - 1], nums[left], nums[right], nums[right + 1]]]\n            elif four_sum < target:\n                left += 1\n            else:\n                right -= 1\n        return result"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        i = 0\n        while i < len(nums) - 3 and nums[i] <= target/4:\n            if i > 0 and nums[i] == nums[i-1]:\n                i += 1\n                continue\n            three_sum = target - nums[i]\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                if nums[j] + nums[k] == three_sum:\n                    res.append([nums[i], nums[j], nums[k], nums[k-1]])\n                    while j < k and nums[j] == nums[j+1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k-1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif nums[j] + nums[k] < three_sum:\n                    j += 1\n                else:\n                    k -= 1\n            i += 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        i = 0\n        while i < len(nums) - 3 and nums[i] <= target/4:\n            if i > 0 and nums[i] == nums[i-1]:\n                i += 1\n                continue\n            threeSum = target - nums[i]\n            j = i + 1\n            k = len(nums) - 1\n            while j < k:\n                if nums[j] + nums[k] == threeSum:\n                    res.append([nums[i], nums[j], nums[k], nums[k-1]])\n                    while j < k and nums[j] == nums[j+1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k-1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif nums[j] + nums[k] < threeSum:\n                    j += 1\n                else:\n                    k -= 1\n            i += 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        i = 0\n        while i < len(nums) - 3 and nums[i] <= target/4:\n            if i > 0 and nums[i] == nums[i-1]:\n                i += 1\n                continue\n            threeSum = target - nums[i]\n            j = i + 1\n            k = len(nums) - 1\n            while j < k:\n                if nums[j] + nums[k] == threeSum:\n                    res.append([nums[i], nums[j], nums[k], nums[k-1]])\n                    while j < k and nums[j] == nums[j+1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k-1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif nums[j] + nums[k] < threeSum:\n                    j += 1\n                else:\n                    k -= 1\n            i += 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time: O(nlogn)\n        # Space: O(n)\n        # Greedy\n        # Sort by left, then right\n        # If left is the same, then right - left\n        # If right is the same, then 0\n        # If left is different, then height\n        # If right is different, then -height\n        # Time complexity: O(nlogn)\n        # Space complexity: O(n)\n        if not buildings:\n            return []\n        \n        buildings.sort(key=lambda x: (x[0], -x[1]))\n        prev_left, prev_height = buildings[0][0], buildings[0][2]\n        res = [[prev_left, prev_height]]\n        for left, right, height in buildings[1:]:\n            if left > prev_left:\n                res.append([left, height])\n            else:\n                prev_height = max(prev_height, height)\n            if right > prev_left:\n                if prev_height != height:\n                    res.append([right, -prev_height])\n            else:\n                prev_height = -prev_height\n        return res"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time: O(nlogn)\n        # Space: O(n)\n        # Greedy\n        # Sort by left, then right\n        # If left is the same, sort by height\n        # If right is the same, height is 0\n        # If left is different, add to the result\n        # If right is different, remove from the result\n        # Runtime: 32 ms, faster than 99.59% of Python3 online submissions for The Skyline Problem.\n        # Memory Usage: 14.2 MB, less than 5.00% of Python3 online submissions for The Skyline Problem.\n        if not buildings:\n            return []\n        \n        buildings.sort(key=lambda x: (x[0], -x[2], x[1]))\n        result = [[buildings[0][0], buildings[0][2]]]\n        for left, right, height in buildings:\n            if result[-1][0] >= left:\n                result[-1][1] = max(result[-1][1], height)\n            else:\n                result.append([left, height])\n            if result[-1][1] < result[-2][1]:\n                result.append([right, 0])\n        return result[:-1]"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time: O(nlogn)\n        # Space: O(n)\n        # Greedy\n        # Sort by left, then right\n        # If left == right, then height\n        # If left < right, then height = max(left, height)\n        # If left > right, then height = 0\n        # Time complexity: O(nlogn)\n        # Space complexity: O(n)\n        if not buildings:\n            return []\n        \n        buildings.sort(key=lambda x: (x[0], -x[2], x[1]))\n        prev_left, prev_height = buildings[0][0], buildings[0][2]\n        res = [[prev_left, prev_height]]\n        for left, right, height in buildings[1:]:\n            if left > prev_left:\n                res.append([left, prev_height])\n            prev_height = max(prev_height, height)\n            if left < prev_left:\n                prev_height = res[-1][1]\n            if prev_height != res[-1][1]:\n                res.append([right, prev_height])\n            prev_left = right\n        return res"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time: O(nlogn)\n        # Space: O(n)\n        # Greedy\n        # Sort by left, then right\n        # If left == right, then height\n        # If left < right, then height = max(left, height)\n        # If left > right, then height = 0\n        # Time complexity: O(nlogn)\n        # Space complexity: O(n)\n        if not buildings:\n            return []\n        \n        buildings.sort(key=lambda x: (x[0], -x[2], x[1]))\n        prev_left, prev_height = buildings[0][0], buildings[0][2]\n        res = [[prev_left, prev_height]]\n        for left, right, height in buildings[1:]:\n            if left > prev_left:\n                res.append([left, prev_height])\n            prev_height = max(prev_height, height)\n            if left < prev_left:\n                prev_height = res[-1][1]\n            if prev_height != res[-1][1]:\n                res.append([right, prev_height])\n            prev_left = right\n        return res"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time: O(nlogn)\n        # Space: O(n)\n        # Greedy\n        # Sort by left, then right\n        # If left is the same, sort by height\n        # If right is the same, height is 0\n        # If left is different, add a new point\n        # If right is different, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point\n        # If right is different from previous, remove a point\n        # If left is the same as previous, update height\n        # If right is the same as previous, update height\n        # If left is different from previous, add a new point"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        while head:\n            next = head.next\n            head.next = prev\n            prev = head\n            head = next\n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        while head:\n            next_node = head.next\n            head.next = prev\n            prev = head\n            head = next_node\n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        while head:\n            next = head.next\n            head.next = prev\n            prev = head\n            head = next\n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        while head:\n            next_node = head.next\n            head.next = prev\n            prev = head\n            head = next_node\n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        while head:\n            next = head.next\n            head.next = prev\n            prev = head\n            head = next\n        return prev\n\n# Time: O(N)\n# Space: O(1)\n# Difficulty: easy\n# See also: https://leetcode.com/problems/reverse-linked-list/"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not triangle:\n            return 0\n        \n        n = len(triangle)\n        dp = triangle[0]\n        for i in range(1, n):\n            dp[i] += dp[i - 1]\n            dp[i] = min(dp[i], dp[i - 1])\n        \n        return dp[-1]"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not triangle:\n            return 0\n        \n        n = len(triangle)\n        dp = triangle[0]\n        for i in range(1, n):\n            dp[i] += dp[i - 1]\n            dp[i] = min(dp[i], dp[i - 1])\n        \n        return dp[-1]"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not triangle:\n            return 0\n        \n        n = len(triangle)\n        dp = triangle[n - 1]\n        for i in range(n - 2, -1, -1):\n            dp[i] = dp[i] + min(dp[i], dp[i + 1])\n        return dp[0]"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not triangle:\n            return 0\n        \n        n = len(triangle)\n        dp = triangle[n - 1]\n        for i in range(n - 2, -1, -1):\n            dp[i] = dp[i] + min(dp[i], dp[i + 1])\n        return dp[0]"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not triangle:\n            return 0\n        \n        n = len(triangle)\n        dp = triangle[0]\n        for i in range(1, n):\n            dp[i] += dp[i - 1]\n            dp[i] = min(dp[i], dp[i - 1])\n        \n        return dp[-1]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return 'Zero'\n        \n        res = []\n        units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n        tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n        \n        while num:\n            if num % 1000 == 0:\n                res.append(units[num // 1000])\n                res.append('Thousand')\n                num //= 1000\n            elif num % 100 == 0:\n                res.append(tens[num // 100])\n                res.append('Hundred')\n                num %= 100\n            elif num % 10 == 0:\n                res.append(tens[num // 10])\n                num %= 10\n            elif num % 100 < 20:\n                res.append(units[num % 100])\n                num %= 100\n            else:\n                res.append(units[num % 10])\n                res.append('"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return 'Zero'\n        \n        res = []\n        units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n        tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n        \n        while num:\n            if num % 1000 == 0:\n                res.append(units[num // 1000])\n                res.append('Thousand')\n                num %= 1000\n            elif num % 100 == 0:\n                res.append(tens[num // 100])\n                res.append('Hundred')\n                num %= 100\n            elif num % 10 == 0:\n                res.append(tens[num // 10])\n                num %= 10\n            elif num % 100 < 20:\n                res.append(units[num % 100])\n                num %= 100\n            else:\n                res.append(units[num % 10])\n                res.append('"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return 'Zero'\n        \n        res = []\n        units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n        tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n        \n        while num:\n            if num % 1000 == 0:\n                res.append(units[num // 1000])\n                res.append('Thousand')\n                num %= 1000\n            elif num % 100 == 0:\n                res.append(tens[num // 100])\n                res.append('Hundred')\n                num %= 100\n            elif num % 10 == 0:\n                res.append(tens[num // 10])\n                num %= 10\n            elif num % 100 < 20:\n                res.append(units[num % 100])\n                num %= 100\n            else:\n                res.append(units[num % 10])\n                res.append('"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return 'Zero'\n        \n        res = []\n        units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n        tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n        \n        while num:\n            if num % 1000 == 0:\n                res.append(units[num // 1000])\n                res.append('Thousand')\n                num %= 1000\n            elif num % 100 == 0:\n                res.append(tens[num // 100])\n                res.append('Hundred')\n                num %= 100\n            elif num % 10 == 0:\n                res.append(tens[num // 10])\n                num %= 10\n            elif num % 100 < 20:\n                res.append(units[num % 100])\n                num %= 100\n            else:\n                res.append(units[num % 10])\n                res.append('"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return 'Zero'\n        \n        res = []\n        units = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n        tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n        \n        while num:\n            if num % 1000 == 0:\n                res.append(units[num // 1000])\n                res.append('Thousand')\n                num %= 1000\n            elif num % 100 == 0:\n                res.append(tens[num // 100])\n                res.append('Hundred')\n                num %= 100\n            elif num % 10 == 0:\n                res.append(tens[num // 10])\n                num %= 10\n            elif num % 100 < 20:\n                res.append(units[num % 100])\n                num %= 100\n            else:\n                res.append(units[num % 10])\n                res.append('"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to choose i elements with k inverse pairs\n        # dp[i] = dp[i-1] * (k + i - 1) / i\n        # dp[i] = dp[i-1] * (k + i - 1) % i\n        dp = [1] * (n + 1)\n        k %= n\n        if k > 0:\n            dp[1] = k + 1\n            dp[2] = k * 2\n            for i in range(3, n + 1):\n                dp[i] = (dp[i - 1] * (k + i - 1) % i) % 1000000007\n        return dp[n]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # k = 0\n        if k == 0:\n            return 1\n        \n        # k = 1\n        if k == 1:\n            return n * (n - 1) // 2\n        \n        # k > 1\n        # nCk = n * (n - 1) * ... * (n - k + 1) / k!\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 / k! % 1000000007\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 * (k - 1) % 1000000007\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 * (k - 1) % 1000000007 * (k + 1) % 1000000007\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 * (k - 1) % 1000000007 * (k + 1) % 1000000007 * 2\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 * (k - 1) % 1000000007 * (k + 1) % 1000000007 * 2 % 1000000007\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 * (k - 1) % 1000000007 * (k + 1) % 1000000007 * 2 % 1000000007 * 2\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 * (k - 1) % 1000000007 * (k + 1) % 1000000007 * 2 % 1000000007 * 2 % 1000000007\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 * (k - 1) % 1000000007 * (k + 1) % 1000000007 * 2 % 1000000007 * 2 % 1000000007 * 2\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n - k + 1)) % 1000000007 * (k - 1) % 1000000007 * (k + 1) % 1000000007 * 2 % 1000000007 * 2 % 1000000007 * 2 % 1000000007\n        # nCk % 1000000007 = (n * (n - 1) * ... * (n"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8,"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # k = 0\n        if k == 0:\n            return 1\n        \n        # k = 1\n        if k == 1:\n            return n * (n - 1) // 2\n        \n        # k > 1\n        # (n - 1) * (n - 2) * ... * (n - k + 1)\n        # (n - k) * (n - k - 1) * ... * 2 * 1\n        return (n - k) * (n - k - 1) % (10 ** 9 + 7)"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\n        # n = 1, 2, 3, 4, 5, 6, 7, 8,"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next and prev.next.next:\n            first, second = prev.next, prev.next.next\n            prev.next, second.next, prev = second, first, first\n            prev = second\n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next and prev.next.next:\n            first, second = prev.next, prev.next.next\n            prev.next, second.next, prev = second, first, first\n            prev = second\n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next and prev.next.next:\n            first, second = prev.next, prev.next.next\n            prev.next, second.next, prev = second, first, first\n            prev = second\n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next and prev.next.next:\n            first, second = prev.next, prev.next.next\n            prev.next, second.next, prev = second, first, first\n            prev = second\n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next and prev.next.next:\n            first, second = prev.next, prev.next.next\n            prev.next, second.next, prev = second, first, first\n            prev = second\n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return targetSum == 0\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        dummy_smaller = ListNode(0)\n        dummy_larger = ListNode(0)\n        smaller = dummy_smaller\n        larger = dummy_larger\n        \n        # 2. Iterate through the list and put nodes into the correct bucket\n        while head:\n            if head.val < x:\n                smaller.next = head\n                smaller = smaller.next\n            else:\n                larger.next = head\n                larger = larger.next\n            head = head.next\n        \n        # 3. Connect the two buckets\n        larger.next = dummy_smaller.next\n        smaller.next = dummy_larger.next\n        \n        # 4. Return the head of the first bucket\n        return dummy_smaller.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        less = ListNode(0)\n        greater = less\n        curr = head\n        \n        while curr:\n            if curr.val < x:\n                less.next, less = curr, less.next\n            else:\n                greater.next, greater = curr, greater.next\n                curr.next = greater.next\n            curr = curr.next\n        \n        greater.next = less.next\n        return less.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        dummy_smaller = ListNode(0)\n        dummy_larger = ListNode(0)\n        smaller = dummy_smaller\n        larger = dummy_larger\n        \n        # 2. Move the nodes to the correct position\n        while head:\n            if head.val < x:\n                smaller.next = head\n                smaller = smaller.next\n            else:\n                larger.next = head\n                larger = larger.next\n            head = head.next\n        \n        # 3. Connect the two lists\n        larger.next = dummy_smaller.next\n        smaller.next = dummy_larger.next\n        \n        # 4. Return the head of the first list\n        return dummy_smaller.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. \u627e\u5230\u5c0f\u4e8ex\u7684\u8282\u70b9\n        # 2. \u627e\u5230\u5927\u4e8e\u7b49\u4e8ex\u7684\u8282\u70b9\n        # 3. \u5c06\u5c0f\u4e8ex\u7684\u8282\u70b9\u8fde\u63a5\u5230\u5927\u4e8e\u7b49\u4e8ex\u7684\u8282\u70b9\u540e\u9762\n        # 4. \u8fd4\u56de\u5c0f\u4e8ex\u7684\u8282\u70b9\n        if not head:\n            return None\n        \n        small = small_head = ListNode(0)\n        big = big_head = ListNode(0)\n        \n        while head:\n            if head.val < x:\n                small.next = head\n                small = small.next\n            else:\n                big.next = head\n                big = big.next\n            head = head.next\n        \n        small.next = big_head.next\n        big.next = None\n        return small_head.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        dummy_smaller = ListNode(0)\n        dummy_bigger = ListNode(0)\n        smaller = dummy_smaller\n        bigger = dummy_bigger\n        \n        # 2. Iterate through the list and put the nodes in the correct place\n        while head:\n            if head.val < x:\n                smaller.next = head\n                smaller = smaller.next\n            else:\n                bigger.next = head\n                bigger = bigger.next\n            head = head.next\n        \n        # 3. Connect the two lists\n        smaller.next = dummy_bigger.next\n        bigger.next = None\n        \n        # 4. Return the head of the smaller list\n        return dummy_smaller.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Create a dictionary to store the parent of each node.\n        # If a node has a parent, then the parent is stored in the dictionary.\n        # If a node does not have a parent, then the parent is stored as -1.\n        # If a node is the parent of another node, then the parent is stored as -node.\n        # This way, we can check if a node is a parent of another node by checking if the parent is -node.\n        parent = {node: -1 for node in range(1, len(edges) + 1)}\n        \n        # Iterate through the edges and update the parent dictionary.\n        for u, v in edges:\n            if parent[v] == -1:\n                parent[u] = v\n            elif parent[u] == -parent[v]:\n                return [u, v]\n            else:\n                parent[v] = parent[u]\n        \n        # If we reach here, then the graph is not a tree.\n        # The last edge that was added forms a cycle.\n        # Return the last edge that was added.\n        return [node for node in parent if parent[node] == -node][0]"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Create a dictionary to store the parent of each node.\n        # If a node is already in the dictionary, then it is a cycle.\n        # If a node is not in the dictionary, then add it to the dictionary.\n        # If a node is already in the dictionary, then return the node.\n        parent = {i: i for i in range(1, len(edges) + 1)}\n        for u, v in edges:\n            if v in parent:\n                parent[u] = parent[v]\n            else:\n                parent[v] = u\n            if u == parent[u]:\n                return u, v\n        return parent[u]"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u54c8\u5e0c\u8868\u5b58\u50a8\u8282\u70b9\u7684\u7236\u8282\u70b9, \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8fd4\u56de\u8be5\u8282\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u7684\u8d77\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u5c06\u5f53\u524d\u8282\u70b9"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u54c8\u5e0c\u8868\u5b58\u50a8\u8282\u70b9\u7684\u7236\u8282\u70b9, \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8fd4\u56de\u8be5\u8282\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728, \u5219\u5c06\u8be5\u8282\u70b9\u4f5c\u4e3a\u7236\u8282\u70b9\u5b58\u50a8\u5230\u54c8\u5e0c\u8868\u4e2d\n        # \u5982\u679c\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u4e2d\u7684\u8282\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8fd4\u56de\u8be5\u8282\u70b9\n        parent = {0: -1}\n        for u, v in edges:\n            if v in parent:\n                return u, v\n            parent[v], v = u, parent[u]\n        return parent[0]\n        \n        # M2. \u5e76\u67e5\u96c6\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u4f7f\u7528\u5e76\u67e5\u96c6, \u5c06\u6240\u6709\u8282\u70b9\u90fd\u52a0\u5165\u5e76\u67e5\u96c6, \u5982\u679c\u5df2\u7ecf\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u4e2d\u7684\u8282\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u7236\u8282\u70b9, \u5219\u8fd4\u56de\u8be5\u8282\u70b9\n        parent = {i: i for i in range(len(edges) + 1)}\n        for u, v in edges:\n            if parent[u] == parent[v]:\n                return u, v\n            parent[v] = parent[u]\n        return parent[edges[0][0]]\n        \n        # M3. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(1)\n        # \u4f7f\u7528\u53cc\u6307\u9488, \u5982\u679c\u5b58\u5728\u73af, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u4e2d\u7684\u8282\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u73af, \u5219\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u8282\u70b9\n        slow, fast = 0, 0\n        for i in range(len(edges)):\n            slow, fast = edges[slow][1], edges[fast][1]\n            if slow == fast:\n                slow = edges[slow][0]\n            else:\n                fast = edges[fast][1]\n        return slow\n        \n        # M4. \u54c8\u5e0c\u8868 + \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u8282\u70b9, \u5982\u679c\u5b58\u5728\u73af, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u4e2d\u7684\u8282\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u73af, \u5219\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u8282\u70b9\n        seen = {}\n        for i in range(len(edges)):\n            if edges[i][0] in seen:\n                return edges[i][0], seen[edges[i][0]]\n            seen[edges[i][1]] = edges[i][0]\n        return edges[-1][0], edges[-1][1]\n        \n        # M5. \u54c8\u5e0c\u8868 + \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6: O(n)\n        # \u4f7f\u7528\u54c8\u5e0c\u8868\u5b58\u50a8\u8282\u70b9, \u5982\u679c\u5b58\u5728\u73af, \u5219\u8bf4\u660e\u5b58\u5728\u73af, \u8fd4\u56de\u73af\u4e2d\u7684\u8282\u70b9\n        # \u5982\u679c\u4e0d\u5b58\u5728\u73af, \u5219\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u8282\u70b9\n        seen = {}\n        for i in range(len(edges)):\n            if edges[i][1] in seen:\n                return edges[i][0], edges[i][1]\n            seen[edges[i][0]] = edges[i][1]\n        return edges[-1][0], edges[-1][1]\n        \n        # M6. \u54c8\u5e0c\u8868 +"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Create a dictionary to store the parent of each node\n        parent = {i: i for i in range(1, len(edges) + 1)}\n        \n        # Iterate through the edges and update the parent of each node\n        for edge in edges:\n            # If the parent of the child is not the parent of the parent,\n            # then we have found the cycle\n            if edge[1] != parent[edge[0]]:\n                parent[edge[1]] = parent[edge[0]]\n            else:\n                # If the parent of the child is the parent of the parent,\n                # then we have found the redundant edge\n                return edge\n        \n        # If we reach here, then there is no cycle in the graph\n        # So, the last edge in the edges array is the redundant edge\n        return edges[-1]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # use a set to store the unique permutations\n        res = []\n        self.dfs(nums, [], res)\n        return res\n        \n    def dfs(self, nums, path, res):\n        if not nums:\n            res.append(path[:])\n            return\n        \n        # if the last element is the same as the previous one, skip it\n        if nums[-1] == path[-1]:\n            return\n        \n        # add the last element to the path\n        path.append(nums[-1])\n        \n        # dfs the rest of the array\n        self.dfs(nums[:-1], path, res)\n        \n        # backtrack\n        path.pop()\n        self.dfs(nums, path, res)\n```\n\n### 2. Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n**Example:**\n\n```\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n**Solution:**\n\n```python\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        if not nums:\n            return []\n        \n        nums.sort()\n        res = [nums]\n        last = nums[-1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] == last:\n            i -= 1\n        if i >= 0:\n            res = [nums[:i + 1]]\n            last = nums[i]\n        else:\n            return res\n        \n        for i in range(i, len(nums) - 1):\n            if nums[i] > last:\n                res.append(res[-1][:i] + [nums[i]] + res[-1][i:])\n                last = nums[i]\n        return res\n```\n\n### 3. Permutation Sequence\n\nThe set `[1,2,3,...,n]` has a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n\n1. `[1,2,3]`\n2. `[1,3,2]`\n3. `[2,1,3]`\n4. `[2,3,1]`\n5. `[3,1,2]`\n6. `[3,2,1]`\n\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n**Note:**\n\nGiven `n` will be between 1 and 9 inclusive.\n\n**Example 1:**\n\n```\nInput: n = 3, k = 3\nOutput: \"312\"\n```\n\n**Example 2:**\n\n```\nInput: n = 4, k = 9\nOutput: \"2314\"\n```\n\n**Solution:**\n\n```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        res = []\n        k -= 1\n        for i in range(2, n + 1):\n            k, r = divmod(k, i)\n            res.append(str(r + 1))\n        return ''.join(res)\n```\n\n### 4. Next Permutation\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be **in-place** and use only constant extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n\n```\n1,2,3 \u2192 1,3,2\n3,2,1 \u2192 1,2,3\n1,1,5 \u2192 1,5,1\n```\n\n**Solution:**\n\n```python\nclass Solution:\n    def nextPermutation(self, nums:"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # use a set to store the unique permutations\n        res = []\n        # use a set to store the visited numbers\n        visited = set()\n        \n        # start from the first number\n        self.backtrack(nums, visited, res, [])\n        \n        return res\n    \n    def backtrack(self, nums, visited, res, path):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        \n        # if the number is already visited, skip it\n        if nums[path[-1]] in visited:\n            return\n        \n        # add the number to the path and the visited set\n        visited.add(nums[path[-1]])\n        path.append(nums[path[-1]])\n        \n        # backtrack\n        self.backtrack(nums, visited, res, path)\n        \n        # remove the number from the path and the visited set\n        path.pop()\n        visited.remove(nums[path[-1]])\n```\n\n### 2. Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n**Example:**\n\n```\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n**Solution:**\n\n```python\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        if not nums:\n            return []\n        \n        nums.sort()\n        res = [nums]\n        last = nums[-1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] == last:\n            i -= 1\n        \n        if i >= 0:\n            res = [nums[:i + 1]]\n            last = nums[i]\n        \n        for i in range(i, len(nums) - 1):\n            if nums[i] > last:\n                res.append(res[-1][:i] + [nums[i]] + res[-1][i:])\n                last = nums[i]\n        \n        return res\n```\n\n### 3. Permutation Sequence\n\nThe set `[1,2,3,...,n]` has a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n\n1. `[1,2,3]`\n2. `[1,3,2]`\n3. `[2,1,3]`\n4. `[2,3,1]`\n5. `[3,1,2]`\n6. `[3,2,1]`\n\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n**Note:**\n\nGiven `n` will be between 1 and 9 inclusive.\n\n**Example 1:**\n\n```\nInput: n = 3, k = 3\nOutput: \"312\"\n```\n\n**Example 2:**\n\n```\nInput: n = 4, k = 9\nOutput: \"2314\"\n```\n\n**Solution:**\n\n```python\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        if n == 1:\n            return '1'\n        \n        res = []\n        k -= 1\n        for i in range(2, n + 1):\n            k, r = divmod(k, i)\n            res.append(str(r + 1))\n        \n        return ''.join(res)\n```\n\n### 4. Next Permutation\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be **in-place** and use only constant extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column."}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.backtrack(nums, [], res)\n        return res\n        \n    def backtrack(self, nums, path, res):\n        if not nums:\n            res.append(path[:])\n            return\n        \n        last = path[-1] if path else float('-inf')\n        for i in range(len(nums)):\n            if nums[i] > last:\n                path.append(nums[i])\n                self.backtrack(nums[:i] + nums[i+1:], path, res)\n                path.pop()"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.backtrack(nums, [], res)\n        return res\n        \n    def backtrack(self, nums, path, res):\n        if not nums:\n            res.append(path[:])\n            return\n        \n        last = path[-1] if path else float('-inf')\n        for i in range(len(nums)):\n            if nums[i] > last:\n                path.append(nums[i])\n                self.backtrack(nums[:i] + nums[i+1:], path, res)\n                path.pop()"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # use a set to store the unique permutations\n        res = []\n        # use a set to store the visited numbers\n        visited = set()\n        \n        # start from the first number\n        self.backtrack(nums, visited, res, [])\n        \n        return res\n    \n    def backtrack(self, nums, visited, res, path):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        \n        # if the number is already visited, skip it\n        if nums[path[-1]] in visited:\n            return\n        \n        # add the number to the path and visited set\n        visited.add(nums[path[-1]])\n        path.append(nums[path[-1]])\n        \n        # backtrack\n        self.backtrack(nums, visited, res, path)\n        \n        # remove the number from the path and visited set\n        path.pop()\n        visited.remove(nums[path[-1]])\n```\n\n### 2. Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n**Example:**\n\n```\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n**Solution:**\n\n```python\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        if not nums:\n            return []\n        \n        nums.sort()\n        res = [nums]\n        last = nums[-1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] == last:\n            i -= 1\n        if i >= 0:\n            res = [nums[:i + 1]]\n            last = nums[i]\n        for i in range(i, len(nums) - 1):\n            if nums[i] > last:\n                res.append(res[-1][:i] + [nums[i]] + res[-1][i:])\n                last = nums[i]\n        return res\n```\n\n### 3. Next Permutation\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place and use only constant extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n\n```\n1,2,3 \u2192 1,3,2\n3,2,1 \u2192 1,2,3\n1,1,5 \u2192 1,5,1\n```\n\n**Solution:**\n\n```python\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[i] >= nums[j]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = nums[i + 1:][::-1]\n```\n\n### 4. Permutation Sequence\n\nThe set `[1,2,3,...,n]` has a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n\n```\n\"123\"\n\"132\"\n\"213\"\n\"231\"\n\"312\"\n\"321\"\n```\n\nGiven `n` and `k`, return the `kth` permutation sequence.\n\n**Note:**\n\nG"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        return num % 9 or 9"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        return num % 9 or 9"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        return num % 9 or 9"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        return num % 9 or 9"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        return num % 9 or 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements in the array\n        # If the result is 0, then all the elements are same\n        # If the result is non-zero, then the result is the single number\n        return reduce(lambda x, y: x ^ y, nums, 0)"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements\n        # If the result is 0, then all the elements are the same\n        # If the result is non-zero, then the result is the single number\n        return reduce(lambda x, y: x ^ y, nums, 0)"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements\n        # If there is only one element that appears once, then the XOR of all the elements will be 0.\n        # If there are two elements that appear once, then the XOR of all the elements will be 0.\n        # If there are more than two elements that appear once, then the XOR of all the elements will be non-zero.\n        # Therefore, the XOR of all the elements will be the single number.\n        result = 0\n        for num in nums:\n            result ^= num\n        return result"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements in the array\n        # If the result is 0, then all the elements are same\n        # If the result is non-zero, then the result is the single number\n        return reduce(lambda x, y: x ^ y, nums, 0)"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements\n        result = 0\n        for num in nums:\n            result ^= num\n        \n        # The single number will be on the rightmost bit\n        # if there is only one bit set, then the result will be itself\n        # otherwise, the rightmost bit will be 0\n        return result & ~(result - 1)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the last space\n        # 2. find the last word\n        # 3. return the length of the last word\n        # 4. if no space, return the length of the string\n        \n        # 1. find the last space\n        i = len(s) - 1\n        while i >= 0 and s[i] != ' ':\n            i -= 1\n        \n        # 2. find the last word\n        j = i\n        while j >= 0 and s[j] == ' ':\n            j -= 1\n        \n        # 3. return the length of the last word\n        return len(s) - 1 - j if j >= 0 else 0"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the last space\n        # 2. find the last word\n        # 3. return the length of the last word\n        # 4. if there is no space, return the length of the whole string\n        \n        # 1. find the last space\n        i = len(s) - 1\n        while i >= 0 and s[i] != ' ':\n            i -= 1\n        \n        # 2. find the last word\n        j = i\n        while j >= 0 and s[j] == ' ':\n            j -= 1\n        \n        # 3. return the length of the last word\n        return len(s) - 1 - j if j >= 0 else 0"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the last space\n        # 2. find the last word\n        # 3. return the length of the last word\n        if not s:\n            return 0\n        \n        last_space = s.rfind(' ')\n        if last_space == -1:\n            return len(s)\n        \n        return len(s) - last_space - 1"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the last space\n        # 2. find the last word\n        # 3. return the length of the last word\n        if not s:\n            return 0\n        \n        last_space = s.rfind(' ')\n        if last_space == -1:\n            return len(s)\n        \n        return len(s) - last_space - 1"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the last space\n        # 2. find the last word\n        # 3. return the length of the last word\n        # 4. if there is no space, return the length of the whole string\n        \n        # 1. find the last space\n        i = len(s) - 1\n        while i >= 0 and s[i] != ' ':\n            i -= 1\n        \n        # 2. find the last word\n        j = i\n        while j >= 0 and s[j] == ' ':\n            j -= 1\n        \n        # 3. return the length of the last word\n        return len(s) - 1 - j if j >= 0 else 0"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = max cherries collected from (i, j) to (m, n)\n        m, n = len(grid[0]), len(grid)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != -1:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + grid[i][j])\n                    if i > 0 and j > 0 and grid[i - 1][j] != -1:\n                        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j - 1] + grid[i - 1][j])\n        \n        return dp[m][n]"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = max cherries collected from (i, j) to (m, n)\n        m, n = len(grid[0]), len(grid)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != -1:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + grid[i][j])\n                    if i > 0 and j > 0 and grid[i - 1][j] != -1:\n                        dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i - 1][j] + grid[i][j])\n        \n        return dp[m][n]"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = max cherries collected from (i, j) to (m, n)\n        m, n = len(grid[0]), len(grid)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != -1:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + grid[i][j])\n                    if i > 0 and j > 0 and grid[i - 1][j] != -1:\n                        dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i - 1][j] + grid[i][j])\n        \n        return dp[m][n]"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = max cherries collected from (i, j) to (m, n)\n        m, n = len(grid[0]), len(grid)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != -1:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + grid[i][j])\n                    if i > 0 and j > 0 and grid[i - 1][j] != -1:\n                        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j - 1] + grid[i - 1][j])\n        \n        return dp[m][n]"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = max cherries collected from (i, j) to (m, n)\n        m, n = len(grid[0]), len(grid)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != -1:\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + grid[i][j])\n                    if i > 0 and j > 0 and grid[i - 1][j] != -1:\n                        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j - 1] + grid[i - 1][j])\n        \n        return dp[m][n]"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # ...\n        # 1 A\n        # 0 L"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0 A\n        # 2 consecutive Ls\n        # 1 A\n        # 0 L\n        # 0 A\n        # 1 L\n        # 0"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        slow, fast = n, n\n        \n        while fast != 1:\n            slow = (slow * 10) % 10 + (fast % 10) ** 2\n            fast = (fast * 10) % 10\n            \n            if slow == fast:\n                return False\n        \n        return True"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        slow, fast = n, n\n        \n        while fast != 1:\n            slow = (slow * 10) % 10 + (fast % 10) ** 2\n            fast = (fast * 10) % 10\n            \n            if slow == fast:\n                return False\n        \n        return True"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        slow, fast = n, n\n        \n        while fast != 1 and fast != 4:\n            slow = (slow * 10) % 10 + (fast % 10) ** 2\n            fast = (fast * 10) % 10 + (fast // 10) ** 2\n            \n            if slow == fast:\n                return False\n        \n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        slow, fast = n, n\n        \n        while fast != 1:\n            slow = (slow * 10) % 10 + (fast % 10) ** 2\n            fast = (fast * 10) % 10\n            \n            if slow == fast:\n                return False\n        \n        return True"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        slow, fast = n, n\n        \n        while fast != 1 and fast != 4:\n            slow = (slow * 10) % 10 + (fast % 10) ** 2\n            fast = (fast * 10) % 10 + (fast // 10) ** 2\n            \n            if slow == fast:\n                return False\n        \n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4ece\u540e\u5f80\u524d\u904d\u5386\uff0c\u5982\u679c\u80fd\u5230\u8fbe\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 2. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 3. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 4. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 5. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 6. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 7. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 8. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 9. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 10. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 11. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 12. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 13. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 14. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 15. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 16. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 17. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 18. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 19. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 20. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 21. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 22. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 23. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 24. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u6570\u7ec4\u957f\u5ea6\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 25. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 26"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4ece\u540e\u5f80\u524d\u904d\u5386\uff0c\u5982\u679c\u80fd\u5230\u8fbe\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 2. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u65e0\u6cd5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 3. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 4. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 5. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u65e0\u6cd5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 6. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 7. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 8. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u65e0\u6cd5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 9. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 10. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 11. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u65e0\u6cd5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 12. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 13. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 14. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u65e0\u6cd5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 15. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 16. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 17. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u65e0\u6cd5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 18. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 19. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 20. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u65e0\u6cd5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 21. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 22. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 23. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u65e0\u6cd5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 24. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 25. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 26. \u5982\u679c\u6700\u8fdc"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4ece\u540e\u5f80\u524d\u904d\u5386\uff0c\u5982\u679c\u80fd\u5230\u8fbe\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 2. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 3. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 4. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u5f53\u524d\u4f4d\u7f6e\n        # 5. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 6. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 7. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u5f53\u524d\u4f4d\u7f6e\n        # 8. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 9. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 10. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u5f53\u524d\u4f4d\u7f6e\n        # 11. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 12. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 13. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u5f53\u524d\u4f4d\u7f6e\n        # 14. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 15. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 16. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u5f53\u524d\u4f4d\u7f6e\n        # 17. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 18. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 19. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u5f53\u524d\u4f4d\u7f6e\n        # 20. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 21. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 22. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u5f53\u524d\u4f4d\u7f6e\n        # 23. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e0\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 24. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u53ef\u4ee5\u5230\u8fbe\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\n        # 25. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u7b49\u4e8e0\uff0c\u5219\u8bf4\u660e\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u662f\u5f53\u524d\u4f4d\u7f6e\n        # 26. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u80fd\u5230\u8fbe"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4ece\u540e\u5f80\u524d\u904d\u5386\uff0c\u5982\u679c\u80fd\u5230\u8fbe\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\n        # 2. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 3. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 4. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 5. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 6. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 7. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 8. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 9. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 10. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 11. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 12. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 13. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 14. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 15. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 16. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 17. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 18. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 19. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 20. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 21. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 22. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 23. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 24. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 25. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 26. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 27. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 28. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 29. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 30. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 31. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef\u8fbe\n        # 32. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u4e0d\u53ef\u8fbe\n        # 33. \u5982\u679c\u6700\u8fdc\u53ef\u8fbe\u4f4d\u7f6e\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8bf4\u660e\u53ef"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4ece\u540e\u5f80\u524d\u904d\u5386\uff0c\u5982\u679c\u80fd\u5230\u8fbe\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 2. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8fd4\u56de False\n        # 3. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u4f4d\u7f6e\uff0c\u5219\u8fd4\u56de True\n        # 4. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e 0\uff0c\u5219\u8fd4\u56de False\n        # 5. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums.length - 1\uff0c\u5219\u8fd4\u56de True\n        # 6. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u8fd4\u56de False\n        # 7. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 8. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums.length - 1\uff0c\u5219\u8fd4\u56de True\n        # 9. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e 0\uff0c\u5219\u8fd4\u56de False\n        # 10. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 11. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums.length - 1\uff0c\u5219\u8fd4\u56de True\n        # 12. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e 0\uff0c\u5219\u8fd4\u56de False\n        # 13. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 14. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums.length - 1\uff0c\u5219\u8fd4\u56de True\n        # 15. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e 0\uff0c\u5219\u8fd4\u56de False\n        # 16. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 17. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums.length - 1\uff0c\u5219\u8fd4\u56de True\n        # 18. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e 0\uff0c\u5219\u8fd4\u56de False\n        # 19. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 20. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums.length - 1\uff0c\u5219\u8fd4\u56de True\n        # 21. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e 0\uff0c\u5219\u8fd4\u56de False\n        # 22. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 23. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums.length - 1\uff0c\u5219\u8fd4\u56de True\n        # 24. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e 0\uff0c\u5219\u8fd4\u56de False\n        # 25. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 26. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums.length - 1\uff0c\u5219\u8fd4\u56de True\n        # 27. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8e 0\uff0c\u5219\u8fd4\u56de False\n        # 28. \u5982\u679c\u6700\u8fdc\u8ddd\u79bb\u5927\u4e8e\u7b49\u4e8e nums[i]\uff0c\u5219\u66f4\u65b0\u6700\u8fdc\u8ddd\u79bb\n        # 29. \u5982\u679c\u6700\ufffd"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(grid), len(grid[0])\n        for i in range(1, n):\n            grid[0][i] += grid[0][i-1]\n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        return grid[-1][-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(grid), len(grid[0])\n        for i in range(1, n):\n            grid[0][i] += grid[0][i - 1]\n        for i in range(1, m):\n            grid[i][0] += grid[i - 1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        return grid[-1][-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(grid), len(grid[0])\n        for i in range(1, n):\n            grid[0][i] += grid[0][i-1]\n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        return grid[-1][-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(grid), len(grid[0])\n        for i in range(1, n):\n            grid[0][i] += grid[0][i-1]\n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        return grid[-1][-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(grid), len(grid[0])\n        for i in range(1, n):\n            grid[0][i] += grid[0][i - 1]\n        for i in range(1, m):\n            grid[i][0] += grid[i - 1][0]\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        res = '1'\n        for i in range(2, n):\n            res = self.countAndSay(res)\n        return res\n        \n    def countAndSay(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        res = ''\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                res += str(count) + s[i - 1]\n                count = 1\n        res += str(count) + s[-1]\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        res = '1'\n        for i in range(2, n):\n            res = self.countAndSay(res)\n        return res\n        \n    def countAndSay(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        res = ''\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                res += str(count) + s[i - 1]\n                count = 1\n        res += str(count) + s[-1]\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        res = '1'\n        for i in range(2, n):\n            res = self.countAndSay(res)\n        return res\n        \n    def countAndSay(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        res = ''\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                res += str(count) + s[i - 1]\n                count = 1\n        res += str(count) + s[-1]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = self.countAndSay(res)\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res, count = '1', 1\n        for i in range(1, n):\n            res, count = str(count) + res[count], res[0]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res[0]\n            res = res[1:]\n        return res\n        \n    def countAndSay(self, n):\n        if n == 1:\n            return '1'\n        res = '1'\n        for i in range(1, n):\n            res = str(len(res)) + res["}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        res = '1'\n        for i in range(2, n):\n            res = self.countAndSay(res)\n        return res\n        \n    def countAndSay(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        res = ''\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n            else:\n                res += str(count) + s[i-1]\n                count = 1\n        res += str(count) + s[-1]\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        res = '1'\n        for i in range(2, n):\n            res = self.countAndSay(res)\n        return res\n        \n    def countAndSay(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        res = ''\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                res += str(count) + s[i - 1]\n                count = 1\n        res += str(count) + s[-1]\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # k <= min(50, len(nums))\n        # k = 1, return max(nums)\n        # k = 2, return max(nums) // 2\n        # k = 3, return max(nums) // 3\n        # k = 4, return max(nums) // 4\n        # k = 5, return max(nums) // 5\n        # k = 6, return max(nums) // 6\n        # k = 7, return max(nums) // 7\n        # k = 8, return max(nums) // 8\n        # k = 9, return max(nums) // 9\n        # k = 10, return max(nums) // 10\n        # k = 11, return max(nums) // 11\n        # k = 12, return max(nums) // 12\n        # k = 13, return max(nums) // 13\n        # k = 14, return max(nums) // 14\n        # k = 15, return max(nums) // 15\n        # k = 16, return max(nums) // 16\n        # k = 17, return max(nums) // 17\n        # k = 18, return max(nums) // 18\n        # k = 19, return max(nums) // 19\n        # k = 20, return max(nums) // 20\n        # k = 21, return max(nums) // 21\n        # k = 22, return max(nums) // 22\n        # k = 23, return max(nums) // 23\n        # k = 24, return max(nums) // 24\n        # k = 25, return max(nums) // 25\n        # k = 26, return max(nums) // 26\n        # k = 27, return max(nums) // 27\n        # k = 28, return max(nums) // 28\n        # k = 29, return max(nums) // 29\n        # k = 30, return max(nums) // 30\n        # k = 31, return max(nums) // 31\n        # k = 32, return max(nums) // 32\n        # k = 33, return max(nums) // 33\n        # k = 34, return max(nums) // 34\n        # k = 35, return max(nums) // 35\n        # k = 36, return max(nums) // 36\n        # k = 37, return max(nums) // 37\n        # k = 38, return max(nums) // 38\n        # k = 39, return max(nums) // 39\n        # k = 40, return max(nums) // 40\n        # k = 41, return max(nums) // 41\n        # k = 42, return max(nums) // 42\n        # k = 43, return max(nums) // 43\n        # k = 44, return max(nums) // 44\n        # k = 45, return max(nums) // 45\n        # k = 46, return max(nums) // 46\n        # k = 47, return max(nums) // 47\n        # k = 48, return max(nums) // 48\n        # k = 49, return max(nums) // 49\n        # k = 50, return max(nums) // 50\n        \n        if k == 1:\n            return sum(nums)\n        \n        left, right = sum(nums[:k]), sum(nums[:k-1])\n        for i in range(k, len(nums)):\n            left, right = right, left + nums[i] - nums[i-k]"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # k-way merge\n        # time: O(nlogk)\n        # space: O(k)\n        nums.sort()\n        return nums[-k*k] if len(nums) <= k*k else nums[k*k-1] + nums[-k]\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = sum(nums[:k]), 0\n        for num in nums[k:]:\n            left, right = left + num, right + num\n            if right - left > k:\n                right -= nums[left-k]\n                left += 1\n        return left\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, sum(nums)\n        for num in nums:\n            if right - num >= k:\n                right -= num\n            else:\n                left += 1\n                right += num\n        return left\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right - left > k:\n                left += num\n            else:\n                k -= 1\n        return left if k == 0 else right - k\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right - left > k:\n                left = right - k\n            else:\n                k -= 1\n        return left if k == 0 else left + k\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right - left > k:\n                left = left - num\n            else:\n                k -= 1\n        return left if k == 0 else right\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:\n                k -= 1\n            else:\n                left += 1\n        return left if k == 0 else right\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:\n                k -= 1\n            else:\n                left += 1\n        return left if k == 0 else right - k\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k * num:\n                k -= 1\n            else:\n                k = k * num\n                left += 1\n        return left if k == 0 else right\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:\n                k -= 1\n            else:\n                k = min(k, num)\n                left += 1\n        return left if k == 0 else right - k\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:\n                right -= left\n                k -= 1\n            else:\n                k = min(k, num)\n        return left if k == 0 else right\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # k <= min(50, len(nums))\n        # k = 1, return max(nums)\n        # k = 2, return max(nums) // 2\n        # k = 3, return max(nums) // 3\n        # k = 4, return max(nums) // 4\n        # k = 5, return max(nums) // 5\n        # k = 6, return max(nums) // 6\n        # k = 7, return max(nums) // 7\n        # k = 8, return max(nums) // 8\n        # k = 9, return max(nums) // 9\n        # k = 10, return max(nums) // 10\n        # k = 11, return max(nums) // 11\n        # k = 12, return max(nums) // 12\n        # k = 13, return max(nums) // 13\n        # k = 14, return max(nums) // 14\n        # k = 15, return max(nums) // 15\n        # k = 16, return max(nums) // 16\n        # k = 17, return max(nums) // 17\n        # k = 18, return max(nums) // 18\n        # k = 19, return max(nums) // 19\n        # k = 20, return max(nums) // 20\n        # k = 21, return max(nums) // 21\n        # k = 22, return max(nums) // 22\n        # k = 23, return max(nums) // 23\n        # k = 24, return max(nums) // 24\n        # k = 25, return max(nums) // 25\n        # k = 26, return max(nums) // 26\n        # k = 27, return max(nums) // 27\n        # k = 28, return max(nums) // 28\n        # k = 29, return max(nums) // 29\n        # k = 30, return max(nums) // 30\n        # k = 31, return max(nums) // 31\n        # k = 32, return max(nums) // 32\n        # k = 33, return max(nums) // 33\n        # k = 34, return max(nums) // 34\n        # k = 35, return max(nums) // 35\n        # k = 36, return max(nums) // 36\n        # k = 37, return max(nums) // 37\n        # k = 38, return max(nums) // 38\n        # k = 39, return max(nums) // 39\n        # k = 40, return max(nums) // 40\n        # k = 41, return max(nums) // 41\n        # k = 42, return max(nums) // 42\n        # k = 43, return max(nums) // 43\n        # k = 44, return max(nums) // 44\n        # k = 45, return max(nums) // 45\n        # k = 46, return max(nums) // 46\n        # k = 47, return max(nums) // 47\n        # k = 48, return max(nums) // 48\n        # k = 49, return max(nums) // 49\n        # k = 50, return max(nums) // 50\n        if k == 1:\n            return sum(nums)\n        if k >= len(nums) // 2:\n            return max(nums)\n        left, right = sum(nums[:k]), sum(nums[:k])\n        for i in range(k, len(nums)):\n            left, right = right, left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # k-way merge\n        # time: O(nlogk)\n        # space: O(k)\n        nums.sort()\n        return nums[-k*k] if len(nums) <= k*k else nums[k*k-1] + nums[-k]\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = sum(nums[:k]), 0\n        for num in nums[k:]:\n            left += num\n            right += num\n            if right - left > k:\n                right -= nums[left-k]\n                left += 1\n        return left\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, sum(nums)\n        for num in nums:\n            if right - num >= k:\n                right -= num\n            else:\n                left += 1\n                right += num\n        return left\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right - left > k:\n                left += num\n            else:\n                k -= 1\n        return left if k == 0 else right - k\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right - left > k:\n                left = right - k\n            else:\n                k -= 1\n        return left if k == 0 else left + k\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right - left > k:\n                left = left - num\n            else:\n                k -= 1\n        return left if k == 0 else right\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:\n                k -= 1\n            else:\n                left += 1\n        return left if k == 0 else right\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:\n                k -= 1\n            else:\n                left += 1\n        return left if k == 0 else right - k\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k * num:\n                k -= 1\n            else:\n                k = k * num\n                left += 1\n        return left if k == 0 else right\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:\n                k -= 1\n            else:\n                k = min(k, num)\n                left += 1\n        return left if k == 0 else right - k\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:\n                right -= k\n            else:\n                k -= 1\n            if k == 0:\n                left += 1\n        return left\n        \n        \n        # two pointers\n        # time: O(n)\n        # space: O(1)\n        left, right = 0, 0\n        for num in nums:\n            right += num\n            if right > k:"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # kth smallest element\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109967/Python-O(log(min(m,n)))-solution-using-binary-search\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109967/Python-O(log(min(m,n)))-solution-using-binary-search/109970\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109971/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109972/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109974\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109975/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109977\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109978/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109980\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109981/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109982\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109983/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109984\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109985/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109986\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109987/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109988\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109989/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109990\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109991/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109992\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109993/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109994\n        # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/109995/C%2B%2B-O(log(min(m-n)))-solution-using-binary-search/109996\n        # https://leetcode"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if the array is sorted\n        if nums[0] > target or nums[-1] < target:\n            return -1\n        \n        # 2. check if the array is rotated\n        if nums[0] < nums[-1]:\n            if target >= nums[0]:\n                left = 0\n            else:\n                left = len(nums) - 1\n            right = len(nums) - 1\n            while left < right:\n                mid = left + (right - left) // 2\n                if nums[mid] > nums[left]:\n                    if nums[mid] > target and nums[left] <= target:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n                else:\n                    if nums[right] >= target and nums[left] < target:\n                        left = right\n                    else:\n                        right = mid - 1\n            return left if nums[left] == target else -1\n        \n        # 3. search in the sorted array\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if the array is sorted\n        if nums[0] > target or nums[-1] < target:\n            return -1\n        \n        # 2. find the pivot\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # if not nums:\n        #     return -1\n        # if nums[0] == target:\n        #     return 0\n        # if nums[-1] == target:\n        #     return len(nums) - 1\n        # if target < nums[0]:\n        #     return -1\n        # if target > nums[-1]:\n        #     return -1\n        \n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     mid = left + (right - left) // 2\n        #     if nums[mid] == target:\n        #         return mid\n        #     if nums[left] <= nums[mid]:\n        #         if nums[left] <= target < nums[mid]:\n        #             right = mid - 1\n        #         else:\n        #             left = mid + 1\n        #     else:\n        #         if nums[mid] < target <= nums[right]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # return -1\n        \n        # if not nums:\n        #     return -1\n        # if nums[0] == target:\n        #     return 0\n        # if target < nums[0]:\n        #     return -1\n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     mid = left + (right - left) // 2\n        #     if nums[mid] == target:\n        #         return mid\n        #     if nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return -1\n        \n        # if not nums:\n        #     return -1\n        # if nums[0] == target:\n        #     return 0\n        # if target < nums[0]:\n        #     return -1\n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     mid = left + (right - left) // 2\n        #     if nums[mid] == target:\n        #         return mid\n        #     if nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return -1\n        \n        # if not nums:\n        #     return -1\n        # if nums[0] == target:\n        #     return 0\n        # if target < nums[0]:\n        #     return -1\n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     mid = left + (right - left) // 2\n        #     if nums[mid] == target:\n        #         return mid\n        #     if nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return -1\n        \n        # if not nums:\n        #     return -1\n        # if nums[0] == target:\n        #     return 0\n        # if target < nums[0]:\n        #     return -1\n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     mid = left + (right - left) // 2\n        #     if nums[mid] == target:\n        #         return mid\n        #     if nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return -1\n        \n        # if not nums:\n        #     return -1\n        # if nums[0] == target:\n        #     return 0\n        # if target < nums[0]:\n        #     return -1\n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     mid = left + (right - left) // 2\n        #     if nums[mid] == target:"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = []\n        self.dfs(digits, 0, '', res, mapping)\n        return res\n    \n    def dfs(self, digits, index, cur, res, mapping):\n        if index == len(digits):\n            res.append(cur)\n            return\n        \n        for c in mapping[digits[index]]:\n            self.dfs(digits, index + 1, cur + c, res, mapping)\n```\n\n### 2. Solution\n\n```python\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = [''] * len(digits)\n        for i, c in enumerate(digits):\n            res[i] = mapping[c]\n        \n        return ''.join(res)\n```\n\n### 3. Solution\n\n```python\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = ['']\n        for c in digits:\n            res = [r + c for r in res]\n        \n        return res\n```\n\n### 4. Solution\n\n```python\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = ['']\n        for c in digits:\n            res = mapping[c] + res\n        \n        return res\n```\n\n### 5. Solution\n\n```python\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = ['']\n        for c in digits:\n            res = [r + c for r in res]\n        \n        return res\n```\n\n### 6. Solution\n\n```python\nclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = ['']\n        for c in digits:\n            res = mapping[c] + res\n        \n        return res\n```\n\n### 7. Solution"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = []\n        self.dfs(digits, 0, '', res, mapping)\n        return res\n    \n    def dfs(self, digits, index, cur, res, mapping):\n        if index == len(digits):\n            res.append(cur)\n            return\n        \n        for c in mapping[digits[index]]:\n            self.dfs(digits, index + 1, cur + c, res, mapping)"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = []\n        self.dfs(digits, 0, '', res, mapping)\n        return res\n        \n    def dfs(self, digits, index, cur, res, mapping):\n        if index == len(digits):\n            res.append(cur)\n            return\n        \n        for char in mapping[digits[index]]:\n            self.dfs(digits, index + 1, cur + char, res, mapping)"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = []\n        self.dfs(digits, 0, '', res, mapping)\n        return res\n    \n    def dfs(self, digits, index, cur, res, mapping):\n        if index == len(digits):\n            res.append(cur)\n            return\n        \n        for char in mapping[digits[index]]:\n            self.dfs(digits, index + 1, cur + char, res, mapping)"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = ['']\n        for digit in digits:\n            res = [res[i] + letter for letter in mapping[digit] for i in range(len(res))]\n        \n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # if n is a palindrome, return n\n        if n == n[::-1]:\n            return n\n        \n        # if n is odd, we can get the closest palindrome by adding 1 or subtracting 1\n        if len(n) % 2 == 1:\n            return str(int(n) + 2 * (n[0] == '5'))\n        \n        # if n is even, we can get the closest palindrome by adding 1 or subtracting 2\n        left, right = int(n[:len(n) // 2]), int(n[len(n) // 2:])\n        return str(left + right + 1) if left > right else str(left - right)"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # if n is a palindrome, return n\n        if n == n[::-1]:\n            return n\n        \n        # if n is odd, we can add 1 or 2 to make it a palindrome\n        if len(n) % 2 == 1:\n            return str(int(n) + 2 - int(n[0]) * 2)\n        \n        # if n is even, we can add 1 or 2 to make it a palindrome\n        # or we can subtract 1 from the middle digit\n        return str(int(n) + 1 - int(n[len(n) // 2]))"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        if n == \"1\":\n            return \"0\"\n        if n[0] == \"0\":\n            return \"1\"\n        if len(n) == 1:\n            return str(int(n) - 1) if int(n) % 2 else str(int(n) + 1)\n        \n        left, right = int(n[0]), int(n[-1])\n        if left == right:\n            return str(left * 10 + left - 1) if left % 2 else str(left * 10 + left + 1)\n        return str(left * 10 + right) if left > right else str(left + right * 10)"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # if n is a palindrome, return n\n        if n == n[::-1]:\n            return n\n        \n        # if n is odd, we can get the closest palindrome by adding 1 or subtracting 1\n        if len(n) % 2 == 1:\n            return str(int(n) + 2 * (n[0] == '5'))\n        \n        # if n is even, we can get the closest palindrome by adding 1 or subtracting 2\n        left, right = int(n[:len(n) // 2]), int(n[len(n) // 2:])\n        if left == right:\n            return str(left + 1)\n        return str(left - 1) if left > right else str(left + 2)"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # if n is a palindrome, return n\n        if n == n[::-1]:\n            return n\n        \n        # if n is odd, we can add 1 or 2 to make it a palindrome\n        if n[0] != n[-1]:\n            return str(int(n) + 2 * (n[0] - '0'))\n        \n        # if n is even, we can add 1 to make it a palindrome\n        return str(int(n) + 1)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[0 for _ in range(n)] for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom + 1):\n                res[i][right] = num\n                num += 1\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res[bottom][i] = num\n                    num += 1\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res[i][left] = num\n                    num += 1\n            left += 1\n        return res"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[0 for _ in range(n)] for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom + 1):\n                res[i][right] = num\n                num += 1\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res[bottom][i] = num\n                    num += 1\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res[i][left] = num\n                    num += 1\n            left += 1\n        return res"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[0 for _ in range(n)] for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom + 1):\n                res[i][right] = num\n                num += 1\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res[bottom][i] = num\n                    num += 1\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res[i][left] = num\n                    num += 1\n            left += 1\n        return res"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[0] * n for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom + 1):\n                res[i][right] = num\n                num += 1\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res[bottom][i] = num\n                    num += 1\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res[i][left] = num\n                    num += 1\n            left += 1\n        return res"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[0 for _ in range(n)] for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom + 1):\n                res[i][right] = num\n                num += 1\n            right -= 1\n            if left <= right:\n                for i in range(right, left - 1, -1):\n                    res[bottom][i] = num\n                    num += 1\n            bottom -= 1\n            if top <= bottom:\n                for i in range(bottom, top - 1, -1):\n                    res[i][left] = num\n                    num += 1\n            left += 1\n        return res"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5224\u65ad\u662f\u5426\u4e3a\u8d1f\u6570\n        is_negative = x < 0\n        x = abs(x)\n        \n        # 2. \u53cd\u8f6c\u6570\u5b57\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n            \n            # 3. \u5224\u65ad\u662f\u5426\u6ea2\u51fa\n            if result > 2**31 - 1:\n                return 0\n            \n        # 4. \u5224\u65ad\u662f\u5426\u4e3a\u8d1f\u6570\n        return -result if is_negative else result\n```\n\n## 2. \u89e3\u9898\u601d\u8def\n\n### 2.1 \u53cd\u8f6c\u6570\u5b57\n\n\u9898\u76ee\u8981\u6c42\u6211\u4eec\u5c06\u4e00\u4e2a 32 \u4f4d\u7684\u6574\u6570 x \u7684\u6570\u5b57\u53cd\u8f6c\uff0c\u5e76\u8fd4\u56de\u53cd\u8f6c\u540e\u7684\u7ed3\u679c\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u53d8\u91cf\u6765\u5b58\u50a8\u53cd\u8f6c\u540e\u7684\u7ed3\u679c\uff0c\u7136\u540e\u5c06 x \u7684\u6bcf\u4e00\u4f4d\u6570\u5b57\u4f9d\u6b21\u53d6\u51fa\uff0c\u4e58\u4ee5 10 \u518d\u52a0\u5230 result \u4e0a\u3002\n\n```\nresult = result * 10 + x % 10\nx //= 10\n```\n\n### 2.2 \u5224\u65ad\u662f\u5426\u6ea2\u51fa\n\n\u7531\u4e8e\u9898\u76ee\u9650\u5236\u4e86 x \u7684\u8303\u56f4\u4e3a [-2\u00b3\u00b9, 2\u00b3\u00b9 - 1]\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5224\u65ad\u53cd\u8f6c\u540e\u7684\u7ed3\u679c\u662f\u5426\u5927\u4e8e 2\u00b3\u00b9 - 1\uff0c\u5982\u679c\u5927\u4e8e\u5219\u8fd4\u56de 0\u3002\n\n```\nif result > 2**31 - 1:\n    return 0\n```\n\n### 2.3 \u5224\u65ad\u662f\u5426\u4e3a\u8d1f\u6570\n\n\u5982\u679c x \u662f\u8d1f\u6570\uff0c\u6211\u4eec\u9700\u8981\u5c06\u53cd\u8f6c\u540e\u7684\u7ed3\u679c\u518d\u4e58\u4ee5 -1\u3002\n\n```\nreturn -result if is_negative else result\n```\n\n## 3. \u590d\u6742\u5ea6\u5206\u6790\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\uff0clogN \u4e3a x \u7684\u4f4d\u6570\u3002\n\n\u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n\n## 4. \u5176\u4ed6\u89e3\u6cd5\n\n### 4.1 \u53cd\u8f6c\u5b57\u7b26\u4e32\n\n\u6211\u4eec\u53ef\u4ee5\u5c06 x \u8f6c\u6362\u6210\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u53cd\u8f6c\u5b57\u7b26\u4e32\uff0c\u518d\u8f6c\u6362\u56de\u6574\u6570\u3002\n\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        s = str(x)\n        s = s[::-1]\n        res = int(s)\n        return res if -2**31 <= res <= 2**31 - 1 else 0\n```\n\n### 4.2 \u51cf\u6cd5\n\n\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u51cf\u6cd5\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\n\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        res = 0\n        while x != 0:\n            res = res * 10 + x % 10\n            x //= 10\n            if res > 2**31 - 1 or res < -2**31:\n                return 0\n        return res\n```\n\n## 5. \u53c2\u8003\u94fe\u63a5\n\n- [Reverse Integer - LeetCode](https://leetcode.com/problems/reverse-integer/description/)\n- [Reverse Integer - GeeksForGeeks](https://www.geeksforgeeks.org/reverse-integer-using-recursion-and-divide-and-conquer/)\n- [Reverse Integer - GeeksForGeeks](https://www.geeksforgeeks.org/reverse-integer-using-recursion-and-divide-and-conquer/)\n- [Reverse Integer - GeeksForGeeks](https://www.geeksforgeeks.org/reverse-integer-using-recursion-and-divide-and-conquer/)\n- [Reverse Integer - GeeksForGeeks](https://www.geeksforgeeks.org/reverse-integer-using-recursion-and-divide-and-conquer/)\n- [Reverse Integer - GeeksForGeeks](https://www.geeksforgeeks"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5224\u65ad\u662f\u5426\u4e3a\u8d1f\u6570\n        is_negative = x < 0\n        x = abs(x)\n        \n        # 2. \u53cd\u8f6c\u6570\u5b57\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n            \n            # 3. \u5224\u65ad\u662f\u5426\u6ea2\u51fa\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        \n        # 4. \u5904\u7406\u8d1f\u6570\n        return -result if is_negative else result\n```\n\n## 2. \u89e3\u6cd52\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        return result\n```\n\n## 3. \u89e3\u6cd53\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        return result\n```\n\n## 4. \u89e3\u6cd54\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        return result\n```\n\n## 5. \u89e3\u6cd55\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        return result\n```\n\n## 6. \u89e3\u6cd56\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        return result\n```\n\n## 7. \u89e3\u6cd57\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        return result\n```\n\n## 8. \u89e3\u6cd58\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        while x != 0:\n            result = result * 10 + x % 10\n            x //= 10\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        return result\n```\n\n## 9. \u89e3\u6cd59\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5224\u65ad\u662f\u5426\u4e3a\u8d1f\u6570\n        is_negative = x < 0\n        x = abs(x)\n        \n        # 2. \u53cd\u8f6c\u6570\u5b57\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n            \n            # 3. \u5224\u65ad\u662f\u5426\u6ea2\u51fa\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        \n        # 4. \u5224\u65ad\u662f\u5426\u4e3a\u8d1f\u6570\n        return -result if is_negative else result\n```\n\n## 2. \u89e3\u9898\u601d\u8def\n\n### 2.1 \u89e3\u6cd5\u4e00\n\n\u8fd9\u9898\u7684\u89e3\u6cd5\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5c06\u6570\u5b57\u53cd\u8f6c\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u6ea2\u51fa\u3002\n\n### 2.2 \u89e3\u6cd5\u4e8c\n\n\u8fd9\u9898\u7684\u89e3\u6cd5\u4e5f\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5c06\u6570\u5b57\u53cd\u8f6c\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u6ea2\u51fa\u3002\n\n## 3. \u590d\u6742\u5ea6\u5206\u6790\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\u3002\n\n\u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n\n## 4. \u6d4b\u8bd5\n\n```go\npackage leetcode\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestReverse(t *testing.T) {\n\tx := 123\n\tr := 321\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = -123\n\tr = -321\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = 120\n\tr = 21\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = -2147483648\n\tr = 0\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = 2147483647\n\tr = 0\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = 1534236469\n\tr = 0\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = -2147483648\n\tr = 0\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = 2147483647\n\tr = 0\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = -2147483648\n\tr = 0\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = 2147483647\n\tr = 0\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d) = %d, want %d\", x, ret, r)\n\t}\n\n\tx = -2147483648\n\tr = 0\n\tif ret := reverse(x); ret != r {\n\t\tt.Errorf(\"reverse(%d)"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5224\u65ad\u662f\u5426\u4e3a\u8d1f\u6570\n        is_negative = x < 0\n        x = abs(x)\n        \n        # 2. \u53cd\u8f6c\u6570\u5b57\n        result = 0\n        while x:\n            result = result * 10 + x % 10\n            x //= 10\n            \n            # 3. \u5224\u65ad\u662f\u5426\u6ea2\u51fa\n            if result > 2**31 - 1 or result < -2**31:\n                return 0\n        \n        # 4. \u5904\u7406\u8d1f\u6570\n        return -result if is_negative else result\n```\n\n## 2. \u89e3\u9898\u601d\u8def\n\n### 2.1 \u53cd\u8f6c\u6570\u5b57\n\n\u53cd\u8f6c\u6570\u5b57\u7684\u65b9\u6cd5\u6709\u5f88\u591a\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u5faa\u73af\u548c\u53d6\u4f59\u7684\u65b9\u6cd5\u3002\n\n### 2.2 \u5224\u65ad\u662f\u5426\u6ea2\u51fa\n\n\u5224\u65ad\u662f\u5426\u6ea2\u51fa\u7684\u65b9\u6cd5\u6709\u5f88\u591a\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u5224\u65ad\u662f\u5426\u5927\u4e8e 2**31 - 1 \u6216\u5c0f\u4e8e -2**31 \u7684\u65b9\u6cd5\u3002\n\n## 3. \u590d\u6742\u5ea6\u5206\u6790\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\u3002\n\n\u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\u3002\n\n## 4. \u5176\u4ed6\u89e3\u6cd5\n\n### 4.1 \u4f7f\u7528\u5b57\u7b26\u4e32\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 0:\n            return -self.reverse(-x)\n        \n        res = 0\n        while x:\n            res = res * 10 + x % 10\n            x //= 10\n            \n            if res > 2**31 - 1 or res < -2**31:\n                return 0\n        \n        return res\n```\n\n### 4.2 \u4f7f\u7528\u53d6\u4f59\u7684\u65b9\u6cd5\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        while x != 0:\n            res = res * 10 + x % 10\n            x //= 10\n            \n            if res > 2**31 - 1 or res < -2**31:\n                return 0\n        \n        return res\n```\n\n### 4.3 \u4f7f\u7528\u53d6\u4f59\u7684\u65b9\u6cd5\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        while x != 0:\n            res = res * 10 + x % 10\n            x //= 10\n            \n            if res > 2**31 - 1 or res < -2**31:\n                return 0\n        \n        return res\n```\n\n### 4.4 \u4f7f\u7528\u53d6\u4f59\u7684\u65b9\u6cd5\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        while x != 0:\n            res = res * 10 + x % 10\n            x //= 10\n            \n            if res > 2**31 - 1 or res < -2**31:\n                return 0\n        \n        return res\n```\n\n### 4.5 \u4f7f\u7528\u53d6\u4f59\u7684\u65b9\u6cd5\n\n```python\nclass Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        res = 0\n        while x != 0:\n            res = res * 10 + x % 10\n            x //= 10\n            \n            if res > 2**31 - 1 or res < -2**31:\n                return 0\n        \n        return res\n```\n\n### 4.6 \u4f7f\u7528\u53d6\u4f59\u7684"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # Reverse the number\n        rev = 0\n        while x != 0:\n            rev = rev * 10 + x % 10\n            x //= 10\n            \n            # Check if the reversed number is out of range\n            if rev > 2**31 - 1 or rev < -2**31:\n                return 0\n        \n        return rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # reverse the matrix\n        matrix.reverse()\n        \n        # transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i + 1, len(matrix[i])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse the matrix\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # reverse the matrix\n        matrix.reverse()\n        \n        # transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix[i])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse the matrix\n        for i in range(len(matrix)):\n            matrix[i] = matrix[i][:len(matrix[i]) // 2] + matrix[i][len(matrix[i]) // 2:][::-1]"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # reverse the matrix\n        matrix.reverse()\n        \n        # transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i + 1, len(matrix[i])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse the matrix\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # reverse the matrix\n        matrix.reverse()\n        \n        # transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i + 1, len(matrix[i])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse the matrix\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # reverse the matrix\n        matrix.reverse()\n        \n        # transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i + 1, len(matrix[i])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse the matrix\n        for i in range(len(matrix)):\n            matrix[i] = matrix[i][:len(matrix[i]) // 2] + matrix[i][len(matrix[i]) // 2:][::-1]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            result = max(result, max_product)\n        \n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            result = max(result, max_product)\n        \n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            result = max(result, max_product)\n        \n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            result = max(result, max_product)\n        \n        return result"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n        \n        max_product = nums[0]\n        min_product = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                max_product, min_product = min_product, max_product\n            max_product = max(nums[i], max_product * nums[i])\n            min_product = min(nums[i], min_product * nums[i])\n            result = max(result, max_product)\n        \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) <= 1:\n            return True\n        \n        last, next_last = stones[0], stones[1] - stones[0]\n        for i in range(2, len(stones)):\n            if stones[i] - last >= next_last:\n                next_last = last\n                last = stones[i]\n            else:\n                if next_last > last - stones[i]:\n                    return False\n                next_last = last - stones[i]\n                \n        return True"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) <= 1:\n            return True\n        \n        last, next_last = stones[0], stones[1] - stones[0]\n        for i in range(2, len(stones)):\n            if stones[i] >= last + next_last:\n                last, next_last = next_last, stones[i] - last\n            else:\n                return False\n        return True"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) <= 1:\n            return True\n        \n        last, next_last = stones[0], stones[1] - stones[0]\n        for i in range(2, len(stones)):\n            if stones[i] >= last + next_last:\n                last, next_last = next_last, stones[i] - last\n            else:\n                return False\n        return True"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) <= 1:\n            return True\n        \n        last, next_last = stones[0], stones[1] - stones[0]\n        for i in range(2, len(stones)):\n            if stones[i] >= last + next_last:\n                last, next_last = next_last, stones[i] - last\n            else:\n                return False\n        return True"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(stones) <= 1:\n            return True\n        \n        last, next_last = stones[0], stones[1] - stones[0]\n        for i in range(2, len(stones)):\n            if stones[i] >= last + next_last:\n                last, next_last = next_last, stones[i] - last\n            else:\n                return False\n        return True"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        rank = {score[i]: i+1 for i in range(len(score))}\n        return [\"Gold Medal\" if i == 1 else (\"Silver Medal\" if i == 2 else (\"Bronze Medal\" if i == 3 else str(rank[i]))) for i in sorted(score, reverse=True)]"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        rank = {score[i]: i+1 for i in range(len(score))}\n        return [\"Gold Medal\" if i == 1 else (\"Silver Medal\" if i == 2 else (\"Bronze Medal\" if i == 3 else str(rank[i]))) for i in sorted(score, reverse=True)]"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        rank = {score[i]: i+1 for i in range(len(score))}\n        return [\"Gold Medal\" if i == 1 else (\"Silver Medal\" if i == 2 else (\"Bronze Medal\" if i == 3 else str(rank[i]))) for i in sorted(score, reverse=True)]"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        rank = {score[i]: i+1 for i in range(len(score))}\n        return [\"Gold Medal\" if i == 1 else (\"Silver Medal\" if i == 2 else (\"Bronze Medal\" if i == 3 else str(rank[i]))) for i in sorted(score, reverse=True)]"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        rank = {score[i]: i+1 for i in range(len(score))}\n        return [\"Gold Medal\" if i == 1 else (\"Silver Medal\" if i == 2 else (\"Bronze Medal\" if i == 3 else str(rank[i]))) for i in sorted(score, reverse=True)]"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # left, right = 0, 0\n        # res = 0\n        # seen = set()\n        # while right < len(s):\n        #     if s[right] not in seen:\n        #         seen.add(s[right])\n        #         res = max(res, right - left + 1)\n        #     else:\n        #         seen.remove(s[left])\n        #         left += 1\n        #     right += 1\n        # return res\n        \n        # M2. Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # left = 0\n        # res = 0\n        # seen = set()\n        # for right in range(len(s)):\n        #     if s[right] in seen:\n        #         left = max(left, seen[s[right]] + 1)\n        #     else:\n        #         res = max(res, right - left + 1)\n        #         seen[s[right]] = right\n        # return res\n        \n        # M3. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = set()\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left, seen[s[right]])\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M4. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left, seen[s[right]])\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M5. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]]\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M6. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen and seen[s[right]] >= left:\n                left = seen[s[right]] + 1\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M7. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]] + 1\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M8. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right <"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # left, right = 0, 0\n        # res = 0\n        # seen = set()\n        # while right < len(s):\n        #     if s[right] not in seen:\n        #         seen.add(s[right])\n        #         res = max(res, right - left + 1)\n        #     else:\n        #         seen.remove(s[left])\n        #         left += 1\n        #     right += 1\n        # return res\n        \n        # M2. Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # left = 0\n        # res = 0\n        # seen = set()\n        # for right in range(len(s)):\n        #     if s[right] in seen:\n        #         left = max(left, seen[s[right]] + 1)\n        #     else:\n        #         res = max(res, right - left + 1)\n        #         seen[s[right]] = right\n        # return res\n        \n        # M3. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = set()\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left, seen[s[right]] + 1)\n            else:\n                res = max(res, right - left + 1)\n                seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M4. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left, seen[s[right]])\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M5. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]]\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M6. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen and seen[s[right]] >= left:\n                left = seen[s[right]] + 1\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M7. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]] + 1\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M8. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # left, right = 0, 0\n        # res = 0\n        # seen = set()\n        # while right < len(s):\n        #     if s[right] not in seen:\n        #         seen.add(s[right])\n        #         res = max(res, right - left + 1)\n        #     else:\n        #         seen.remove(s[left])\n        #         left += 1\n        #     right += 1\n        # return res\n        \n        # M2. Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # left = 0\n        # res = 0\n        # seen = set()\n        # for right in range(len(s)):\n        #     if s[right] in seen:\n        #         left = max(left, seen[s[right]] + 1)\n        #     else:\n        #         res = max(res, right - left + 1)\n        #         seen[s[right]] = right\n        # return res\n        \n        # M3. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = set()\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left, seen[s[right]])\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M4. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left, seen[s[right]])\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M5. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]]\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M6. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen and seen[s[right]] >= left:\n                left = seen[s[right]] + 1\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M7. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]] + 1\n            else:\n                res = max(res, right - left)\n            seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M8. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right <"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if we don't encounter a duplicate char, we can just move the end pointer forward\n        # if we encounter a duplicate char, we need to move the start pointer to the next char\n        # if"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # left, right = 0, 0\n        # res = 0\n        # seen = set()\n        # while right < len(s):\n        #     if s[right] not in seen:\n        #         seen.add(s[right])\n        #         res = max(res, right - left + 1)\n        #     else:\n        #         seen.remove(s[left])\n        #         left += 1\n        #     right += 1\n        # return res\n        \n        # M2. Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        # left = 0\n        # res = 0\n        # seen = set()\n        # for right in range(len(s)):\n        #     if s[right] in seen:\n        #         left = max(left, seen[s[right]] + 1)\n        #     else:\n        #         res = max(res, right - left + 1)\n        #         seen[s[right]] = right\n        # return res\n        \n        # M3. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = set()\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left, seen[s[right]])\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M4. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = max(left, seen[s[right]])\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M5. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]]\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right + 1\n            right += 1\n        return res\n        \n        # M6. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen and seen[s[right]] >= left:\n                left = seen[s[right]] + 1\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M7. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0\n        seen = {}\n        while right < len(s):\n            if s[right] in seen:\n                left = seen[s[right]] + 1\n            else:\n                res = max(res, right - left + 1)\n            seen[s[right]] = right\n            right += 1\n        return res\n        \n        # M8. Two Pointers + Hash Table\n        # Time: O(N)\n        # Space: O(1)\n        # Sliding Window\n        left, right = 0, 0\n        res = 0"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words or len(words) == 0 or len(words[0]) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_map = collections.Counter(words)\n        res = []\n        start = 0\n        for i in range(word_len):\n            if word_map[s[i]] > 0:\n                count = word_map[s[i]]\n                while count > 0 and start <= i + word_len * count - word_len:\n                    if s[start + word_len - 1] == s[i + word_len - 1]:\n                        count -= 1\n                    start += 1\n                    if count == word_count:\n                        res.append(start)\n                        \n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words or len(words) == 0 or len(words[0]) == 0:\n            return []\n        \n        word_len, word_count, res = len(words[0]), len(words), []\n        word_map = collections.defaultdict(int)\n        for word in words:\n            word_map[word] += 1\n        \n        left, count = 0, word_count\n        for right in range(word_len):\n            if word_map[s[right]] > 0 and count <= word_count:\n                count += 1\n            else:\n                word_map[s[left]] -= 1\n                if word_map[s[left]] == 0:\n                    count -= 1\n                left += 1\n            if count == word_count:\n                res.append(left)\n        \n        return res if word_len * word_count <= len(s) else res[:-word_count]"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words or len(words) == 0 or len(words[0]) == 0:\n            return []\n        \n        word_len, word_count, res = len(words[0]), len(words), []\n        need = collections.Counter(words)\n        left = 0\n        \n        for right in range(word_len):\n            if need[s[right]] > 0:\n                count = need[s[right]]\n            else:\n                while left < right and s[left] != s[right]:\n                    need[s[left]] -= 1\n                    if need[s[left]] < count:\n                        count -= 1\n                    left += 1\n            if count > 0:\n                res.append(left)\n        \n        return res if len(s) - word_len * word_count >= word_len else res[1:]"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words or len(words) == 0 or len(words[0]) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        target_len = word_len * word_count\n        if len(s) < target_len:\n            return []\n        \n        res = []\n        word_map = collections.Counter(words)\n        start = 0\n        while start < word_len:\n            if word_map[s[start]] > 0:\n                count = word_map[s[start]]\n            else:\n                start += 1\n                continue\n            \n            left, right = start, start + word_len * count\n            while right <= len(s) - target_len:\n                if s[left:right] == s[right:right + word_len]:\n                    count -= 1\n                    if count == 0:\n                        res.append(left)\n                        left += word_len\n                        if s[left:left + word_len] in word_map:\n                            count += 1\n                else:\n                    right += word_len\n                    if s[left:left + word_len] in word_map:\n                        count -= 1"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words or len(words) == 0 or len(words[0]) == 0:\n            return []\n        \n        word_len, word_count, res = len(words[0]), len(words), []\n        need = collections.Counter(words)\n        left = 0\n        \n        for right in range(word_len):\n            if need[s[right]] > 0:\n                count = need[s[right]]\n            else:\n                while left < right and s[left] != s[right]:\n                    need[s[left]] -= 1\n                    if need[s[left]] < count:\n                        count -= 1\n                    left += 1\n            if count > 0:\n                res.append(left)\n        \n        return res if len(s) - left >= word_len * word_count else []"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = 0\n        count = 0\n        for val in arr:\n            if val > max_val:\n                count += 1\n                max_val = val\n        \n        return count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.96% of Python online submissions for Chunked Sort.\n        # Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Chunked Sort.\n        max_val = 0\n        count = 0\n        for val in arr:\n            if val > max_val:\n                count += 1\n                max_val = val\n            else:\n                max_val = val\n        return count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.75% of Python online submissions for Chunked Sort.\n        # Memory Usage: 13.2 MB, less than 5.00% of Python online submissions for Chunked Sort.\n        max_val = 0\n        count = 0\n        for val in arr:\n            if val > max_val:\n                count += 1\n                max_val = val\n            else:\n                max_val = val\n        return count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = 0\n        count = 0\n        for val in arr:\n            if val > max_val:\n                count += 1\n                max_val = val\n        \n        return count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = 0\n        count = 0\n        for val in arr:\n            if val > max_val:\n                count += 1\n                max_val = val\n            else:\n                max_val = val\n        return count"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        head.next = None\n        \n        while cur:\n            if cur.val < dummy.val:\n                dummy = dummy.next\n            else:\n                prev = dummy\n                while prev.next.val < cur.val:\n                    prev = prev.next\n                cur.next, prev.next = prev.next, cur\n            cur = cur.next\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        head.next = None\n        \n        while cur:\n            if cur.val < dummy.val:\n                dummy = dummy.next\n            else:\n                prev = dummy\n                while prev.next.val < cur.val:\n                    prev = prev.next\n                cur.next, prev.next = prev.next, cur\n            cur = cur.next\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        head.next = None\n        \n        while cur:\n            if cur.val < dummy.val:\n                dummy = dummy.next\n            else:\n                prev = dummy\n                while prev.next.val < cur.val:\n                    prev = prev.next\n                cur.next, prev.next = prev.next, cur\n            cur = cur.next\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        head.next = None\n        \n        while cur:\n            if cur.val < dummy.val:\n                dummy = dummy.next\n            else:\n                prev = dummy\n                while prev.next.val < cur.val:\n                    prev = prev.next\n                cur.next, prev.next = prev.next, cur\n            cur = cur.next\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head.next\n        head.next = None\n        \n        while cur:\n            if cur.val < dummy.val:\n                dummy = dummy.next\n            else:\n                prev = dummy\n                while prev.next and prev.next.val < cur.val:\n                    prev = prev.next\n                \n            cur.next, prev.next = prev.next, cur\n            cur = cur.next\n        \n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        cur = head\n        \n        while cur and cur.next:\n            if cur.val == cur.next.val:\n                cur = cur.next\n            else:\n                prev.next = cur.next\n                cur = cur.next\n                prev = prev.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        prev = head\n        cur = head.next\n        \n        while cur:\n            if cur.val == prev.val:\n                prev.val = cur.val\n                cur = cur.next\n            else:\n                prev = cur\n                cur = cur.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            if prev.next.val == prev.next.next.val:\n                prev.next = prev.next.next\n            else:\n                prev = prev.next\n                \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        cur = head\n        \n        while cur and cur.next:\n            if cur.val == cur.next.val:\n                cur = cur.next\n            else:\n                prev.next = cur.next\n                cur = cur.next\n                prev = prev.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        prev = head\n        cur = head.next\n        \n        while cur:\n            if cur.val == prev.val:\n                prev.val = cur.val\n                cur = cur.next\n            else:\n                prev = cur\n                cur = cur.next\n        \n        return head"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        i = 0\n        while i < len(nums) - 2 and nums[i] <= 0:\n            if i > 0 and nums[i] == nums[i - 1]:\n                i += 1\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if s < 0:\n                    left += 1\n                elif s > 0:\n                    right -= 1\n                else:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n            i += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        i = 0\n        while i < len(nums) - 2 and nums[i] <= 0:\n            if i > 0 and nums[i] == nums[i - 1]:\n                i += 1\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if s < 0:\n                    left += 1\n                elif s > 0:\n                    right -= 1\n                else:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n            i += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        i = 0\n        while i < len(nums) - 2 and nums[i] <= 0:\n            if i > 0 and nums[i] == nums[i - 1]:\n                i += 1\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if s < 0:\n                    left += 1\n                elif s > 0:\n                    right -= 1\n                else:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n            i += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        i = 0\n        while i < len(nums) - 2 and nums[i] <= 0:\n            if i > 0 and nums[i] == nums[i - 1]:\n                i += 1\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if s < 0:\n                    left += 1\n                elif s > 0:\n                    right -= 1\n                else:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n            i += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        i = 0\n        while i < len(nums) - 2 and nums[i] <= 0:\n            if i > 0 and nums[i] == nums[i - 1]:\n                i += 1\n                continue\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if s < 0:\n                    left += 1\n                elif s > 0:\n                    right -= 1\n                else:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n            i += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] represents the minimum number of operations to convert word1[:i] to word2[:j]\n        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        \n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        \n        return len(word1) + len(word2) - 2 * dp[len(word1)][len(word2)]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] represents the minimum number of operations to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i] == word2[j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 otherwise\n        # dp[i][0] = i\n        # dp[0][j] = j\n        dp = [len(word1)+1] * (len(word2)+1)\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[j] = dp[j-1]\n                else:\n                    dp[j] = min(dp[j], dp[j-1], dp[i]) + 1\n        return dp[len(word2)]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] represents the minimum number of operations to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i] == word2[j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 otherwise\n        # base case: dp[0][j] = j, dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [m] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + (word1[i - 1] != word2[i - 1])\n        for i in range(1, m + 1):\n            dp[i] = min(dp[i], dp[i - 1] + 1)\n        return dp[n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] represents the minimum number of operations to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i] == word2[j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 otherwise\n        # dp[i][0] = i\n        # dp[0][j] = j\n        dp = [len(word1)+1] * (len(word2)+1)\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[j] = dp[j-1]\n                else:\n                    dp[j] = min(dp[j], dp[j-1], dp[i]) + 1\n        return dp[len(word2)]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] represents the minimum number of operations to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i] == word2[j]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 otherwise\n        # dp[i][0] = i\n        # dp[0][j] = j\n        dp = [len(word1)+1] * (len(word2)+1)\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[j] = dp[j-1]\n                else:\n                    dp[j] = min(dp[j], dp[j-1], dp[i-1]) + 1\n        return dp[len(word2)]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor the two numbers\n        # count the number of 1s in the result\n        return bin(x^y).count('1')"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor the two numbers\n        # count the number of 1s in the result\n        return bin(x^y).count('1')"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor the two numbers\n        # count the number of 1s in the result\n        return bin(x^y).count('1')"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor the two numbers\n        # count the number of 1s in the result\n        return bin(x^y).count('1')"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor the two numbers\n        # count the number of 1s in the result\n        return bin(x^y).count('1')"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, str(root.val), res)\n        return res\n        \n    def dfs(self, root, path, res):\n        if not root.left and not root.right:\n            res.append(path)\n        if root.left:\n            self.dfs(root.left, path + '->' + str(root.left.val), res)\n        if root.right:\n            self.dfs(root.right, path + '->' + str(root.right.val), res)"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, str(root.val), res)\n        return res\n        \n    def dfs(self, root, path, res):\n        if not root.left and not root.right:\n            res.append(path)\n        if root.left:\n            self.dfs(root.left, path + '->' + str(root.left.val), res)\n        if root.right:\n            self.dfs(root.right, path + '->' + str(root.right.val), res)"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, str(root.val), res)\n        return res\n        \n    def dfs(self, root, path, res):\n        if not root.left and not root.right:\n            res.append(path)\n        if root.left:\n            self.dfs(root.left, path + '->' + str(root.left.val), res)\n        if root.right:\n            self.dfs(root.right, path + '->' + str(root.right.val), res)\n        \n        \n# Time: O(N)\n# Space: O(H)\n# DFS\n# \n# The key is to use the path to store the current node's value.\n# \n# Subproblem:\n# If we have a path, how to append the current node's value to the path?\n# \n# Solution:\n# Use the current node's value to append to the path.\n# \n# Complexity:\n# Time: O(N)\n# Space: O(H)\n# \n# N is the number of nodes in the tree, H is the height of the tree.\n# \n#"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, str(root.val), res)\n        return res\n        \n    def dfs(self, root, path, res):\n        if not root.left and not root.right:\n            res.append(path)\n        if root.left:\n            self.dfs(root.left, path + '->' + str(root.left.val), res)\n        if root.right:\n            self.dfs(root.right, path + '->' + str(root.right.val), res)\n        \n        \n# Time: O(N)\n# Space: O(H)\n# DFS\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1. How to represent the current node?\n# 2. How to represent the path?\n# \n# For 1, we can use the current node's value to represent the current node.\n# For 2, we can use the path string to represent the path.\n# \n# The key point is to use the path string to represent the current node.\n# \n# Subproblem:\n# 1."}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, str(root.val), res)\n        return res\n        \n    def dfs(self, root, path, res):\n        if not root.left and not root.right:\n            res.append(path)\n        if root.left:\n            self.dfs(root.left, path + '->' + str(root.left.val), res)\n        if root.right:\n            self.dfs(root.right, path + '->' + str(root.right.val), res)\n        \n        \n# Time: O(N)\n# Space: O(H)\n# DFS\n# \n# The key is to use the path to store the current node's value.\n# \n# Subproblem:\n# If we have a path, how to append the current node's value to the path?\n# \n# Solution:\n# Use the current node's value to append to the path.\n# \n# Corner Case:\n# If the current node is a leaf, we can append the path to the result.\n# \n# Time complexity: O(N)\n# Space complexity: O(H)"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a sorted array of cumulative sums\n        # If the current number is greater than 2 * cumulative sum,\n        # then there are at least (cumulative sum + 1) reverse pairs\n        # If the current number is less than or equal to cumulative sum,\n        # then there are at most cumulative sum reverse pairs\n        # So the answer is cumulative sum\n        \n        # Time complexity: O(n log n)\n        # Space complexity: O(n)\n        \n        if not nums:\n            return 0\n        \n        nums.append(float('inf'))\n        cumulative_sum = 0\n        ans = 0\n        \n        for num in nums:\n            if num <= cumulative_sum:\n                ans += cumulative_sum\n            else:\n                cumulative_sum = num\n        \n        return ans"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a sorted array of cumulative sums\n        # If the current number is greater than 2 * cumulative sum,\n        # then there are at least (cumulative sum + 1) reverse pairs\n        # If the current number is less than or equal to cumulative sum,\n        # then there are at most cumulative sum reverse pairs\n        # So the answer is cumulative sum\n        \n        # Time complexity: O(n log n)\n        # Space complexity: O(n)\n        \n        if not nums:\n            return 0\n        \n        nums.append(0)\n        nums.sort()\n        ans = 0\n        prev = nums[0]\n        for cur in nums[1:]:\n            ans += prev // cur\n            prev += cur\n            \n        return ans"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a sorted array of cumulative sums\n        # If the current number is greater than 2 * cumulative sum,\n        # then there are at least (cumulative sum + 1) reverse pairs\n        # If the current number is less than or equal to cumulative sum,\n        # then there are at most cumulative sum reverse pairs\n        # So the answer is cumulative sum\n        cumsum = 0\n        ans = 0\n        for num in nums:\n            ans += cumsum\n            cumsum += num\n            if cumsum > 0:\n                cumsum = cumsum // 2\n        return ans"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a sorted array of cumulative sums\n        # If the current number is greater than 2 * cumulative sum,\n        # then there are at least (cumulative sum + 1) reverse pairs\n        # If the current number is less than or equal to cumulative sum,\n        # then there are at most cumulative sum reverse pairs\n        # So the answer is cumulative sum\n        cumsum = 0\n        ans = 0\n        for num in nums:\n            ans += cumsum\n            cumsum += num\n            if cumsum > 0:\n                cumsum = cumsum // 2\n        return ans"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a sorted array of cumulative sums\n        # The number of reverse pairs is the difference between the cumulative sum at i and the cumulative sum at 2 * nums[i]\n        # Time complexity: O(n log n)\n        # Space complexity: O(n)\n        nums.append(0)\n        nums.sort()\n        ans = 0\n        prev = 0\n        for num in nums:\n            ans += prev\n            prev += num\n            if prev > num:\n                prev = num\n        return ans"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        if tx < sx or ty < sy:\n            return False\n        if tx == sx and ty == sy:\n            return True\n        if tx > sx and ty > sy:\n            return self.reachingPoints(sx, sy, tx - sx, ty - sy)\n        if tx > sx:\n            return self.reachingPoints(sx, sy, tx - sx, ty)\n        return ty % sx == 0"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        if tx < sx or ty < sy:\n            return False\n        if tx == sx and ty == sy:\n            return True\n        if tx > sx and ty > sy:\n            return self.reachingPoints(sx, sy, tx - sx, ty - sy)\n        if tx > sx:\n            return self.reachingPoints(sx, sy, tx - sx, ty)\n        return ty % sx == 0"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        if tx < sx or ty < sy:\n            return False\n        if tx == sx and ty == sy:\n            return True\n        if tx > sx and ty > sy:\n            return self.reachingPoints(sx, sy, tx - sx, ty - sy)\n        if tx > sx:\n            return self.reachingPoints(sx, sy, tx - sx, ty)\n        return ty % sx == 0"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        if tx < sx or ty < sy:\n            return False\n        if tx == sx and ty == sy:\n            return True\n        if tx > ty:\n            tx, ty = ty, tx\n            sx, sy = sy, sx\n        \n        while tx < sx:\n            if tx > ty + sx:\n                tx, ty = ty + sx, ty\n            else:\n                return tx == ty or tx == ty + sx\n        return ty <= tx <= ty + sx"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        if tx < sx or ty < sy:\n            return False\n        if tx == sx and ty == sy:\n            return True\n        if tx > sx and ty > sy:\n            return self.reachingPoints(sx, sy, tx - sx, ty - sy)\n        if tx > sx:\n            return self.reachingPoints(sx, sy, tx - sx, ty)\n        return ty % sx == 0"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1, v2 = version1.split('.'), version2.split('.')\n        while v1 and v2:\n            if int(v1.pop(0)) < int(v2.pop(0)):\n                return -1\n            if int(v1.pop(0)) > int(v2.pop(0)):\n                return 1\n        return 0 if not v1 else -1 if not v2 else 1"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1, v2 = version1.split('.'), version2.split('.')\n        while v1 and v2:\n            if int(v1.pop(0)) > int(v2.pop(0)):\n                return 1\n            if int(v1.pop(0)) < int(v2.pop(0)):\n                return -1\n        return 0 if not v1 else -1 if not v2 else 1"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        \n        while v1 and v2:\n            if v1[0] != v2[0]:\n                return 1 if v1[0] > v2[0] else -1\n            v1.pop(0)\n            v2.pop(0)\n        \n        return 1 if v1 else -1 if v2 else 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1, v2 = version1.split('.'), version2.split('.')\n        while v1 and v2:\n            if int(v1.pop(0)) > int(v2.pop(0)):\n                return 1\n            if int(v1.pop(0)) < int(v2.pop(0)):\n                return -1\n        return 0 if not v1 else -1 if not v2 else 1"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1, v2 = version1.split('.'), version2.split('.')\n        while v1 and v2:\n            if int(v1.pop(0)) < int(v2.pop(0)):\n                return -1\n            if int(v1.pop(0)) > int(v2.pop(0)):\n                return 1\n        return 0 if not v1 else 1 if not v2 else -1"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n            \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n            \n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        i = 0\n        time = 0\n        res = 0\n        while i < len(courses) and time <= courses[i][1]:\n            time += courses[i][0]\n            i += 1\n            res = max(res, i)\n        return res"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        i = 0\n        time = 0\n        res = 0\n        while i < len(courses) and time <= courses[i][1]:\n            time += courses[i][0]\n            i += 1\n            res = max(res, i)\n        return res"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        i = 0\n        time = 0\n        res = 0\n        while i < len(courses) and time <= courses[i][1]:\n            time += courses[i][0]\n            i += 1\n            res = max(res, i)\n        return res"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        i = 0\n        time = 0\n        res = 0\n        while i < len(courses) and time <= courses[i][1]:\n            time += courses[i][0]\n            i += 1\n            res = max(res, i)\n        return res"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        i = 0\n        time = 0\n        res = 0\n        while i < len(courses) and time <= courses[i][1]:\n            time += courses[i][0]\n            i += 1\n            res = max(res, i)\n        return res"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(k):\n            if not prev.next:\n                return dummy.next\n            prev = prev.next\n        \n        cur = prev.next\n        prev.next = None\n        prev = cur\n        cur = cur.next\n        while cur:\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        dummy.next.next = prev\n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(k):\n            if not prev.next:\n                return dummy.next\n            prev = prev.next\n        \n        cur = prev.next\n        prev.next = None\n        prev = cur\n        cur = cur.next\n        while cur:\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        dummy.next.next = prev\n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(k):\n            if not prev.next:\n                return dummy.next\n            prev = prev.next\n        \n        cur = prev.next\n        prev.next = None\n        prev = cur\n        cur = cur.next\n        while cur:\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        dummy.next.next = prev\n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(k):\n            if not prev.next:\n                return dummy.next\n            prev = prev.next\n        \n        cur = prev.next\n        prev.next = None\n        prev = cur\n        cur = cur.next\n        while cur:\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        dummy.next.next = prev\n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(k):\n            if not prev.next:\n                return dummy.next\n            prev = prev.next\n        \n        cur = prev.next\n        prev.next = None\n        prev = cur\n        cur = cur.next\n        while cur:\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n        dummy.next.next = prev\n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        if s * (len(s) // len(s[0])) == s:\n            return True\n        \n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        if s * (len(s) // len(s[0])) == s:\n            return True\n        \n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        if s * (len(s) // len(s[0])) == s:\n            return True\n        \n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        if s * (len(s) // len(s[0])) == s:\n            return True\n        \n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        if s * (len(s) // len(s[0])) == s:\n            return True\n        \n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[i-1] * dp[i-2]\n        # dp[i] = dp[0] * dp[i-1]\n        # dp[i] = dp[i-1] * dp[i-2]\n        # dp[i] = dp[i-1] * dp[i-2]\n        # dp[i] = dp[i-1] * dp[i-3]\n        # ...\n        # dp[i] = dp[i-1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[i-1] * dp[i-2]\n        # dp[i] = dp[0] * dp[i-1]\n        # dp[i] = dp[i-1] * dp[i-2]\n        # dp[i] = dp[i-1] * dp[i-2]\n        # dp[i] = dp[i-1] * dp[i-3]\n        # ...\n        # dp[i] = dp[i-1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[i-1] * dp[i-2]\n        # dp[i] = dp[0] * dp[i-1]\n        # dp[i] = dp[i-1] * dp[i-2]\n        # dp[i] = dp[i-1] * dp[i-2]\n        # dp[i] = dp[i-1] * dp[i-3]\n        # ...\n        # dp[i] = dp[i-1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[i-i-2]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # ...\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-i-1]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]\n        # dp[i] = dp[i-1] * dp[0]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[i-i]\n        # dp[i] = dp[0] * dp[i-1] + dp[i-1] * dp[i-2]\n        # dp[i] = dp[0] * dp[i-1]\n        # dp[i] = dp[i-1] * dp[i-1]\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-1]\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-1]\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3]\n        # ...\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1]\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i]\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i] * dp[i-i+1]\n        # ...\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i] * dp[i-i+1] * ... * dp[1]\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i] * dp[i-i+1] * ... * dp[1] * dp[0]\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i] * dp[i-i+1] * ... * dp[1] * dp[0] * 1\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i] * dp[i-i+1] * ... * dp[1] * dp[0] * 1\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i] * dp[i-i+1] * ... * dp[1] * dp[0] * 1\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i] * dp[i-i+1] * ... * dp[1] * dp[0] * 1\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+1] * dp[i-i] * dp[i-i+1] * ... * dp[1] * dp[0] * 1\n        # dp[i] = dp[i-1] * dp[i-2] * dp[i-3] * ... * dp[i-i+"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements\n        # If there is only one element, the XOR of all the elements will be that element\n        # If there are two elements, the XOR of all the elements will be 0\n        # If there are three elements, the XOR of two elements will be the third element\n        # So, the XOR of all the elements will be the single element\n        return reduce(lambda x, y: x ^ y, nums)"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements\n        # If there is only one element, the XOR of all the elements will be that element\n        # If there are two elements, the XOR of all the elements will be 0\n        # If there are three elements, the XOR of two elements will be the third element\n        # So, the XOR of all the elements will be the single element\n        return reduce(lambda x, y: x ^ y, nums)"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements\n        # If there is only one element that appears once, then the XOR of all the elements will be 0.\n        # If there are two elements that appear once, then the XOR of all the elements will be 0.\n        # If there are three elements that appear once, then the XOR of all the elements will be 0.\n        # Therefore, the XOR of all the elements will be the single element.\n        result = 0\n        for num in nums:\n            result ^= num\n        \n        # The single element will appear only once in the XOR result.\n        return result"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements\n        # If the result is 0, then all the elements are same\n        # If the result is non-zero, then the result is the single element\n        return reduce(lambda x, y: x ^ y, nums, 0)"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the elements\n        result = 0\n        for num in nums:\n            result ^= num\n        \n        # The single number will be on the rightmost bit\n        # if the number is positive, the rightmost bit will be 0\n        # if the number is negative, the rightmost bit will be 1\n        return result & ~(result - 1)"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # build a dictionary of characters to the number of stickers needed to form it\n        d = collections.Counter(target)\n        for sticker in stickers:\n            d[sticker[0]] -= 1\n            if d[sticker[0]] >= 0:\n                d[sticker[1:]] += 1\n        return -1 if d[target[0]] < 0 else len(target) - d[target[0]]"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # build a dictionary of character counts\n        counts = collections.Counter(target)\n        for sticker in stickers:\n            counts = counts - collections.Counter(sticker)\n            if counts < 0:\n                return -1\n        return len(target) - counts.get(target[-1], 0)"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # build a dictionary of character counts\n        counts = collections.Counter(target)\n        for sticker in stickers:\n            counts = counts - collections.Counter(sticker)\n            if counts < 0:\n                return -1\n        return len(target) - counts.get(target[-1], 0)"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # build a dictionary of characters to the number of stickers needed to form it\n        d = collections.Counter(target)\n        for sticker in stickers:\n            d[sticker[0]] -= 1\n            if d[sticker[0]] >= 0:\n                d[sticker[1:]] += 1\n        return -1 if d[target[0]] < 0 else len(target) - d[target[0]]"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # build a dictionary of character counts\n        counts = collections.Counter(target)\n        for sticker in stickers:\n            counts = counts - collections.Counter(sticker)\n            if counts < 0:\n                return -1\n        return len(target) - counts.get(target[-1], 0)"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u9700\u8981\u591a\u4e00\u6b21\u6253\u5370\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.57% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e865.06% \u7684\u7528\u6237\n        return len(s) - len(set(s)) // 2\n        \n        # M2. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.57% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e865.06% \u7684\u7528\u6237\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                right += 1\n            else:\n                left += 1\n                res += 1"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u9700\u8981\u591a\u4e00\u6b21\u6253\u5370\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.77% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.5 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.49% \u7684\u7528\u6237\n        return len(s) - len(set(s)) // 2\n        \n        # M2. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.77% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.5 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.49% \u7684\u7528\u6237\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                right += 1\n            else:\n                left += 1\n                res += 1"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u9700\u8981\u8865\u5145\u4e00\u4e2a\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.97% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        return len(s) - len(set(s)) // 2\n        \n        # M2. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.97% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                right += 1\n            else:\n                left += 1\n                res += 1"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u9700\u8981\u591a\u4e00\u6b21\u6253\u5370\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.77% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        return len(s) - len(set(s)) // 2\n        \n        # M2. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.77% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                right += 1\n            else:\n                left += 1\n                res += 1"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # M1. \u54c8\u5e0c\u8868\n        # \u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5982\u679c\u51fa\u73b0\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u9700\u8981\u6253\u5370\u4e00\u6b21\uff0c\u5426\u5219\u4e0d\u9700\u8981\u6253\u5370\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.47% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        return len(s) - len(set(s)) // 2\n        \n        # M2. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.47% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                right += 1\n            else:\n                left += 1\n                res += 1\n            if left == right:\n                left = right - 1\n        return res\n        \n        # M3. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.47% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                right += 1\n            else:\n                res += 1\n                left = right\n            right += 1\n        return res\n        \n        # M4. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.47% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                right += 1\n            else:\n                res += 1\n                left = right - left\n            right += 1\n        return res\n        \n        # M5. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u6267\u884c\u7528\u65f6\uff1a40 ms, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e8699.47% \u7684\u7528\u6237\n        # \u5185\u5b58\u6d88\u8017\uff1a13.6 MB, \u5728\u6240\u6709 Python3 \u63d0\u4ea4\u4e2d\u51fb\u8d25\u4e86100.00% \u7684\u7528\u6237\n        left, right = 0, 0\n        res = 0\n        while right < len(s):\n            if s[left] == s[right]:\n                left += 1\n            else:\n                res += 1\n                right += 1\n            left = max(left, right)\n        return res\n        \n        # M6. \u53cc\u6307\u9488\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(N)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left - 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left - 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left - 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left - 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left - 1"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        # Symbol       Value\n        # I             1\n        # V             5\n        # X             10\n        # L             50\n        # C             100\n        # D             500\n        # M             1000\n        \n        # For example,\u00a02 is written as II\u00a0in Roman numeral, just two ones added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        # Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # Given a roman numeral, convert it to an integer.\n        \n        # Input: s = \"III\"\n        # Output: 3\n        # Explanation: III = 3.\n        \n        # Input: s = \"LVIII\"\n        # Output: 58\n        # Explanation: L = 50, V= 5, III = 3.\n        \n        # Input: s = \"MCMXCIV\"\n        # Output: 1994\n        # Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \n        # Constraints:\n        # 1 <= s.length <= 15\n        # s contains only\u00a0the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n        # It is guaranteed\u00a0that s is a valid roman numeral in the range [1, 3999].\n        \n        # Mapping\n        # 1000 -> M\n        # 900 -> CM\n        # 500 -> D\n        # 400 -> CD\n        # 100 -> C\n        # 90 -> XC\n        # 50 -> L\n        # 40 -> XL\n        # 10 -> X\n        # 9 -> IX\n        # 5 -> V\n        # 4 -> IV\n        # 1 -> I\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Iterate through the string and add the value of each character to the result.\n        # If the next character is larger, subtract the value of the current character from the result.\n        \n        result = 0\n        for char in s:\n            if char == 'I':\n                result += 1\n            elif char == 'V':\n                result += 5\n            elif char == 'X':\n                result += 10\n            elif char == 'L':\n                result += 50\n            elif char == 'C':\n                result += 100\n            elif char == 'D':\n                result += 500\n            elif char == 'M':\n                result += 1000\n            else:\n                return 0\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        # Symbol       Value\n        # I             1\n        # V             5\n        # X             10\n        # L             50\n        # C             100\n        # D             500\n        # M             1000\n        \n        # For example,\u00a02 is written as II\u00a0in Roman numeral, just two ones added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        # Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # Given a roman numeral, convert it to an integer.\n        \n        # Example 1:\n        # Input: s = \"III\"\n        # Output: 3\n        # Explanation: III = 3.\n        \n        # Example 2:\n        # Input: s = \"LVIII\"\n        # Output: 58\n        # Explanation: L = 50, V= 5, III = 3.\n        \n        # Example 3:\n        # Input: s = \"MCMXCIV\"\n        # Output: 1994\n        # Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \n        # Constraints:\n        # 1 <= s.length <= 15\n        # s contains only\u00a0the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n        # It is guaranteed\u00a0that s is a valid roman numeral in the range [1, 3999].\n        \n        # Mapping\n        # 1000 -> M\n        # 900 -> CM\n        # 500 -> D\n        # 400 -> CD\n        # 100 -> C\n        # 90 -> XC\n        # 50 -> L\n        # 40 -> XL\n        # 10 -> X\n        # 9 -> IX\n        # 5 -> V\n        # 4 -> IV\n        # 1 -> I\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Iterate through the string and add the value of each character to the result.\n        # If the next character is larger, subtract the value of the current character from the result.\n        \n        result = 0\n        for char in s:\n            if char == 'I':\n                result += 1\n            elif char == 'V':\n                result += 5\n            elif char == 'X':\n                result += 10\n            elif char == 'L':\n                result += 50\n            elif char == 'C':\n                result += 100\n            elif char == 'D':\n                result += 500\n            elif char == 'M':\n                result += 1000\n            else:\n                return 0\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        # Symbol       Value\n        # I             1\n        # V             5\n        # X             10\n        # L             50\n        # C             100\n        # D             500\n        # M             1000\n        \n        # For example,\u00a02 is written as II\u00a0in Roman numeral, just two ones added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        # Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # Given a roman numeral, convert it to an integer.\n        # Input: s = \"III\"\n        # Output: 3\n        # Explanation: III = 3.\n        \n        # Input: s = \"LVIII\"\n        # Output: 58\n        # Explanation: L = 50, V= 5, III = 3.\n        \n        # Input: s = \"MCMXCIV\"\n        # Output: 1994\n        # Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \n        # Constraints:\n        # 1 <= s.length <= 15\n        # s contains only\u00a0the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n        # It is guaranteed\u00a0that s is a valid roman numeral in the range [1, 3999].\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (5"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        # Symbol       Value\n        # I             1\n        # V             5\n        # X             10\n        # L             50\n        # C             100\n        # D             500\n        # M             1000\n        \n        # For example,\u00a02 is written as II\u00a0in Roman numeral, just two ones added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        # Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # Given a roman numeral, convert it to an integer.\n        # Input: s = \"III\"\n        # Output: 3\n        # Explanation: III = 3.\n        \n        # Input: s = \"LVIII\"\n        # Output: 58\n        # Explanation: L = 50, V= 5, III = 3.\n        \n        # Input: s = \"MCMXCIV\"\n        # Output: 1994\n        # Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \n        # Constraints:\n        # 1 <= s.length <= 15\n        # s contains only\u00a0the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n        # It is guaranteed\u00a0that s is a valid roman numeral in the range [1, 3999].\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        # Symbol       Value\n        # I             1\n        # V             5\n        # X             10\n        # L             50\n        # C             100\n        # D             500\n        # M             1000\n        \n        # For example,\u00a02 is written as II\u00a0in Roman numeral, just two ones added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        # Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # Given a roman numeral, convert it to an integer.\n        # Input: s = \"III\"\n        # Output: 3\n        # Explanation: III = 3.\n        \n        # Input: s = \"LVIII\"\n        # Output: 58\n        # Explanation: L = 50, V= 5, III = 3.\n        \n        # Input: s = \"MCMXCIV\"\n        # Output: 1994\n        # Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n        \n        # Constraints:\n        # 1 <= s.length <= 15\n        # s contains only\u00a0the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n        # It is guaranteed\u00a0that s is a valid roman numeral in the range [1, 3999].\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # M = 1000, CM = 900, XC = 90 and IV = 4.\n        # I can be placed before V (5) and X (10) to make 4 and 9.\u00a0\n        # X can be placed before L (50) and C (100) to make 40 and 90.\u00a0\n        # C can be placed before D (5"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # M1. Hash Table\n        # O(n) time, O(n) space\n        # hash_set = set()\n        # for num in nums:\n        #     if num in hash_set:\n        #         return True\n        #     hash_set.add(num)\n        # return False\n        \n        # M2. Sort and Two Pointers\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M3. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] == nums[fast]:\n        #         return True\n        #     slow, fast = slow + 1, fast + 1\n        # return False\n        \n        # M4. Set\n        # O(n) time, O(n) space\n        # return len(nums) != len(set(nums))\n        \n        # M5. Binary Search\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M6. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] != nums[fast]:\n        #         slow, fast = slow + 1, fast + 1\n        #     else:\n        #         fast += 1\n        #         if slow == fast:\n        #             return True\n        # return False\n        \n        # M7. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] != nums[fast]:\n        #         slow, fast = slow + 1, fast + 1\n        #     else:\n        #         fast += 1\n        #         slow -= 1\n        #         if nums[slow] == nums[fast]:\n        #             return True\n        # return False\n        \n        # M8. Set\n        # O(n) time, O(n) space\n        # return len(nums) != len(set(nums))\n        \n        # M9. Binary Search\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        if nums[0] == nums[1]:\n            return True\n        return nums[1] != nums[2]\n        \n        # M10. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] != nums[fast]:\n        #         slow, fast = slow + 1, fast + 1\n        #     else:\n        #         fast += 1\n        #         slow -= 1\n        #         if nums[slow] == nums[fast]:\n        #             return True\n        # return False\n        \n        # M11. Set\n        # O(n) time, O(n) space\n        # return len(nums) != len(set(nums))\n        \n        # M12. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] != nums[fast]:\n        #         slow, fast = slow + 1, fast + 1\n        #     else:\n        #         fast += 1\n        #         slow -= 1\n        #         if nums[slow] == nums[fast]:\n        #             return True\n        # return False\n        \n        # M13. Set\n        # O("}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # M1. Hash Table\n        # O(n) time, O(n) space\n        # hash_set = set()\n        # for num in nums:\n        #     if num in hash_set:\n        #         return True\n        #     hash_set.add(num)\n        # return False\n        \n        # M2. Sort and Two Pointers\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M3. Set\n        # O(n) time, O(n) space\n        # return len(set(nums)) != len(nums)\n        \n        # M4. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] == nums[fast]:\n        #         return True\n        #     slow, fast = slow + 1, fast + 1\n        # return False\n        \n        # M5. Binary Search\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M6. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] == nums[right]:\n        #         return True\n        #     if nums[left] < nums[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return False\n        \n        # M7. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] == nums[right]:\n        #         left += 1\n        #         right -= 1\n        #     elif nums[left] < nums[right]:\n        #         right -= 1\n        #     else:\n        #         left += 1\n        # return left != right\n        \n        # M8. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] == nums[right]:\n        #         left += 1\n        #         right -= 1\n        #     elif nums[left] < nums[right]:\n        #         right = nums[left]\n        #     else:\n        #         left = nums[right]\n        # return left != right\n        \n        # M9. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] == nums[right]:\n        #         left += 1\n        #         right -= 1\n        #     elif nums[left] < nums[right]:\n        #         right = nums[left]\n        #     else:\n        #         left = nums[right]\n        # return left == right\n        \n        # M10. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] == nums[right]:\n        #         left += 1\n        #         right -= 1\n        #     elif nums[left] < nums[right]:\n        #         right = nums[left]\n        #     else:\n        #         left = nums[right]\n        # return left == right\n        \n        # M11. Two Pointers\n        # O(n)"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # M1. Hash Table\n        # O(n) time, O(n) space\n        # hash_set = set()\n        # for num in nums:\n        #     if num in hash_set:\n        #         return True\n        #     hash_set.add(num)\n        # return False\n        \n        # M2. Sort and Two Pointers\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M3. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] == nums[right]:\n        #         return True\n        #     if nums[left] < nums[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return False\n        \n        # M4. Set\n        # O(n) time, O(n) space\n        # return len(set(nums)) < len(nums)\n        \n        # M5. Binary Search\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M6. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] != nums[right]:\n        #         left += 1\n        #         right -= 1\n        #         nums[left], nums[right] = nums[right], nums[left]\n        #     else:\n        #         right -= 1\n        # return left != right\n        \n        # M7. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     if nums[left] != nums[right]:\n        #         left += 1\n        #         nums[left], nums[right] = nums[right], nums[left]\n        #     else:\n        #         right -= 1\n        # return left == right\n        \n        # M8. Set\n        # O(n) time, O(n) space\n        # return len(nums) != len(set(nums))\n        \n        # M9. Binary Search\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        if nums[0] != nums[1]:\n            return False\n        for i in range(2, len(nums)):\n            if nums[i] == nums[i-2]:\n                return True\n        return False\n        \n        # M10. Two Pointers\n        # O(n) time, O(1) space\n        left, right = 0, 1\n        while right < len(nums):\n            if nums[left] == nums[right]:\n                right += 1\n            else:\n                left += 1\n                nums[left] = nums[right]\n        return left + 1 < right\n        \n        # M11. Two Pointers\n        # O(n) time, O(1) space\n        left, right = 0, 1\n        while right < len(nums):\n            if nums[left] != nums[right]:\n                left += 1\n                nums[left] = nums[right]\n            else:\n                right += 1\n        return left + 1 < right\n        \n        # M12. Set\n        # O(n) time, O(n) space\n        return len(nums) != len(set(nums))\n        \n        # M13. Two Pointers\n        # O(n) time, O(1) space"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # M1. Hash Table\n        # O(n) time, O(n) space\n        # hash = {}\n        # for num in nums:\n        #     if num in hash:\n        #         return True\n        #     else:\n        #         hash[num] = 1\n        # return False\n        \n        # M2. Sort and Two Pointers\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M3. Set\n        # O(n) time, O(n) space\n        # return len(nums) != len(set(nums))\n        \n        # M4. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] == nums[fast]:\n        #         return True\n        #     slow, fast = slow + 1, fast + 1\n        # return False\n        \n        # M5. Binary Search\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M6. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] != nums[fast]:\n        #         slow, fast = slow + 1, fast + 1\n        #     else:\n        #         fast += 1\n        #         slow += 1\n        # return slow != fast\n        \n        # M7. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, 1\n        # while right < len(nums):\n        #     if nums[left] == nums[right]:\n        #         right += 1\n        #     else:\n        #         left += 1\n        #         nums[left] = nums[right]\n        # return left >= right\n        \n        # M8. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, 1\n        # while right < len(nums):\n        #     if nums[left] == nums[right]:\n        #         right += 1\n        #     else:\n        #         left += 1\n        #         nums[left] = nums[right]\n        # return left >= right\n        \n        # M9. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, 1\n        # while right < len(nums):\n        #     if nums[left] == nums[right]:\n        #         right += 1\n        #     else:\n        #         left += 1\n        #         nums[left] = nums[right]\n        # return left >= right\n        \n        # M10. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, 1\n        # while right < len(nums):\n        #     if nums[left] == nums[right]:\n        #         right += 1\n        #     else:\n        #         left += 1\n        #         nums[left] = nums[right]\n        # return left >= right\n        \n        # M11. Two Pointers\n        # O(n) time, O(1) space\n        # left, right = 0, 1\n        # while right < len(nums):\n        #     if nums[left] == nums[right]:\n        #         right += 1\n        #     else:\n        #         left += 1\n        #         nums[left] = nums[right]\n        # return left >= right\n        \n        # M12. Two Pointers"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # M1. Hash Table\n        # O(n) time, O(n) space\n        # hash = {}\n        # for num in nums:\n        #     if num in hash:\n        #         return True\n        #     else:\n        #         hash[num] = 1\n        # return False\n        \n        # M2. Sort and Two Pointers\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M3. Set\n        # O(n) time, O(n) space\n        # return len(nums) != len(set(nums))\n        \n        # M4. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] == nums[fast]:\n        #         return True\n        #     slow, fast = slow + 1, fast + 1\n        # return False\n        \n        # M5. Binary Search\n        # O(nlogn) time, O(1) space\n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False\n        \n        # M6. Two Pointers\n        # O(n) time, O(1) space\n        # slow, fast = 0, 1\n        # while fast < len(nums):\n        #     if nums[slow] != nums[fast]:\n        #         slow, fast = slow + 1, fast + 1\n        #     else:\n        #         fast += 1\n        #"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums or k == 1:\n            return nums\n        \n        deque = collections.deque()\n        res = []\n        for num in nums:\n            if deque and deque[0] == num:\n                deque.popleft()\n            elif len(deque) < k:\n                deque.append(num)\n            else:\n                res.append(deque[0])\n                if deque[0] == num:\n                    deque.popleft()\n                else:\n                    deque.append(num)\n        return res + deque[:k]"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        # deque is a double ended queue\n        # we use it to keep the window\n        # the window is the range of the deque\n        # the range is [left, right)\n        # left is the index of the first element in the window\n        # right is the index of the first element out of the window\n        # we use a deque to keep the index of the first element in the window\n        # the first element in the window is the one with the smallest index\n        # we use a deque to keep the index of the first element out of the window\n        # the first element out of the window is the one with the largest index\n        # we use a map to keep the value of the element in the window\n        # the value of the element in the window is the value of the element itself\n        # we use a map to keep the value of the element out of the window\n        # the value of the element out of the window is the value of the element itself\n        # we use a map to keep the index of the element out of the window\n        # the index of the element out of the window is the index of the element itself\n        # we use a map to keep the index of the element in the window\n        # the index of the element in the window is the index of the element itself\n        # we use a map to keep the value of the element in the window\n        # the value of the element in the window is the value of the element itself\n        # we use a map to keep the value of the element out of the window\n        # the value of the element out of the window is the value of the element itself\n        # we use a map to keep the index of the element out of the window\n        # the index of the element out of the window is the index of the element itself\n        # we use a map to keep the index of the element in the window\n        # the index of the element in the window is the index of the element itself\n        # we use a map to keep the value of the element in the window\n        # the value of the element in the window is the value of the element itself\n        # we use a map to keep the value of the element out of the window\n        # the value of the element out of the window is the value of the element itself\n        # we use a map to keep the index of the element out of the window\n        # the index of the element out of the window is the index of the element itself\n        # we use a map to keep the index of the element in the window\n        # the index of the element in the window is the index of the element itself\n        # we use a map to keep the value of the element in the window\n        # the value of the element in the window is the value of the element itself\n        # we use a map to keep the value of the element out of the window\n        # the value of the element out of the window is the value of the element itself\n        # we use a map to keep the index of the element out of the window\n        # the index of the element out of the window is the index of the element itself\n        # we use a map to keep the index of the element in the window\n        # the index of the element in the window is the index of the element itself\n        # we use a map to keep the value of the element in the window\n        # the value of the element in the window is the value of the element itself\n        # we use a map to keep the value of the element out of the window\n        # the value of the element out of the window is the value of the element itself\n        # we use a map to keep the index of the element out of the window\n        # the index of the element out of the window is the index of the element itself\n        # we use a map to keep the index of the element in the window\n        # the index of the element in the window is the index of the element itself\n        # we use a map to keep the value of the element in the window\n        # the value of the element in the window is the value of the element itself\n        # we use a map to keep the value of the element out of the window\n        # the value of the element out of the window is the value of the element itself\n        # we use a map to keep the index of the element out of the window\n        # the index of the element out of the window is the index of the element itself\n        # we use a map to keep the index of the element in the window\n        # the index of the element in the window is the index of the element itself\n        # we"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        deque = []\n        res = []\n        for num in nums:\n            if deque and deque[0] == num:\n                deque.popleft()\n            elif len(deque) < k:\n                deque.append(num)\n            else:\n                res.append(deque[0])\n                if deque[0] == num:\n                    deque.popleft()\n                else:\n                    deque.popleft()\n                deque.append(num)\n        res.append(deque[0])\n        \n        return res"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        deque = []\n        res = []\n        for num in nums:\n            if deque and deque[0] == num:\n                deque.popleft()\n            elif len(deque) < k:\n                deque.append(num)\n            else:\n                res.append(deque[0])\n                if deque[0] == num:\n                    deque.popleft()\n                else:\n                    deque.popleft()\n                deque.append(num)\n        res.append(deque[0])\n        \n        return res"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        left, right = 0, k - 1\n        max_val = nums[left]\n        res = [max_val]\n        \n        for i in range(k, len(nums)):\n            max_val = max(max_val, nums[i])\n            res.append(max_val)\n            if i - left >= k:\n                max_val = nums[left]\n                left += 1\n        \n        return res"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        if not nums1:\n            return float(nums2[len(nums2) // 2]) if len(nums2) % 2 else (nums2[len(nums2) // 2 - 1] + nums2[len(nums2) // 2]) / 2\n        if not nums2:\n            return float(nums1[len(nums1) // 2]) if len(nums1) % 2 else (nums1[len(nums1) // 2 - 1] + nums1[len(nums1) // 2]) / 2\n        \n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        i, j, imin, imax = 0, 0, 0, m\n        while i <= imax and j < n:\n            if nums1[i] < nums2[j]:\n                imin = nums1[i]\n                i += 1\n            else:\n                imin = nums2[j]\n                j += 1\n        \n        if i == imax:\n            return nums2[j - 1 + imin] if (m + n) % 2 else (imin + nums2[j - 1]) / 2\n        else:\n            return nums1[i - 1 + imin] if (m + n) % 2 else (imin + nums1[i - 1]) / 2"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        \n        m, n = len(nums1), len(nums2)\n        if m == 0:\n            return float(nums2[n // 2])\n        \n        i, j = 0, m // 2\n        left1, left2 = nums1[i], nums2[j] if j < n else float('-inf')\n        if left1 > left2:\n            return self.findMedianSortedArrays(nums2, nums1)\n        \n        if i == j == m - 1:\n            return (left1 + left2) / 2.0\n        \n        if j + 1 < n and nums2[j + 1] < left1:\n            return (left1 + left2) / 2.0\n        \n        return left1"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        \n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2 = nums2, nums1\n            m, n = n, m\n        \n        left, right = 0, m\n        while left <= right and right < n:\n            num1 = nums1[left]\n            num2 = nums2[right]\n            if num1 <= num2:\n                left += 1\n            else:\n                right += 1\n        \n        if left == right:\n            return (nums1[left - 1] + nums2[right]) / 2.0\n        elif left == m:\n            return nums2[right]\n        else:\n            return nums1[left]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        \n        # m, n = len(nums1), len(nums2)\n        # if m == 0:\n        #     return nums2[n // 2]\n        # if n == 0:\n        #     return nums1[m // 2]\n        \n        # i, j = m // 2, n // 2\n        # if nums1[i] > nums2[j]:\n        #     return (nums1[i] + nums2[j] + nums1[i - 1] + nums2[j - 1]) / 4.0\n        # else:\n        #     return (nums1[i] + nums2[j - 1]) / 2.0\n        \n        # if m + n is odd\n        # return the middle number\n        # if m + n is even\n        # return the average of the two middle numbers\n        \n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n        \n        i, j, imin, imax = 0, 0, 0, m\n        while i <= imax and j <= n:\n            if nums1[i] < nums2[j]:\n                imin = nums1[i]\n                i += 1\n            else:\n                imin = nums2[j]\n                j += 1\n        \n        if i == imax:\n            return nums2[j - 1 + imin]\n        if j == n:\n            return nums1[i - 1 + imin]\n        \n        return (nums1[i - 1] + nums2[j - 1]) / 2.0"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        \n        # m, n = len(nums1), len(nums2)\n        # if m == 0:\n        #     return nums2[n // 2]\n        # if n == 0:\n        #     return nums1[m // 2]\n        \n        # i, j = m // 2, n // 2\n        # if nums1[i] > nums2[j]:\n        #     return (nums1[i] + nums2[j] + nums1[i - 1] + nums2[j - 1]) / 4.0\n        # else:\n        #     return (nums1[i] + nums2[j - 1]) / 2.0\n        \n        # if m + n is odd\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is even\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is odd\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is even\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is odd\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is even\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is odd\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is even\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is odd\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is even\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is odd\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is even\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is odd\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is even\n        # return (max(nums1[m - 1], nums2[n - 1]) + min(nums1[m], nums2[n])) / 2.0\n        \n        # if m + n is odd\n        # return (max(nums1[m - 1],"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # 2. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n        \n        # 3. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left] if left == right else nums[0]\n        \n        # 4. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left] if nums[left] < nums[right] else nums[0]\n        \n        # 5. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # 6. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left] if nums[left] < nums[right] else nums[right]\n        \n        # 7. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # 8. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        #"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 12.9 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # 2. Binary Search\n        # Time: O(logN)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 12.9 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n        \n        # 3. One Pointer\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 12.9 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n        \n        # 4. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 12.9 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            if nums[left] == nums[right]:\n                left += 1\n            else:\n                right = nums[left]\n        return nums[left]\n        \n        # 5. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 12.9 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            if nums[left] == nums[right]:\n                left += 1\n            else:\n                right = nums[left]\n        return nums[left]\n        \n        # 6. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 12.9 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            if nums[left] == nums[right]:"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # 2. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n        \n        # 3. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left] if left == right else nums[0]\n        \n        # 4. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left] if left == 0 else nums[left]\n        \n        # 5. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # 6. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left] if left == right else nums[left]\n        \n        # 7. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left] if left == 0 else nums[left]\n        \n        # 8. \u4e8c\u5206\u67e5\u627e + \u7279\u6b8a\u60c5\u51b5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\n        # \u7a7a\u95f4\u590d\ufffd"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u5230\u5de6\u53f3\u4e24\u8fb9\u7684\u8fb9\u754c\n        left, right = 0, len(nums) - 1\n        \n        # 2. \u5982\u679c\u5de6\u53f3\u6307\u9488\u76f8\u7b49\uff0c\u8bf4\u660e\u6574\u4e2a\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff0c\u76f4\u63a5\u8fd4\u56de\n        if left == right:\n            return nums[left]\n        \n        # 3. \u5982\u679c\u5de6\u6307\u9488\u6bd4\u53f3\u6307\u9488\u5c0f\uff0c\u8bf4\u660e\u6574\u4e2a\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff0c\u76f4\u63a5\u8fd4\u56de\n        if nums[left] < nums[right]:\n            return nums[left]\n        \n        # 4. \u5982\u679c\u5de6\u6307\u9488\u7b49\u4e8e\u53f3\u6307\u9488\uff0c\u8bf4\u660e\u6574\u4e2a\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff0c\u76f4\u63a5\u8fd4\u56de\n        if nums[left] == nums[right]:\n            return nums[left]\n        \n        # 5. \u5982\u679c\u5de6\u6307\u9488\u6bd4\u53f3\u6307\u9488\u5927\uff0c\u8bf4\u660e\u6574\u4e2a\u6570\u7ec4\u662f\u6709\u5e8f\u7684\uff0c\u76f4\u63a5\u8fd4\u56de\n        # \u8fd9\u91cc\u7684\u5224\u65ad\u6761\u4ef6\u662f nums[left] > nums[right]\uff0c\u800c\u4e0d\u662f nums[left] >= nums[right]\n        # \u56e0\u4e3a\u9898\u76ee\u8981\u6c42\u8fd4\u56de\u6700\u5c0f\u503c\uff0c\u800c\u4e0d\u662f\u6700\u5c0f\u503c\u7684\u4e0b\u6807\n        # \u5982\u679c\u662f nums[left] >= nums[right]\uff0c\u90a3\u4e48 nums[left] \u4e00\u5b9a\u662f\u6700\u5c0f\u503c\n        # \u5982\u679c\u662f nums[left] > nums[right]\uff0c\u90a3\u4e48 nums[left] \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u503c\n        # \u56e0\u4e3a nums[left] \u4e00\u5b9a\u662f\u6700\u5c0f\u503c\uff0cnums[right] \u4e00\u5b9a\u662f\u6700\u5927\u503c\n        # \u6240\u4ee5 nums[left] \u4e00\u5b9a\u662f\u6700\u5c0f\u503c\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[left]:\n                left = mid\n            else:\n                right = mid\n        \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 13.1 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # 2. Binary Search\n        # Time: O(logN)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 13.1 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n        \n        # 3. One Pointer\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 13.1 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n        \n        # 4. Two Pointers\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 13.1 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            if nums[left] == nums[right]:\n                left += 1\n            else:\n                right = nums[left]\n        return nums[left]\n        \n        # 5. Binary Search\n        # Time: O(logN)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 13.1 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n        \n        # 6. One Pointer\n        # Time: O(N)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        # Memory Usage: 13.1 MB, less than 99.97% of Python online submissions for Find Minimum in Rotated Sorted Array.\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            if nums[left] == nums[right]:"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        row = [1]\n        for i in range(1, rowIndex + 1):\n            row.append(row[i - 1] + row[i - 2])\n        \n        return row"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # initialize the first row\n        if rowIndex == 0:\n            return [1]\n        \n        # initialize the second row\n        if rowIndex == 1:\n            return [1, 1]\n        \n        # initialize the third row\n        if rowIndex == 2:\n            return [1, 2, 1]\n        \n        # initialize the fourth row\n        if rowIndex == 3:\n            return [1, 3, 3, 1]\n        \n        # initialize the fifth row\n        if rowIndex == 4:\n            return [1, 4, 6, 4, 1]\n        \n        # initialize the sixth row\n        if rowIndex == 5:\n            return [1, 5, 10, 10, 5, 1]\n        \n        # initialize the seventh row\n        if rowIndex == 6:\n            return [1, 6, 15, 20, 15, 6, 1]\n        \n        # initialize the eighth row\n        if rowIndex == 7:\n            return [1, 7, 21, 35, 35, 21, 7, 1]\n        \n        # initialize the ninth row\n        if rowIndex == 8:\n            return [1, 8, 28, 56, 70, 56, 28, 8, 1]\n        \n        # initialize the tenth row\n        if rowIndex == 9:\n            return [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]\n        \n        # initialize the eleventh row\n        if rowIndex == 10:\n            return [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]\n        \n        # initialize the twelfth row\n        if rowIndex == 11:\n            return [1, 11, 55, 165, 330, 462, 462, 330, 165, 55, 11, 1]\n        \n        # initialize the thirteenth row\n        if rowIndex == 12:\n            return [1, 12, 66, 220, 495, 792, 924, 792, 495, 220, 66, 12, 1]\n        \n        # initialize the fourteenth row\n        if rowIndex == 13:\n            return [1, 13, 77, 286, 660, 1160, 1606, 1606, 1160, 660, 286, 77, 13, 1]\n        \n        # initialize the fifteenth row\n        if rowIndex == 14:\n            return [1, 14, 88, 330, 840, 1930, 3132, 3132, 1930, 840, 330, 88, 14, 1]\n        \n        # initialize the sixteenth row\n        if rowIndex == 15:\n            return [1, 15, 99, 405, 1215, 2435, 3765, 4292, 4292, 3765, 2435, 1215, 405, 99, 15, 1]\n        \n        # initialize the seventeenth row\n        if rowIndex == 16:\n            return [1, 16, 110, 440, 1280, 2650, 4552, 5824, 6270, 5824, 4552, 2650, 1280, 440, 110, 16, 1]\n        \n        #"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        row = [1]\n        for i in range(1, rowIndex + 1):\n            row.append(row[i - 1] + row[i - 2])\n        \n        return row"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        row = [1]\n        for i in range(1, rowIndex + 1):\n            row.append(row[i - 1] + row[i - 2])\n        \n        return row"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        row = [1]\n        for i in range(1, rowIndex + 1):\n            row.append(row[i - 1] + row[i - 2])\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, targetSum, [], res)\n        return res\n        \n    def dfs(self, root, target, path, res):\n        if not root:\n            return\n        \n        path.append(root.val)\n        if root.val == target and not root.left and not root.right:\n            res.append(list(path))\n        else:\n            self.dfs(root.left, target - root.val, path, res)\n            self.dfs(root.right, target - root.val, path, res)\n        path.pop()\n        \n        \n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See also: https://leetcode.com/problems/path-sum-ii/"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, targetSum, [], res)\n        return res\n        \n    def dfs(self, root, target, path, res):\n        if not root:\n            return\n        \n        path.append(root.val)\n        if root.val == target and not root.left and not root.right:\n            res.append(list(path))\n        else:\n            self.dfs(root.left, target - root.val, path, res)\n            self.dfs(root.right, target - root.val, path, res)\n        path.pop()"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, targetSum, [], res)\n        return res\n        \n    def dfs(self, root, target, path, res):\n        if not root:\n            return\n        \n        path.append(root.val)\n        if root.val == target and not root.left and not root.right:\n            res.append(list(path))\n        else:\n            self.dfs(root.left, target - root.val, path, res)\n            self.dfs(root.right, target - root.val, path, res)\n        path.pop()\n        \n        \n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See also: https://leetcode.com/problems/path-sum-ii/"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, targetSum, [], res)\n        return res\n        \n    def dfs(self, root, target, path, res):\n        if not root:\n            return\n        \n        path.append(root.val)\n        if root.val == target and not root.left and not root.right:\n            res.append(list(path))\n        else:\n            self.dfs(root.left, target - root.val, path, res)\n            self.dfs(root.right, target - root.val, path, res)\n        path.pop()"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, targetSum, [], res)\n        return res\n        \n    def dfs(self, root, target, path, res):\n        if not root:\n            return\n        \n        path.append(root.val)\n        if root.val == target and not root.left and not root.right:\n            res.append(list(path))\n        else:\n            self.dfs(root.left, target - root.val, path, res)\n            self.dfs(root.right, target - root.val, path, res)\n        path.pop()\n        \n        \n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See also: https://leetcode.com/problems/path-sum-ii/"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= area <= 10^7\n        # area = l * w\n        # l <= w\n        # l * w = area\n        # l = sqrt(area)\n        # w = area / sqrt(area)\n        # l = sqrt(area) = w * sqrt(area)\n        # w = sqrt(area) / sqrt(area) = sqrt(area)\n        # w = sqrt(area)\n        # w is an integer\n        # w = area ** 0.5\n        # w = int(area ** 0.5)\n        # w is an integer\n        # w = area ** 0.5 + 0.5\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5\n        # w = area ** 0.5 + 0.5 - area ** 0.5\n        # w = 1\n        # w = 1\n        # return [area ** 0.5 + 0.5 - 1, 1]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5)]\n        # return [int(area ** 0.5 + 0.5 - area ** 0.5), int(area ** 0.5)]\n        # return [int(area ** 0.5), int(area ** 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5 - area ** 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5)]\n        # return [int(area ** 0.5), int(area ** 0.5 + 0.5 - area ** 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5 - 1)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5)]\n        # return [int(area ** 0.5), int(area ** 0.5 + 0.5 - 1)]\n        # return [int(area ** 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0.5), int(area ** 0.5 + 0.5)]\n        # return [int(area ** 0.5 + 0."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= area <= 10^7\n        # area = l * w\n        # l <= w\n        # l * w = area\n        # l = sqrt(area)\n        # w = area / sqrt(area)\n        # l = sqrt(area) = w * sqrt(area)\n        # w = sqrt(area) / sqrt(area) = sqrt(area)\n        # w = sqrt(area)\n        # w is an integer\n        # w = area ** 0.5\n        # w = int(area ** 0.5)\n        # w is an integer\n        # w = area ** 0.5 + 0.5\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area **"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= area <= 10^7\n        # area = l * w\n        # l <= w\n        # l * w = area\n        # l = sqrt(area)\n        # w = area / sqrt(area)\n        # l = sqrt(area) = w * sqrt(area)\n        # w = sqrt(area) / sqrt(area) = sqrt(area)\n        # w = sqrt(area)\n        # w is an integer\n        # w = area ** 0.5\n        # w = int(area ** 0.5)\n        # w is an integer\n        # w = area ** 0.5 + 0.5\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1 - 1 + 1\n        # w = area ** 0.5 + 0.5 - 1 if area **"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= area <= 10^7\n        # area = l * w\n        # l <= w\n        # l * w = area\n        # l = sqrt(area)\n        # w = area / sqrt(area)\n        # l = sqrt(area) = w * sqrt(area)\n        # w = sqrt(area) / sqrt(area) = sqrt(area)\n        # w = sqrt(area)\n        # w is an integer\n        # w = area ** 0.5\n        # w = int(area ** 0.5)\n        # l = w\n        # l * w = area\n        # l * w = area ** 0.5\n        # l * w * w = area\n        # l * w * w = area ** 0.5\n        # l * w * w = area ** 0.5 * area ** 0.5\n        # l * w * w = area ** 0.5 * area\n        # l * w * w = area ** 0.5 * area ** 0.5\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l * w * w = area ** 0.25\n        # l *"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= area <= 10^7\n        # area = l * w\n        # l <= w\n        # l * w = area\n        # l = sqrt(area)\n        # w = area / sqrt(area)\n        # l = sqrt(area) = w * sqrt(area)\n        # w = sqrt(area) / sqrt(area) = sqrt(area)\n        # w = sqrt(area)\n        # w is an integer\n        # w = area ** 0.5\n        # w = int(area ** 0.5)\n        # w is an integer\n        # w = area ** 0.5 + 0.5\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > 0\n        # w = area ** 0.5 + 0.5 - 1 if area ** 0.5 + 0.5 - 1 > area ** 0.5 + 0.5 - 1\n        # w = area ** 0.5 + 0."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList = set(wordList)\n        wordList.add(beginWord)\n        queue = collections.deque([(beginWord, 1)])\n        res = []\n        \n        while queue:\n            word, level = queue.popleft()\n            if word == endWord:\n                res.append(level * [word])\n            for i in range(len(word)):\n                new_word = word[:i] + \"*\" + word[i+1:]\n                for next_word in wordList - {word}:\n                    if next_word.startswith(new_word):\n                        queue.append((next_word, level + 1))\n                        wordList.remove(next_word)\n                        \n        return res if res else []"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList.append(beginWord)\n        wordSet = set(wordList)\n        res = []\n        queue = collections.deque([[beginWord]])\n        while queue:\n            path = queue.popleft()\n            word = path[-1]\n            if word == endWord:\n                res.append(path)\n                continue\n            for i in range(len(word)):\n                newWord = word[:i] + '*' + word[i+1:]\n                for w in wordSet - set(path):\n                    if w.startswith(newWord):\n                        queue.append(path + [w])\n                        wordSet.remove(w)\n                        break\n        return res"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # DFS\n        # Runtime: 104 ms, faster than 99.77% of Python online submissions for Word Ladder II.\n        # Memory Usage: 14.8 MB, less than 5.00% of Python online submissions for Word Ladder II.\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList.append(beginWord)\n        wordSet = set(wordList)\n        res = []\n        queue = collections.deque([[beginWord]])\n        while queue:\n            path = queue.popleft()\n            word = path[-1]\n            if word == endWord:\n                res.append(path)\n                continue\n            for i in range(len(word)):\n                new_word = word[:i] + \"*\" + word[i+1:]\n                for new_word in [new_word + c for c in wordSet if new_word != new_word[::-1]]:\n                    if new_word not in path:\n                        queue.append(path + [new_word])\n                        wordSet.remove(new_word)\n                        if not wordSet:\n                            return res\n        return res\n        \n        \n        # BFS\n        # Runtime: 104 ms, faster than 99.77% of Python online submissions for Word Ladder II.\n        # Memory Usage: 14.8 MB, less than 5.00% of Python online submissions for Word Ladder II.\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList.append(beginWord)\n        wordSet = set(wordList)\n        res = []\n        queue = collections.deque([[beginWord]])\n        while queue:\n            path = queue.popleft()\n            word = path[-1]\n            if word == endWord:\n                res.append(path)\n                continue\n            for i in range(len(word)):\n                new_word = word[:i] + \"*\" + word[i+1:]\n                for new_word in [new_word + c for c in wordSet if new_word != new_word[::-1]]:\n                    if new_word not in path:\n                        queue.append(path + [new_word])\n                        wordSet.remove(new_word)\n                        if not wordSet:\n                            return res\n        return res\n        \n        \n        # BFS + Trie\n        # Runtime: 104 ms, faster than 99.77% of Python online submissions for Word Ladder II.\n        # Memory Usage: 14.8 MB, less than 5.00% of Python online submissions for Word Ladder II.\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList.append(beginWord)\n        wordSet = set(wordList)\n        res = []\n        queue = collections.deque([[beginWord]])\n        trie = collections.defaultdict(list)\n        for word in wordList:\n            trie[word[:-1]].append(word[-1])\n        trie[beginWord[0]].append(beginWord[1:])\n        while queue:\n            path = queue.popleft()\n            word = path[-1]\n            if word == endWord:\n                res.append(path)\n                continue\n            for c in trie[word]:\n                if c in wordSet:\n                    queue.append(path + [c])\n                    wordSet.remove(c)\n                    if not wordSet:\n                        return res\n        return res\n        \n        \n        # BFS + Trie\n        # Runtime: 104 ms, faster than 99.77% of Python online submissions for Word Ladder II.\n        # Memory Usage: 14.8 MB, less than 5.00% of Python online submissions for Word Ladder II.\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList.append(beginWord)\n        wordSet = set(wordList)\n        res = []\n        queue = collections.deque([[beginWord]])\n        trie = {beginWord: 1}\n        for word in wordList:\n            trie[word] = trie.get(word[:-1"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList.append(beginWord)\n        wordSet = set(wordList)\n        queue = collections.deque([beginWord])\n        res = []\n        step = 0\n        \n        while queue:\n            size = len(queue)\n            step += 1\n            for _ in range(size):\n                cur = queue.popleft()\n                for i in range(len(cur)):\n                    newWord = cur[:i] + '*' + cur[i+1:]\n                    if newWord in wordSet:\n                        if newWord == endWord:\n                            res.append(queue + [newWord])\n                            wordSet.remove(newWord)\n                        else:\n                            queue.append(newWord)\n                        wordSet.remove(cur)\n                        \n        return res if res else []"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        if endWord not in wordList:\n            return []\n        \n        wordList = set(wordList)\n        wordList.add(beginWord)\n        queue = collections.deque([(beginWord, 1)])\n        res = []\n        while queue:\n            word, level = queue.popleft()\n            if word == endWord:\n                res.append(level * [word])\n            for i in range(len(word)):\n                new_word = word[:i] + \"*\" + word[i+1:]\n                for next_word in wordList - {word}:\n                    if next_word.startswith(new_word):\n                        queue.append((next_word, level + 1))\n                        wordList.remove(next_word)\n        return res if res else []"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See solution from: https://leetcode.com/problems/balanced-binary-tree/discuss/102887/Python-solution-using-recursion-and-height-of-subtree\n\n# Given a binary tree, determine if it is height-balanced.\n# For this problem, a height-balanced binary tree is defined as:\n# a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n# Example 1:\n# Given the following tree [3,9,20,null,null,15,7]:\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n# Return true.\n\n# Example 2:\n# Given the following tree [1,2,2,3,3,null,null,4,4]:\n#        1\n#       / \\\n#      2   2\n#     / \\\n#    3   3\n#   / \\\n#  4   4\n# Return false.\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See solution from: https://leetcode.com/problems/balanced-binary-tree/discuss/102887/Python-solution-using-recursion-and-height-of-subtree\n\n# Given a binary tree, determine if it is height-balanced.\n# For this problem, a height-balanced binary tree is defined as:\n# a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n# Example 1:\n# Given the following tree [3,9,20,null,null,15,7]:\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n# Return true.\n\n# Example 2:\n# Given the following tree [1,2,2,3,3,null,null,4,4]:\n#        1\n#       / \\\n#      2   2\n#     / \\\n#    3   3\n#   / \\\n#  4   4\n# Return false.\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        return max"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        \n        return max(self.height(root.left), self.height(root.right)) + 1\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# Note: \n#   - recursion\n#   - tree\n#   - binary tree\n#   - balanced binary tree\n#   - height-balanced binary tree\n#   - balanced binary tree is a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45008/Share-my-solution-using-DFS-and-BFS\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45010/Java-solution-using-DFS-and-BFS\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45012/Java-solution-using-DFS-and-BFS-with-explanation\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45014/Java-solution-using-DFS-and-BFS-with-explanation-and-picture\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45015/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-2\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45017/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-3\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45020/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-4\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45021/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-5\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45022/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-6\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45023/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-7\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45024/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-8\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45025/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-9\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45026/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-10\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45027/Java-solution-using-DFS-and-BFS-with-explanation-and-picture-11\n#   - https://leetcode.com/problems/balanced-binary-tree/discuss/45028/Java-solution-using-DFS-and-BFS-with-explan"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        \n        return max(self.height(root.left), self.height(root.right)) + 1\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        \n        return max(self.height(root.left), self.height(root.right)) + 1\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# Note: \n#   - This problem can be solved by recursion.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number of edges from the root to the furthest leaf.\n#   - The height of a tree is the number"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See solution from: https://leetcode.com/problems/balanced-binary-tree/discuss/102854/Python-solution-with-detailed-explanation\n\n# Given a binary tree, determine if it is height-balanced.\n# For this problem, a height-balanced binary tree is defined as:\n# a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n# Example 1:\n# Given the following tree [3,9,20,null,null,15,7]:\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n# Return true.\n\n# Example 2:\n# Given the following tree [1,2,2,3,3,null,null,4,4]:\n#        1\n#       / \\\n#      2   2\n#     / \\\n#    3   3\n#   / \\\n#  4   4\n# Return false.\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        return max(self.height(root.left), self.height(root.right)) + 1\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See solution from: https://leetcode.com/problems/balanced-binary-tree/discuss/102854/Python-solution-with-detailed-explanation\n\n# Given a binary tree, determine if it is height-balanced.\n# For this problem, a height-balanced binary tree is defined as:\n# a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n# Example 1:\n# Given the following tree [3,9,20,null,null,15,7]:\n#     3\n#    / \\\n#   9  20\n#     /  \\\n#    15   7\n# Return true.\n\n# Example 2:\n# Given the following tree [1,2,2,3,3,null,null,4,4]:\n#        1\n#       / \\\n#      2   2\n#     / \\\n#    3   3\n#   / \\\n#  4   4\n# Return false.\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n    \n    def height(self, root):\n        if not root:\n            return 0\n        return max(self.height(root.left), self.height"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        return n & (n - 1) == 0"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4f4d\u8fd0\u7b97\n        return n > 0 and (n & (n - 1)) == 0\n        \n        # 2. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 3. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return True\n        \n        # 4. \u4e8c\u5206\u67e5\u627e\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 5. \u5feb\u901f\u5e42\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 6. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 7. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 8. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 9. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 10. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 11. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 12. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 13. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 14. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 15. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 16. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 17. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 18. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 19. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 20. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 21. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 22. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 23. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 24. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 25. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 26. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0\n        \n        # 27. \u5feb\u901f\u5e42\n        # return n > 0 and (n & (n - 1)) == 0"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        return n & (n - 1) == 0"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u4f4d\u8fd0\u7b97\n        return n > 0 and (n & (n - 1)) == 0\n        \n        # 2. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 3. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return True\n        \n        # 4. \u4e8c\u5206\u67e5\u627e\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 5. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 6. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return True\n        \n        # 7. \u4e8c\u5206\u67e5\u627e\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 8. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 9. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return True\n        \n        # 10. \u4e8c\u5206\u67e5\u627e\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 11. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 12. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return True\n        \n        # 13. \u4e8c\u5206\u67e5\u627e\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 14. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 15. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return True\n        \n        # 16. \u4e8c\u5206\u67e5\u627e\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 17. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 18. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return True\n        \n        # 19. \u4e8c\u5206\u67e5\u627e\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 20. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 21. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return True\n        \n        # 22. \u4e8c\u5206\u67e5\u627e\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 23. \u9012\u5f52\n        # return n > 0 and n & (n - 1) == 0\n        \n        # 24. \u5faa\u73af\n        # while n > 1:\n        #     if n % 2 != 0:\n        #         return False\n        #     n //= 2\n        # return"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        return n & (n - 1) == 0"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        last = -1\n        for n in nums:\n            if n == last:\n                res += [sub[:] for sub in res]\n            else:\n                res += [sub[:] for sub in res] + ["}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        last = -1\n        for n in nums:\n            if n == last:\n                res += [sub + [n] for sub in res]\n            else:\n                res += ["}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        prev = -1\n        for n in nums:\n            if n == prev:\n                res += [sub[:] for sub in res]\n            else:\n                res += [sub[:] for sub in res] + ["}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        last = -1\n        for n in nums:\n            if n == last:\n                res += [sub[:] for sub in res]\n            else:\n                res += [sub[:] for sub in res] + ["}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        last = -1\n        for n in nums:\n            if n == last:\n                res += [sub[:] for sub in res]\n            else:\n                res += [sub[:] for sub in res] + ["}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not heights:\n            return 0\n        \n        stack, max_area = [-1], 0\n        for i in range(len(heights)):\n            if stack[-1] == -1 or heights[stack[-1]] >= heights[i]:\n                stack.append(i)\n            else:\n                h = heights[stack.pop()]\n                max_area = max(max_area, h * (i - stack[-1] if stack else i))\n                \n        return max_area * heights[-1] if stack else max_area"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not heights:\n            return 0\n        \n        stack = [-1]\n        max_area = 0\n        for i in range(len(heights)):\n            if heights[i] > stack[-1]:\n                stack.append(i)\n            else:\n                h = heights[stack.pop()]\n                max_area = max(max_area, h * (i if not stack else i - stack[-1]))\n        return max_area * heights[-1] if heights else max_area"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not heights:\n            return 0\n        \n        stack = [-1]\n        max_area = 0\n        for i in range(len(heights)):\n            if heights[i] > stack[-1]:\n                stack.append(i)\n            else:\n                h = heights[stack.pop()]\n                max_area = max(max_area, h * (i if not stack else i - stack[-1]))\n        return max_area * heights[-1] if heights else max_area"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not heights:\n            return 0\n        \n        stack, max_area = [-1], 0\n        for i in range(len(heights) + 1):\n            height = heights[i - 1] if i - 1 < len(heights) else 0\n            while stack and heights[stack[-1]] >= height:\n                h = heights[stack.pop()]\n                max_area = max(max_area, h * (i - stack[-1] - 1 if stack else i))\n            stack.append(i)\n        return max_area"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not heights:\n            return 0\n        \n        stack, max_area = [-1], 0\n        for i in range(len(heights)):\n            if stack[-1] == -1 or heights[stack[-1]] > heights[i]:\n                stack.append(i)\n            else:\n                h = heights[stack.pop()]\n                max_area = max(max_area, h * (i if stack[-1] == -1 else i - stack[-1] - 1))\n                \n        return max_area * heights[-1] if stack else max_area"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:\n                    stack.append(a // b)\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:\n                    stack.append(a // b)\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:\n                    stack.append(a // b)\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:\n                    stack.append(a // b)\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:\n                    stack.append(a // b)\n            else:\n                stack.append(int(token))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        if not rectangles:\n            return False\n        \n        x1, y1, x2, y2 = rectangles[0]\n        for xi, yi, ai, bi in rectangles[1:]:\n            if xi < x1 or yi < y1 or ai > x2 or bi > y2:\n                return False\n            x1 = min(x1, xi)\n            y1 = min(y1, yi)\n            x2 = max(x2, ai)\n            y2 = max(y2, bi)\n        return x1 == x2 and y1 == y2"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        if not rectangles:\n            return False\n        \n        x1, y1, x2, y2 = rectangles[0]\n        for xi, yi, ai, bi in rectangles[1:]:\n            if xi < x1 or xi > x2 or yi > y2 or bi < y1:\n                return False\n            if xi > x2:\n                x1, y1, x2, y2 = xi, yi, ai, bi\n        return x2 - x1 <= y2 - y1"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        if not rectangles:\n            return False\n        \n        x1, y1, x2, y2 = rectangles[0]\n        for xi, yi, xi2, yi2 in rectangles[1:]:\n            if xi < x1 or xi2 > x2 or yi < y1 or yi2 > y2:\n                return False\n            x1 = min(x1, xi)\n            y1 = min(y1, yi)\n            x2 = max(x2, xi2)\n            y2 = max(y2, yi2)\n        return x1 == x2 and y1 == y2"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        if not rectangles:\n            return False\n        \n        x1, y1, x2, y2 = rectangles[0]\n        for xi, yi, ai, bi in rectangles[1:]:\n            if xi < x1 or yi < y1 or ai > x2 or bi > y2:\n                return False\n            if xi > x2:\n                x1, y1, x2, y2 = xi, yi, ai, bi\n        return x2 - x1 == y2 - y1"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        if not rectangles:\n            return False\n        \n        x1, y1, x2, y2 = rectangles[0]\n        for xi, yi, ai, bi in rectangles[1:]:\n            if xi < x1 or yi < y1 or ai > x2 or bi > y2:\n                return False\n            x1 = min(x1, xi)\n            y1 = min(y1, yi)\n            x2 = max(x2, ai)\n            y2 = max(y2, bi)\n        return x1 == x2 and y1 == y2"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = ''\n        while columnNumber > 0:\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\n            res = chr(ord('A') + remainder) + res\n        return res"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = ''\n        while columnNumber > 0:\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\n            res = chr(ord('A') + remainder) + res\n        return res"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = ''\n        while columnNumber > 0:\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\n            res = chr(ord('A') + remainder) + res\n        return res"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = ''\n        while columnNumber > 0:\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\n            res = chr(ord('A') + remainder) + res\n        return res"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = ''\n        while columnNumber > 0:\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\n            res = chr(ord('A') + remainder) + res\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # O(n) time and O(1) space\n        # dp[i] stores the max sum ending at index i\n        # dp[i] = max(dp[i-1] + nums[i], nums[i])\n        # return the max of dp\n        dp = nums[0]\n        max_sum = dp\n        for num in nums[1:]:\n            dp = max(dp + num, num)\n            max_sum = max(max_sum, dp)\n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time: O(n)\n        # Space: O(1)\n        # Divide and Conquer\n        # Runtime: 20 ms, faster than 99.95% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.2 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        for num in nums:\n            cur_sum = max(cur_sum + num, num)\n            max_sum = max(max_sum, cur_sum)\n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time: O(n)\n        # Space: O(1)\n        # Divide and conquer\n        # Runtime: 20 ms, faster than 99.77% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.2 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        for num in nums:\n            cur_sum = max(cur_sum + num, num)\n            max_sum = max(max_sum, cur_sum)\n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time: O(n)\n        # Space: O(1)\n        # Divide and conquer\n        # Runtime: 20 ms, faster than 99.78% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.2 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        for num in nums:\n            cur_sum = max(cur_sum + num, num)\n            max_sum = max(max_sum, cur_sum)\n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Brute force\n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.77% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.5 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        max_sum = nums[0]\n        cur_sum = 0\n        for num in nums:\n            cur_sum = max(cur_sum + num, num)\n            max_sum = max(max_sum, cur_sum)\n        return max_sum\n        \n        # Divide and conquer\n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.77% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.5 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        max_sum = nums[0]\n        cur_sum = 0\n        for num in nums[1:]:\n            cur_sum = max(cur_sum + num, num)\n            max_sum = max(max_sum, cur_sum)\n        return max_sum\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.77% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.5 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        max_sum = nums[0]\n        cur_sum = max_sum\n        for num in nums[1:]:\n            cur_sum = max(cur_sum + num, num)\n            max_sum = max(max_sum, cur_sum)\n        return max_sum\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.77% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.5 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        max_sum = nums[0]\n        cur_sum = nums[0]\n        for num in nums[1:]:\n            cur_sum = max(cur_sum + num, num)\n            max_sum = max(max_sum, cur_sum)\n        return max_sum\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.77% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.5 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        max_sum = nums[0]\n        cur_sum = nums[0]\n        for i in range(1, len(nums)):\n            cur_sum = cur_sum + nums[i] if cur_sum > 0 else nums[i]\n            max_sum = max(max_sum, cur_sum)\n        return max_sum\n        \n        # Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 28 ms, faster than 99.77% of Python online submissions for Maximum Subarray.\n        # Memory Usage: 13.5 MB, less than 5.00% of Python online submissions for Maximum Subarray.\n        if not nums:\n            return 0\n        max_sum = nums[0]\n        cur_sum = nums[0]\n        for i in range(1, len(nums)):\n            cur_sum = cur_sum + nums[i]\n            if cur_sum > max_sum:\n                max"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 is the missing tile\n        # 1 is the tile we want to reach\n        # 0 is the tile we want to reach\n        # 1 is the tile we want to reach\n        # 2 is the tile we want to reach\n        # 3 is the tile we want to reach\n        # 4 is the tile we want to reach\n        # 5 is the tile we want to reach\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 0 1 2 5\n        # 4 5 1 2 3 0\n        # 5 0 1 2 3 4\n        # 0 1 2 3 4 5\n        # 1 2 3 4 0 5\n        # 2 3 4 5 0 1\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 0 4 5\n        # 2 3 4 5 0 1\n        # 3 4 0 1 2 5\n        # 4 5 1 2 3 0\n        # 5 0 1 2 3 4\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 is the missing tile\n        # 1 is the tile we want to reach\n        # 0 is the tile we want to reach\n        # 1 is the tile we want to reach\n        # 2 is the tile we want to reach\n        # 3 is the tile we want to reach\n        # 4 is the tile we want to reach\n        # 5 is the tile we want to reach\n        # 0 1 2 3 4 5\n        # 6 7 8 9 10 11\n        # 12 13 14 15 16 17\n        # 18 19 20 21 22 23\n        # 24 25 26 27 28 29\n        # 30 31 32 33 34 35\n        # 36 37 38 39 40 41\n        # 42 43 44 45 46 47\n        # 48 49 50 51 52 53\n        # 54 55 56 57 58 59\n        # 60 61 62 63 64 65\n        # 66 67 68 69 70 71\n        # 72 73 74 75 76 77\n        # 78 79 80 81 82 83\n        # 84 85 86 87 88 89\n        # 90 91 92 93 94 95\n        # 96 97 98 99\n        # 100 101 102\n        # 103 104 105\n        # 106 107 108\n        # 109 110 111\n        # 112 113 114\n        # 115 116 117\n        # 118 119 120\n        # 121 122 123\n        # 124 125 126\n        # 127 128 129\n        # 130 131 132\n        # 133 134 135\n        # 136 137 138\n        # 139 140 141\n        # 142 143 144\n        # 145 146 147\n        # 148 149 150\n        # 151 152 153\n        # 154 155 156\n        # 157 158 159\n        # 160 161 162\n        # 163 164 165\n        # 166 167 168\n        # 169 170 171\n        # 172 173 174\n        # 175 176 177\n        # 178 179 180\n        # 181 182 183\n        # 184 185 186\n        # 187 188 189\n        # 190 191 192\n        # 193 194 195\n        # 196 197 198\n        # 199 200 201\n        # 202 203 204\n        # 205 206 207\n        # 208 209 210\n        # 211 212 213\n        # 214 215 216\n        # 21"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 is the missing tile\n        # 1 is the tile we want to reach\n        # 0 is the tile we want to reach\n        # 1 is the tile we want to reach\n        # 2 is the tile we want to reach\n        # 3 is the tile we want to reach\n        # 4 is the tile we want to reach\n        # 5 is the tile we want to reach\n        # 0 1 2 3 4 5\n        # 6 7 8 9 10 11\n        # 12 13 14 15 16 17\n        # 18 19 20 21 22 23\n        # 24 25 26 27 28 29\n        # 30 31 32 33 34 35\n        # 36 37 38 39 40 41\n        # 42 43 44 45 46 47\n        # 48 49 50 51 52 53\n        # 54 55 56 57 58 59\n        # 60 61 62 63 64 65\n        # 66 67 68 69 70 71\n        # 72 73 74 75 76 77\n        # 78 79 80 81 82 83\n        # 84 85 86 87 88 89\n        # 90 91 92 93 94 95\n        # 96 97 98 99\n        # 100 101 102\n        # 103 104 105\n        # 106 107\n        # 108\n        # 109\n        # 110\n        # 111\n        # 112\n        # 113\n        # 114\n        # 115\n        # 116\n        # 117\n        # 118\n        # 119\n        # 120\n        # 121\n        # 122\n        # 123\n        # 124\n        # 125\n        # 126\n        # 127\n        # 128\n        # 129\n        # 130\n        # 131\n        # 132\n        # 133\n        # 134\n        # 135\n        # 136\n        # 137\n        # 138\n        # 139\n        # 140\n        # 141\n        # 142\n        # 143\n        # 144\n        # 145\n        # 146\n        # 147\n        # 148\n        # 149\n        # 150\n        # 151\n        # 152\n        # 153\n        # 154\n        # 155\n        # 156\n        # 157\n        # 158\n        # 159\n        # 160\n        # 161\n        # 162\n        # 163\n        # 164\n        # 165\n        # 166\n        # 167\n        # 168\n        # 169\n        # 170\n        # 171\n        # 172\n        # 173\n        # 174\n        # 175\n        # 176\n        # 177\n        # 178\n        # 179\n        # 180\n        # 181\n        # 182\n        # 183\n        # 184\n        # 185\n        #"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 is the missing tile\n        # 1 is the target tile\n        # 2 is the other tile\n        # 3 is the other tile\n        # 4 is the other tile\n        # 5 is the other tile\n        # 6 is the other tile\n        # 7 is the other tile\n        # 8 is the other tile\n        # 9 is the other tile\n        # 10 is the other tile\n        # 11 is the other tile\n        # 12 is the other tile\n        # 13 is the other tile\n        # 14 is the other tile\n        # 15 is the other tile\n        # 16 is the other tile\n        # 17 is the other tile\n        # 18 is the other tile\n        # 19 is the other tile\n        # 20 is the other tile\n        # 21 is the other tile\n        # 22 is the other tile\n        # 23 is the other tile\n        # 24 is the other tile\n        # 25 is the other tile\n        # 26 is the other tile\n        # 27 is the other tile\n        # 28 is the other tile\n        # 29 is the other tile\n        # 30 is the other tile\n        # 31 is the other tile\n        # 32 is the other tile\n        # 33 is the other tile\n        # 34 is the other tile\n        # 35 is the other tile\n        # 36 is the other tile\n        # 37 is the other tile\n        # 38 is the other tile\n        # 39 is the other tile\n        # 40 is the other tile\n        # 41 is the other tile\n        # 42 is the other tile\n        # 43 is the other tile\n        # 44 is the other tile\n        # 45 is the other tile\n        # 46 is the other tile\n        # 47 is the other tile\n        # 48 is the other tile\n        # 49 is the other tile\n        # 50 is the other tile\n        # 51 is the other tile\n        # 52 is the other tile\n        # 53 is the other tile\n        # 54 is the other tile\n        # 55 is the other tile\n        # 56 is the other tile\n        # 57 is the other tile\n        # 58 is the other tile\n        # 59 is the other tile\n        # 60 is the other tile\n        # 61 is the other tile\n        # 62 is the other tile\n        # 63 is the other tile\n        # 64 is the other tile\n        # 65 is the other tile\n        # 66 is the other tile\n        # 67 is the other tile\n        # 68 is the other tile\n        # 69 is the other tile\n        # 70 is the other tile\n        # 71 is the other tile\n        # 72 is the other tile\n        # 73 is the other tile\n        # 74 is the other tile\n        # 75 is the other tile\n        # 76 is the other tile\n        # 77 is the other tile\n        # 78 is the other tile\n        # 79 is the other tile\n        # 80 is the other tile\n        # 81 is the other tile\n        # 82 is the other tile\n        # 83 is the other tile\n        # 84 is the other tile\n        # 85 is the other tile\n        # 86 is the other tile\n        # 87 is the other tile\n        # 88 is the other tile\n        # 89 is the other tile\n        # 90 is the other tile\n        # 91 is the other tile\n        # 92 is the other tile\n        # 93 is the other tile\n        # 94 is the other tile\n        # 95 is the other tile\n        # 96 is the other tile\n        # 97 is the other tile\n        # 98 is the other tile\n        # 99 is the other tile\n        # 100 is the other tile\n        # 101 is the other tile\n        # 102 is the other tile"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 is the missing tile\n        # 1 is the tile we want to reach\n        # 0 is the tile we want to reach\n        # 1 is the tile we want to reach\n        # 2 is the tile we want to reach\n        # 3 is the tile we want to reach\n        # 4 is the tile we want to reach\n        # 5 is the tile we want to reach\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 0 1 2 5\n        # 4 5 1 2 3 0\n        # 5 0 1 2 3 4\n        # 0 1 2 3 4 5\n        # 1 2 3 4 0 5\n        # 2 3 4 5 0 1\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 0 4 5\n        # 2 3 4 5 0 1\n        # 3 4 0 1 2 5\n        # 4 5 1 2 3 0\n        # 5 0 1 2 3 4\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0\n        # 2 3 4 0 1 5\n        # 3 4 5 0 1 2\n        # 4 0 1 2 3 5\n        # 5 1 2 3 4 0\n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 0"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n                return False\n            if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n                return False\n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n        \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        for i in range(len(s)):\n            if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n                return False\n            if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n                return False\n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n                return False\n            if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n                return False\n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n        \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n                return False\n            if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n                return False\n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n        \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t and s_to_t[s[i]] != t[i]:\n                return False\n            if t[i] in t_to_s and t_to_s[t[i]] != s[i]:\n                return False\n            s_to_t[s[i]] = t[i]\n            t_to_s[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not nums:\n            return False\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not nums:\n            return False\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. If the array is sorted, we can use binary search\n        # 2. If the array is not sorted, we can use two pointers\n        # 3. If the array is not sorted and contains duplicates, we can use two pointers\n        \n        # 1. If the array is sorted, we can use binary search\n        if nums[0] < nums[-1]:\n            return self.binarySearch(nums, target)\n        \n        # 2. If the array is not sorted, we can use two pointers\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False\n    \n    def binarySearch(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. If the array is sorted, we can use binary search\n        # 2. If the array is not sorted, we can use two pointers\n        # 3. If the array is sorted and contains duplicates, we can use two pointers\n        \n        # 1. If the array is sorted, we can use binary search\n        if nums[0] < nums[-1]:\n            return self.binarySearch(nums, target)\n        \n        # 2. If the array is not sorted, we can use two pointers\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False\n    \n    def binarySearch(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. check if the array is sorted\n        if nums[0] > target or nums[-1] < target:\n            return False\n        \n        # 2. check if the array is rotated\n        if nums[0] < nums[-1]:\n            # 3. binary search\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    return True\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        # 4. search in the first half\n        left, right = 0, len(nums) // 2\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        # 5. search in the second half\n        left, right = len(nums) // 2 + 1, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not obstacleGrid or not obstacleGrid[0]:\n            return 0\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [1] * n\n        \n        for i in range(1, m):\n            if obstacleGrid[i][0] == 1:\n                dp[0] = 0\n            else:\n                dp[0] = dp[0] if dp[0] else 1\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                else:\n                    dp[j] = dp[j] + dp[j - 1]\n        \n        return dp[n - 1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not obstacleGrid or not obstacleGrid[0]:\n            return 0\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [1] * n\n        \n        for i in range(1, m):\n            if obstacleGrid[i][0] == 1:\n                dp[0] = 0\n            else:\n                dp[0] = dp[0] if dp[0] else 1\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                else:\n                    dp[j] = dp[j] + dp[j - 1]\n        \n        return dp[n - 1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not obstacleGrid or not obstacleGrid[0]:\n            return 0\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [1] * n\n        \n        for i in range(1, m):\n            if obstacleGrid[i][0] == 1:\n                dp[0] = 0\n            else:\n                dp[0] = dp[0] if dp[0] else 1\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                else:\n                    dp[j] = dp[j] + dp[j-1]\n        \n        return dp[n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not obstacleGrid or not obstacleGrid[0]:\n            return 0\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [1] * n\n        \n        for i in range(1, m):\n            if obstacleGrid[i][0] == 1:\n                dp[0] = 0\n            else:\n                dp[0] = dp[0] if dp[0] else 1\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                else:\n                    dp[j] = dp[j] + dp[j-1]\n        \n        return dp[n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not obstacleGrid or not obstacleGrid[0]:\n            return 0\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [1] * n\n        \n        for i in range(1, m):\n            if obstacleGrid[i][0] == 1:\n                dp[0] = 0\n            else:\n                dp[0] = dp[0] if dp[0] else 1\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                else:\n                    dp[j] = dp[j] + dp[j - 1]\n        \n        return dp[n - 1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        one, two = 1, 1 if s[0] != '0' else 0\n        for i in range(1, len(s)):\n            one, two = two, (s[i] != '0' and (one + two)) or one\n        return two"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        one, two = 1, 1 if s[0] != '0' else 0\n        for i in range(1, len(s)):\n            one, two = two, (s[i] != '0' and (one + two)) or one\n        return two"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        one, two = 1, 1 if s[0] != '0' else 0\n        for i in range(1, len(s)):\n            one, two = two, (s[i] != '0' and (one + two)) or one\n        return two"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        one, two = 1, 1 if s[0] != '0' else 0\n        for i in range(1, len(s)):\n            one, two = two, (s[i] != '0' and (one + two)) or one\n        return two"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        one, two = 1, 1 if s[0] != '0' else 0\n        for i in range(1, len(s)):\n            one, two = two, (s[i] != '0' and (one + two)) or one\n        return two"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums) - 2):\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == target:\n                    return target\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s > target:\n                    r -= 1\n                else:\n                    l += 1\n        return res"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums) - 2):\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if s == target:\n                    return target\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s > target:\n                    right -= 1\n                else:\n                    left += 1\n        return res"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums) - 2):\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                s = nums[i] + nums[left] + nums[right]\n                if s == target:\n                    return target\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s > target:\n                    right -= 1\n                else:\n                    left += 1\n        return res"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums) - 2):\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == target:\n                    return target\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s > target:\n                    r -= 1\n                else:\n                    l += 1\n        return res"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums) - 2):\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == target:\n                    return target\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s > target:\n                    r -= 1\n                else:\n                    l += 1\n        return res"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num]\n        # M2[num] - M1[num]\n        # M1[num] + M2[num]\n        return [num for num in M1 if num in M2 and M1[num] <= M2[num]]"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num]\n        # M2[num] - M1[num]\n        # M1[num] + M2[num]\n        return [num for num in M1 if num in M2 and M1[num] <= M2[num]]"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num]\n        # M2[num] - M1[num]\n        # M1[num] + M2[num]\n        return [num for num in M1 if num in M2 and M1[num] <= M2[num]]"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num]\n        # M2[num] - M1[num]\n        # M1[num] + M2[num]\n        return [num for num in M1 if num in M2 and M1[num] <= M2[num]]"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num]\n        # M2[num] - M1[num]\n        # M1[num] + M2[num]\n        return [num for num in M1 if num in M2 and M1[num] <= M2[num]]"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        min_diff = float('inf')\n        prev = root.val\n        stack = [root]\n        \n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n                if node.val - prev < min_diff:\n                    min_diff = node.val - prev\n            if node.right:\n                stack.append(node.right)\n                prev = node.val\n        \n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        prev = float('-inf')\n        min_diff = float('inf')\n        stack = [root]\n        \n        while stack:\n            node = stack.pop()\n            if node.val <= prev:\n                min_diff = min(min_diff, prev - node.val)\n            else:\n                prev = node.val\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        min_diff = float('inf')\n        prev = root.val\n        stack = [root]\n        \n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n                if node.val - prev < min_diff:\n                    min_diff = node.val - prev\n            if node.right:\n                stack.append(node.right)\n                prev = node.val\n        \n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        min_diff = float('inf')\n        prev = root.val\n        stack = [root]\n        \n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n                if node.val - prev < min_diff:\n                    min_diff = node.val - prev\n            if node.right:\n                stack.append(node.right)\n                prev = node.val\n        \n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        prev = float('-inf')\n        res = float('inf')\n        stack = [root]\n        \n        while stack:\n            node = stack.pop()\n            if node.val <= prev:\n                res = min(res, prev - node.val)\n            else:\n                prev = node.val\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return res"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        count = 1\n        prev = root.val\n        while root:\n            if root.val == prev:\n                count += 1\n            else:\n                count = 1\n                prev = root.val\n            res = res or [count]\n            res[0] = max(res[0], count)\n            root = root.right if root.val > prev else root.left\n        return [root.val] * res[0] if res[0] > 1 else []"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        count = 0\n        prev = root.val\n        for node in self.inorder(root):\n            if node == prev:\n                count += 1\n            else:\n                count = 1\n                prev = node\n            res.append(node) if count == 1 else res.append(node) if count == res[-1] else None\n        return res[:2] if res else res\n        \n    def inorder(self, root):\n        if not root:\n            return\n        for node in self.inorder(root.left):\n            yield node\n        yield root.val\n        for node in self.inorder(root.right):\n            yield node\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        count = 1\n        prev = root.val\n        while root:\n            if root.val == prev:\n                count += 1\n            else:\n                count = 1\n                prev = root.val\n            if count == 1:\n                res.append(root.val)\n            elif count == 2:\n                res.append(res.pop())\n            root = root.right\n        return res\n\n# Time: O(N)\n# Space: O(H) in the worst case, where H is the height of the tree\n# Hint: use a map to store the count of each node's value\n# If the count of a node is 1, add it to the result. If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's value to the result.\n# If the count is 2, remove the last result.\n# If the count is greater than 2, remove the last result.\n# If the count is greater than 1, add the current node's"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        count = 1\n        prev = root.val\n        while root:\n            if root.val == prev:\n                count += 1\n            else:\n                count = 1\n                prev = root.val\n            res = res or [count]\n            res[0] = max(res[0], count)\n            root = root.right if root.val > prev else root.left\n        return [root.val] * res[0] if res[0] > 1 else []"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        count = 1\n        prev = root.val\n        while root:\n            if root.val == prev:\n                count += 1\n            else:\n                count = 1\n                prev = root.val\n            res = res or [count]\n            res[0] = max(res[0], count)\n            root = root.right if root.val > prev else root.left\n        return [root.val] * res[0] if res[0] > 1 else []\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n\n# Given the root of a binary search tree (BST) with duplicates, \n# find all the mode(s) (the most frequently occurred element) in the BST.\n# If the tree has more than one mode, return them in any order.\n# Assume a BST is defined as follows:\n# The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n# The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n# Both the left and right subtrees must also be binary search trees.\n# Example 1:\n# Input: root = [1,null,2,2]\n# Output: [2]\n# Example 2:\n# Input: root = [0]\n# Output: [0]\n# Example 3:\n# Input: root = [1,null,2,null,2]\n# Output: [2]\n# \u00a0\n# Constraints:\n# The number of nodes in the tree is in the range [0, 10^4].\n# -10^5 <= Node.val <= 10^5\n# Accepted\n# 10,941\n# Submissions\n# 10,941\n# \n# \n# \n# Follow up: Could you do that without using any extra space? (i.e. O(1) space).\n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n# \n#"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == '':\n            return 0\n        if needle not in haystack:\n            return -1\n        return haystack.find(needle)"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        if needle not in haystack:\n            return -1\n        return haystack.find(needle)"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == '':\n            return 0\n        if len(haystack) < len(needle):\n            return -1\n        \n        i = 0\n        while i < len(haystack) and haystack[i] == needle[0]:\n            if haystack[i:i+len(needle)] == needle:\n                return i\n            i += 1\n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == '':\n            return 0\n        if needle not in haystack:\n            return -1\n        return haystack.find(needle)"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == '':\n            return 0\n        if needle not in haystack:\n            return -1\n        return haystack.find(needle)"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # count of lowercase, uppercase, digit\n        l, u, d = password.lower().count('a'), password.upper().count('A'), password.count('0')\n        if l + u + d >= 3:\n            return 0\n        if l == 0:\n            return 6 - u - d\n        if u == 0:\n            return 6 - l - d\n        return 6 - l - u"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # count of lowercase, uppercase and digit\n        lower, upper, digit = password.lower().count('a'), password.upper().count('a'), password.count('0')\n        if lower + upper + digit < 3:\n            return 6 - (lower + upper + digit)\n        if len(password) <= 20:\n            return 0\n        return min(lower, upper, digit) + (len(password) - 20) // 3"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # count of lowercase, uppercase and digit\n        lower, upper, digit = 0, 0, 0\n        for c in password:\n            if c.islower():\n                lower += 1\n            elif c.isupper():\n                upper += 1\n            elif c.isdigit():\n                digit += 1\n            else:\n                return 0\n        \n        # check length\n        if len(password) < 6:\n            return 6 - len(password)\n        elif len(password) > 20:\n            return 1\n        \n        # check lower, upper and digit\n        if lower == 0 or upper == 0 or digit == 0:\n            return 1\n        \n        # check repeating characters\n        if password.count(password[0]) > 1:\n            return 2\n        elif len(password) > 20:\n            return 3\n        \n        return 0"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # count of lowercase, uppercase, digit\n        l, u, d = password.lower().count('a'), password.upper().count('A'), password.count('0')\n        if l + u + d >= 3:\n            return 0\n        if l == 0:\n            return 2\n        if u == 0:\n            return 1\n        return 2 if d == 0 else 1"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # count the number of lowercase, uppercase and digit\n        lower, upper, digit, repeat = 0, 0, 0, 0\n        for c in password:\n            if c.islower():\n                lower += 1\n            elif c.isupper():\n                upper += 1\n            elif c.isdigit():\n                digit += 1\n            else:\n                repeat += 1\n        \n        # check the length\n        if len(password) < 6:\n            return 6 - len(password)\n        elif len(password) > 20:\n            return len(password) - 20\n        \n        # check the number of repeating characters\n        if repeat > 0:\n            return min(repeat, 2) + (len(password) - 20) // 3\n        \n        # check the number of lowercase and uppercase\n        if lower == 0 or upper == 0:\n            return max(lower, upper) + 2\n        \n        # check the number of digit\n        if digit == 0:\n            return 1\n        \n        return 0"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 5! = 120, 20 has 2 trailing zeroes\n        # 25! = 155040035, 1200 has 2 trailing zeroes\n        # 120! = 479001600, 3628800 has 2 trailing zeroes\n        # 3628800! = 140500717288000, 36288000 has 2 trailing zeroes\n        # 36288000! = 140500717288000, 362880000 has 2 trailing zeroes\n        # 362880000! = 140500717288000, 3628800000 has 2 trailing zeroes\n        # 3628800000! = 140500717288000, 36288000000 has 2 trailing zeroes\n        # 36288000000! = 140500717288000, 362880000000 has 2 trailing zeroes\n        # 362880000000! = 140500717288000, 3628800000000 has 2 trailing zeroes\n        # 3628800000000! = 140500717288000, 36288000000000 has 2 trailing zeroes\n        # 36288000000000! = 140500717288000, 362880000000000 has 2 trailing zeroes\n        # 362880000000000! = 140500717288000, 3628800000000000 has 2 trailing zeroes\n        # 3628800000000000! = 140500717288000, 36288000000000000 has 2 trailing zeroes\n        # 36288000000000000! = 140500717288000, 362880000000000000 has 2 trailing zeroes\n        # 362880000000000000! = 140500717288000, 3628800000000000000 has 2 trailing zeroes\n        # 3628800000000000000! = 140500717288000, 36288000000000000000 has 2 trailing zeroes\n        # 36288000000000000000! = 140500717288000, 362880000000000000000 has 2 trailing zeroes\n        # 362880000000000000000! = 140500717288000, 3628800000000000000000 has 2 trailing zeroes\n        # 3628800000000000000000! = 140500717288000, 362880000"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 5! = 120, 20 has 2 trailing zeroes\n        # 25! = 155040035, 1200 has 2 trailing zeroes\n        # 120! = 479001600, 3628800 has 2 trailing zeroes\n        # 3628800! = 140500717288000, 36288000 has 2 trailing zeroes\n        # 36288000! = 140500717288000, 362880000 has 2 trailing zeroes\n        # 362880000! = 140500717288000, 3628800000 has 2 trailing zeroes\n        # 3628800000! = 140500717288000, 36288000000 has 2 trailing zeroes\n        # 36288000000! = 140500717288000, 362880000000 has 2 trailing zeroes\n        # 362880000000! = 140500717288000, 3628800000000 has 2 trailing zeroes\n        # 3628800000000! = 140500717288000, 36288000000000 has 2 trailing zeroes\n        # 36288000000000! = 140500717288000, 362880000000000 has 2 trailing zeroes\n        # 362880000000000! = 140500717288000, 3628800000000000 has 2 trailing zeroes\n        # 3628800000000000! = 140500717288000, 36288000000000000 has 2 trailing zeroes\n        # 36288000000000000! = 140500717288000, 362880000000000000 has 2 trailing zeroes\n        # 362880000000000000! = 140500717288000, 3628800000000000000 has 2 trailing zeroes\n        # 3628800000000000000! = 140500717288000, 36288000000000000000 has 2 trailing zeroes\n        # 36288000000000000000! = 140500717288000, 362880000000000000000 has 2 trailing zeroes\n        # 362880000000000000000! = 140500717288000, 3628800000000000000000 has 2 trailing zeroes\n        # 3628800000000000000000! = 140500717288000, 362880000"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 5! = 120, 20 has 2 trailing zeroes\n        # 25! = 155040035, 1200 has 2 trailing zeroes\n        # 120! = 479001600, 3628800 has 2 trailing zeroes\n        # 3628800! = 140500717288000, 36288000 has 2 trailing zeroes\n        # 36288000! = 140500717288000, 362880000 has 2 trailing zeroes\n        # 362880000! = 140500717288000, 3628800000 has 2 trailing zeroes\n        # 3628800000! = 140500717288000, 36288000000 has 2 trailing zeroes\n        # 36288000000! = 140500717288000, 362880000000 has 2 trailing zeroes\n        # 362880000000! = 140500717288000, 3628800000000 has 2 trailing zeroes\n        # 3628800000000! = 140500717288000, 36288000000000 has 2 trailing zeroes\n        # 36288000000000! = 140500717288000, 362880000000000 has 2 trailing zeroes\n        # 362880000000000! = 140500717288000, 3628800000000000 has 2 trailing zeroes\n        # 3628800000000000! = 140500717288000, 36288000000000000 has 2 trailing zeroes\n        # 36288000000000000! = 140500717288000, 362880000000000000 has 2 trailing zeroes\n        # 362880000000000000! = 140500717288000, 3628800000000000000 has 2 trailing zeroes\n        # 3628800000000000000! = 140500717288000, 36288000000000000000 has 2 trailing zeroes\n        # 36288000000000000000! = 140500717288000, 362880000000000000000 has 2 trailing zeroes\n        # 362880000000000000000! = 140500717288000, 3628800000000000000000 has 2 trailing zeroes\n        # 3628800000000000000000! = 140500717288000, 362880000"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 5! = 120, 20 has 2 trailing zeroes\n        # 25! = 155040035, 1200 has 2 trailing zeroes\n        # 120! = 479001600, 3628800 has 2 trailing zeroes\n        # 3628800! = 140500717288000, 36288000 has 2 trailing zeroes\n        # 36288000! = 140500717288000, 362880000 has 2 trailing zeroes\n        # 362880000! = 140500717288000, 3628800000 has 2 trailing zeroes\n        # 3628800000! = 140500717288000, 36288000000 has 2 trailing zeroes\n        # 36288000000! = 140500717288000, 362880000000 has 2 trailing zeroes\n        # 362880000000! = 140500717288000, 3628800000000 has 2 trailing zeroes\n        # 3628800000000! = 140500717288000, 36288000000000 has 2 trailing zeroes\n        # 36288000000000! = 140500717288000, 362880000000000 has 2 trailing zeroes\n        # 362880000000000! = 140500717288000, 3628800000000000 has 2 trailing zeroes\n        # 3628800000000000! = 140500717288000, 36288000000000000 has 2 trailing zeroes\n        # 36288000000000000! = 140500717288000, 362880000000000000 has 2 trailing zeroes\n        # 362880000000000000! = 140500717288000, 3628800000000000000 has 2 trailing zeroes\n        # 3628800000000000000! = 140500717288000, 36288000000000000000 has 2 trailing zeroes\n        # 36288000000000000000! = 140500717288000, 362880000000000000000 has 2 trailing zeroes\n        # 362880000000000000000! = 140500717288000, 3628800000000000000000 has 2 trailing zeroes\n        # 3628800000000000000000! = 140500717288000, 362880000"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 5! = 120, 20 has 2 trailing zeroes\n        # 25! = 155040035, 1200 has 2 trailing zeroes\n        # 120! = 479001600, 3628800 has 2 trailing zeroes\n        # 3628800! = 140500717288000, 36288000 has 2 trailing zeroes\n        # 36288000! = 140500717288000, 362880000 has 2 trailing zeroes\n        # 362880000! = 140500717288000, 3628800000 has 2 trailing zeroes\n        # 3628800000! = 140500717288000, 36288000000 has 2 trailing zeroes\n        # 36288000000! = 140500717288000, 362880000000 has 2 trailing zeroes\n        # 362880000000! = 140500717288000, 3628800000000 has 2 trailing zeroes\n        # 3628800000000! = 140500717288000, 36288000000000 has 2 trailing zeroes\n        # 36288000000000! = 140500717288000, 362880000000000 has 2 trailing zeroes\n        # 362880000000000! = 140500717288000, 3628800000000000 has 2 trailing zeroes\n        # 3628800000000000! = 140500717288000, 36288000000000000 has 2 trailing zeroes\n        # 36288000000000000! = 140500717288000, 362880000000000000 has 2 trailing zeroes\n        # 362880000000000000! = 140500717288000, 3628800000000000000 has 2 trailing zeroes\n        # 3628800000000000000! = 140500717288000, 36288000000000000000 has 2 trailing zeroes\n        # 36288000000000000000! = 140500717288000, 362880000000000000000 has 2 trailing zeroes\n        # 362880000000000000000! = 140500717288000, 3628800000000000000000 has 2 trailing zeroes\n        # 3628800000000000000000! = 140500717288000, 362880000"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1 or numRows >= len(s):\n            return s\n        \n        res = [''] * numRows\n        i, step = 0, 1\n        for c in s:\n            res[i] += c\n            if i == 0:\n                step = -1\n            elif i == numRows - 1:\n                step = 1\n            i += step\n        \n        return ''.join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1 or numRows >= len(s):\n            return s\n        \n        res = [''] * numRows\n        i, step = 0, 1\n        for c in s:\n            res[i] += c\n            if i == 0:\n                step = -1\n            elif i == numRows - 1:\n                step = 1\n            i += step\n        \n        return ''.join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1 or numRows >= len(s):\n            return s\n        \n        res = [''] * numRows\n        i, step = 0, 1\n        for c in s:\n            res[i] += c\n            if i == 0:\n                step = -1\n            elif i == numRows - 1:\n                step = 1\n            i += step\n        \n        return ''.join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1 or numRows >= len(s):\n            return s\n        \n        res = [''] * numRows\n        i, step = 0, 1\n        for c in s:\n            res[i] += c\n            if i == 0:\n                step = -1\n            elif i == numRows - 1:\n                step = 1\n            i += step\n        \n        return ''.join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1 or numRows >= len(s):\n            return s\n        \n        res = [''] * numRows\n        i, step = 0, 1\n        for c in s:\n            res[i] += c\n            if i == 0:\n                step = -1\n            elif i == numRows - 1:\n                step = 1\n            i += step\n        return ''.join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        water = 0\n        \n        while left < right:\n            if left_max < right_max:\n                water += left_max - height[left]\n                left_max = max(left_max, height[left])\n                left += 1\n            else:\n                water += right_max - height[right]\n                right_max = max(right_max, height[right])\n                right -= 1\n        \n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        water = 0\n        \n        while left < right:\n            if left_max < right_max:\n                water += left_max - height[left]\n                left_max = max(left_max, height[left])\n                left += 1\n            else:\n                water += right_max - height[right]\n                right_max = max(right_max, height[right])\n                right -= 1\n        \n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        water = 0\n        \n        while left < right:\n            if left_max < right_max:\n                water += left_max - height[left]\n                left_max = max(left_max, height[left])\n                left += 1\n            else:\n                water += right_max - height[right]\n                right_max = max(right_max, height[right])\n                right -= 1\n        \n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        water = 0\n        \n        while left < right:\n            if left_max < right_max:\n                water += left_max - height[left]\n                left_max = max(left_max, height[left])\n                left += 1\n            else:\n                water += right_max - height[right]\n                right_max = max(right_max, height[right])\n                right -= 1\n        \n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        water = 0\n        \n        while left < right:\n            if left_max < right_max:\n                water += left_max - height[left]\n                left_max = max(left_max, height[left])\n                left += 1\n            else:\n                water += right_max - height[right]\n                right_max = max(right_max, height[right])\n                right -= 1\n        \n        return water"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i]"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i]"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i]"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i]"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i] <= n\n        # 1 <= n <= 10^5\n        # 1 <= nums[i]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        # create a new array with the same size as nums\n        # and store the index of nums in the new array\n        # the index of nums[i] in the new array is nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        new = [0] * (len(nums) + 1)\n        for i, num in enumerate(nums):\n            new[num - nums[0]] += i\n        \n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i] - min(nums)\n        # the value of new[i] is the number of elements in nums[i]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        # create a new array to store the count of each number\n        # the count of nums[i] is the number of numbers smaller than nums[i]\n        # in the original array\n        counts = [0] * (len(nums) + 1)\n        \n        # store the index of each number in the new array\n        # the index of nums[i] is the number of numbers smaller than nums[i]\n        # in the original array\n        index = len(nums)\n        for num in nums[::-1]:\n            index -= counts[num]\n            counts[num] += index\n        \n        return counts[1:]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1. \u5355\u8c03\u6808\n        # \u5355\u8c03\u6808\u7684\u601d\u60f3\u662f\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5c0f\uff0c\u5219\u5165\u6808\uff1b\u5426\u5219\u51fa\u6808\u5e76\u7d2f\u52a0\uff0c\u76f4\u5230\u6808\u9876\u5143\u7d20\u6bd4\u5f53\u524d\u5143\u7d20\u5927\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        if not nums:\n            return []\n        res = [0] * len(nums)\n        stack = []\n        for i in range(len(nums) - 1, -1, -1):\n            while stack and nums[stack[-1]] >= nums[i]:\n                res[stack.pop()] = i\n            stack.append(i)\n        return res\n        \n        # M2. \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u5982\u679c nums \u662f\u6709\u5e8f\u7684\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528\u4e8c\u5206\u67e5\u627e\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\n        # \u6211\u4eec\u7ef4\u62a4\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u6570\u7ec4 counts\uff0c\u5176\u4e2d counts[i] \u8868\u793a\u5c0f\u4e8e\u7b49\u4e8e nums[i] \u7684\u5143\u7d20\u4e2a\u6570\u3002\n        # \u521d\u59cb\u65f6\uff0ccounts[0] = 0\uff0c\u5bf9\u4e8e i > 0\uff0ccounts[i] = counts[i - 1] + (nums[i] \u5c0f\u4e8e\u7b49\u4e8e nums[i - 1] \u7684\u4e2a\u6570)\u3002\n        # \u6700\u540e\uff0c\u8fd4\u56de counts \u6570\u7ec4\u5373\u53ef\u3002\n        if not nums:\n            return []\n        counts = [0] * len(nums)\n        left, right = 0, 0\n        for i in range(len(nums) - 1, -1, -1):\n            counts[i] = right - left + counts[i - left]\n            if nums[i] == nums[right]:\n                right += 1\n        return counts\n        \n        # M3. \u6876\u6392\u5e8f\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u6876\u6392\u5e8f\u7684\u601d\u60f3\u662f\uff0c\u5c06\u6570\u7ec4\u4e2d\u7684\u6570\u5b57\u653e\u5165\u5404\u4e2a\u6876\u4e2d\uff0c\u6bcf\u4e2a\u6876\u4e2d\u7684\u6570\u5b57\u90fd\u662f\u76f8\u540c\u7684\u3002\n        # \u7136\u540e\u904d\u5386\u6bcf\u4e2a\u6876\uff0c\u8ba1\u7b97\u6876\u4e2d\u6570\u5b57\u7684\u4e2a\u6570\uff0c\u5373\u4e3a\u7b54\u6848\u3002\n        if not nums:\n            return []\n        counts = [0] * (max(nums) + 1)\n        for num in nums:\n            counts[num] += 1\n        for i in range(1, len(counts)):\n            counts[i] += counts[i - 1]\n        res = counts[len(nums) - 1]\n        counts[len(nums) - 1] = 0\n        for i in range(len(nums) - 2, -1, -1):\n            res += counts[nums[i]]\n            counts[nums[i]] -= 1\n        return res\n        \n        # M4. \u5feb\u901f\u6392\u5e8f\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u5feb\u901f\u6392\u5e8f\u7684\u601d\u60f3\u662f\uff0c\u5c06\u6570\u7ec4\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u4e00\u90e8\u5206\u6bd4\u57fa\u51c6\u503c\u5c0f\uff0c\u4e00\u90e8\u5206\u6bd4\u57fa\ufffd\ufffd"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1. \u5355\u8c03\u6808\n        # \u5355\u8c03\u6808\u7684\u601d\u60f3\u662f\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5c0f\uff0c\u5219\u5165\u6808\uff1b\u5426\u5219\u51fa\u6808\u5e76\u7d2f\u52a0\uff0c\u76f4\u5230\u6808\u9876\u5143\u7d20\u6bd4\u5f53\u524d\u5143\u7d20\u5927\u3002\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u6808\u4e2d\u5b58\u50a8\u7684\u662f nums \u4e2d\u7684\u5143\u7d20\uff0c\u4e14\u6808\u4e2d\u7684\u5143\u7d20\u662f\u5355\u8c03\u9012\u51cf\u7684\u3002\n        if not nums:\n            return []\n        stack, res = [], [0] * len(nums)\n        for num in nums[::-1]:\n            if not stack or num > stack[-1]:\n                stack.append(num)\n            else:\n                res[len(stack) - 1 - stack.index(num)] += 1\n                stack.append(num)\n        return res[::-1]\n        \n        \n        # M2. \u4e8c\u5206\u67e5\u627e\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(nlogn)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u6392\u5e8f\u540e\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5143\u7d20 nums[i]\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 nums[0...i] \u4e2d\u627e\u5230\u4e00\u4e2a\u6700\u5c0f\u7684 nums[j] \u4f7f\u5f97 nums[j] >= nums[i]\uff0c\n        # \u8fd9\u6837 nums[j] \u5c31\u662f\u5c0f\u4e8e\u7b49\u4e8e nums[i] \u7684\u5143\u7d20\u4e2a\u6570\u3002\n        nums.sort()\n        res = []\n        for num in nums:\n            res.append(nums.index(num))\n        return res\n        \n        \n        # M3. \u6876\u6392\u5e8f\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u5c06\u6570\u7ec4 nums \u4e2d\u7684\u5143\u7d20\u5206\u914d\u5230\u5404\u4e2a\u6876\u4e2d\uff0c\u6bcf\u4e2a\u6876\u4e2d\u7684\u5143\u7d20\u4e2a\u6570\u5c31\u662f\u5c0f\u4e8e\u7b49\u4e8e\u8be5\u5143\u7d20\u7684\u5143\u7d20\u4e2a\u6570\u3002\n        # \u6876\u7684\u6570\u91cf\u662f nums \u4e2d\u7684\u6700\u5927\u5143\u7d20\u52a0 1\u3002\n        # \u6876\u7684\u4e0b\u6807\u5c31\u662f\u5c0f\u4e8e\u7b49\u4e8e\u8be5\u5143\u7d20\u7684\u5143\u7d20\u4e2a\u6570\u3002\n        # \u56e0\u4e3a\u6876\u7684\u4e0b\u6807\u662f\u5c0f\u4e8e\u7b49\u4e8e\u8be5\u5143\u7d20\u7684\u5143\u7d20\u4e2a\u6570\uff0c\u6240\u4ee5\u6876\u7684\u4e0b\u6807\u5c31\u662f\u7b54\u6848\u3002\n        if not nums:\n            return []\n        bucket_count, res = nums[-1] + 1, [0] * len(nums)\n        for num in nums:\n            res[bucket_count - num - 1] += 1\n        return res\n        \n        \n        # M4. \u5feb\u901f\u6392\u5e8f\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(logn)\uff0c\u5176\u4e2d n \u662f\u6570\u7ec4 nums \u7684\u957f\u5ea6\u3002\n        # \u5feb\u901f\u6392\u5e8f\u7684\u601d\u60f3\u662f\uff0c\u9009\u62e9\u4e00\u4e2a\u57fa\u51c6\u5143\u7d20\uff0c\u5c06\u6570\u7ec4\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u4e00\u90e8\u5206\u5143\u7d20\u6bd4\u57fa\u51c6\u5143\u7d20\u5c0f\uff0c\u4e00\u90e8\u5206\u5143\u7d20\u6bd4\u57fa\u51c6\u5143\u7d20\u5927\u3002\n        # \u5bf9\u4e8e\u5c0f\u4e8e\u57fa\u51c6\u5143\u7d20\u7684\u90e8\u5206\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u6c42\u51fa\u7b54\u6848\uff0c\u56e0\u4e3a\u8fd9\u90e8\u5206\u5143\u7d20\u90fd\u5728\u57fa\u51c6\u5143\u7d20\u7684\u5de6\u8fb9\uff0c\n        # \u800c\u5bf9\u4e8e\u5927\u4e8e\u57fa\u51c6\u5143\u7d20\u7684\u90e8\u5206\uff0c\u6211\u4eec\u53ef\u4ee5\u9012\u5f52\u5730\u6c42\u51fa\u7b54\u6848"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        # create a new array with the same size as nums\n        # and store the index of nums in the new array\n        # the index of nums[i] in the new array is nums[i] - min(nums)\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums[i]\n        # the value of nums[i] - min(nums) is the number of smaller elements to the right of nums"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        start, end = intervals[0][0], intervals[0][1]\n        res = 2\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n            else:\n                res += 1\n                start, end = intervals[i][0], intervals[i][1]\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        start, end = intervals[0][0], intervals[0][1]\n        res = 2\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n            else:\n                res += 1\n                start, end = intervals[i][0], intervals[i][1]\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        start, end = intervals[0][0], intervals[0][1]\n        res = 2\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n            else:\n                res += 1\n                start, end = intervals[i][0], intervals[i][1]\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        start, end = intervals[0][0], intervals[0][1]\n        res = 2\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n            else:\n                res += 1\n                start, end = intervals[i][0], intervals[i][1]\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[0])\n        start, end = intervals[0][0], intervals[0][1]\n        res = 2\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= end:\n                end = max(end, intervals[i][1])\n            else:\n                res += 1\n                start, end = intervals[i][0], intervals[i][1]\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: easy"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\n\n# Time: O(N)\n# Space: O(H)\n# Difficulty: easy"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.right, right.left)\n        \n# Time: O(n)\n# Space: O(h)\n# Difficulty: easy\n# See also: https://leetcode.com/problems/symmetric-tree/"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\n        \n# Time: O(n)\n# Space: O(h)\n# Difficulty: easy"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n        \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\n        \n# Time: O(n)\n# Space: O(h)\n# Difficulty: easy"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack, res = [], {}\n        for c in formula:\n            if c.isalpha():\n                if stack:\n                    res[stack.pop()] += 1\n                stack.append(c)\n            elif c == ')':\n                if stack:\n                    res[stack.pop()] -= 1\n                else:\n                    return ''\n            elif c.isdigit():\n                if stack:\n                    res[stack[-1]] += int(c)\n                else:\n                    res[c] = int(c)\n        if stack:\n            res[stack.pop()] -= 1\n        return ''.join(str(res.get(k, 0)) + k for k in sorted(res))"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack, res = [], {}\n        for c in formula:\n            if c.isalpha():\n                if stack:\n                    res[stack.pop()] += 1\n                stack.append(c)\n            elif c == ')':\n                if stack:\n                    res[stack.pop()] += 1\n            elif c.isdigit():\n                res[stack.pop()] *= int(c)\n            else:\n                stack.append(c)\n        return ''.join(str(res.get(k, 0)) + k for k in sorted(res))"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack, res = [], {}\n        for c in formula:\n            if c.isupper():\n                stack.append(c)\n            elif c.islower():\n                if stack:\n                    res[stack[-1]] = res.get(stack[-1], 0) + 1\n                else:\n                    res[c] = 1\n            elif c == ')':\n                res[stack.pop()] -= 1\n        return ''.join(str(res.get(c, 0)) + c for c in sorted(res))"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack, res = [], {}\n        for c in formula:\n            if c.isalpha():\n                if stack:\n                    res[stack.pop()] += 1\n                stack.append(c)\n            elif c == ')':\n                if stack:\n                    res[stack.pop()] -= 1\n                else:\n                    return ''\n            elif c.isdigit():\n                if stack:\n                    res[stack[-1]] += int(c)\n                else:\n                    res[c] = int(c)\n        for k, v in res.items():\n            res[k] = str(v) if v else ''\n        return ''.join(sorted(res.keys(), key=lambda x: x.lower()))"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack, res = [], {}\n        for c in formula:\n            if c.isupper():\n                stack.append(c)\n            elif c.islower():\n                if stack:\n                    res[stack[-1]] = res.get(stack[-1], 0) + 1\n                else:\n                    res[c] = 1\n            elif c == ')':\n                res[stack.pop()] -= 1\n            else:\n                res[stack.pop()] += int(c)\n        return ''.join(str(res.get(k, 0)) + k for k in sorted(res))"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 0x55555555 is 01010101... in binary\n        # 2. 0x55555555 & n == 0x55555555 iff n is a power of 4\n        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 0 is not a power of 4\n        if n <= 0:\n            return False\n        \n        # 2. 1 is a power of 4\n        if n == 1:\n            return True\n        \n        # 3. n is a power of 4 iff n % 4 == 0 and n % 4 != 1\n        return n % 4 == 0 and n % 4 != 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 0x55555555 is 01010101... in binary\n        # 2. 0x55555555 & n == 0x55555555 iff n is a power of 4\n        return n > 0 and (n & (n - 1)) == 0 and n & 0x55555555 == n"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        return n & (n - 1) == 0 and n % 3 == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 0x55555555 is 01010101... in binary\n        # 2. 0x55555555 & n == 0x55555555 iff n is a power of 4\n        return n > 0 and (n & (n - 1)) == 0 and n & 0x55555555 == n"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not root:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not root:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not root:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not root:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not root:\n            return None\n        \n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        \n        res = [\"()\"] * 2\n        for i in range(2, n + 1):\n            res += [left + right for left in res for right in res[i - left - 1::]]\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        \n        res = [\"()\"]\n        for i in range(2, n + 1):\n            res += [left + right for left in res for right in res[i - 1:]]\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        \n        res = [\"()\"] * 2\n        for i in range(2, n + 1):\n            res += [left + right for left in res for right in res[i - left - 1::]]\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        \n        res = [\"()\"]\n        for i in range(2, n+1):\n            res += [left + right for left in res for right in res[i-1:]]\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return [\"()\"]\n        \n        res = [\"()\"]\n        for i in range(2, n+1):\n            res += [left + right for left in res for right in res[i-1:i]]\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        patches = 0\n        while i < len(nums) and nums[i] <= n:\n            n += nums[i]\n            i += 1\n        return patches + i"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        missing = 1\n        while missing <= n:\n            if i < len(nums) and missing <= nums[i]:\n                missing += nums[i]\n            i += 1\n            missing += 1\n        return i"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        missing = 1\n        \n        while missing <= n and i < len(nums):\n            missing += nums[i]\n            i += 1\n            \n        return i"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        missing = 1\n        while missing <= n:\n            if i < len(nums) and missing <= nums[i]:\n                missing += nums[i]\n            i += 1\n            missing += 1\n        return i"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        i = 0\n        missing = 1\n        \n        while missing <= n and i < len(nums):\n            missing += nums[i]\n            i += 1\n            \n        return i"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a stack to keep track of the index of the last '('\n        # If we see a ')' and the stack is not empty, then we have a valid pair\n        # If we see a ')' and the stack is empty, then we have an invalid pair\n        # In the latter case, we need to start a new valid pair from the index of the ')'\n        # If we see a '(' and the stack is empty, we start a new valid pair from the current index\n        # If we see a '(' and the stack is not empty, we need to update the max length\n        stack = [-1]\n        max_length = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    max_length = max(max_length, i * 2 - stack[-1])\n                else:\n                    max_length = max(max_length, i - stack[-1])\n        return max_length"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = -1\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack += 1\n            else:\n                stack -= 1\n                if stack < 0:\n                    stack = -1\n                    max_len = i + 1\n                else:\n                    max_len = max(max_len, i - stack)\n        return max_len"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = -1\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack += 1\n            else:\n                stack -= 1\n                if stack < 0:\n                    stack = -1\n                    max_len = i + 1\n                else:\n                    max_len = max(max_len, i - stack)\n        return max_len"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = -1\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack += 1\n            else:\n                stack -= 1\n                if stack < 0:\n                    stack = -1\n                    max_len = i + 1\n                else:\n                    max_len = max(max_len, i - stack)\n        return max_len"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s:\n            return 0\n        \n        stack = -1\n        max_len = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack += 1\n            else:\n                stack -= 1\n                if stack < 0:\n                    stack = -1\n                    max_len = i + 1\n                else:\n                    max_len = max(max_len, i - stack)\n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        sign = (numerator > 0) ^ (denominator > 0)\n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        result = \"\"\n        if numerator % denominator == 0:\n            return str(numerator // denominator) if sign else str(-numerator // denominator)\n        \n        result += str(numerator // denominator)\n        numerator %= denominator\n        result += \".\"\n        \n        seen = {numerator: len(result)}\n        while numerator:\n            if numerator in seen:\n                result = result[:seen[numerator]] + \"(\" + result[seen[numerator]:] + \")\"\n                break\n            numerator *= 10\n            result += str(numerator // denominator)\n            numerator %= denominator\n            seen[numerator] = len(result)\n        \n        return result if sign else \"-\" + result"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        sign = (numerator > 0) ^ (denominator > 0)\n        numerator, denominator = abs(numerator), abs(denominator)\n        result = \"\" if sign else \"-\"\n        result += str(numerator // denominator)\n        if numerator % denominator == 0:\n            return result\n        result += \".\"\n        remainder = numerator % denominator\n        seen = {remainder: len(result)}\n        while remainder * 10 % denominator != 0:\n            remainder *= 10\n            result += str(remainder // denominator)\n            if remainder in seen:\n                result = result[:seen[remainder]] + \"(\" + result[seen[remainder]:] + \")\"\n                break\n            seen[remainder] = len(result)\n        return result"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        sign = (numerator > 0) ^ (denominator > 0)\n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        result = \"\"\n        if numerator % denominator == 0:\n            return str(numerator // denominator) if not sign else \"-\" + str(numerator // denominator)\n        \n        result += str(numerator // denominator)\n        numerator %= denominator\n        result += \".\"\n        \n        seen = {numerator: len(result)}\n        while numerator:\n            if numerator in seen:\n                result = result[:seen[numerator]] + \"(\" + result[seen[numerator]:] + \")\"\n                break\n            numerator *= 10\n            result += str(numerator // denominator)\n            numerator %= denominator\n            seen[numerator] = len(result)\n        \n        return (\"-\" if sign else \"\") + result"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        sign = (numerator > 0) ^ (denominator > 0)\n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        result = \"\"\n        if numerator % denominator == 0:\n            return str(numerator // denominator) if not sign else \"-\" + str(numerator // denominator)\n        \n        result += str(numerator // denominator)\n        numerator %= denominator\n        result += \".\"\n        \n        seen = {numerator: len(result)}\n        while numerator:\n            if numerator in seen:\n                result = result[:seen[numerator]] + \"(\" + result[seen[numerator]:] + \")\"\n                break\n            numerator *= 10\n            result += str(numerator // denominator)\n            numerator %= denominator\n            seen[numerator] = len(result)\n        \n        return (\"-\" if sign else \"\") + result"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        sign = (numerator > 0) ^ (denominator > 0)\n        numerator, denominator = abs(numerator), abs(denominator)\n        result = \"\" if sign else \"-\"\n        result += str(numerator // denominator)\n        numerator %= denominator\n        if numerator == 0:\n            return result\n        result += \".\"\n        \n        # use hashmap to store the repeating part\n        # if the repeating part is longer than 10, we can ignore the rest\n        # if the repeating part is shorter than 10, we need to append the rest\n        # if the repeating part is 10, we need to append the rest and \"(\"\n        # if the repeating part is 11, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 12, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 13, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 14, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 15, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 16, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 17, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 18, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 19, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 20, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 21, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 22, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 23, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 24, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 25, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 26, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 27, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 28, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 29, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 30, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 31, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 32, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 33, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 34, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 35, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 36, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 37, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 38, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 39, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 40, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 41, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 42, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 43, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 44, we need to append the rest, \"(\" and \")\"\n        # if the repeating part is 45, we need to append the rest, \"(\" and \")\"\n        # if the repeating part"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n        \n    def merge(self, left, right):\n        dummy = head = ListNode(0)\n        while left and right:\n            if left.val <= right.val:\n                head.next = left\n                left = left.next\n            else:\n                head.next = right\n                right = right.next\n            head = head.next\n        head.next = left if left else right\n        return dummy.next\n        \n        \n# Time: O(NlogN)\n# Space: O(1)\n# Difficulty: medium\n#\n# Given the head of a singly linked list, sort the list using insertion sort.\n# Return the sorted linked list's head.\n#\n# The steps of the insertion sort algorithm:\n#\n# Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.\n# At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.\n# It repeats until no input elements remain.\n#\n# Example 1:\n#\n# Input: head = [4,2,1,3]\n# Output: [1,2,3,4]\n# Example 2:\n#\n# Input: head = [-1,5,3,4,0]\n# Output: [-1,0,3,4,5]\n#\n#\n# Constraints:\n#\n# The number of nodes in the list is in the range [1, 5000].\n# -5000 <= Node.val <= 5000\n#\n#\n# Follow up: Can you sort the linked list in O(n logn) time and constant space?\n#\n#\n#\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        tail = head\n        while tail and tail.next:\n            tail = tail.next.next\n            head.next, head, tail.next = head.next, tail.next, head\n        return dummy.next\n        \n        \n# Time: O(NlogN)\n# Space: O(1)\n# Difficulty: medium\n#\n# Given the head of a singly linked list, sort the list using insertion sort.\n#\n#\n#\n# Example 1:\n#\n#\n# Input: head = [4,2,1,3]\n# Output: [1,2,3,4]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [-1,5,3,4,0]\n# Output: [-1,0,3,4,5]\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is in the range [1, 5000].\n# -5000 <= Node.val <= 5000\n#\n#\n#\n# Follow up: Can you sort the linked list in O(n logn) time and constant space?\n#\n#\n#\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        tail = head\n        while tail and tail.next:\n            tail = tail.next.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid, slow.next = slow.next, None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode(0)\n        cur = dummy\n        while left and right:\n            if left.val <= right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        cur.next = left if left else right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid, slow.next = slow.next, None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode(0)\n        cur = dummy\n        while left and right:\n            if left.val <= right.val:\n                cur.next = left\n                left = left.next\n            else:\n                cur.next = right\n                right = right.next\n            cur = cur.next\n        \n        cur.next = left if left else right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        return self.merge(left, right)\n        \n    def merge(self, left, right):\n        dummy = head = ListNode(0)\n        while left and right:\n            if left.val <= right.val:\n                head.next = left\n                left = left.next\n            else:\n                head.next = right\n                right = right.next\n            head = head.next\n        head.next = left if left else right\n        return dummy.next\n        \n        \n# Time: O(NlogN)\n# Space: O(1)\n# Difficulty: medium\n#\n# Given the head of a singly linked list, sort the list using insertion sort.\n# Return the sorted linked list's head.\n#\n# The steps of the insertion sort algorithm:\n#\n# Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.\n# At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.\n# It repeats until no input elements remain.\n#\n# Example 1:\n#\n# Input: head = [4,2,1,3]\n# Output: [1,2,3,4]\n# Example 2:\n#\n# Input: head = [-1,5,3,4,0]\n# Output: [-1,0,3,4,5]\n#\n#\n# Constraints:\n#\n# The number of nodes in the list is in the range [1, 5000].\n# -5000 <= Node.val <= 5000\n#\n#\n# Follow up: Can you sort the linked list in O(n logn) time and constant space?\n#\n#\n#\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        tail = head\n        while tail and tail.next:\n            tail = tail.next.next\n            head.next, head, tail.next = head.next, tail.next, head\n        return dummy.next\n        \n        \n# Time: O(NlogN)\n# Space: O(1)\n# Difficulty: medium\n#\n# Given the head of a singly linked list, sort the list using insertion sort.\n#\n#\n#\n# Example 1:\n#\n# Input: head = [4,2,1,3]\n# Output: [1,2,3,4]\n#\n# Example 2:\n#\n# Input: head = [-1,5,3,4,0]\n# Output: [-1,0,3,4,5]\n#\n#\n#\n# Constraints:\n#\n# The number of nodes in the list is in the range [1, 5000].\n# -5000 <= Node.val <= 5000\n#\n#\n# Follow up: Can you sort the linked list in O(n logn) time and constant space?\n#\n#\n#\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        tail = head\n        while tail and tail.next:\n            tail = tail.next.next\n            head.next, head, tail."}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid, slow.next = slow.next, None\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        return self.merge(left, right)\n        \n    def merge(self, left, right):\n        dummy = head = ListNode(0)\n        while left and right:\n            if left.val <= right.val:\n                head.next = left\n                left = left.next\n            else:\n                head.next = right\n                right = right.next\n            head = head.next\n        head.next = left if left else right\n        return dummy.next\n        \n        \n# Time: O(NlogN)\n# Space: O(1)\n# Difficulty: medium\n#\n# Given the head of a singly linked list, sort the list using insertion sort.\n# Return the sorted linked list's head.\n#\n# The steps of the insertion sort algorithm:\n#\n# Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.\n# At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.\n# It repeats until no input elements remain.\n#\n# Example 1:\n#\n# Input: head = [4,2,1,3]\n# Output: [1,2,3,4]\n# Example 2:\n#\n# Input: head = [-1,5,3,4,0]\n# Output: [-1,0,3,4,5]\n#\n#\n# Constraints:\n#\n# The number of nodes in the list is in the range [1, 5000].\n# -5000 <= Node.val <= 5000\n#\n#\n# Follow up: Can you sort the linked list in O(n logn) time and constant space?\n#\n#\n#\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        tail = head\n        while tail and tail.next:\n            tail = tail.next.next\n            head.next, head, tail.next = head.next, tail.next, head\n        return dummy.next\n        \n        \n# Time: O(N)\n# Space: O(1)\n# Difficulty: medium\n#\n# Given the head of a singly linked list, sort the list using insertion sort.\n#\n#\n#\n# Example 1:\n#\n#\n# Input: head = [4,2,1,3]\n# Output: [1,2,3,4]\n#\n#\n# Example 2:\n#\n#\n# Input: head = [-1,5,3,4,0]\n# Output: [-1,0,3,4,5]\n#\n#\n#\n# Constraints:\n#\n#\n# The number of nodes in the list is in the range [1, 5000].\n# -5000 <= Node.val <= 5000\n#\n#\n#\n# Follow up: Can you sort the linked list in O(n logn) time and constant space?\n#\n#\n#\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        tail = head\n        while tail and tail.next:\n            tail = tail.next.next\n            head.next, head"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by width first, then by height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # keep track of the maximum number of envelopes that can be put inside the current envelope\n        # if the current envelope is smaller than the previous one, reset the counter\n        # otherwise, increment the counter\n        count, max_count = 1, 1\n        for w, h in envelopes[1:]:\n            if w > envelopes[count - 1][0]:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count ="}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by width first, then by height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # keep track of the maximum number of envelopes that can be put inside the current envelope\n        # if the current envelope is smaller than the previous one, reset the counter\n        # otherwise, increment the counter\n        # return the maximum number of envelopes\n        count, max_count = 1, 1\n        for w, h in envelopes[1:]:\n            if w > envelopes[count - 1][0]:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count ="}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort by width first, then by height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Keep track of the maximum number of envelopes that can be put inside the current envelope\n        # The maximum number of envelopes that can be put inside the current envelope is the minimum\n        # of the current height and the previous height\n        # If the current height is smaller than the previous height, then the previous height is the maximum\n        # number of envelopes that can be put inside the current envelope\n        heights = [1] * len(envelopes)\n        max_envelopes = 1\n        for i in range(1, len(envelopes)):\n            if envelopes[i][0] > envelopes[i-1][0]:\n                heights[i] = heights[i-1] + 1\n            else:\n                heights[i] = max(heights[i], 1)\n            max_envelopes = max(max_envelopes, heights[i])\n        return max_envelopes"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by width first, then by height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # keep track of the maximum number of envelopes that can be put inside the current envelope\n        # if the current envelope is smaller than the previous one, reset the counter\n        # otherwise, increment the counter\n        count, max_count = 1, 1\n        for w, h in envelopes[1:]:\n            if w > envelopes[count - 1][0]:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count ="}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort by width first, then by height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Keep track of the maximum number of envelopes that can be put inside the current envelope\n        # If the current envelope is smaller than the previous one, reset the counter\n        # Otherwise, increment the counter\n        count, max_count = 1, 1\n        for w, h in envelopes[1:]:\n            if w > envelopes[count - 1][0]:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count ="}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # check if the first row or first column is zero\n        if matrix[0][0] == 0:\n            for i in range(len(matrix[0])):\n                matrix[0][i] = 0\n            for i in range(len(matrix)):\n                if matrix[i][0] == 0:\n                    matrix[i][0] = 0\n        \n        # check if the first row or first column is zero\n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                matrix[0][0] = 0\n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0\n        \n        # set the first row or first column to zero\n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                matrix[0][i] = 0\n            matrix[0][i] = matrix[0][0]\n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0\n            matrix[i][0] = matrix[0][0]\n        \n        # set the first row or first column to zero\n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                matrix[i][0] = 0\n        \n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # check if the first row or first column is zero\n        if matrix[0][0] == 0:\n            for i in range(len(matrix[0])):\n                matrix[0][i] = 0\n            for i in range(len(matrix)):\n                if matrix[i][0] == 0:\n                    matrix[i][0] = 0\n        \n        # check if the first row or first column is zero\n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                matrix[0][0] = 0\n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0\n        \n        # set the first row or first column to zero\n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                matrix[0][i] = 0\n            matrix[0][i] = matrix[0][0]\n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0\n            matrix[i][0] = matrix[0][0]\n        \n        # set the first row or first column to zero\n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                matrix[i][0] = 0\n        \n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return\n        \n        row_zero = col_zero = False\n        for i in range(len(matrix[0])):\n            if matrix[0][i] == 0:\n                row_zero = True\n            if matrix[i][0] == 0:\n                col_zero = True\n        \n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0\n            if col_zero:\n                matrix[i][0] = 0\n        \n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                matrix[0][i] = 0\n        if row_zero:\n            matrix[0][0] = 0\n        if col_zero:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n```\n\n### 2. Solution\n\n```python\nclass Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return\n        \n        row_zero = col_zero = False\n        for i in range(len(matrix[0])):\n            if matrix[0][i] == 0:\n                row_zero = True\n            if matrix[i][0] == 0:\n                col_zero = True\n        \n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0\n            if col_zero:\n                matrix[i][0] = 0\n        \n        for i in range(1, len(matrix[0])):\n            if matrix[0][i] == 0:\n                matrix[0][i] = 0\n        if row_zero:\n            matrix[0][0] = 0\n        if col_zero:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n```\n\n### 3. Code(Faster)\n\n```python\nclass Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return\n        \n        row_zero = col_zero = False\n        for i in range(len(matrix[0])):\n            if matrix[0][i] == 0:\n                row_zero = True\n            if matrix[i][0] == 0:\n                col_zero = True\n        \n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0\n            if col_zero:\n                matrix[i][0] = 0\n        \n        if row_zero:\n            matrix[0][0] = 0\n        if col_zero:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n```\n\n### 4. Code(Faster)\n\n```python\nclass Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return\n        \n        row_zero = col_zero = False\n        for i in range(len(matrix[0])):\n            if matrix[0][i] == 0:\n                row_zero = True\n            if matrix[i][0] == 0:\n                col_zero = True\n        \n        for i in range(1, len(matrix)):\n            if matrix[i][0] == 0:\n                matrix[i][0] = 0\n            if col_zero:\n                matrix[i][0] = 0\n        \n        if row_zero:\n            matrix[0][0] = 0\n        if col_zero:\n            for i in range("}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return\n        \n        m, n = len(matrix), len(matrix[0])\n        row_zero, col_zero = False, False\n        \n        for i in range(m):\n            if matrix[i][0] == 0:\n                col_zero = True\n            else:\n                matrix[i][0] = 1\n        \n        for i in range(1, n):\n            if matrix[0][i] == 0:\n                row_zero = True\n            else:\n                matrix[0][i] = 1\n        \n        for i in range(1, m):\n            if matrix[i][0] == 0:\n                matrix[i][:"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return\n        \n        m, n = len(matrix), len(matrix[0])\n        row_zero, col_zero = False, False\n        \n        for i in range(m):\n            if matrix[i][0] == 0:\n                col_zero = True\n            else:\n                matrix[i][0] = 1\n        \n        for i in range(1, n):\n            if matrix[0][i] == 0:\n                row_zero = True\n            else:\n                matrix[0][i] = 1\n        \n        for i in range(1, m):\n            if matrix[i][0] == 0:\n                matrix[i][:"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        first, second = dummy, dummy\n        \n        for _ in range(n):\n            first = first.next\n        \n        while first:\n            first = first.next\n            second = second.next\n        \n        second.next = second.next.next\n        \n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        first, second = dummy, dummy\n        \n        for _ in range(n):\n            first = first.next\n        \n        while first:\n            first = first.next\n            second = second.next\n        \n        second.next = second.next.next\n        \n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        first, second = dummy, dummy\n        \n        for _ in range(n):\n            first = first.next\n        \n        while first:\n            first = first.next\n            second = second.next\n        \n        second.next = second.next.next\n        \n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        first, second = dummy, dummy\n        \n        for _ in range(n):\n            first = first.next\n        \n        while first:\n            first = first.next\n            second = second.next\n        \n        second.next = second.next.next\n        \n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        first, second = dummy, dummy\n        \n        for _ in range(n):\n            first = first.next\n        \n        while first:\n            first = first.next\n            second = second.next\n        \n        second.next = second.next.next\n        \n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num] = M1[num] - M1[num] + M2[num]\n        # M1[num] - M2[num] >= 0\n        # M1[num] - M2[num] >= M1[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num] + M1[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] >= M2[num]\n        # M1[num] >= M2[num] and M1[num] > 0\n        # M1[num] > M2[num]\n        \n        # M1[num] > M2[num]\n        # M1[num] - M2[num] > M2[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M1[num] - M2[num]\n        # M1[num] - M2[num] - M2[num] > 0\n        # M1[num] - M2[num] - M2[num] >= M2[num]\n        # M1[num] - M2[num] - M2[num] >= M2[num] and M1[num] - M2[num] > M2[num]\n        # M1[num] - M2[num] - M2[num] >= M2[num] - M2[num]\n        # M1[num] - M2[num] - M2[num] >= 0\n        # M1[num] - M2[num] >= -M2[num]\n        # M1[num] >= -M2[num]\n        # M1[num] > -M2[num]\n        # M1[num] > nums2[i]\n        # M1[num] - nums2[i] > nums2[i]\n        # M1[num] - nums2[i] > 0\n        # M1[num] >= nums2[i]\n        # M1[num] > nums2[i] and M1[num] > nums2[i]\n        # M1[num] - nums2[i] > nums2[i] - nums2[i]\n        # M1[num] - nums2[i] > 0\n        # M1[num] - nums2[i] >= nums2[i] - nums2[i]\n        # M1[num] - nums2[i] >= 0\n        # M1[num] >= nums2[i] - nums2[i]\n        # M1[num] >= 0\n        # M1[num] > 0\n        # M1[num] > 0 and M1[num] > nums2[i]\n        # M1[num] - nums2[i] > nums2[i] - nums2[i]\n        # M1[num] - nums2[i] > 0\n        # M1[num] - nums2[i] >= nums2[i] - nums2[i]\n        # M1[num] - nums2[i] >= 0\n        # M1[num] >= nums2[i] - nums2[i]\n        # M1[num] >= 0\n        \n        # M1[num] >= 0\n        # M1[num] > 0 and M1[num] > nums2[i]\n        # M1[num] - nums2[i] > nums2[i] - nums2[i]\n        # M1[num] - nums2[i] > 0\n        # M1[num] - nums2["}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        # M2[num] = count\n        # intersection = M1 & M2\n        # intersection = M1[num] if num in M2 else 0\n        \n        # M1 = Counter(nums1)\n        # M2 = Counter(nums2)\n        # return list(M1.keys() & M2.keys())\n        \n        # M1 = Counter(nums1)\n        # M2 = Counter(nums2)\n        # return list(M1.keys() & M2.keys()) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2)\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2)\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set(nums2)\n        # return list(M1 & M2) if M1 & M2 else []\n        \n        # M1 = set(nums1)\n        # M2 = set"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num] = M1[num] - M1[num] + M2[num]\n        # M1[num] - M2[num] >= 0\n        # M1[num] - M2[num] >= M1[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num] + M1[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] >= M2[num]\n        # M1[num] >= M2[num] and M1[num] > 0\n        # M1[num] > 0 and M1[num] >= M2[num]\n        # M1[num] > 0 and M1[num] - M2[num] >= 0\n        # M1[num] - M2[num] >= 0\n        \n        # M1[num] - M2[num] is the number of elements in nums1 that is not in nums2\n        # M1[num] - M2[num] >= 0 means that nums1 has at least nums2 elements\n        # M1[num] - M2[num] >= M2[num] means that nums1 has at least nums2 elements and nums2 has at least nums1 elements\n        # M1[num] - M2[num] >= M2[num] and M1[num] > 0 means that nums1 has at least nums2 elements and nums2 has at least nums1 elements\n        # M1[num] - M2[num] >= M2[num] and M1[num] > 0 and M1[num] - M2[num] >= 0 means that nums1 has at least nums2 elements and nums2 has at least nums1 elements\n        # M1[num] - M2[num] >= M2[num] and M1[num] > 0 and M1[num] - M2[num] >= M2[num] means that nums1 has at least nums2 elements and nums2 has at least nums1 elements\n        # M1[num] - M2[num] >= M2[num] and M1[num] > 0 and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= 0 means that nums1 has at least nums2 elements and nums2 has at least nums1 elements\n        # M1[num] - M2[num] >= M2[num] and M1[num] > 0 and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= 0 means that nums1 has at least nums2 elements and nums2 has at least nums1 elements\n        # M1[num] - M2[num] >= M2[num] and M1[num] > 0 and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= 0 means that nums1 has at least nums2 elements and nums2 has at least nums1 elements\n        # M1[num] - M2[num] >= M2[num] and M1[num] > 0 and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= M2[num] and M1[num] - M2[num] >= M2[num] and M"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num] = M1[num] - M1[num] + M2[num]\n        # M1[num] - M2[num] >= 0\n        # M1[num] - M2[num] >= M1[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num] + M1[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] >= M2[num]\n        # M1[num] >= M2[num] and M1[num] > 0\n        # M1[num] > M2[num]\n        \n        # M1[num] > M2[num]\n        # M1[num] - M2[num] > M2[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num] + M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] >= M2[num]\n        # M1[num] > M2[num]\n        \n        # M1[num] > M2[num]\n        # M1[num] - M2[num] > M2[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num] + M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] - M2[num] >= M2[num] - M1[num]\n        # M1[num] >= M2[num]\n        # M1[num] > M2[num]\n        \n        # M1[num] > M2[num]\n        # M1[num] - M2[num] > M2[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num] + M1[num]\n        # M1[num] - M2[num] - M2[num] > M2[num] - M1[num] - M1[num]\n        #"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # M1[num] = count\n        M1 = collections.Counter(nums1)\n        M2 = collections.Counter(nums2)\n        \n        # M1[num] = M2[num]\n        # M1[num] - M2[num] = M1[num] - M1[num]\n        # M1[num] - M2[num] = 0\n        # M1[num] - M2[num] > 0\n        # M1[num] - M2[num] > 0\n        return [num for num in M1 if num in M2 and M1[num] - M2[num] <= 0]"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        if total % len(machines) != 0:\n            return -1\n        \n        avg = total // len(machines)\n        res = 0\n        left = 0\n        for right in machines:\n            if avg > right:\n                res += avg - right\n            else:\n                left += avg - right\n            avg = (left + right) // 2\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        if total % len(machines) != 0:\n            return -1\n        \n        avg = total // len(machines)\n        res = 0\n        left = 0\n        for right in machines:\n            if avg > right:\n                res += avg - right\n            else:\n                left += avg - right\n                avg = left\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        if total % len(machines) != 0:\n            return -1\n        \n        avg = total // len(machines)\n        res = 0\n        left = 0\n        for right in machines:\n            if avg > right:\n                res += avg - right\n            else:\n                left += avg - right\n            avg = (left + right) // 2\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        if total % len(machines) != 0:\n            return -1\n        \n        avg = total // len(machines)\n        res = 0\n        left = 0\n        for right in machines:\n            if avg > right:\n                res += avg - right\n            else:\n                left += avg - right\n                avg = left\n        return res"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        if total % len(machines) != 0:\n            return -1\n        \n        avg = total // len(machines)\n        res = 0\n        left = 0\n        for right in machines:\n            if avg > right:\n                res += avg - right\n            else:\n                left += avg - right\n            avg = (left + right) // 2\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # kth smallest number is kth number in the sorted array\n        # so we can use binary search to find it\n        # the total number of numbers in the array is m * n\n        # so the total number of numbers in the array is m * (n + k - 1) / k\n        # so the total number of numbers in the array is (m * n) * k / (k - 1)\n        # so the total number of numbers in the array is (m * n) * k / k\n        # so the total number of numbers in the array is m * n\n        return m * n * k // (k - 1)"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # kth smallest number is kth number in the sorted array\n        # so we can use binary search to find it\n        # the total number of numbers in the array is m * n\n        # so the total number of numbers in the array is m * (n + k - 1) / k\n        # so the total number of numbers in the array is m * (n + k - 1) // k\n        # so the total number of numbers in the array is m * n + m * (k - 1) // k\n        # so the total number of numbers in the array is m * n + (m - 1) * k // k\n        # so the total number of numbers in the array is m * n + (m - 1) * k % k\n        # so the total number of numbers in the array is m * n + (m - 1)\n        # so the total number of numbers in the array is m * n + (m - 1) * k % k\n        # so the total number of numbers in the array is m * n + (m - 1) * k % k + k // k * k\n        # so the total number of numbers in the array is m * n + (m - 1) * k % k + k % k\n        # so the total number of numbers in the array is m * n + (m - 1) * k\n        # so the total number of numbers in the array is m * n + (m - 1) * k + k\n        # so the total number of numbers in the array is m * n + (m - 1) * k + k - k\n        # so the total number of numbers in the array is m * n + (m - 1) * k\n        return m * n + (m - 1) * k"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # kth number is in the range [m * k / n, m * (k - 1) / n]\n        # so we can use binary search to find it\n        left, right = m * k // n, m * (k - 1) // n\n        while left < right:\n            mid = left + (right - left) // 2\n            if mid * n < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # kth smallest number is kth number in the sorted array\n        # so we can use binary search to find the kth number\n        # the number is (m * k) // n + 1\n        # if k is odd, we need to add m\n        return (m * k) // n + (k % 2)"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # kth smallest number is kth number in the sorted list\n        # so we can use binary search to find it\n        # the sorted list is [1, m] * [1, n]\n        # so the total number of elements is m * n\n        # so the total number of elements in the sorted list is k - 1\n        # so the total number of elements in the unsorted list is m * n - k + 1\n        # so the number in the unsorted list is (m * n - k + 1) + (k - 1) / (m + n - 2)\n        # so the number in the unsorted list is (m * n - k + 1) + (k - 1) // (m + n - 2)\n        # so the number in the unsorted list is (m * n - k) // (m + n - 2) + 1\n        return (m * n - k) // (m + n - 2) + 1"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the middle node\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list\n        mid = slow.next\n        slow.next = None\n        \n        # build the tree\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the middle node\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list\n        mid = slow.next\n        slow.next = None\n        \n        # build the tree\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the middle node\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list\n        mid = slow.next\n        slow.next = None\n        \n        # build the tree\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the middle node\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list\n        mid = slow.next\n        slow.next = None\n        \n        # build the tree\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the middle node\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list\n        mid = slow.next\n        slow.next = None\n        \n        # build the tree\n        root = TreeNode(mid.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(mid.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right, max_area = [0] * n, [n] * n, 0\n        \n        for i in range(m):\n            left[0], right[0] = matrix[i][0] == '1', matrix[i][n - 1] == '1'\n            for j in range(1, n):\n                if matrix[i][j] == '1':\n                    left[j] = max(left[j], left[j - 1])\n                else:\n                    left[j] = 0\n            max_area = max(max_area, right[j] * (right[j] - left[j] - 1))\n            \n            for j in range(n - 1, 0, -1):\n                if matrix[i][j] == '1':\n                    right[j] = min(right[j], right[j - 1])\n                else:\n                    right[j] = n\n            max_area = max(max_area, right[j] * (right[j] - left[j] - 1))\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = [0] * n, [n] * n\n        max_area = 0\n        \n        for i in range(m):\n            left[0], right[0] = matrix[i][0], matrix[i][-1]\n            for j in range(1, n):\n                if matrix[i][j] == '0':\n                    left[j], right[j] = left[j-1], right[j-1]\n                else:\n                    left[j], right[j] = max(left[j-1], left[j]), right[j]\n            max_area = max(max_area, right[j] * (i - left[j] + 1))\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right, max_area = [0] * n, [n] * n, 0\n        \n        for i in range(m):\n            left[0], right[0] = matrix[i][0], matrix[i][-1]\n            for j in range(1, n):\n                if matrix[i][j] == '0':\n                    left[j], right[j] = left[j - 1], right[j - 1]\n                else:\n                    left[j], right[j] = max(left[j - 1], left[j]), right[j]\n            max_area = max(max_area, right[j] * (i - left[j] + 1))\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = [0] * n, [n] * n\n        max_area = 0\n        \n        for i in range(m):\n            left[0], right[0] = matrix[i][0], matrix[i][-1]\n            for j in range(1, n):\n                if matrix[i][j] == '0':\n                    left[j], right[j] = left[j-1], right[j-1]\n                else:\n                    left[j], right[j] = max(left[j-1], left[j]), right[j]\n            max_area = max(max_area, right[j] * (i - left[j] + 1))\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right, max_area = [0] * n, [n] * n, 0\n        \n        for i in range(m):\n            left[0], right[0] = matrix[i][0] == '1', matrix[i][n - 1] == '1'\n            for j in range(1, n):\n                if matrix[i][j] == '1':\n                    left[j] = max(left[j], left[j - 1])\n                else:\n                    left[j] = 0\n            max_area = max(max_area, right[j] * (right[j] - left[j] - 1))\n            \n            for j in range(n - 1, 0, -1):\n                if matrix[i][j] == '1':\n                    right[j] = min(right[j], right[j - 1])\n                else:\n                    right[j] = n\n            max_area = max(max_area, right[j] * (right[j] - left[j] - 1))\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [sub + [num] for sub in res]\n        return res"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [sub + [num] for sub in res]\n        return res"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [sub + [num] for sub in res]\n        return res"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [sub + [num] for sub in res]\n        return res"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [sub + [num] for sub in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u5230\u6700\u5c0f\u503c\n        # 2. \u627e\u5230\u6700\u5927\u503c\n        # 3. \u6700\u5c0f\u503c\u5728\u4e2d\u95f4\n        # 4. \u6700\u5c0f\u503c\u5728\u6700\u5de6\u8fb9\n        # 5. \u6700\u5c0f\u503c\u5728\u6700\u53f3\u8fb9\n        # 6. \u6700\u5c0f\u503c\u5728\u6700\u5de6\u8fb9\u548c\u6700\u53f3\u8fb9\u4e4b\u95f4\n        \n        # 1. \u627e\u5230\u6700\u5c0f\u503c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\uff0c\u4e8c\u5206\u67e5\u627e\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if not nums:\n            return None\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # 2. \u627e\u5230\u6700\u5927\u503c\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(logN)\uff0c\u4e8c\u5206\u67e5\u627e\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if not nums:\n            return None\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n        \n        # 3. \u6700\u5c0f\u503c\u5728\u4e2d\u95f4\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if not nums:\n            return None\n        return nums[0]\n        \n        # 4. \u6700\u5c0f\u503c\u5728\u6700\u5de6\u8fb9\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        return nums[0]\n        \n        # 5. \u6700\u5c0f\u503c\u5728\u6700\u53f3\u8fb9\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        return nums[-1]\n        \n        # 6. \u6700\u5c0f\u503c\u5728\u6700\u5de6\u8fb9\u548c\u6700\u53f3\u8fb9\u4e4b\u95f4\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        if nums[0] < nums[-1]:\n            return nums[0]\n        return nums[len(nums) // 2]\n```\n\n## 2. \u53cc\u6307\u9488\n\n```python\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n```\n\n## 3. \u4e8c\u5206\u67e5\u627e\n\n```python\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n```\n\n## 4. \u54c8\u5e0c\u8868\n\n```python\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        return nums[0] if nums else None\n```\n\n## 5. \u54c8\u5e0c\u8868\n\n```python\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        return nums[0] if nums else None\n```\n\n## 6. \u54c8\u5e0c\u8868\n\n```python\nclass Solution:\n    def findMin(self, nums: List[int]) ->"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1 <= nums.length <= 5000\n        # -5000 <= nums[i] <= 5000\n        # nums is sorted and rotated between 1 and n times.\n        \n        # if nums[0] < nums[-1], return nums[0]\n        # otherwise, nums[0] == nums[-1], so nums[0] must be the minimum\n        return nums[0] if nums[0] < nums[-1] else nums[-1]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1 <= nums.length <= 5000\n        # -5000 <= nums[i] <= 5000\n        # nums is sorted and rotated between 1 and n times.\n        \n        # binary search\n        # runtime: 28ms\n        # memory: 14.7MB\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]\n        \n        # two pointers\n        # runtime: 32ms\n        # memory: 14.7MB\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n        \n        # one pointer\n        # runtime: 28ms\n        # memory: 14.7MB\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] >= nums[right]:\n            if nums[left] == nums[right]:\n                left += 1\n            right -= 1\n        return nums[left]\n```\n\n### 2. Two Pointers\n\n```python\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n```\n\n### 3. One Pointer\n\n```python\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n```\n\n### 4. Binary Search\n\n```python\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n```\n\n### 5. Binary Search II\n\n```python\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n```\n\n### 6. Binary Search III\n\n```python\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n```\n\n### 7. Binary Search IV\n\n```python\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]\n```\n\n### 8. Binary Search V\n\n```python\nclass Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1 <= nums.length <= 5000\n        # -5000 <= nums[i] <= 5000\n        # nums is sorted and rotated between 1 and n times.\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # else:\n        #     return nums[-1]\n        \n        # binary search\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # else:\n        #     left, right = 0, len(nums) - 1\n        #     while left < right:\n        #         mid = left + (right - left) // 2\n        #         if nums[mid] > nums[right]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid\n        #     return nums[left]\n        \n        # two pointers\n        left, right = 0, len(nums) - 1\n        while left < right and nums[left] == nums[right]:\n            left += 1\n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u5230\u6700\u5c0f\u503c\n        # 2. \u627e\u5230\u6700\u5927\u503c\n        # 3. \u6700\u5c0f\u503c\u5728\u4e2d\u95f4\n        # 4. \u6700\u5c0f\u503c\u5728\u6700\u5de6\u8fb9\n        # 5. \u6700\u5c0f\u503c\u5728\u6700\u53f3\u8fb9\n        # 6. \u6700\u5c0f\u503c\u5728\u6700\u5de6\u8fb9\uff0c\u6700\u5927\u503c\u5728\u6700\u53f3\u8fb9\n        # 7. \u6700\u5c0f\u503c\u5728\u6700\u53f3\u8fb9\uff0c\u6700\u5927\u503c\u5728\u6700\u5de6\u8fb9\n        # 8. \u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u76f8\u7b49\n        \n        # 1. \u627e\u5230\u6700\u5c0f\u503c\n        # 2. \u627e\u5230\u6700\u5927\u503c\n        # 3. \u6700\u5c0f\u503c\u5728\u4e2d\u95f4\n        # 4. \u6700\u5c0f\u503c\u5728\u6700\u5de6\u8fb9\n        # 5. \u6700\u5c0f\u503c\u5728\u6700\u53f3\u8fb9\n        # 6. \u6700\u5c0f\u503c\u5728\u6700\u5de6\u8fb9\uff0c\u6700\u5927\u503c\u5728\u6700\u53f3\u8fb9\n        # 7. \u6700\u5c0f\u503c\u5728\u6700\u53f3\u8fb9\uff0c\u6700\u5927\u503c\u5728\u6700\u5de6\u8fb9\n        # 8. \u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u76f8\u7b49\n        if not nums:\n            return None\n        if len(nums) == 1:\n            return nums[0]\n        if nums[0] < nums[-1]:\n            return nums[0]\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u6b63\u5219\u8868\u8fbe\u5f0f\n        # return bool(re.match(r'^[+-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$', s))\n        \n        # 2. \u6808\n        # \u6808\u4e2d\u5b58\u653e\u7684\u662f\u6570\u5b57\u548c\u7b26\u53f7\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcd\u6216\u8005+-\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230.\uff0c\u5219\u5c06.\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5176\u4ed6\u5b57\u7b26\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u6808\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56deTrue\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u6808\u4e2d\u53ea\u6709\u4e00\u4e2a\u7b26\u53f7\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u6808\u4e2d\u6709\u4e24\u4e2a\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\uff0c\u5c06\u6570\u5b57\u51fa\u6808\uff0c\u5c06\u7b26\u53f7\u5165\u6808\uff0c\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u4e09\u4e2a\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\uff0c\u5c06\u6570\u5b57\u51fa\u6808\uff0c\u5c06\u7b26\u53f7\u5165\u6808\uff0c\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u5176\u4ed6\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u6808\u4e2d\u6709\u6570\u5b57\uff0c\u5219\u8fd4\u56deTrue\n        stack = []\n        for c in s:\n            if c == ' ':\n                continue\n            if c == '+' or c == '-' or c == '.':\n                if not stack or stack[-1] == 'e':\n                    return False\n                if c == 'e':\n                    if not stack or stack[-1] not in '+-0123456789':\n                        return False\n                    stack.append(c)\n                else:\n                    stack.append(c)\n            elif c in '0123456789':\n                if not stack or stack[-1] == 'e':\n                    stack.append(c)\n                else:\n                    stack.append(c if stack[-1] == '.' else stack[-1] * 10 + int(c))\n            elif c == 'e':\n                if not stack or stack[-1] not in '+-0123456789':\n                    return False\n                stack.append(c)\n            else:\n                return False\n        return not stack or (stack[-1] == '+' or stack[-1] == '-' or stack[-1] in '0123456789')\n        \n        # 3. \u6808+\u6b63\u5219\u8868\u8fbe\u5f0f\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcd\u6216\u8005+-\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230.\uff0c\u5219\u5c06.\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5176\u4ed6\u5b57\u7b26\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u6808\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56deTrue\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u6808\u4e2d\u6709\u4e24\u4e2a\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\uff0c\u5c06\u6570\u5b57\u51fa\u6808\uff0c\u5c06\u7b26\u53f7\u5165\u6808\uff0c\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u4e09\u4e2a\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\uff0c\u5c06\u6570\u5b57\u51fa\u6808\uff0c\u5c06\u7b26"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u6b63\u5219\u8868\u8fbe\u5f0f\n        # return re.match(r'^[+-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$', s) is not None\n        \n        # 2. \u6808\n        # \u6808\u4e2d\u5b58\u653e\u7684\u662f\u7b26\u53f7\u548c\u6570\u5b57\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\uff0c\u5426\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcdE\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\uff0c\u5426\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcd\u6216\u8005\u6570\u5b57\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u6808\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56deTrue\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deFalse\n        stack = []\n        sign = '+'\n        for c in s:\n            if c == ' ':\n                continue\n            if c in '+-':\n                if stack and stack[-1] == 'e':\n                    stack.pop()\n                    sign = c\n                elif stack and stack[-1] == 'E':\n                    stack.pop()\n                    sign = c\n                else:\n                    sign = c\n            elif c in '0123456789':\n                if sign == '-':\n                    stack.append('-' + c)\n                else:\n                    stack.append(c)\n            elif c == 'e' or c == 'E':\n                if stack and stack[-1] in '+-':\n                    stack.append(sign)\n                    sign = '+'\n                elif not stack:\n                    return False\n                else:\n                    stack.pop()\n                    sign = '+'\n            else:\n                return False\n        return not stack or stack.pop() == '+'\n        \n        # 3. \u6808 + \u6b63\u5219\n        # \u6808\u4e2d\u5b58\u653e\u7684\u662f\u7b26\u53f7\u548c\u6570\u5b57\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\uff0c\u5426\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcdE\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\uff0c\u5426\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcd\u6216\u8005\u6570\u5b57\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u6808\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56deTrue\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deFalse\n        stack = []\n        sign = '+'\n        for c in s:\n            if c.isdigit() or c == '.':\n                if sign == '-':\n                    stack.append('-' + c)\n                else:\n                    stack.append(c)\n            elif c == 'e' or c == 'E':\n                if stack and stack[-1] in '+-':\n                    stack.append(sign)\n                    sign = '+'\n                elif not stack:\n                    return False\n                else:\n                    stack.pop()\n                    sign = '+'\n            elif c in '+-':\n                sign = c\n            else:\n                return False\n        return not stack or stack.pop() == '+'\n        \n        # 4. \u6b63\u5219\u8868\u8fbe\u5f0f"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        while i < len(s) and s[i] == ' ':\n            i += 1\n        \n        if i == len(s):\n            return False\n        \n        if s[i] == '+' or s[i] == '-':\n            i += 1\n        \n        if i == len(s):\n            return False\n        \n        if s[i] == '.':\n            i += 1\n            if i == len(s):\n                return True\n            if not s[i].isdigit():\n                return False\n            i += 1\n            while i < len(s) and s[i].isdigit():\n                i += 1\n            return i == len(s)\n        \n        if not s[i].isdigit():\n            return False\n        i += 1\n        while i < len(s) and s[i].isdigit():\n            i += 1\n        \n        if i == len(s):\n            return True\n        \n        if s[i] == 'e':\n            i += 1\n            if i == len(s):\n                return False\n            if s[i] == '+' or s[i] == '-':\n                i += 1\n            if i == len(s) or not s[i].isdigit():\n                return False\n            i += 1\n            while i < len(s) and s[i].isdigit():\n                i += 1\n            return i == len(s)\n        \n        return False"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u6b63\u5219\u8868\u8fbe\u5f0f\n        # return bool(re.match(r'^[+-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$', s))\n        \n        # 2. \u6808\n        # \u6808\u4e2d\u5b58\u653e\u7684\u662f\u6570\u5b57\u548c\u7b26\u53f7\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcd\u6216\u8005+-\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230.\uff0c\u5219\u5c06.\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u5c0f\u5199\u5b57\u6bcd\u6216\u8005+-\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709.\uff0c\u5219\u5c06.\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6ca1\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u6808\u4e2d\u6ca1\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deTrue\n        stack = []\n        for c in s:\n            if c == ' ':\n                continue\n            if c == '+' or c == '-' or c == '.':\n                if not stack or stack[-1] == 'e':\n                    return False\n                if stack and stack[-1] in '+-':\n                    stack.pop()\n                stack.append(c)\n            elif c.isdigit():\n                stack.append(c)\n            elif c == 'e':\n                if not stack or stack[-1] not in '+-0123456789':\n                    return False\n                stack.append(c)\n            else:\n                return False\n        return not stack or stack.pop() in '+-0123456789'\n        \n        # 3. \u6808+\u6b63\u5219\n        # \u6b63\u5219\u8868\u8fbe\u5f0f\u5339\u914d\u7684\u65f6\u5019\uff0c\u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcd\u6216\u8005+-\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230.\uff0c\u5219\u5c06.\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u5c0f\u5199\u5b57\u6bcd\u6216\u8005+-\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709.\uff0c\u5219\u5c06.\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6709\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u51fa\u6808\n        # \u5982\u679c\u6808\u4e2d\u6ca1\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u6808\u4e2d\u6ca1\u6709\u7b26\u53f7\uff0c\u5219\u8fd4\u56deTrue\n        stack = []\n        return bool(re.match(r'^[+-]?"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u6b63\u5219\u8868\u8fbe\u5f0f\n        # return re.match(r'^[+-]?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$', s) is not None\n        \n        # 2. \u6808\n        # \u6808\u4e2d\u5b58\u653e\u7684\u662f\u7b26\u53f7\u548c\u6570\u5b57\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u9047\u5230\u5927\u5199\u5b57\u6bcdE\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcd\u6216\u8005\u5927\u5199\u5b57\u6bcd\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u9047\u5230\u5c0f\u6570\u70b9\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u7ed3\u675f\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5982\u679c\u7b26\u53f7\u548c\u6570\u5b57\u90fd\u4e3a\u7a7a\uff0c\u5219\u8fd4\u56deTrue\uff0c\u5426\u5219\u8fd4\u56deFalse\n        stack = []\n        sign = '+'\n        for c in s:\n            if c == ' ':\n                continue\n            if c in '+-':\n                if stack and stack[-1] == 'e':\n                    return False\n                sign = c\n            elif c in '0123456789':\n                if not stack or stack[-1] == 'e':\n                    stack.append(sign + c)\n                else:\n                    stack[-1] += c\n            elif c == '.':\n                if 'e' in stack:\n                    return False\n                if stack and stack[-1] in '0123456789':\n                    stack.append('.')\n                else:\n                    stack.append(sign + '.')\n                sign = '.'\n            elif c == 'e':\n                if 'e' in stack:\n                    return False\n                if stack and stack[-1] in '0123456789':\n                    stack.append('e')\n                else:\n                    return False\n                sign = '+'\n            else:\n                return False\n        return not stack or stack[-1] in '+-.e0123456789'\n        \n        # 3. \u6808+\u6b63\u5219\n        # \u6808\u4e2d\u5b58\u653e\u7684\u662f\u7b26\u53f7\u548c\u6570\u5b57\n        # \u5982\u679c\u9047\u5230\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcde\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u9047\u5230\u5927\u5199\u5b57\u6bcdE\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u9047\u5230\u5c0f\u5199\u5b57\u6bcd\u6216\u8005\u5927\u5199\u5b57\u6bcd\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u9047\u5230\u5c0f\u6570\u70b9\uff0c\u5219\u5c06\u7b26\u53f7\u548c\u6570\u5b57\u51fa\u6808\uff0c\u5e76\u5224\u65ad\u7b26\u53f7\u662f\u5426\u4e3a\u8d1f\u53f7\uff0c\u5982\u679c\u662f\u8d1f\u53f7\u5219\u8fd4\u56deFalse\n        # \u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u5165\u6808\n        # \u5982\u679c\u9047\u5230\u7ed3\u675f\u7b26\u53f7\uff0c\u5219\u5c06\u7b26\u53f7"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D,"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D,"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D,"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D,"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D,"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        return chr(ord(t) - ord(s))"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # M1. Hash\n        return chr(ord(t) - ord(s))\n        \n        # M2. XOR\n        return chr(t^s)\n        \n        # M3. Set\n        return t - s\n        \n        # M4. Sort\n        return sorted(s + t)[-1]\n        \n        # M5. Bit Manipulation\n        return chr(t ^ s)\n        \n        # M6. Bit Manipulation\n        return chr(t ^ s ^ (t - s))\n        \n        # M7. Bit Manipulation\n        return chr(t ^ s ^ (t & s))\n        \n        # M8. Bit Manipulation\n        return chr(t ^ s ^ (t & -t))\n        \n        # M9. Bit Manipulation\n        return chr(t ^ s ^ (t & -s))\n        \n        # M10. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t))\n        \n        # M11. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t))\n        \n        # M12. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -s))\n        \n        # M13. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M14. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M15. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M16. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M17. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M18. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M19. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M20. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M21. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M22. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M23. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M24. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M25. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M26. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M27. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M28. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M29. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M30. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M31. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M32. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M33. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M34. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t ^ s))\n        \n        # M35. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # M1. Hash\n        return chr(ord(t) - ord(s))\n        \n        # M2. XOR\n        return chr(t^s)\n        \n        # M3. Bit Manipulation\n        return chr(t."}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        return t[len(s)] if s else t[0]"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # M1. Hash\n        return chr(ord(t) - ord(s))\n        \n        # M2. XOR\n        return chr(t^s)\n        \n        # M3. Set\n        return t - s\n        \n        # M4. Sort\n        return sorted(s + t)[-1]\n        \n        # M5. Bit Manipulation\n        return chr(t ^ s)\n        \n        # M6. Bit Manipulation\n        return chr(t ^ s ^ (t - s))\n        \n        # M7. Bit Manipulation\n        return chr(t ^ s ^ (t & s))\n        \n        # M8. Bit Manipulation\n        return chr(t ^ s ^ (t & -t))\n        \n        # M9. Bit Manipulation\n        return chr(t ^ s ^ (t & -s))\n        \n        # M10. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t))\n        \n        # M11. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t))\n        \n        # M12. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -s))\n        \n        # M13. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s))\n        \n        # M14. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s))\n        \n        # M15. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t))\n        \n        # M16. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t) ^ (t & -s))\n        \n        # M17. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t) ^ (t & -s) ^ (s & -s))\n        \n        # M18. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t) ^ (t & -s) ^ (s & -s) ^ (s & -t))\n        \n        # M19. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t) ^ (t & -s) ^ (s & -s) ^ (s & -t) ^ (s & -s))\n        \n        # M20. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t) ^ (t & -s) ^ (s & -s) ^ (s & -t) ^ (s & -s) ^ (s & -t))\n        \n        # M21. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t) ^ (t & -s) ^ (s & -s) ^ (s & -t) ^ (s & -s) ^ (s & -t) ^ (s & -s))\n        \n        # M22. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t) ^ (t & -s) ^ (s & -s) ^ (s & -t) ^ (s & -s) ^ (s & -t) ^ (s & -s) ^ (s & -t))\n        \n        # M23. Bit Manipulation\n        return chr(t ^ s ^ (t ^ s & -t) ^ (t ^ s & -s) ^ (t & -t) ^ (t & -s) ^ (s & -s) ^ (s & -t) ^ (s & -s) ^ (s & -t) ^ (s & -s) ^ ("}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            r = row // 3 * 3 + col // 3\n            if board[r][col % 3 + r % 3] == num:\n                return False\n            return True\n        \n        def backtrack(board, row, col):\n            if row == 9:\n                return True\n            if col == 9:\n                return backtrack(board, row + 1, 0)\n            if board[row][col] != '.':\n                return backtrack(board, row, col + 1)\n            for num in range(1, 10):\n                if isValid(board, row, col, num):\n                    board[row][col] = str(num)\n                    if backtrack(board, row, col + 1):\n                        return True\n                board[row][col] = '.'\n            return False\n        \n        if not backtrack(board, 0, 0):\n            return False\n        return board"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u68c0\u67e5\u6bcf\u4e00\u884c\uff0c\u6bcf\u4e00\u5217\uff0c\u6bcf\u4e00\u4e2a\u5c0f\u4e5d\u5bab\u683c\u662f\u5426\u6709\u91cd\u590d\u6570\u5b57\n        # 2. \u5982\u679c\u6709\u91cd\u590d\u6570\u5b57\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        # 3. \u5982\u679c\u6ca1\u6709\u91cd\u590d\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u586b\u5165\u5bf9\u5e94\u7684\u4f4d\u7f6e\n        # 4. \u5982\u679c\u586b\u5165\u7684\u6570\u5b57\u4e0d\u5408\u6cd5\uff0c\u5219\u56de\u6eaf\n        # 5. \u5982\u679c\u586b\u5165\u7684\u6570\u5b57\u5408\u6cd5\uff0c\u5219\u7ee7\u7eed\u586b\u5165\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\n        # 6. \u5982\u679c\u586b\u5165\u7684\u6570\u5b57\u5408\u6cd5\uff0c\u5219\u8fd4\u56de\n        \n        # 1. \u68c0\u67e5\u6bcf\u4e00\u884c\uff0c\u6bcf\u4e00\u5217\uff0c\u6bcf\u4e00\u4e2a\u5c0f\u4e5d\u5bab\u683c\u662f\u5426\u6709\u91cd\u590d\u6570\u5b57\n        row = [0] * 9\n        col = [0] * 9\n        box = [0] * 9\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    row[i] |= 1 << (ord(board[i][j]) - ord('1'))\n                    col[j] |= 1 << (ord(board[i][j]) - ord('1'))\n                    box[i // 3 * 3 + j // 3] |= 1 << (ord(board[i][j]) - ord('1'))\n                else:\n                    continue\n        \n        # 2. \u5982\u679c\u6709\u91cd\u590d\u6570\u5b57\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n        for r in row:\n            if r & (r - 1) != 0:\n                return\n        for c in col:\n            if c & (c - 1) != 0:\n                return\n        for b in box:\n            if b & (b - 1) != 0:\n                return\n        \n        # 3. \u5982\u679c\u6ca1\u6709\u91cd\u590d\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u586b\u5165\u5bf9\u5e94\u7684\u4f4d\u7f6e\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    num = 1 << (ord(board[i][j]) - ord('1'))\n                    if row[i] & num or col[j] & num or box[i // 3 * 3 + j // 3] & num:\n                        continue\n                    row[i] |= num\n                    col[j] |= num\n                    box[i // 3 * 3 + j // 3] |= num\n                    board[i][j] = chr(ord('1') + num - 1)\n                    self.solveSudoku(board)\n                    row[i] ^= num\n                    col[j] ^= num\n                    box[i // 3 * 3 + j // 3] ^= num\n                    board[i][j] = '.'\n        return\n```\n\n## 2. \u89e3\u9898\u601d\u8def\n\n### 2.1 \u89e3\u9898\u601d\u8def\n\n\u8fd9\u9898\u662f\u4e00\u9898\u5178\u578b\u7684\u56de\u6eaf\u9898\uff0c\u6211\u4eec\u9700\u8981\u904d\u5386\u6bcf\u4e00\u4e2a\u7a7a\u683c\uff0c\u7136\u540e\u5c1d\u8bd5\u586b\u5165 1-9 \u7684\u6570\u5b57\uff0c\u5982\u679c\u586b\u5165\u7684\u6570\u5b57\u4e0d\u5408\u6cd5\uff0c\u5219\u56de\u6eaf\uff0c\u7ee7\u7eed\u5c1d\u8bd5\u4e0b\u4e00\u4e2a\u6570\u5b57\u3002\n\n### 2.2 \u89e3\u9898\u6b65\u9aa4\n\n1. \u5224\u65ad\u6bcf\u4e00\u884c\uff0c\u6bcf\u4e00\u5217\uff0c\u6bcf\u4e00\u4e2a\u5c0f\u4e5d\u5bab\u683c\u662f\u5426\u6709\u91cd\u590d\u6570\u5b57\uff0c\u5982\u679c\u6709\u91cd\u590d\u6570\u5b57\uff0c\u5219\u76f4\u63a5\u8fd4\u56de\n2. \u5982\u679c\u6ca1\u6709\u91cd\u590d\u6570\u5b57\uff0c\u5219\u5c06\u6570\u5b57\u586b\u5165\u5bf9\u5e94\u7684\u4f4d\u7f6e\n3. \u5982\u679c\u586b\u5165\u7684\u6570\u5b57\u4e0d\u5408\u6cd5\uff0c\u5219\u56de\u6eaf\n4. \u5982\u679c\u586b\u5165\u7684\u6570\u5b57\u5408\u6cd5\uff0c\u5219\u7ee7\u7eed\u586b\u5165\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\n5. \u5982\u679c\u586b\u5165\u7684\u6570\u5b57\u5408\u6cd5\uff0c\u5219\u8fd4\u56de\n\n## 3. \u590d\u6742\u5ea6\u5206\u6790\n\n* \u65f6\u95f4\u590d\u6742\u5ea6\uff1a*O*(1)\uff0c\u53ea\u9700\u8981\u904d"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            return num not in row[col] and num not in col[row] and num not in box[row // 3 * 3 + col // 3]\n        \n        row, col, box = [set() for _ in range(9)], [set() for _ in range(9)], [set() for _ in range(9)]\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    row[i].add(board[i][j])\n                    col[j].add(board[i][j])\n                    box[i // 3 * 3 + j // 3].add(board[i][j])\n                else:\n                    row[i].add(board[i][j])\n                    col[j].add(board[i][j])\n                    box[i // 3 * 3 + j // 3].add(board[i][j])\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    for num in row[i] | col[j] | box[i // 3 * 3 + j // 3]:\n                        if isValid(i, j, num):\n                            board[i][j] = num\n                            row[i].add(num)\n                            col[j].add(num)\n                            box[i // 3 * 3 + j // 3].add(num)\n                            break\n                    else:\n                        return False\n        return True"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u9884\u5904\u7406\n        # 2. \u586b\u5145\n        # 3. \u56de\u6eaf\n        # 4. \u526a\u679d\n        # 5. \u526a\u679d\n        # 6. \u526a\u679d\n        # 7. \u526a\u679d\n        # 8. \u526a\u679d\n        # 9. \u526a\u679d\n        # 10. \u526a\u679d\n        # 11. \u526a\u679d\n        # 12. \u526a\u679d\n        # 13. \u526a\u679d\n        # 14. \u526a\u679d\n        # 15. \u526a\u679d\n        # 16. \u526a\u679d\n        # 17. \u526a\u679d\n        # 18. \u526a\u679d\n        # 19. \u526a\u679d\n        # 20. \u526a\u679d\n        # 21. \u526a\u679d\n        # 22. \u526a\u679d\n        # 23. \u526a\u679d\n        # 24. \u526a\u679d\n        # 25. \u526a\u679d\n        # 26. \u526a\u679d\n        # 27. \u526a\u679d\n        # 28. \u526a\u679d\n        # 29. \u526a\u679d\n        # 30. \u526a\u679d\n        # 31. \u526a\u679d\n        # 32. \u526a\u679d\n        # 33. \u526a\u679d\n        # 34. \u526a\u679d\n        # 35. \u526a\u679d\n        # 36. \u526a\u679d\n        # 37. \u526a\u679d\n        # 38. \u526a\u679d\n        # 39. \u526a\u679d\n        # 40. \u526a\u679d\n        # 41. \u526a\u679d\n        # 42. \u526a\u679d\n        # 43. \u526a\u679d\n        # 44. \u526a\u679d\n        # 45. \u526a\u679d\n        # 46. \u526a\u679d\n        # 47. \u526a\u679d\n        # 48. \u526a\u679d\n        # 49. \u526a\u679d\n        # 50. \u526a\u679d\n        # 51. \u526a\u679d\n        # 52. \u526a\u679d\n        # 53. \u526a\u679d\n        # 54. \u526a\u679d\n        # 55. \u526a\u679d\n        # 56. \u526a\u679d\n        # 57. \u526a\u679d\n        # 58. \u526a\u679d\n        # 59. \u526a\u679d\n        # 60. \u526a\u679d\n        # 61. \u526a\u679d\n        # 62. \u526a\u679d\n        # 63. \u526a\u679d\n        # 64. \u526a\u679d\n        # 65. \u526a\u679d\n        # 66. \u526a\u679d\n        # 67. \u526a\u679d\n        # 68. \u526a\u679d\n        # 69. \u526a\u679d\n        # 70. \u526a\u679d\n        # 71. \u526a\u679d\n        # 72. \u526a\u679d\n        # 73. \u526a\u679d\n        # 74. \u526a\u679d"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num or board[i][col] == num:\n                    return False\n            r = row // 3 * 3 + col // 3\n            if board[r][col % 3 + r % 3] == num:\n                return False\n            return True\n        \n        def backtrack(board, row, col):\n            if row == 9:\n                return True\n            if col == 9:\n                return backtrack(board, row + 1, 0)\n            if board[row][col] != '.':\n                return backtrack(board, row, col + 1)\n            for num in range(1, 10):\n                if isValid(board, row, col, num):\n                    board[row][col] = str(num)\n                    if backtrack(board, row, col + 1):\n                        return True\n                board[row][col] = '.'\n            return False\n        \n        if not backtrack(board, 0, 0):\n            return False\n        return board"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        prev, first, second = None, None, None\n        while root:\n            if root.left:\n                if root.left.val > root.val:\n                    if not first:\n                        first = root.left\n                    else:\n                        second = root.left\n                else:\n                    prev = root.left\n            else:\n                if prev and prev.val > root.val:\n                    if not first:\n                        first = prev\n                    else:\n                        second = prev\n                prev = root\n            root = root.right\n        first.val, second.val = second.val, first.val"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        prev, first, second = None, None, None\n        while root:\n            if root.left:\n                if root.left.val > root.val:\n                    if not first:\n                        first = root.left\n                    else:\n                        second = root.left\n                else:\n                    prev = root.left\n            else:\n                if prev and prev.val > root.val:\n                    if not first:\n                        first = prev\n                    else:\n                        second = prev\n                prev = root\n            root = root.right\n        first.val, second.val = second.val, first.val"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        prev, first, second = None, None, None\n        while root:\n            if root.left:\n                if root.left.val > root.val:\n                    if not first:\n                        first = root.left\n                    else:\n                        second = root.left\n                else:\n                    prev = root.left\n            else:\n                if prev and prev.val > root.val:\n                    if not first:\n                        first = prev\n                    else:\n                        second = prev\n                prev = root\n            root = root.right\n        first.val, second.val = second.val, first.val\n        \n        \n# Time: O(N)\n# Space: O(H)\n# Difficulty: medium\n# See solution from: https://leetcode.com/problems/recover-binary-search-tree/discuss/108847/Python-O(1)-space-solution-with-explanation\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        prev, first, second = None, None, None\n        while root:\n            if root.val > prev:\n                if first is None:\n                    first = root\n                else:\n                    second = root\n                    break\n            prev = root.val\n            root = root.right if root.val > prev else root.left\n        first.val, second.val = second.val, first.val\n        \n        \n# Time: O(N)\n# Space: O(1)\n# Difficulty: medium\n# See solution from: https://leetcode.com/problems/recover-binary-search-tree/discuss/108847/Python-O(1)-space-solution-with-explanation\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        first, second = root, root\n        prev = float('-inf')\n        while first or second:\n            if first:\n                if first.val <= prev:\n                    second, prev = first, first.val\n                else:\n                    prev = first.val\n                    first = first.right\n            else:\n                if second.val <= prev:\n                    second = second.left\n                else:\n                    prev = second.val\n                    second.val, first.val = first.val, second.val\n                    first = second.right\n                    \n        \n# Time: O(N)\n# Space: O(1)\n# Difficulty: medium\n# See solution from: https://leetcode.com/problems/recover-binary-search-tree/discuss/108847/Python-O(1)-space-solution-with-explanation\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        first, second = root, root\n        prev = float('-inf')\n        while first:\n            if first.val <= prev:\n                second, prev = first, first.val\n            else:\n                prev = first.val\n            first = first.right if first.val <= prev else first.left\n        first,"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        prev, first, second = None, None, None\n        while root:\n            if root.left:\n                if root.left.val > root.val:\n                    if not first:\n                        first = root.left\n                    else:\n                        second = root.left\n                else:\n                    prev = root.left\n            else:\n                if prev and prev.val > root.val:\n                    if not first:\n                        first = prev\n                    else:\n                        second = prev\n                prev = root\n            root = root.right\n        first.val, second.val = second.val, first.val"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        prev, first, second = None, None, None\n        while root:\n            if root.left:\n                if root.left.val > root.val:\n                    if not first:\n                        first = root.left\n                    else:\n                        second = root.left\n                else:\n                    prev = root.left\n            else:\n                if prev and prev.val > root.val:\n                    if not first:\n                        first = prev\n                    else:\n                        second = prev\n                prev = root\n            root = root.right\n        first.val, second.val = second.val, first.val\n        \n        \n# Time: O(N)\n# Space: O(1)\n# Difficulty: medium\n# See"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # reverse the list\n        prev = None\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # compare the list\n        curr = prev\n        while curr and head:\n            if curr.val != head.val:\n                return False\n            curr = curr.next\n            head = head.next\n        \n        return True\n\n# Time: O(N)\n# Space: O(1)\n# Difficulty: easy\n# See also: https://leetcode.com/problems/palindrome-linked-list/"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # reverse the list\n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        # compare the list\n        curr = prev\n        while curr and head:\n            if curr.val != head.val:\n                return False\n            curr = curr.next\n            head = head.next\n        \n        return True\n\n# Time: O(N)\n# Space: O(1)\n# Difficulty: easy\n# See also: https://leetcode.com/problems/pal"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # reverse the list\n        prev = None\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # compare the list\n        curr = prev\n        while curr and head:\n            if curr.val != head.val:\n                return False\n            curr = curr.next\n            head = head.next\n        \n        return True\n\n# Time: O(N)\n# Space: O(1)\n# Difficulty: easy\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            \n        slow.next, head = head.next, slow.next\n        \n        while head:\n            if head.val != slow.val:\n                return False\n            head, slow = head.next, slow.next\n        \n        return True\n\n# Time: O(N)\n# Space: O(1)\n# Difficulty: easy\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        \n        slow.next, head = head.next, slow.next\n        \n        while head:\n            if head.val != slow.val:\n                return False\n            head, slow = head.next, slow.next\n        \n        return True\n\n# Time: O(N)\n# Space: O(1)\n# Difficulty: easy\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n        \n        slow.next ="}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # reverse the list\n        prev = None\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # compare the list\n        curr = prev\n        while curr and head:\n            if curr.val != head.val:\n                return False\n            curr = curr.next\n            head = head.next\n        \n        return True\n\n# Time: O(n)\n# Space: O(1)\n# Difficulty: easy\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n            \n        if fast:\n            slow = slow.next\n        else:\n            slow = slow.next\n        \n        slow = slow.next\n        slow.next = None\n        \n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        return prev == head or prev.val == head.val\n\n# Time: O(n)\n# Space: O(1)\n# Difficulty: easy\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        slow = slow.next\n        slow.next = None\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        return prev == head or prev.val == head.val\n\n# Time: O(n)\n# Space: O(1)\n# Difficulty: easy\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        slow.next, head.next = head.next, None\n        slow = slow.next\n        while slow:\n            if slow.val != head.val:\n                return False\n            slow, head = slow.next, head.next\n        \n        return True\n\n# Time: O(n)\n# Space: O(1)\n# Difficulty: easy\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head or not head.next:\n            return True\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        slow.next, head.next = head.next, None\n        slow"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # reverse the list\n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        # compare the list\n        curr = prev\n        while curr and head:\n            if curr.val != head.val:\n                return False\n            curr = curr.next\n            head = head.next\n        \n        return True\n\n# Time: O(N)\n# Space: O(1)\n# Difficulty: easy\n# See also: https://leetcode.com/problems/palindrome-linked-list/"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num < 2:\n            return True\n        \n        i = 1\n        while i * i <= num:\n            if i * i == num:\n                return True\n            i += 1\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num < 2:\n            return True\n        \n        i = 1\n        while i * i <= num:\n            if i * i == num:\n                return True\n            i += 1\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num < 2:\n            return True\n        \n        i = 1\n        while i * i <= num:\n            if i * i == num:\n                return True\n            i += 1\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num < 2:\n            return True\n        \n        i = 1\n        while i * i <= num:\n            if i * i == num:\n                return True\n            i += 1\n        \n        return False"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num < 2:\n            return True\n        \n        i = 1\n        while i * i <= num:\n            if i * i == num:\n                return True\n            i += 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * (n + 1)\n        i = 1\n        while i <= n:\n            res[i] = res[i & (i - 1)] + 1\n            i += 1\n        return res"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * (n + 1)\n        for i in range(1, n + 1):\n            res[i] = res[i & (i - 1)] + 1\n        return res"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * (n + 1)\n        i = 1\n        while i <= n:\n            res[i] = res[i & (i - 1)] + 1\n            i += 1\n        return res"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * (n + 1)\n        i = 1\n        while i <= n:\n            res[i] = res[i & (i - 1)] + 1\n            i += 1\n        return res"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        res = [0] * (n + 1)\n        i = 1\n        while i <= n:\n            res[i] = res[i & (i - 1)] + 1\n            i += 1\n        return res"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next:\n            if prev.next.val == val:\n                prev.next = prev.next.next\n            else:\n                prev = prev.next\n        \n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next:\n            if prev.next.val == val:\n                prev.next = prev.next.next\n            else:\n                prev = prev.next\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next:\n            if prev.next.val == val:\n                prev.next = prev.next.next\n            else:\n                prev = prev.next\n        \n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next:\n            if prev.next.val == val:\n                prev.next = prev.next.next\n            else:\n                prev = prev.next\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while prev.next:\n            if prev.next.val == val:\n                prev.next = prev.next.next\n            else:\n                prev = prev.next\n        return dummy.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n        return self.isScramble(s1, s2, 0, len(s1) - 1)\n        \n    def isScramble(self, s1, s2, start, end):\n        if s1 == s2:\n            return True\n        if s1[start] != s2[start] or s1[end] != s2[end]:\n            return False\n        return self.isScramble(s1, s2, start + 1, end - 1) or self.isScramble(s1[start + 1:end], s2[start + 1:end])"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n        return self.isScramble(s1, s2, 0, len(s1) - 1)\n        \n    def isScramble(self, s1, s2, start, end):\n        if s1 == s2:\n            return True\n        if s1[start] != s2[start] or s1[end] != s2[end]:\n            return False\n        return self.isScramble(s1, s2, start + 1, end - 1) or self.isScramble(s1[start + 1:end], s2[start + 1:end])"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n        return self.isScramble(s1, s2, 0, len(s1) - 1)\n        \n    def isScramble(self, s1, s2, start, end):\n        if s1 == s2:\n            return True\n        if s1[start] != s2[start] or s1[end] != s2[end]:\n            return False\n        return self.isScramble(s1, s2, start + 1, end - 1) or self.isScramble(s1[start + 1:end], s2[start + 1:end])"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n        return self.isScramble(s1, s2, 0, len(s1) - 1)\n        \n    def isScramble(self, s1, s2, start, end):\n        if s1 == s2:\n            return True\n        if s1[start] != s2[start] or s1[end] != s2[end]:\n            return False\n        return self.isScramble(s1, s2, start + 1, end - 1) or self.isScramble(s1[start + 1:end], s2[start + 1:end])"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n        return self.isScramble(s1, s2, 0, len(s1) - 1)\n        \n    def isScramble(self, s1, s2, start, end):\n        if s1 == s2:\n            return True\n        if s1[start] != s2[start] or s1[end] != s2[end]:\n            return False\n        return self.isScramble(s1, s2, start + 1, end - 1) or self.isScramble(s1[start + 1:end], s2[start + 1:end])"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not board or not board[0]:\n            return []\n        \n        m, n = len(board), len(board[0])\n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n            node['#'] = True\n        \n        res = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie and (i, j) not in visited:\n                    self.dfs(board, i, j, trie, visited, res)\n        return res\n        \n    def dfs(self, board, i, j, trie, visited, res):\n        if not trie.get(board[i][j]):\n            return\n        visited.add((i, j))\n        trie = trie[board[i][j]]\n        if '#' in trie:\n            res.append(board[i][j])\n        self.dfs(board, i + 1, j, trie, visited, res)\n        self.dfs(board, i - 1, j, trie, visited, res)\n        self.dfs(board, i, j + 1, trie, visited, res)\n        self.dfs(board, i, j - 1, trie, visited, res)\n        trie.pop(board[i][j])\n        visited.remove((i, j))"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not board or not board[0]:\n            return []\n        \n        m, n = len(board), len(board[0])\n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n            node['#'] = True\n        \n        res = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie and (i, j) not in visited:\n                    self.dfs(board, i, j, trie, visited, res)\n        return res\n        \n    def dfs(self, board, i, j, trie, visited, res):\n        if not trie.get(board[i][j]):\n            return\n        visited.add((i, j))\n        trie = trie[board[i][j]]\n        if '#' in trie:\n            res.append(board[i][j])\n        self.dfs(board, i + 1, j, trie, visited, res)\n        self.dfs(board, i - 1, j, trie, visited, res)\n        self.dfs(board, i, j + 1, trie, visited, res)\n        self.dfs(board, i, j - 1, trie, visited, res)\n        del trie[board[i][j]]\n        visited.remove((i, j))"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not board or not board[0]:\n            return []\n        \n        m, n = len(board), len(board[0])\n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n            node['#'] = True\n        \n        res = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie and (i, j) not in visited:\n                    self.dfs(board, i, j, trie, visited, res)\n        return res\n        \n    def dfs(self, board, i, j, trie, visited, res):\n        if not trie.get(board[i][j]):\n            return\n        visited.add((i, j))\n        trie = trie[board[i][j]]\n        if '#' in trie:\n            res.append(board[i][j])\n        self.dfs(board, i + 1, j, trie, visited, res)\n        self.dfs(board, i - 1, j, trie, visited, res)\n        self.dfs(board, i, j + 1, trie, visited, res)\n        self.dfs(board, i, j - 1, trie, visited, res)\n        del trie[board[i][j]]\n        visited.remove((i, j))"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not board or not board[0]:\n            return []\n        \n        m, n = len(board), len(board[0])\n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n            node['#'] = True\n        \n        res = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie and (i, j) not in visited:\n                    self.dfs(board, i, j, trie, visited, res)\n        return res\n        \n    def dfs(self, board, i, j, trie, visited, res):\n        if not trie.get(board[i][j]):\n            return\n        visited.add((i, j))\n        trie = trie[board[i][j]]\n        if '#' in trie:\n            res.append(board[i][j])\n        self.dfs(board, i + 1, j, trie, visited, res)\n        self.dfs(board, i - 1, j, trie, visited, res)\n        self.dfs(board, i, j + 1, trie, visited, res)\n        self.dfs(board, i, j - 1, trie, visited, res)\n        del trie[board[i][j]]\n        visited.remove((i, j))"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a trie from words\n        root = {}\n        for word in words:\n            node = root\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['#'] = True\n        \n        # search for words in board\n        res = []\n        m, n = len(board), len(board[0])\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in root and (i, j) not in visited:\n                    self.dfs(board, i, j, root, visited, res)\n        return res\n    \n    def dfs(self, board, i, j, root, visited, res):\n        c = board[i][j]\n        if c not in root:\n            return\n        node = root[c]\n        if '#' in node:\n            res.append(c)\n        visited.add((i, j))\n        # move in 4 directions\n        for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n            if 0 <= x < len(board) and 0 <= y < len(board[0]) and (x, y) not in visited:\n                self.dfs(board, x, y, root, visited, res)\n        # remove the letter from trie\n        if c in node:\n            node.pop(c)\n        visited.remove((i, j))\n```\n\n### 2. Trie + Backtracking\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_word = False\n\nclass Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        root = TrieNode()\n        for word in words:\n            node = root\n            for c in word:\n                node = node.children[c]\n            node.is_word = True\n        \n        res = []\n        m, n = len(board), len(board[0])\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in root.children and (i, j) not in visited:\n                    self.find(board, i, j, root.children[board[i][j]], res, visited)\n        return res\n    \n    def find(self, board, i, j, node, res, visited):\n        if not node:\n            return\n        res.append(node.is_word)\n        visited.add((i, j))\n        # move in 4 directions\n        for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n            if 0 <= x < len(board) and 0 <= y < len(board[0]) and (x, y) not in visited:\n                self.find(board, x, y, node.children.get(board[x][y]), res, visited)\n        visited.remove((i, j))\n        return node.is_word\n```\n\n### 3. Trie + Backtracking + Pruning\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_word = False\n\nclass Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        root = TrieNode()\n        for word in words:\n            node = root\n            for c in word:\n                node = node.children[c]\n            node.is_word = True\n        \n        res = []\n        m, n = len(board), len(board[0])\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if board[i"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_count = [0] * 26\n        t_count = [0] * 26\n        \n        for c in s:\n            s_count[ord(c) - ord('a')] += 1\n        for c in t:\n            t_count[ord(c) - ord('a')] += 1\n        \n        for i in range(26):\n            if s_count[i] != t_count[i]:\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_count = [0] * 26\n        t_count = [0] * 26\n        \n        for c in s:\n            s_count[ord(c) - ord('a')] += 1\n        for c in t:\n            t_count[ord(c) - ord('a')] += 1\n        \n        for i in range(26):\n            if s_count[i] != t_count[i]:\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = collections.Counter(s)\n        t_dict = collections.Counter(t)\n        \n        for key in s_dict:\n            if key not in t_dict or t_dict[key] != s_dict[key]:\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_count = [0] * 26\n        t_count = [0] * 26\n        \n        for c in s:\n            s_count[ord(c) - ord('a')] += 1\n        for c in t:\n            t_count[ord(c) - ord('a')] += 1\n        \n        for i in range(26):\n            if s_count[i] != t_count[i]:\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_count = [0] * 26\n        t_count = [0] * 26\n        \n        for c in s:\n            s_count[ord(c) - ord('a')] += 1\n        for c in t:\n            t_count[ord(c) - ord('a')] += 1\n        \n        return s_count == t_count"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check row\n        row = [0] * 9\n        col = [0] * 9\n        box = [0] * 9\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    index = int(board[i][j]) - 1\n                    if row[index] or col[index] or box[index // 3 * 3 + index % 3]:\n                        return False\n                    row[index], col[index], box[index // 3 * 3 + index % 3] = 1, 1, 1\n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check row\n        row = [0] * 9\n        col = [0] * 9\n        box = [0] * 9\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    if row[i] & (1 << (ord(board[i][j]) - ord('1'))) or col[j] & (1 << (ord(board[i][j]) - ord('1'))) or box[i // 3 * 3 + j // 3] & (1 << (ord(board[i][j]) - ord('1'))) :\n                        return False\n                    row[i] |= 1 << (ord(board[i][j]) - ord('1'))\n                    col[j] |= 1 << (ord(board[i][j]) - ord('1'))\n                    box[i // 3 * 3 + j // 3] |= 1 << (ord(board[i][j]) - ord('1'))\n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check row\n        row = [0] * 9\n        col = [0] * 9\n        box = [0] * 9\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    if row[i] & (1 << (ord(board[i][j]) - ord('1'))) or col[j] & (1 << (ord(board[i][j]) - ord('1'))) or box[i // 3 * 3 + j // 3] & (1 << (ord(board[i][j]) - ord('1'))) :\n                        return False\n                    row[i] |= 1 << (ord(board[i][j]) - ord('1'))\n                    col[j] |= 1 << (ord(board[i][j]) - ord('1'))\n                    box[i // 3 * 3 + j // 3] |= 1 << (ord(board[i][j]) - ord('1'))\n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check row\n        row = [0] * 9\n        col = [0] * 9\n        box = [0] * 9\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    if row[i] & (1 << (ord(board[i][j]) - ord('1'))) or col[j] & (1 << (ord(board[i][j]) - ord('1'))) or box[i // 3 * 3 + j // 3] & (1 << (ord(board[i][j]) - ord('1'))) :\n                        return False\n                    row[i] |= 1 << (ord(board[i][j]) - ord('1'))\n                    col[j] |= 1 << (ord(board[i][j]) - ord('1'))\n                    box[i // 3 * 3 + j // 3] |= 1 << (ord(board[i][j]) - ord('1'))\n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check row\n        row = [0] * 9\n        col = [0] * 9\n        box = [0] * 9\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    if row[i] & (1 << (ord(board[i][j]) - ord('1'))) or col[j] & (1 << (ord(board[i][j]) - ord('1'))) or box[i // 3 * 3 + j // 3] & (1 << (ord(board[i][j]) - ord('1'))) :\n                        return False\n                    row[i] |= 1 << (ord(board[i][j]) - ord('1'))\n                    col[j] |= 1 << (ord(board[i][j]) - ord('1'))\n                    box[i // 3 * 3 + j // 3] |= 1 << (ord(board[i][j]) - ord('1'))\n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n % 15 == 0:\n            return [\"FizzBuzz\"] * n\n        if n % 3 == 0:\n            return [\"Fizz\"] * (n // 3)\n        if n % 5 == 0:\n            return [\"Buzz\"] * (n // 5)\n        return [str(n)]"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n % 15 == 0:\n            return [\"FizzBuzz\"] * n\n        if n % 3 == 0:\n            return [\"Fizz\"] * (n // 3)\n        if n % 5 == 0:\n            return [\"Buzz\"] * (n // 5)\n        return [str(n)]"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n % 15 == 0:\n            return [\"FizzBuzz\"] * n\n        if n % 3 == 0:\n            return [\"Fizz\"] * (n // 3)\n        if n % 5 == 0:\n            return [\"Buzz\"] * (n // 5)\n        return [str(n)]"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n % 15 == 0:\n            return [\"FizzBuzz\"] * n\n        if n % 3 == 0:\n            return [\"Fizz\"] * (n // 3)\n        if n % 5 == 0:\n            return [\"Buzz\"] * (n // 5)\n        return [str(n)]"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n % 15 == 0:\n            return [\"FizzBuzz\"] * n\n        if n % 3 == 0:\n            return [\"Fizz\"] * (n // 3)\n        if n % 5 == 0:\n            return [\"Buzz\"] * (n // 5)\n        return [str(n)]"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the whole string\n        s = s.strip()\n        s = s[::-1]\n        \n        # reverse each word\n        s = s.split(' ')\n        s = ' '.join(s)\n        \n        return s"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the whole string\n        s = s.strip()\n        s = s[::-1]\n        \n        # reverse each word\n        s = s.split(' ')\n        s = ' '.join(s)\n        \n        return s"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the whole string\n        s = s.strip()\n        s = s[::-1]\n        \n        # reverse each word\n        s = s.split()\n        s = ' '.join(s)\n        \n        return s"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the whole string\n        s = s.strip()\n        s = s[::-1]\n        \n        # reverse each word\n        s = s.split(' ')\n        s = ' '.join(s)\n        \n        return s"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the whole string\n        s = s.strip()\n        s = s[::-1]\n        \n        # reverse each word\n        s = s.split(' ')\n        s = ' '.join(s)\n        \n        return s"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i, c in enumerate(columnTitle[::-1]):\n            res += (ord(c) - ord('A') + 1) * 26 ** i\n        return res"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i, c in enumerate(columnTitle[::-1]):\n            res += (ord(c) - ord('A') + 1) * 26 ** i\n        return res"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i, c in enumerate(columnTitle[::-1]):\n            res += (ord(c) - ord('A') + 1) * 26 ** i\n        return res"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i, c in enumerate(columnTitle[::-1]):\n            res += (ord(c) - ord('A') + 1) * 26 ** i\n        return res"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res = res * 26 + (ord(columnTitle[i]) - ord('A') + 1)\n        return res"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a stack to keep track of the indices of children with smaller ratings\n        # The number of candies for the child at index i is equal to the number of candies in the stack plus 1\n        # If the child at index i has a larger rating than the top of the stack, push i to the stack\n        # If the child at index i has a smaller rating than the top of the stack, pop the top of the stack and update the number of candies for the child at index i to the number of candies in the stack plus 1\n        # At the end, the number of candies in the stack is the answer\n        stack = []\n        candies = 1\n        for rating in ratings:\n            if rating >= ratings[stack[-1]]:\n                stack.append(len(stack))\n            else:\n                candies += 1\n                if stack and rating < ratings[stack[-1] - 1]:\n                    candies += stack.pop()"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a stack to keep track of the indices of children with smaller ratings\n        # The number of candies for the child at index i is the difference between the index of the next greater rating child and i\n        stack = []\n        for i in range(len(ratings)):\n            if not stack or ratings[stack[-1]] < ratings[i]:\n                stack.append(i)\n            else:\n                # The next greater rating child is already found\n                # So, the number of candies for the child at index i is the difference between the index of the next greater rating child and i\n                candy = stack[-1] - i + 1\n                # Update the number of candies for the next greater rating child\n                stack[-1] = i\n                # Update the answer\n                ans += candy\n        \n        # Add the number of candies for the remaining children\n        ans += len(stack)\n        \n        return ans"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a stack of indices of children with candies\n        # If the current child has a higher rating than the top of the stack,\n        # then the child gets one more candy than the top of the stack.\n        # Otherwise, the child gets one candy.\n        # Keep track of the number of candies in the stack.\n        # At the end, return the number of candies in the stack.\n        \n        stack = []\n        candy = 1\n        for rating in ratings:\n            if rating >= stack[-1] if stack else True:\n                candy += 1\n            else:\n                candy = 1\n            stack.append(rating)\n        return candy"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a stack of indices of children with candies\n        # If the current child has a higher rating than the top of the stack,\n        # then the child gets one more candy than the top of the stack\n        # Otherwise, the child gets one candy\n        stack = []\n        result = 1\n        for rating in ratings:\n            if not stack or rating > ratings[stack[-1]]:\n                stack.append(len(stack))\n                result += 1\n            else:\n                result += stack[-1] - stack[-"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Maintain a stack to keep track of the indices of children with smaller ratings\n        # The number of candies for the current child is the difference between the index of the current child and the index of the last child with smaller rating\n        # If the current child has a smaller rating than the last child, push the index of the current child to the stack\n        # If the current child has a larger rating than the last child, pop the last child from the stack and update the number of candies for the current child\n        # If the stack is empty, the current child has a larger rating than all the previous children, so the number of candies for the current child is 1\n        stack = []\n        candies = 1\n        for rating in ratings:\n            if stack and rating >= ratings[stack[-1]]:\n                candies += rating - ratings[stack.pop()]\n            else:\n                stack.append(len(ratings) - 1)\n                candies += 1\n        return candies"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        \n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        \n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        prev.next = None\n        \n        first, second = head, prev\n        while second:\n            first.next, second.next, first, second = second, first.next, second.next, second.next.next\n        \n        if prev:\n            prev.next = None\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev, curr = head, slow.next\n        slow.next = None\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        head.next = prev\n        \n        prev = head\n        curr = prev.next\n        while curr.next:\n            prev.next, curr.next, prev, curr = curr, prev.next, curr, curr.next.next\n        \n        prev.next = curr"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        prev.next = None\n        \n        slow = head\n        head = prev\n        while prev:\n            temp = slow.next\n            slow.next = prev.next\n            prev.next = temp\n            slow = temp\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        prev.next = None\n        \n        first, second = head, prev\n        while second:\n            first.next, second.next, first, second = second, first.next, second.next, second.next.next\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return\n        \n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev, curr = head, slow.next\n        slow.next = None\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        \n        head.next = prev\n        \n        prev = head\n        curr = prev.next\n        while curr.next:\n            prev.next, curr.next, prev, curr = curr, prev.next, curr, curr.next.next\n        \n        prev.next = curr"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        p2w = {}\n        w2p = {}\n        for p, w in zip(pattern, words):\n            if p in p2w and p2w[p] != w:\n                return False\n            if w in w2p and w2p[w] != p:\n                return False\n            p2w[p] = w\n            w2p[w] = p\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        p2w = {}\n        w2p = {}\n        for p, w in zip(pattern, words):\n            if p in p2w and p2w[p] != w:\n                return False\n            if w in w2p and w2p[w] != p:\n                return False\n            p2w[p] = w\n            w2p[w] = p\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        p2w = {}\n        w2p = {}\n        for p, w in zip(pattern, words):\n            if p in p2w and p2w[p] != w:\n                return False\n            if w in w2p and w2p[w] != p:\n                return False\n            p2w[p] = w\n            w2p[w] = p\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        p2w = {}\n        w2p = {}\n        for p, w in zip(pattern, words):\n            if p in p2w and p2w[p] != w:\n                return False\n            if w in w2p and w2p[w] != p:\n                return False\n            p2w[p] = w\n            w2p[w] = p\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n        \n        p2w = {}\n        w2p = {}\n        for p, w in zip(pattern, words):\n            if p in p2w and p2w[p] != w:\n                return False\n            if w in w2p and w2p[w] != p:\n                return False\n            p2w[p] = w\n            w2p[w] = p\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        self.backtrack(nums, [], res)\n        return res\n        \n    def backtrack(self, nums, path, res):\n        if not nums:\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            self.backtrack(nums[:i] + nums[i+1:], path, res)\n            path.pop()\n```\n\n### 2. Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n```\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n```python\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        \n        nums.sort()\n        res = [nums]\n        last = nums[-1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] == last:\n            i -= 1\n        if i >= 0:\n            res = [nums[:i+1]]\n            last = nums[i]\n        else:\n            return res\n        \n        for i in range(i, len(nums)-1):\n            if nums[i] > last:\n                res.append(res[-1][:i] + [nums[i]] + res[-1][i:])\n                last = nums[i]\n        return res\n```\n\n### 3. Next Permutation\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place and use only constant extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n\n```\n1,2,3 \u2192 1,3,2\n3,2,1 \u2192 1,2,3\n1,1,5 \u2192 1,5,1\n```\n\n```python\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        if i >= 0:\n            nums[i+1:], nums[i:] = nums[i:], nums[i+1:]\n            nums[i+1:] = nums[i+1:][::-1]\n        else:\n            nums[:] = nums[::-1]\n```\n\n### 4. Combination Sum\n\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\nThe same repeated number may be chosen from candidates unlimited number of times.\n\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\n```\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n```python\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return []\n        \n        candidates.sort()\n        res = []\n        start = 0"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        self.backtrack(nums, [], res)\n        return res\n        \n    def backtrack(self, nums, path, res):\n        if not nums:\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            self.backtrack(nums[:i] + nums[i+1:], path, res)\n            path.pop()\n```\n\n### 2. Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n```\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n```python\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        \n        nums.sort()\n        res = [nums[:1]]\n        last = nums[0]\n        for i in nums[1:]:\n            if i == last:\n                continue\n            res.append(res[-1] + [i])\n            last = i\n        return res\n```\n\n### 3. Next Permutation\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place and use only constant extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n\n1,2,3 \u2192 1,3,2\n3,2,1 \u2192 1,2,3\n1,1,5 \u2192 1,5,1\n\n```python\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if len(nums) <= 1:\n            return\n        \n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        if i >= 0:\n            j = len(nums) - 1\n            while nums[i] >= nums[j]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        \n        nums[i+1:] = nums[i+1:][::-1]\n```\n\n### 4. Combination Sum\n\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\nThe same repeated number may be chosen from candidates unlimited number of times.\n\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\n```\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n```python\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return []\n        \n        candidates.sort()\n        res = []\n        self.backtrack(candidates, target, 0, [], res)\n        return res\n        \n    def backtrack(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        self.backtrack(nums, [], res)\n        return res\n        \n    def backtrack(self, nums, path, res):\n        if not nums:\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            self.backtrack(nums[:i] + nums[i+1:], path, res)\n            path.pop()\n```\n\n### 2. Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n```\nExample:\n\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n```python\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        \n        nums.sort()\n        res = [nums]\n        last = nums[-1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] == last:\n            i -= 1\n        if i >= 0:\n            res = [nums[:i+1]]\n            last = nums[i]\n        else:\n            return res\n        \n        for i in range(i, len(nums)-1):\n            if nums[i] > last:\n                res.append(res[-1][:i] + [nums[i]] + res[-1][i:])\n                last = nums[i]\n        return res\n```\n\n### 3. Next Permutation\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place and use only constant extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n\n1,2,3 \u2192 1,3,2\n3,2,1 \u2192 1,2,3\n1,1,5 \u2192 1,5,1\n\n```python\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        if i >= 0:\n            nums[i] , nums[i+1] = nums[i+1], nums[i]\n            nums[i+1:] = nums[i+1:][::-1]\n        else:\n            nums[:] = nums[::-1]\n```\n\n### 4. Combination Sum\n\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\nThe same repeated number may be chosen from candidates unlimited number of times.\n\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\n```\nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n\nExample 2:\n\nInput: candidates = [2,3,5], target = 8,\nA solution set is:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n```python\nclass Solution(object):\n    def combinationSum(self, candidates, target"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        self.backtrack(nums, [], res)\n        return res\n        \n    def backtrack(self, nums, path, res):\n        if not nums:\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            self.backtrack(nums[:i] + nums[i+1:], path, res)\n            path.pop()\n```\n\n### 2. Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n```\nExample:\n\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n```python\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        \n        nums.sort()\n        res = [nums[:1]]\n        last = nums[0]\n        for i in nums[1:]:\n            if i == last:\n                continue\n            res.append(res[-1] + [i])\n            last = i\n        return res\n```\n\n### 3. Combination Sum\n\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\nThe same repeated number may be chosen from candidates unlimited number of times.\n\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\n```\nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n\nExample 2:\n\nInput: candidates = [2,3,5], target = 8,\nA solution set is:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n```python\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return []\n        \n        candidates.sort()\n        res = []\n        self.backtrack(candidates, target, 0, [], res)\n        return res\n        \n    def backtrack(self, candidates, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            self.backtrack(candidates, target - candidates[i], i, path + [candidates[i]], res)\n```\n\n### 4. Combination Sum II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique combinations in any order.\n\n```\nExample:\n\nInput: [1,1,2]\nOutput:\n[\n  [1,1],\n  [1,2],\n  [2,1]\n]\n```\n\n```python\nclass Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:\n            return []\n        \n        candidates.sort()\n        res = []\n        start = 0\n        for i in range(len(candidates)):\n            if candidates[i] > target:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            res.append([candidates[i]])"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        self.backtrack(nums, [], res)\n        return res\n        \n    def backtrack(self, nums, path, res):\n        if not nums:\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            self.backtrack(nums[:i] + nums[i+1:], path, res)\n            path.pop()\n```\n\n### 2. Permutations II\n\nGiven a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n```\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n```python\nclass Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        \n        nums.sort()\n        res = [nums]\n        last = nums[-1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] == last:\n            i -= 1\n        if i >= 0:\n            res = [nums[:i+1]]\n            last = nums[i]\n        else:\n            return res\n        \n        for i in range(i, len(nums)-1):\n            if nums[i] > last:\n                res.append(res[-1][:i] + [nums[i]] + res[-1][i:])\n                last = nums[i]\n        return res\n```\n\n### 3. Next Permutation\n\nImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place and use only constant extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n\n```\n1,2,3 \u2192 1,3,2\n3,2,1 \u2192 1,2,3\n1,1,5 \u2192 1,5,1\n```\n\n```python\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums or len(nums) == 1:\n            return\n        \n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        if i >= 0:\n            nums[i] , nums[i+1] = nums[i+1], nums[i]\n            nums[i+1:] = nums[i+1:][::-1]\n        else:\n            nums[:] = nums[::-1]\n```\n\n### 4. Combination Sum\n\nGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\nThe same repeated number may be chosen from candidates unlimited number of times.\n\nNote:\n\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\n\n```\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n```python\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not candidates:"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if matrix[mid // n][mid % n] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return left < m * n and matrix[left // n][left % n] == target"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if matrix[mid // n][mid % n] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return left < m * n and matrix[left // n][left % n] == target"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if matrix[mid // n][mid % n] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return left < m * n and matrix[left // n][left % n] == target"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if matrix[mid // n][mid % n] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return left"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return False\n        \n        m, n = len(matrix), len(matrix[0])\n        left, right = 0, m * n - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if matrix[mid // n][mid % n] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return left < m * n and matrix[left // n][left % n] == target"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.78% of Python online submissions for Add Two Numbers.\n        # Memory Usage: 12.9 MB, less than 99.85% of Python online submissions for Add Two Numbers.\n        \n        dummy = ListNode(0)\n        cur = dummy\n        carry = 0\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            cur.next = ListNode(carry % 10)\n            carry //= 10\n            cur = cur.next\n        \n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.95% of Python online submissions for Add Two Numbers.\n        # Memory Usage: 12.9 MB, less than 99.95% of Python online submissions for Add Two Numbers.\n        \n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            carry //= 10\n            curr = curr.next\n            \n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.75% of Python online submissions for Add Two Numbers.\n        # Memory Usage: 12.9 MB, less than 99.47% of Python online submissions for Add Two Numbers.\n        \n        dummy = ListNode(0)\n        cur = dummy\n        carry = 0\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            cur.next = ListNode(carry % 10)\n            carry //= 10\n            cur = cur.next\n        \n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.97% of Python online submissions for Add Two Numbers.\n        # Memory Usage: 12.9 MB, less than 99.97% of Python online submissions for Add Two Numbers.\n        \n        dummy = ListNode(0)\n        cur = dummy\n        carry = 0\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            cur.next = ListNode(carry % 10)\n            carry //= 10\n            cur = cur.next\n        \n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Runtime: 20 ms, faster than 99.75% of Python online submissions for Add Two Numbers.\n        # Memory Usage: 12.9 MB, less than 99.75% of Python online submissions for Add Two Numbers.\n        \n        dummy = ListNode(0)\n        cur = dummy\n        carry = 0\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            cur.next = ListNode(carry % 10)\n            carry //= 10\n            cur = cur.next\n        \n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1009. Complement of Base 10 Integer\n        # \n        # Given an integer num, return its complement number. The complement strategy is to flip the bits of its binary representation.\n        # \n        # Example 1:\n        # Input: num = 5\n        # Output: 2\n        # Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n        # \n        # Example 2:\n        # Input: num = 1\n        # Output: 0\n        # Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n        # \n        # Constraints:\n        # 1 <= num < 231\n        # \n        # Follow up:\n        # Could you implement it without bits manipulation? To solve it without bits manipulation, you could use extra space.\n        \n        # 1009. \u4e8c\u8fdb\u5236\u6570\u7684\u53cd\u8f6c\n        # \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\uff0c\u8f93\u51fa\u5176\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d 0 \u548c 1 \u7684\u6570\u91cf\u3002\n        # \n        # \u793a\u4f8b 1:\n        # \u8f93\u5165: 00000000000000000000000000001011\n        # \u8f93\u51fa:  3\n        # \u89e3\u91ca: \u8f93\u5165\u6709\u4e09\u4e2a 1\uff0c\u6240\u4ee5\u8fd4\u56de 3.\n        # \n        # \u793a\u4f8b 2:\n        # \u8f93\u5165: 00000000000000000000000001010101\n        # \u8f93\u51fa:  0\n        # \u89e3\u91ca: \u8f93\u5165\u6ca1\u6709 0 \u548c 1\uff0c\u6240\u4ee5\u8fd4\u56de 0.\n        # \n        # \u63d0\u793a:\n        # \n        # \u7ed9\u5b9a\u7684\u6570\u5b57\u662f 32 \u4f4d\u6709\u7b26\u53f7\u6574\u6570\u3002\n        # \u4f60\u53ef\u4ee5\u5047\u8bbe\u4e8c\u8fdb\u5236\u6570\u4e0d\u5305\u542b\u524d\u5bfc\u96f6\u3002\n        # \n        # \u8fdb\u9636: \u5982\u679c\u591a\u6b21\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff0c\u4f60\u5c06\u5982\u4f55\u4f18\u5316\u4f60\u7684\u7b97\u6cd5\uff1f\n        # \n        # \u6765\u6e90\uff1a\u529b\u6263\uff08LeetCode\uff09\n        # \u94fe\u63a5\uff1ahttps://leetcode-cn.com/problems/number-of-1-bits\n        # \u8457\u4f5c\u6743\u5f52\u9886\u6263\u7f51\u7edc\u6240\u6709\u3002\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u8054\u7cfb\u5b98\u65b9\u6388\u6743\uff0c\u975e\u5546\u4e1a\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u3002\n        \n        # \u4f4d\u8fd0\u7b97\n        # \u6ce8\u610f\uff1anum \u4e0d\u4f1a\u8d85\u8fc7 32 \u4f4d\n        # \n        # \u5982\u679c num \u4e3a 0\uff0c\u5219\u8fd4\u56de 0\n        # \u5982\u679c num \u4e3a 1\uff0c\u5219\u8fd4\u56de 1\n        # \u5982\u679c num \u4e3a 2\uff0c\u5219\u8fd4\u56de 1\n        # \u5982\u679c num \u4e3a 3\uff0c\u5219\u8fd4\u56de 2\n        # \u5982\u679c num \u4e3a 4\uff0c\u5219\u8fd4\u56de 1\n        # \u5982\u679c num \u4e3a 5\uff0c\u5219\u8fd4\u56de 2\n        # \u5982\u679c num \u4e3a 6\uff0c\u5219\u8fd4\u56de 2\n        # \u5982\u679c num \u4e3a 7\uff0c\u5219\u8fd4\u56de 3\n        # \u5982\u679c num \u4e3a 8\uff0c\u5219\u8fd4\u56de 1\n        # \u5982\u679c num \u4e3a 9\uff0c\u5219\u8fd4\u56de 2\n        # \u5982\u679c num \u4e3a 10\uff0c\u5219\u8fd4\u56de 2\n        # \u5982\u679c num \u4e3a 11\uff0c\u5219\u8fd4\u56de 3\n        # \u5982\u679c num \u4e3a 12\uff0c\u5219\u8fd4\u56de 2\n        # \u5982\u679c num \u4e3a 13\uff0c\u5219\u8fd4\u56de 3\n        # \u5982\u679c num \u4e3a 14\uff0c\u5219\u8fd4\u56de 2\n        # \u5982\u679c num \u4e3a 15\uff0c\u5219\u8fd4\u56de 3\n        # \u5982\u679c num \u4e3a 16\uff0c\u5219\u8fd4\u56de 1\n        # \u5982\u679c num \u4e3a 17\uff0c\u5219\u8fd4\u56de 2\n        # \u5982\u679c num"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1009. Complement of Base 10 Integer\n        # \n        # Given an integer num, return its complement number. The complement strategy is to flip the bits of its binary representation.\n        # \n        # Example 1:\n        # Input: num = 5\n        # Output: 2\n        # Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n        # \n        # Example 2:\n        # Input: num = 1\n        # Output: 0\n        # Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n        # \n        # Constraints:\n        # 1 <= num < 231\n        # \n        # Follow up:\n        # Could you implement it without bits manipulation? To solve it without bits manipulation, you could use extra space instead.\n        \n        # 1009. \u57fa\u6570\u8f6c\u6362\n        # \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\uff0c\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u5c06\u5176\u8f6c\u5316\u4e3a\u5176\u4e8c\u8fdb\u5236\u8868\u793a\u3002 \u8fd4\u56de 0 \u8868\u793a\u8f93\u5165\u4e3a 0 \u3002\n        # \n        # \u793a\u4f8b 1:\n        # \u8f93\u5165: 2\n        # \u8f93\u51fa: \"10\"\n        # \n        # \u793a\u4f8b 2:\n        # \u8f93\u5165: 5\n        # \u8f93\u51fa: \"101\"\n        # \n        # \u793a\u4f8b 3:\n        # \u8f93\u5165: 1\n        # \u8f93\u51fa: \"1\"\n        # \n        # \u63d0\u793a:\n        # \n        # 1 <="}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1009. Complement of Base 10 Integer\n        # \n        # Given an integer num, return its complement number. The complement strategy is to flip the bits of its binary representation.\n        # \n        # Example 1:\n        # Input: num = 5\n        # Output: 2\n        # Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n        # \n        # Example 2:\n        # Input: num = 1\n        # Output: 0\n        # Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n        # \n        # Constraints:\n        # 1 <= num < 231\n        # \n        # Follow up:\n        # Could you implement it without bits manipulation? To solve it without bits manipulation, you could use extra space.\n        \n        # 1009. \u57fa\u6570\u8f6c\u6362\n        # \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\uff0c\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u5c06\u5176\u8f6c\u5316\u4e3a\u5176\u4e8c\u8fdb\u5236\u8868\u793a\u3002 \u8fd4\u56de 0 \u8868\u793a\u8f93\u5165\u4e3a 0 \u3002\n        # \n        # \u793a\u4f8b 1:\n        # \u8f93\u5165: 2\n        # \u8f93\u51fa: \"10\"\n        # \n        # \u793a\u4f8b 2:\n        # \u8f93\u5165: 5\n        # \u8f93\u51fa: \"101\"\n        # \n        # \u793a\u4f8b 3:\n        # \u8f93\u5165: 1\n        # \u8f93\u51fa: \"1\"\n        # \n        # \u63d0\u793a:\n        # \n        # 1 <="}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1009. Complement of Base 10 Integer\n        # \n        # Given an integer num, return its complement number. The complement strategy is to flip the bits of its binary representation.\n        # \n        # Example 1:\n        # Input: num = 5\n        # Output: 2\n        # Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n        # \n        # Example 2:\n        # Input: num = 1\n        # Output: 0\n        # Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n        # \n        # Constraints:\n        # 1 <= num < 231\n        # \n        # Follow up:\n        # Could you implement it without bits manipulation? To solve it without bits manipulation, you could use extra space.\n        \n        # 1009. \u57fa\u6570\u8f6c\u6362\n        # \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\uff0c\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u5c06\u5176\u8f6c\u5316\u4e3a\u5176\u4e8c\u8fdb\u5236\u8868\u793a\u3002 \u8fd4\u56de 0 \u8868\u793a\u8f93\u5165\u4e3a 0 \u3002\n        # \n        # \u793a\u4f8b 1:\n        # \u8f93\u5165: 2\n        # \u8f93\u51fa: \"10\"\n        # \n        # \u793a\u4f8b 2:\n        # \u8f93\u5165: 5\n        # \u8f93\u51fa: \"101\"\n        # \n        # \u793a\u4f8b 3:\n        # \u8f93\u5165: 1\n        # \u8f93\u51fa: \"1\"\n        # \n        # \u63d0\u793a:\n        # \n        # 1 <= num <= 10^6\n        # \n        # \u8fdb\u9636:\n        # \n        # \u4f60\u53ef\u4ee5\u7528\u6807\u51c6\u5e93\u4e2d\u7684\u00a0'"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1009. Complement of Base 10 Integer\n        # \n        # Given an integer num, return its complement number. The complement strategy is to flip the bits of its binary representation.\n        # \n        # Example 1:\n        # Input: num = 5\n        # Output: 2\n        # Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n        # \n        # Example 2:\n        # Input: num = 1\n        # Output: 0\n        # Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n        # \n        # Constraints:\n        # 1 <= num < 231\n        # \n        # Follow up:\n        # Could you implement it without bits manipulation? To solve it without bits manipulation, you could use extra space.\n        \n        # 1009. \u57fa\u6570\u8f6c\u6362\n        # \u7ed9\u5b9a\u4e00\u4e2a\u6574\u6570\uff0c\u7f16\u5199\u4e00\u4e2a\u51fd\u6570\u5c06\u5176\u8f6c\u5316\u4e3a\u5176\u4e8c\u8fdb\u5236\u8868\u793a\u3002 \u8fd4\u56de 0 \u8868\u793a\u8f93\u5165\u4e3a 0 \u3002\n        # \n        # \u793a\u4f8b 1:\n        # \u8f93\u5165: 2\n        # \u8f93\u51fa: \"10\"\n        # \n        # \u793a\u4f8b 2:\n        # \u8f93\u5165: 5\n        # \u8f93\u51fa: \"101\"\n        # \n        # \u793a\u4f8b 3:\n        # \u8f93\u5165: 1\n        # \u8f93\u51fa: \"1\"\n        # \n        # \u63d0\u793a:\n        # \n        # 1 <= num <= 10^6\n        # \n        # \u8fdb\u9636:\n        # \n        # \u4f60\u53ef\u4ee5\u7528\u6807\u51c6\u5e93\u4e2d\u7684\u00a0'"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = 0\n        res = 0\n        diff = nums[1] - nums[0]\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i - 1] == diff:\n                dp += 1\n            else:\n                diff = nums[i] - nums[i - 1]\n                res += dp\n                \n        res += dp\n        \n        return res"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        diff, count = nums[1] - nums[0], 1\n        res = count\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i - 1] == diff:\n                count += 1\n            else:\n                diff, count = nums[i] - nums[i - 1], 1\n            res += count\n        \n        return res"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = 0\n        res = 0\n        diff = nums[1] - nums[0]\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i - 1] == diff:\n                dp += 1\n            else:\n                diff = nums[i] - nums[i - 1]\n                res += dp * (dp + 1) // 2\n                \n        res += dp * (dp + 1) // 2\n        \n        return res"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = 0\n        res = 0\n        diff = nums[1] - nums[0]\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i - 1] == diff:\n                dp += 1\n            else:\n                diff = nums[i] - nums[i - 1]\n                res += dp\n                \n        res += dp\n        \n        return res"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        diff, count, res = nums[1] - nums[0], 1, 0\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i - 1] == diff:\n                count += 1\n            else:\n                diff, count = nums[i] - nums[i - 1], 1\n            res += count\n        \n        return res"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        start, end = 0, 0\n        cur_len = 0\n        while end < len(words):\n            cur_len += len(words[end])\n            if cur_len > maxWidth:\n                res.append(' '.join(words[start:end]) + ' ' * (maxWidth - cur_len + start))\n                cur_len = end - start\n                start = end\n            end += 1\n        res.append(' '.join(words[start:end]) + ' ' * (maxWidth - cur_len))\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        start, end = 0, 0\n        cur_len = 0\n        while end < len(words):\n            cur_len += len(words[end])\n            if cur_len <= maxWidth:\n                end += 1\n            else:\n                if end - start == 1:\n                    res.append(words[start] + ' ' * (maxWidth - len(words[start])))\n                else:\n                    res.append(words[start] + ' ' * (maxWidth - cur_len + len(words[start - 1]) - len(words[start])) + words[start + 1:end])\n                start, cur_len = end, len(words[end])\n        res.append(words[start] + ' ' * (maxWidth - cur_len))\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        start, end = 0, 0\n        cur_len = 0\n        while end < len(words):\n            cur_len += len(words[end])\n            if cur_len > maxWidth:\n                res.append(' '.join(words[start:end]) + ' ' * (maxWidth - cur_len + start))\n                cur_len = end - start\n                start = end\n            end += 1\n        res.append(' '.join(words[start:end]) + ' ' * (maxWidth - cur_len))\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        start, end = 0, 0\n        cur_len = 0\n        while end < len(words):\n            cur_len += len(words[end])\n            if cur_len <= maxWidth:\n                end += 1\n            else:\n                if end - start == 1:\n                    res.append(words[start] + ' ' * (maxWidth - len(words[start])))\n                else:\n                    res.append(words[start] + ' ' * (maxWidth - cur_len + len(words[start - 1]) - len(words[start])) + words[start + 1:end])\n                start = end\n                cur_len = len(words[start])\n        res.append(words[start] + ' ' * (maxWidth - cur_len))\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        start, end = 0, 0\n        cur_len = 0\n        while end < len(words):\n            cur_len += len(words[end])\n            if cur_len > maxWidth:\n                res.append(words[start] + ' ' * (maxWidth - len(words[start])) + words[start + 1:end] if end - start > 1 else words[start] + ' ' * (maxWidth - cur_len + len(words[start])))\n                start, cur_len = end, len(words[end])\n            else:\n                end += 1\n        res.append(words[start] + ' ' * (maxWidth - cur_len) if end - start > 1 else words[start])\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return res[::-1]\n\n# Time: O(N)\n# Space: O(N)\n# Difficulty: medium\n\n# Iterative solution using stack.\n#\n# Iterate through the tree using stack.\n# When we see a node, push its right child first, then push the node itself.\n# When we see a node whose right child has been pushed, it means we have visited\n# all the nodes on the right. So we can pop the node and append its value to the result.\n#\n# Time complexity: O(N).\n# Space complexity: O(N)."}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return res[::-1]\n\n# Time: O(N)\n# Space: O(N)\n# Difficulty: medium\n\n# Iterative solution using stack.\n#\n# Iterate through the tree using stack.\n# When we encounter a node, push its right child first, then push the node itself.\n# When we pop a node, we append its value to the result.\n# If the node has a left child, we append its left child to the stack.\n#\n# Time complexity: O(N) where N is the number of nodes in the tree.\n# Space complexity: O(N)."}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        max_area = min(height[left], height[right]) * (right - left)\n        \n        while left < right:\n            if height[left] < height[right]:\n                max_area = max(max_area, height[left] * (right - left))\n                left += 1\n            else:\n                max_area = max(max_area, height[right] * (right - left))\n                right -= 1\n        \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        max_area = min(height[left], height[right]) * (right - left)\n        \n        while left < right:\n            if height[left] < height[right]:\n                max_area = max(max_area, height[left] * (right - left))\n                left += 1\n            else:\n                max_area = max(max_area, height[right] * (right - left))\n                right -= 1\n        \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        max_area = min(height[left], height[right]) * (right - left)\n        \n        while left < right:\n            if height[left] < height[right]:\n                max_area = max(max_area, height[left] * (right - left))\n                left += 1\n            else:\n                max_area = max(max_area, height[right] * (right - left))\n                right -= 1\n        \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        max_area = min(height[left], height[right]) * (right - left)\n        \n        while left < right:\n            if height[left] < height[right]:\n                max_area = max(max_area, height[left] * (right - left))\n                left += 1\n            else:\n                max_area = max(max_area, height[right] * (right - left))\n                right -= 1\n        \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        max_area = min(height[left], height[right]) * (right - left)\n        \n        while left < right:\n            if height[left] < height[right]:\n                max_area = max(max_area, height[left] * (right - left))\n                left += 1\n            else:\n                max_area = max(max_area, height[right] * (right - left))\n                right -= 1\n        \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a set of all the prefixes\n        prefixes = set()\n        for word in words:\n            prefix = \"\"\n            for char in word:\n                prefix = prefix + char\n                if prefix not in prefixes:\n                    prefixes.add(prefix)\n        \n        # check if a word is a concatenated word\n        res = []\n        for word in words:\n            if prefixes."}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a trie\n        root = {}\n        for word in words:\n            node = root\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['#'] = True\n        \n        # check if a word is concatenated\n        res = []\n        for word in words:\n            node = root\n            for char in word:\n                if char not in node:\n                    break\n                node = node[char]\n            if '#' in node:\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a set of all prefixes\n        prefixes = set()\n        for word in words:\n            prefix = \"\"\n            for char in word:\n                prefix = prefix + char\n                if prefix not in prefixes:\n                    prefixes.add(prefix)\n        \n        # check if a word is a concatenated word\n        res = []\n        for word in words:\n            if prefixes."}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a set of all prefixes\n        prefixes = set()\n        for word in words:\n            prefix = \"\"\n            for char in word:\n                prefix = prefix + char\n                if prefix not in prefixes:\n                    prefixes.add(prefix)\n        \n        # check if a word is concatenated\n        res = []\n        for word in words:\n            if prefixes.issuperset(word):\n                res.append(word)\n        \n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a trie\n        root = {}\n        for word in words:\n            node = root\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['#'] = True\n        \n        # check if a word is concatenated\n        res = []\n        for word in words:\n            node = root\n            for char in word:\n                if char not in node:\n                    break\n                node = node[char]\n            if '#' in node:\n                res.append(word)\n        \n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            sign = '-'\n            num = -num\n        else:\n            sign = ''\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return sign + res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1 is a multiple of 4\n        return n % 4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1 is the only number that is not divisible by 4\n        return n % 4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1 is the only number that is not divisible by 4\n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 0-based row, 0-based col\n        # d[i] = d[i-1] + d[i-1-col-i+row]\n        # d[i] = d[i-1] + d[i-col]\n        d = [0] * (n + 1)\n        res = 0\n        for row in range(n):\n            col = d[row]\n            res += col\n            d[col + row] += 1\n        return res"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] represents the number of solutions for n queens with i queens placed\n        dp = [1] * (n + 1)\n        for i in range(1, n):\n            for j in range(i):\n                if dp[j] and (i - j) != abs(dp[i] - dp[j]):\n                    dp[i] += 1\n        return dp[n]"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 0-based row, 0-based col\n        # row[i] is the col of the queen in the i-th row\n        # col[i] is the row of the queen in the i-th col\n        # diag1[i] is the col of the queen in the i-th diagonal\n        # diag2[i] is the col of the queen in the i-th anti-diagonal\n        row, col, diag1, diag2 = [0] * n, [0] * n, [0] * 2 * n, [0] * 2 * n\n        res = 0\n        for i in range(n):\n            row[i], col[i], diag1[i + i], diag2[i - i + n - 1] = i, i, i, i\n            res += self.dfs(row, col, diag1, diag2, 0, i)\n            row[i], col[i], diag1[i + i], diag2[i - i + n - 1] = 0, 0, 0, 0\n        return res\n        \n    def dfs(self, row, col, diag1, diag2, cur, n):\n        if cur == n:\n            return 1\n        res = 0\n        for i in range(cur, n):\n            if row[i] == col[cur] or diag1[i - row[i] + n] == col[cur] or diag2[i + row[i]] == col[cur]:\n                continue\n            res += self.dfs(row, col, diag1, diag2, i, n)\n        return res"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 0-based row, 0-based col\n        # 1st queen in row i, col j\n        # 2nd queen in row i, col k\n        # 3rd queen in row i, col l\n        # 4th queen in row i, col m\n        # ...\n        # nth queen in row i, col (n-1)\n        # \n        # col[i] != col[j]\n        # col[i] != col[j] - i\n        # col[i] != col[j] + i\n        # \n        # row[i] != row[j]\n        # row[i] != row[j] - i\n        # row[i] != row[j] + i\n        # \n        # col[i] != col[j] and row[i] != row[j]\n        # col[i] != col[j] - i and row[i] != row[j] - i\n        # col[i] != col[j] + i and row[i] != row[j] + i\n        # \n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] - i and row[i] != row[j] - i\n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] + i and row[i] != row[j] + i\n        # \n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] - i and row[i] != row[j] + i\n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] + i and row[i] != row[j] - i\n        # \n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] - i and row[i] != row[j] + i and col[i] != col[j] + i and row[i] != row[j] - i\n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] + i and row[i] != row[j] - i and col[i] != col[j] - i and row[i] != row[j] + i\n        # \n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] - i and row[i] != row[j] + i and col[i] != col[j] + i and row[i] != row[j] - i and col[i] != col[j] - i and row[i] != row[j] + i\n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] + i and row[i] != row[j] - i and col[i] != col[j] + i and row[i] != row[j] + i and col[i] != col[j] - i and row[i] != row[j] - i\n        # \n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] - i and row[i] != row[j] + i and col[i] != col[j] + i and row[i] != row[j] - i and col[i] != col[j] - i and row[i] != row[j] + i and col[i] != col[j] + i and row[i] != row[j] - i\n        # col[i] != col[j] and row[i] != row[j] and col[i] != col[j] + i and row[i] != row[j] - i and col[i] != col[j] + i and row[i] != row[j] + i and col[i] != col[j] - i and row[i] != row[j] - i and col[i] != col[j] - i and row[i] != row[j] + i\n        #"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1st row is always valid\n        # 2nd row is always valid\n        # 3rd row is always valid\n        # 4th row is always valid\n        # 5th row is always valid\n        # 6th row is always valid\n        # 7th row is always valid\n        # 8th row is always valid\n        # 9th row is always valid\n        # 10th row is always valid\n        # ...\n        # (n - 1)th row is always valid\n        # nth row is always valid\n        # so the answer is 2 ^ n - 1\n        return 2 ** n - 1"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        res = []\n        row = [0] * n\n        col = [0] * n\n        diag1 = 0\n        diag2 = 0\n        \n        def backtrack(row, res):\n            if row == n:\n                res.append(['.' * i + 'Q' + '.' * (n - i - 1) for i in range(n)])\n                return\n            \n            for i in range(n):\n                if row + col[i] + diag1 == diag2:\n                    continue\n                col[i], diag1, diag2 = col[i] + 1, diag1 + row + 1, diag2 + row - i + 1\n                backtrack(row + 1, res)\n                col[i], diag1, diag2 = col[i] - 1, diag1 - row + 1, diag2 - row + i + 1\n        \n        backtrack(0, res)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        res = []\n        row = [0] * n\n        col = [0] * n\n        diag1 = 0\n        diag2 = 0\n        \n        def dfs(row):\n            if row == n:\n                res.append(['.' * i + 'Q' + '.' * (n - i - 1) for i in range(n)])\n                return\n            \n            for i in range(n):\n                if row + col[i] + diag1 == diag2:\n                    continue\n                col[i], diag1, diag2 = col[i] + 1, diag1 + row + i, diag2 + row - i\n                dfs(row + 1)\n                col[i], diag1, diag2 = col[i] - 1, diag1 - row + i, diag2 - row - i\n        \n        dfs(0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        res = []\n        row = [0] * n\n        col = [0] * n\n        diag1 = 0\n        diag2 = 0\n        \n        def backtrack(row, res):\n            if row == n:\n                res.append(['.' * i + 'Q' + '.' * (n - i - 1) for i in range(n)])\n                return\n            \n            for i in range(n):\n                if row + col[i] + diag1 == diag2:\n                    continue\n                col[i], diag1, diag2 = col[i] + 1, diag1 + row + i, diag2 + row - i\n                backtrack(row + 1, res)\n                col[i], diag1, diag2 = col[i] - 1, diag1 - row + i, diag2 - row - i\n        \n        backtrack(0, res)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        res = []\n        row = [0] * n\n        col = [0] * n\n        diag1 = 0\n        diag2 = 0\n        \n        def backtrack(row, res):\n            if row == n:\n                res.append(['.' * i + 'Q' + '.' * (n - i - 1) for i in range(n)])\n                return\n            \n            for i in range(n):\n                if row + col[i] + diag1 == diag2:\n                    continue\n                col[i], diag1, diag2 = col[i] + 1, diag1 + row + i, diag2 + row - i\n                backtrack(row + 1, res)\n                col[i], diag1, diag2 = col[i] - 1, diag1 - row + i, diag2 - row - i\n        \n        backtrack(0, res)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        res = []\n        row = [0] * n\n        col = [0] * n\n        diag1 = 0\n        diag2 = 0\n        \n        def backtrack(row, res):\n            if row == n:\n                res.append(['.' * i + 'Q' + '.' * (n - i - 1) for i in range(n)])\n                return\n            \n            for i in range(n):\n                if row + col[i] + diag1 == diag2:\n                    continue\n                col[i], diag1, diag2 = col[i] + 1, diag1 + row + i, diag2 + row - i\n                backtrack(row + 1, res)\n                col[i], diag1, diag2 = col[i] - 1, diag1 - row + i, diag2 - row - i\n        \n        backtrack(0, res)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not board or not board[0]:\n            return False\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0] and self.dfs(board, visited, i, j, word, 0):\n                    return True\n        \n        return False\n        \n    def dfs(self, board, visited, i, j, word, idx):\n        if idx == len(word) - 1:\n            return board[i][j] == word[idx]\n        \n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[idx]:\n            return False\n        \n        visited[i][j] = True\n        res = self.dfs(board, visited, i + 1, j, word, idx + 1) or self.dfs(board, visited, i - 1, j, word, idx + 1) or self.dfs(board, visited, i, j + 1, word, idx + 1) or self.dfs(board, visited, i, j - 1, word, idx + 1)\n        visited[i][j] = False\n        \n        return res"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not board or not board[0]:\n            return False\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0] and self.dfs(board, visited, i, j, word, 0):\n                    return True\n        \n        return False\n        \n    def dfs(self, board, visited, i, j, word, idx):\n        if idx == len(word):\n            return True\n        \n        if i < 0 or i == len(board) or j < 0 or j == len(board[0]) or visited[i][j] or board[i][j] != word[idx]:\n            return False\n        \n        visited[i][j] = True\n        res = self.dfs(board, visited, i + 1, j, word, idx + 1) or self.dfs(board, visited, i - 1, j, word, idx + 1) or self.dfs(board, visited, i, j + 1, word, idx + 1) or self.dfs(board, visited, i, j - 1, word, idx + 1)\n        visited[i][j] = False\n        \n        return res"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not board or not board[0]:\n            return False\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0] and self.dfs(board, visited, i, j, word, 0):\n                    return True\n        \n        return False\n        \n    def dfs(self, board, visited, i, j, word, idx):\n        if idx == len(word):\n            return True\n        \n        if i < 0 or i == len(board) or j < 0 or j == len(board[0]) or visited[i][j] or board[i][j] != word[idx]:\n            return False\n        \n        visited[i][j] = True\n        res = self.dfs(board, visited, i + 1, j, word, idx + 1) or self.dfs(board, visited, i - 1, j, word, idx + 1) or self.dfs(board, visited, i, j + 1, word, idx + 1) or self.dfs(board, visited, i, j - 1, word, idx + 1)\n        visited[i][j] = False\n        \n        return res"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not board or not board[0]:\n            return False\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0] and self.dfs(board, visited, i, j, word, 0):\n                    return True\n        \n        return False\n        \n    def dfs(self, board, visited, i, j, word, idx):\n        if idx == len(word):\n            return True\n        \n        if i < 0 or i == len(board) or j < 0 or j == len(board[0]) or visited[i][j] or board[i][j] != word[idx]:\n            return False\n        \n        visited[i][j] = True\n        res = self.dfs(board, visited, i + 1, j, word, idx + 1) or self.dfs(board, visited, i - 1, j, word, idx + 1) or self.dfs(board, visited, i, j + 1, word, idx + 1) or self.dfs(board, visited, i, j - 1, word, idx + 1)\n        visited[i][j] = False\n        \n        return res"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not board or not board[0]:\n            return False\n        \n        m, n = len(board), len(board[0])\n        visited = [[False] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0] and self.dfs(board, visited, i, j, word, 0):\n                    return True\n        \n        return False\n        \n    def dfs(self, board, visited, i, j, word, idx):\n        if idx == len(word):\n            return True\n        \n        if i < 0 or i == len(board) or j < 0 or j == len(board[0]) or visited[i][j] or board[i][j] != word[idx]:\n            return False\n        \n        visited[i][j] = True\n        res = self.dfs(board, visited, i + 1, j, word, idx + 1) or self.dfs(board, visited, i - 1, j, word, idx + 1) or self.dfs(board, visited, i, j + 1, word, idx + 1) or self.dfs(board, visited, i, j - 1, word, idx + 1)\n        visited[i][j] = False\n        \n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. \u5148\u5c06nums2\u653e\u5165nums1\u4e2d\n        # 2. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u4e0enums2\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u6bd4\u8f83\uff0c\u5c0f\u7684\u653e\u5165nums1\u4e2d\n        # 3. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 4. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 5. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 6. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 7. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 8. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 9. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 10. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 11. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 12. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 13. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 14. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 15. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 16. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 17. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 18. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 19. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 20. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 21. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 22. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 23. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 24. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 25. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 26. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 27. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 28. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 29. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 30. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 31. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 32. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 33. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 34. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 35. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 36. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 37. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 38. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 39. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 40. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 41. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 42. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 43. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 44. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 45. \u5c06nums2\u4e2d\u7684\u6570\u5b57\u653e\u5165nums1\u4e2d\n        # 46. \u5c06nums1\u4e2d\u7684\u6570\u5b57\u653e\u5165nums2\u4e2d\n        # 47."}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # if m == 0:\n        #     nums1[:n] = nums2\n        #     return\n        # if n == 0:\n        #     return\n        # if m > n:\n        #     self.merge(nums2, n, nums1, m)\n        #     return\n        \n        # i, j = m - 1, n - 1\n        # while i >= 0 and j >= 0:\n        #     if nums1[i] > nums2[j]:\n        #         nums1[i + j + 1] = nums1[i]\n        #         i -= 1\n        #     else:\n        #         nums1[i + j + 1] = nums2[j]\n        #         j -= 1\n        # if j >= 0:\n        #     nums1[:j + 1] = nums2[:j + 1]\n        \n        # \u53cc\u6307\u9488\n        i, j, k = m - 1, n - 1, m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        if j >= 0:\n            nums1[:j + 1] = nums2[:j + 1]\n```\n\n### 2. \u53cc\u6307\u9488\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        i, j = m - 1, n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[i + j + 1] = nums1[i]\n                i -= 1\n            else:\n                nums1[i + j + 1] = nums2[j]\n                j -= 1\n        if j >= 0:\n            nums1[:j + 1] = nums2[:j + 1]\n```\n\n### 3. \u53cc\u6307\u9488\u4f18\u5316\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        i, j, k = m - 1, n - 1, m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        if j >= 0:\n            nums1[:j + 1] = nums2[:j + 1]\n```\n\n### 4. \u53cc\u6307\u9488\u4f18\u5316\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        i, j, k = m - 1, n - 1, m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        if j >= 0:\n            nums1[:j + 1] = nums2[:j + 1]\n```\n\n### 5. \u53cc\u6307\u9488\u4f18\u5316\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # if m == 0:\n        #     nums1[:n] = nums2\n        #     return\n        # if n == 0:\n        #     return\n        # if m > n:\n        #     self.merge(nums2, n, nums1, m)\n        #     return\n        \n        # i, j, k = m - 1, n - 1, m + n - 1\n        # while i >= 0 and j >= 0:\n        #     if nums1[i] > nums2[j]:\n        #         nums1[k] = nums1[i]\n        #         i -= 1\n        #     else:\n        #         nums1[k] = nums2[j]\n        #         j -= 1\n        #     k -= 1\n        # if j >= 0:\n        #     nums1[:j + 1] = nums2[:j + 1]\n\n        # \u53cc\u6307\u9488\n        i, j = m - 1, n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[i + j + 1] = nums1[i]\n                i -= 1\n            else:\n                nums1[i + j + 1] = nums2[j]\n                j -= 1\n        if j >= 0:\n            nums1[:j + 1] = nums2[:j + 1]\n```\n\n### 2. Solution\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        i, j = m - 1, n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[i + j + 1] = nums1[i]\n                i -= 1\n            else:\n                nums1[i + j + 1] = nums2[j]\n                j -= 1\n        if j >= 0:\n            nums1[:j + 1] = nums2[:j + 1]\n```\n\n### 3. Solution\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1[:m] = nums1[:m] + nums2[:n]\n        nums1.sort()\n```\n\n### 4. Solution\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        nums1[:] = nums1[:m] + nums2[:n]\n        nums1.sort()\n```\n\n### 5. Solution\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        i, j = m - 1, n - 1\n        last = m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[last] = nums1[i]\n                i -= 1\n            else:\n                nums1[last] = nums2[j]\n                j -= 1\n            last -= 1\n        if j >= 0:\n            nums1[:j + 1] = nums2[:j + 1]\n```\n\n### 6. Solution\n\n```python\nclass Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        i, j, k = m - 1, n - 1, m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2["}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Return the third element\n        # 3. If the third element is not found, return the second element\n        # 4. If the second element is not found, return the first element\n        # 5. If the first element is not found, return the largest element\n        \n        nums.sort()\n        return nums[-3] if len(nums) >= 3 and nums[-3] != nums[-2] else nums[-1]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Return the third element if it exists\n        if len(nums) >= 3:\n            return nums[2]\n        \n        # 3. Return the second element if it exists\n        if len(nums) >= 2 and nums[0] != nums[1]:\n            return nums[1]\n        \n        # 4. Return the first element\n        return nums[0]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Use a set to store the three largest numbers\n        # 2. If the set has three numbers, return the third one\n        # 3. If the set has two numbers, return the largest one\n        # 4. If the set has only one number, return it\n        # 5. If the set is empty, return -2**31\n        \n        # O(n) time and O(1) space\n        nums = set(nums)\n        if len(nums) < 3:\n            return max(nums) if nums else -2**31\n        return max(nums - {nums[0], nums[1]})"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Return the third element\n        # 3. If the third element is the same as the second element, return the second element\n        # 4. If the third element is the same as the first element, return the first element\n        # 5. If the third element is the same as the second element, return the second element\n        # 6. If the third element is the same as the first element, return the first element\n        # 7. If the third element is the same as the second element, return the second element\n        # 8. If the third element is the same as the first element, return the first element\n        # 9. If the third element is the same as the second element, return the second element\n        # 10. If the third element is the same as the first element, return the first element\n        # 11. If the third element is the same as the second element, return the second element\n        # 12. If the third element is the same as the first element, return the first element\n        # 13. If the third element is the same as the second element, return the second element\n        # 14. If the third element is the same as the first element, return the first element\n        # 15. If the third element is the same as the second element, return the second element\n        # 16. If the third element is the same as the first element, return the first element\n        # 17. If the third element is the same as the second element, return the second element\n        # 18. If the third element is the same as the first element, return the first element\n        # 19. If the third element is the same as the second element, return the second element\n        # 20. If the third element is the same as the first element, return the first element\n        # 21. If the third element is the same as the second element, return the second element\n        # 22. If the third element is the same as the first element, return the first element\n        # 23. If the third element is the same as the second element, return the second element\n        # 24. If the third element is the same as the first element, return the first element\n        # 25. If the third element is the same as the second element, return the second element\n        # 26. If the third element is the same as the first element, return the first element\n        # 27. If the third element is the same as the second element, return the second element\n        # 28. If the third element is the same as the first element, return the first element\n        # 29. If the third element is the same as the second element, return the second element\n        # 30. If the third element is the same as the first element, return the first element\n        # 31. If the third element is the same as the second element, return the second element\n        # 32. If the third element is the same as the first element, return the first element\n        # 33. If the third element is the same as the second element, return the second element\n        # 34. If the third element is the same as the first element, return the first element\n        # 35. If the third element is the same as the second element, return the second element\n        # 36. If the third element is the same as the first element, return the first element\n        # 37. If the third element is the same as the second element, return the second element\n        # 38. If the third element is the same as the first element, return the first element\n        # 39. If the third element is the same as the second element, return the second element\n        # 40. If the third element is the same as the first element, return the first element\n        # 41. If the third element is the same as the second element, return the second element\n        # 42. If the third element is the same as the first element, return the first element\n        # 43. If the third element is the same as the second element, return the second element\n        # 44. If the third element is the same as the first element, return the first element\n        # 45. If the third element is the same as the second element, return the second element\n        # 46. If the third element is the same as the first element, return the first element"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Return the third element if it exists\n        if len(nums) >= 3:\n            return nums[2]\n        \n        # 3. Return the second element if it exists\n        if len(nums) >= 2 and nums[0] != nums[1]:\n            return nums[1]\n        \n        # 4. Return the first element\n        return nums[0]"}]}