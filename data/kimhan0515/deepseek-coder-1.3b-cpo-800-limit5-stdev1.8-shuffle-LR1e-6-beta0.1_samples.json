{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert all negative numbers to positive numbers\n        ## 2. convert all numbers to their corresponding index\n        ## 3. iterate through the array and check if the index is valid\n        ## 4. if the index is valid, check if the number at that index is valid\n        ## 5. if the number at that index is valid, mark it as negative\n        ## 6. iterate through the array again and find the first positive number\n        ## 7. return the index of that number\n        \n        ## 1. convert all negative numbers to positive numbers\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                nums[i] = 0\n        \n        ## 2. convert all numbers to their corresponding index\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                nums[nums[i] - 1] = nums[i]\n        \n        ## 3. iterate through the array and check if the index is valid\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        ## 4. if the index is valid, check if the number at that index is valid\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        ## Two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] > target:\n                right -= 1\n            else:\n                left += 1\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, prev + curr, res)\n                    backtrack(j+1, curr, prev - curr, prev - curr, res)\n                    backtrack(j+1, curr, prev * curr, prev * curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, 1, res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left_sum = dfs(root.left, curr_sum * 10 + root.val)\n            right_sum = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left_sum + right_sum\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        start = 0\n        tank = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n                \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # add 1 to the end and start\n        nums = [1] + nums + [1]\n        \n        # create a 2d array\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        \n        # fill the dp array\n        for i in range(len(nums) - 2, -1, -1):\n            for j in range(i + 2, len(nums)):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][len(nums) - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while nums1 or nums2:\n                if nums1 > nums2:\n                    out.append(nums1.pop(0))\n                else:\n                    out.append(nums2.pop(0))\n            return out\n        \n        def merge_k(nums1, nums2):\n            if len(nums1) < len(nums2):\n                return merge(nums2, nums1)\n            else:\n                return merge(nums1, nums2)\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k(nums1, nums2)\n            else:\n                return merge_k(nums2, nums1)\n        \n        def merge_k_helper_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper(nums1, nums2)\n            else:\n                return merge_k_helper(nums2, nums1)\n        \n        def merge_k_helper_helper_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper_helper(nums1, nums2)\n            else:\n                return merge_k_helper_helper(nums2, nums1)\n        \n        def merge_k_helper_helper_helper_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper_helper_helper(nums1, nums2)\n            else:\n                return merge_k_helper_helper_helper(nums2, nums1)\n        \n        def merge_k_helper_helper_helper_helper_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper_helper_helper_helper(nums1, nums2)\n            else:\n                return merge_k_helper_helper_helper_helper(nums2, nums1)\n        \n        def merge_k_helper_helper_helper_helper_helper_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper_helper_helper_helper_helper(nums1, nums2)\n            else:\n                return merge_k_helper_helper_helper_helper_helper(nums2, nums1)\n        \n        def merge_k_helper_helper_helper_helper_helper_helper_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i != num / i:\n                    sum += i + num / i\n                else:\n                    sum += i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_list = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_list.append(s_list[i])\n        vowel_list.reverse()\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # BFS\n        # Time:"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        result = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 0\n            else:\n                if carry == 1:\n                    result = '0' + result\n                else:\n                    result = '1' + result\n                carry = 1\n        \n        if carry == 1:\n            result = '1' + result\n        \n        return result"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, lower):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (lower and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        left_idx = binary_search(nums, target, True)\n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        return [left_idx, binary_search(nums, target, False) - 1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n                \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n                \n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder >= 10:\n                hex_list.append(hex_dict[remainder])\n            else:\n                hex_list.append(str(remainder))\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # loop through the string and count the number of occurrences of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # loop through the string again and return the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                curr = int(num1[i]) + int(num2[i]) + carry\n            else:\n                curr = int(num1[i]) + carry\n            \n            carry = curr // 10\n            curr = curr % 10\n            res.append(str(curr))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i):\n            if i >= len(s):\n                return 0\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '(':\n                val, i = helper(s, i + 1)\n                return val, i\n            if s[i] == ')':\n                return 0, i + 1\n            sign = 1\n            if s[i] == '-':\n                sign = -1\n                i += 1\n            if s[i] == '+':\n                i += 1\n            val = 0\n            while i < len(s) and s[i].isdigit():\n                val = val * 10 + int(s[i])\n                i += 1\n            return val * sign + helper(s, i)\n        \n        return helper(s, 0)[0]"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1,i,-1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[j] = nums[j],nums[i]\n        \n        # reverse the numbers after the index\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary\n        # Iterate through the list\n        # If the number is already in the dictionary, return True\n        # If the number is not in the dictionary, add it to the dictionary\n        # If the number is in the dictionary, check if the difference between the current index and the index of the number in the dictionary is less than or equal to k\n        # If the difference is less than or equal to k, return True\n        # If the difference is greater than k, add the number to the dictionary\n        # If the loop completes, return False\n        \n        # Create a dictionary\n        nums_dict = {}\n        \n        # Iterate through the list\n        for i in range(len(nums)):\n            \n            # If the number is already in the dictionary, return True\n            if nums[i] in nums_dict:\n                return True\n            \n            # If the number is not in the dictionary, add it to the dictionary\n            nums_dict[nums[i]] = i\n            \n            # If the number is in the dictionary, check if the difference between the current index and the index of the number in the dictionary is less than or equal to k\n            if i - nums_dict[nums[i]] <= k:\n                return True\n            \n            # If the difference is less than or equal to k, return True\n            \n            # If the difference is greater than k, add the number to the dictionary\n            nums_dict[nums[i]] = i\n            \n        # If the loop completes, return False\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        if n == 2:\n            return 0\n        if n == 4:\n            return 1\n        if n == 6:\n            return 2\n        if n == 8:\n            return 3\n        if n == 10:\n            return 4\n        if n == 12:\n            return 5\n        if n == 14:\n            return 6\n        if n == 16:\n            return 7\n        if n == 18:\n            return 8\n        if n == 20:\n            return 9\n        if n == 22:\n            return 10\n        if n == 24:\n            return 11\n        if n == 26:\n            return 12\n        if n == 28:\n            return 13\n        if n == 30:\n            return 14\n        if n == 32:\n            return 15\n        if n == 34:\n            return 16\n        if n == 36:\n            return 17\n        if n == 38:\n            return 18\n        if n == 40:\n            return 19\n        if n == 42:\n            return 20\n        if n == 44:\n            return 21\n        if n == 46:\n            return 22\n        if n == 48:\n            return 23\n        if n == 50:\n            return 24\n        if n == 52:\n            return 25\n        if n == 54:\n            return 26\n        if n == 56:\n            return 27\n        if n == 58:\n            return 28\n        if n == 60:\n            return 29\n        if n == 62:\n            return 30\n        if n == 64:\n            return 31\n        if n == 66:\n            return 32\n        if n == 68:\n            return 33\n        if n == 70:\n            return 34\n        if n == 72:\n            return 35\n        if n == 74:\n            return 36\n        if n == 76:\n            return 37\n        if n == 78:\n            return 38\n        if n == 80:\n            return 39\n        if n == 82:\n            return 40\n        if n == 84:\n            return 41\n        if n == 86:\n            return 42\n        if n == 88:\n            return 43\n        if n == 90:\n            return 44\n        if n == 92:\n            return 45\n        if n == 94:\n            return 46\n        if n == 96:\n            return 47\n        if n == 98:\n            return 48\n        if n == 100:\n            return 49\n        if n == 102:\n            return 50\n        if n == 104:\n            return 51\n        if n == 106:\n            return 52\n        if n == 108:\n            return 53\n        if n == 110:\n            return 54\n        if n == 112:\n            return 55\n        if n == 114:\n            return 56\n        if n == 116:\n            return 57\n        if n == 118:\n            return 58\n        if n == 120:\n            return 59\n        if n == 122:\n            return 60\n        if n == 124:\n            return 61\n        if n == 126:\n            return 62\n        if n == 128:\n            return 63\n        if n == 130:\n            return 64\n        if n == 132:\n            return 65\n        if n == 134:\n            return 66\n        if n == 136:\n            return 67\n        if n == 138:\n            return 68\n        if n == 140:\n            return 69\n        if n == 142:\n            return 70\n        if"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        \n        for word in words:\n            if word[0] in row1:\n                r = row1\n            elif word[0] in row2:\n                r = row2\n            else:\n                r = row3\n            \n            for c in word:\n                if c not in r:\n                    break\n            else:\n                ans.append(word)\n                \n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        for i in range(left-1):\n            curr = curr.next\n        prev = curr\n        curr = curr.next\n        for i in range(right-left):\n            next = curr.next\n            curr.next = next.next\n            next.next = prev.next\n            prev.next = next\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    start += 1\n            start += 1\n        \n        if min_len > end - start:\n            min_len = end - start\n            min_start = start\n            min_end = end\n        \n        return s[min_start:min_end]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character\n        # 2. create a variable to store the length of the longest palindrome\n        # 3. iterate through the dictionary\n        # 4. if the frequency is odd, add 1 to the length of the longest palindrome\n        # 5. if the frequency is even, add 2 to the length of the longest palindrome\n        # 6. return the length of the longest palindrome\n        \n        # 1. create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # 2. create a variable to store the length of the longest palindrome\n        longest = 0\n        \n        # 3. iterate through the dictionary\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # 4. iterate through the dictionary\n        for char in freq:\n            # 5. if the frequency is odd, add 1 to the length of the longest palindrome\n            if freq[char] % 2 == 1:\n                longest += 1\n            # 6. if the frequency is even, add 2 to the length of the longest palindrome\n            else:\n                longest += 2\n        \n        # 7. return the length of the longest palindrome\n        return longest"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    cur = q.pop(0)\n                    if cur == end:\n                        return steps\n                    for n in [(cur[0], cur[1]+1), (cur[0], cur[1]-1), (cur[0]+1, cur[1]), (cur[0]-1, cur[1])]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start_end(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j), (i, j)\n            return None, None\n        \n        start, end = get_start_end(forest)\n        if start is None:\n            return 0\n        return bfs(start, end)"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the first row\n        # 4. Find the number of coins in the second row\n        # 5. Find the number of coins in the third row\n        # 6. Find the number of coins in the fourth row\n        # 7. Find the number of coins in the fifth row\n        # 8. Find the number of coins in the sixth row\n        # 9. Find the number of coins in the seventh row\n        # 10. Find the number of coins in the eighth row\n        # 11. Find the number of coins in the ninth row\n        # 12. Find the number of coins in the tenth row\n        # 13. Find the number of coins in the eleventh row\n        # 14. Find the number of coins in the twelfth row\n        # 15. Find the number of coins in the thirteenth row\n        # 16. Find the number of coins in the fourteenth row\n        # 17. Find the number of coins in the fifteenth row\n        # 18. Find the number of coins in the sixteenth row\n        # 19. Find the number of coins in the seventeenth row\n        # 20. Find the number of coins in the eighteenth row\n        # 21. Find the number of coins in the nineteenth row\n        # 22. Find the number of coins in the twentieth row\n        # 23. Find the number of coins in the twenty-first row\n        # 24. Find the number of coins in the twenty-second row\n        # 25. Find the number of coins in the twenty-third row\n        # 26. Find the number of coins in the twenty-fourth row\n        # 27. Find the number of coins in the twenty-fifth row\n        # 28. Find the number of coins in the twenty-sixth row\n        # 29. Find the number of coins in the twenty-seventh row\n        # 30. Find the number of coins in the twenty-eighth row\n        # 31. Find the number of coins in the twenty-ninth row\n        # 32. Find the number of coins in the thirty-first row\n        # 33. Find the number of coins in the thirty-second row\n        # 34. Find the number of coins in the thirty-third row\n        # 35. Find the number of coins in the thirty-fourth row\n        # 36. Find the number of coins in the thirty-fifth row\n        # 37. Find the number of coins in the thirty-sixth row\n        # 38. Find the number of coins in the thirty-seventh row\n        # 39. Find the number of coins in the thirty-eighth row\n        # 40. Find the number of coins in the thirty-ninth row\n        # 41. Find the number of coins in the forty-first row\n        # 42. Find the number of coins in the forty-second row\n        # 43. Find the number of coins in the forty-third row\n        # 44. Find the number of coins in the forty-fourth row\n        # 45. Find the number of coins in the forty-fifth row\n        # 46. Find the number of coins in the forty-sixth row\n        # 47. Find the number of coins in the forty-seventh row\n        # 48. Find the number of coins in the forty-eighth row\n        # 49. Find the number of coins in the forty-ninth row\n        # 50. Find the number of coins in the fifty-first row\n        # 51. Find the number of coins in the fifty-second row\n        # 52. Find the number of coins in the fifty-third row\n        # 53. Find the number of coins in the fifty-fourth row\n        # 54. Find the number of coins in the fifty-fifth row\n        # 55. Find the number of coins in the fifty-sixth row\n        # 56. Find the number of coins"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if len(s) == 1:\n            if s[0] == '0':\n                return 0\n            else:\n                return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        for i in range(2**n):\n            res.append(i ^ (i >> 1))\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (not left or left.val < node.val) and (not right or right.val > node.val):\n                return valid(node.left, left, node) and valid(node.right, node, right)\n            else:\n                return False\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is larger than the last element in the list, add it to the end\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if the new interval is smaller than the first element in the list, add it to the beginning\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if the new interval overlaps with the first element in the list, merge the two intervals\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0] = [intervals[0][0], intervals[0][1]]\n            return intervals\n        \n        # if the new interval overlaps with the last element in the list, merge the two intervals\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1] = [intervals[-1][0], intervals[-1][1]]\n            return intervals\n        \n        # if the new interval overlaps with the middle element in the list, merge the two intervals\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = [intervals[i][0], intervals[i][1]]\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        heap = []\n        for i in range(n):\n            for j in range(n):\n                heapq.heappush(heap, (grid[i][j], i, j))\n        \n        visited = set()\n        visited.add((0, 0))\n        time = 0\n        while heap:\n            time, i, j = heapq.heappop(heap)\n            if i == n-1 and j == n-1:\n                return time\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(heap, (max(time, grid[x][y]), x, y))\n                    visited.add((x, y))\n        \n        return time"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array of size m x n\n        grid = [[0 for x in range(n)] for y in range(m)]\n        \n        # set the first row to 1\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # set the first column to 1\n        for i in range(n):\n            grid[0][i] = 1\n        \n        # iterate through the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        return grid[m-1][n-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = [str(x) for x in res]\n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == \"0\":\n            res.pop()\n            \n        return \"\".join(res)"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. DP with 2 variables\n        ## 4. DP with 3 variables\n        ## 5. DP with 4 variables\n        ## 6. DP with 5 variables\n        ## 7. DP with 6 variables\n        ## 8. DP with 7 variables\n        ## 9. DP with 8 variables\n        ## 10. DP with 9 variables\n        ## 11. DP with 10 variables\n        ## 12. DP with 11 variables\n        ## 13. DP with 12 variables\n        ## 14. DP with 13 variables\n        ## 15. DP with 14 variables\n        ## 16. DP with 15 variables\n        ## 17. DP with 16 variables\n        ## 18. DP with 17 variables\n        ## 19. DP with 18 variables\n        ## 20. DP with 19 variables\n        ## 21. DP with 20 variables\n        ## 22. DP with 21 variables\n        ## 23. DP with 22 variables\n        ## 24. DP with 23 variables\n        ## 25. DP with 24 variables\n        ## 26. DP with 25 variables\n        ## 27. DP with 26 variables\n        ## 28. DP with 27 variables\n        ## 29. DP with 28 variables\n        ## 30. DP with 29 variables\n        ## 31. DP with 30 variables\n        ## 32. DP with 31 variables\n        ## 33. DP with 32 variables\n        ## 34. DP with 33 variables\n        ## 35. DP with 34 variables\n        ## 36. DP with 35 variables\n        ## 37. DP with 36 variables\n        ## 38. DP with 37 variables\n        ## 39. DP with 38 variables\n        ## 40. DP with 39 variables\n        ## 41. DP with 40 variables\n        ## 42. DP with 41 variables\n        ## 43. DP with 42 variables\n        ## 44. DP with 43 variables\n        ## 45. DP with 44 variables\n        ## 46. DP with 45 variables\n        ## 47. DP with 46 variables\n        ## 48. DP with 47 variables\n        ## 49. DP with 48 variables\n        ## 50. DP with 49 variables\n        ## 51. DP with 50 variables\n        ## 52. DP with 51 variables\n        ## 53. DP with 52 variables\n        ## 54. DP with 53 variables\n        ## 55. DP with 54 variables\n        ## 56. DP with 55 variables\n        ## 57. DP with 56 variables\n        ## 58. DP with 57 variables\n        ## 59. DP with 58 variables\n        ## 60. DP with 59 variables\n        ## 61. DP with 60 variables\n        ## 62. DP with 61 variables\n        ## 63. DP with 62 variables\n        ## 64. DP with 63 variables\n        ## 65. DP with 64 variables\n        ## 66. DP with 65 variables\n        ## 67. DP with 66 variables\n        ## 68. DP with 67 variables\n        ## 69. DP with 68 variables\n        ## 70. DP with 69 variables"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-28\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n                \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        queue = collections.deque([s])\n        seen = set([s])\n        while queue:\n            s = queue.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    queue.append(t)\n                    seen.add(t)\n        return []"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if l1 == None:\n            return l2\n        \n        if l2 == None:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x//5\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l+r)//2\n            if f(m) < k:\n                l = m+1\n            else:\n                r = m\n        return l-k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                res += 1\n            return res\n        \n        return spread(isInfected) + spread(list(zip(*isInfected)))"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(ni, nj))\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10\n        \n        if n < 1000:\n            return 100\n        \n        if n < 10000:\n            return 1000\n        \n        if n < 100000:\n            return 10000\n        \n        if n < 1000000:\n            return 100000\n        \n        if n < 10000000:\n            return 1000000\n        \n        if n < 100000000:\n            return 10000000\n        \n        if n < 1000000000:\n            return 100000000\n        \n        if n < 10000000000:\n            return 1000000000\n        \n        if n < 100000000000:\n            return 10000000000\n        \n        if n < 1000000000000:\n            return 100000000000\n        \n        if n < 10000000000000:\n            return 1000000000000\n        \n        if n < 100000000000000:\n            return 10000000000000\n        \n        if n < 1000000000000000:\n            return 100000000000000\n        \n        if n < 10000000000000000:\n            return 1000000000000000\n        \n        if n < 100000000000000000:\n            return 10000000000000000\n        \n        if n < 1000000000000000000:\n            return 100000000000000000\n        \n        if n < 10000000000000000000:\n            return 1000000000000000000\n        \n        if n < 100000000000000000000:\n            return 10000000000000000000\n        \n        if n < 1000000000000000000000:\n            return 100000000000000000000\n        \n        if n < 10000000000000000000000:\n            return 1000000000000000000000\n        \n        if n < 100000000000000000000000:\n            return 10000000000000000000000\n        \n        if n < 1000000000000000000000000:\n            return 100000000000000000000000\n        \n        if n < 10000000000000000000000000:\n            return 1000000000000000000000000\n        \n        if n < 100000000000000000000000000:\n            return"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the string\n        word_list_s = []\n        for word in s.split(' '):\n            word_list_s.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = []\n        for word in word_list_s:\n            if word in word_list:\n                word_list_s_in_dict.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_2 = []\n        for word in word_list_s_in_dict:\n            if word not in word_list_s_in_dict_2:\n                word_list_s_in_dict_2.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_3 = []\n        for word in word_list_s_in_dict_2:\n            if word not in word_list_s_in_dict_3:\n                word_list_s_in_dict_3.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_4 = []\n        for word in word_list_s_in_dict_3:\n            if word not in word_list_s_in_dict_4:\n                word_list_s_in_dict_4.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_5 = []\n        for word in word_list_s_in_dict_4:\n            if word not in word_list_s_in_dict_5:\n                word_list_s_in_dict_5.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_6 = []\n        for word in word_list_s_in_dict_5:\n            if word not in word_list_s_in_dict_6:\n                word_list_s_in_dict_6.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_7 = []\n        for word in word_list_s_in_dict_6:\n            if word not in word_list_s_in_dict_7:\n                word_list_s_in_dict_7.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_8 = []\n        for word in word_list_s_in_dict_7:\n            if word not in word_list_s_in_dict_8:\n                word_list_s_in_dict_8.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_9 = []\n        for word in word_list_s_in_dict_8:\n            if word not in word_list_s_in_dict_9:\n                word_list_s_in_dict_9.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_10 = []\n        for word in word_list_s_in_dict_9:\n            if word not in word_list_s_in_dict_10:\n                word_list_s_in_dict_10.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_11 = []\n        for word in word_list_s_in_dict_10:\n            if word not in word_list_s_in_dict_11:\n                word_"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_list = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_list)\n            else:\n                result.append(level_list[::-1])\n            level += 1\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)]\n        heap.extend([(heightMap[i][n-1], i, n-1) for i in range(m)])\n        for j in range(1, n-1):\n            heap.extend([(heightMap[i][j], i, j) for i in range(m)])\n        \n        heapq.heapify(heap)\n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            if (i, j) in seen:\n                continue\n            seen.add((i, j))\n            ans += h\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i+di, j+dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. create a list of k-1 elements\n        # 2. create a list of k elements\n        # 3. create a list of k-1 elements\n        # 4. create a list of k elements\n        # 5. create a list of k-1 elements\n        # 6. create a list of k elements\n        # 7. create a list of k-1 elements\n        # 8. create a list of k elements\n        # 9. create a list of k-1 elements\n        # 10. create a list of k elements\n        # 11. create a list of k-1 elements\n        # 12. create a list of k elements\n        # 13. create a list of k-1 elements\n        # 14. create a list of k elements\n        # 15. create a list of k-1 elements\n        # 16. create a list of k elements\n        # 17. create a list of k-1 elements\n        # 18. create a list of k elements\n        # 19. create a list of k-1 elements\n        # 20. create a list of k elements\n        # 21. create a list of k-1 elements\n        # 22. create a list of k elements\n        # 23. create a list of k-1 elements\n        # 24. create a list of k elements\n        # 25. create a list of k-1 elements\n        # 26. create a list of k elements\n        # 27. create a list of k-1 elements\n        # 28. create a list of k elements\n        # 29. create a list of k-1 elements\n        # 30. create a list of k elements\n        # 31. create a list of k-1 elements\n        # 32. create a list of k elements\n        # 33. create a list of k-1 elements\n        # 34. create a list of k elements\n        # 35. create a list of k-1 elements\n        # 36. create a list of k elements\n        # 37. create a list of k-1 elements\n        # 38. create a list of k elements\n        # 39. create a list of k-1 elements\n        # 40. create a list of k elements\n        # 41. create a list of k-1 elements\n        # 42. create a list of k elements\n        # 43. create a list of k-1 elements\n        # 44. create a list of k elements\n        # 45. create a list of k-1 elements\n        # 46. create a list of k elements\n        # 47. create a list of k-1 elements\n        # 48. create a list of k elements\n        # 49. create a list of k-1 elements\n        # 50. create a list of k elements\n        # 51. create a list of k-1 elements\n        # 52. create a list of k elements\n        # 53. create a list of k-1 elements\n        # 54. create a list of k elements\n        # 55. create a list of k-1 elements\n        # 56. create a list of k elements\n        # 57. create a list of k-1 elements\n        # 58. create a list of k elements\n        # 59. create a list of k-1 elements\n        # 60. create a list of k elements\n        # 61. create a list of k-1 elements\n        # 62. create a list of k elements\n        # 63. create a list of k-1 elements\n        # 64. create a list of k elements\n        # 65. create a list of k-1 elements\n        # 66. create a list of k elements\n        # 67. create a list of k-1 elements\n        # 68. create a list of k elements\n        # 69. create a list of k-1 elements\n        # 70. create a list of k elements\n        # 71. create a list of k-1 elements\n        # 72. create a list of k elements\n        # 73. create a list of k-1 elements\n        # 74. create a list of"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.00001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if p[0] == s[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://leetcode.com/problems/majority-element/discuss/144661/Python-O(n)-time-O(1)-space-with-explanation\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in tickets:\n            graph[from_city].append(to_city)\n        \n        # sort the graph\n        for city in graph:\n            graph[city].sort(reverse=True)\n        \n        # dfs\n        def dfs(city):\n            while graph[city]:\n                dfs(graph[city].pop())\n            itinerary.append(city)\n        \n        itinerary = []\n        dfs('JFK')\n        return itinerary[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current height\n        curr_height = 0\n        \n        # initialize the current building\n        curr_building = None\n        \n        # initialize the current building index\n        curr_building_idx = 0\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None, set the current building\n            if curr_building is None:\n                curr_building = building\n            # if the current building is not None and the current building is not the same as the current building,\n            # add the current building to the result\n            elif curr_building[0] != building[0]:\n                result.append([curr_building[0], curr_height])\n                curr_building = building\n            # if the current building is not None and the current building is the same as the current building,\n            # update the current building\n            else:\n                curr_building[1] = max(curr_building[1], building[2])\n        \n        # add the last building to the result\n        result.append([curr_building[0], curr_height])\n        \n        # return the result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the reversed string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i])-1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j], triangle[i-1][j-1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        num_str = str(num)\n        num_len = len(num_str)\n        \n        if num_len == 1:\n            return self.one_digit(num)\n        \n        if num_len == 2:\n            return self.two_digits(num)\n        \n        if num_len == 3:\n            return self.three_digits(num)\n        \n        if num_len == 4:\n            return self.four_digits(num)\n        \n        if num_len == 5:\n            return self.five_digits(num)\n        \n        if num_len == 6:\n            return self.six_digits(num)\n        \n        if num_len == 7:\n            return self.seven_digits(num)\n        \n        if num_len == 8:\n            return self.eight_digits(num)\n        \n        if num_len == 9:\n            return self.nine_digits(num)\n        \n        if num_len == 10:\n            return self.ten_digits(num)\n        \n        if num_len == 11:\n            return self.eleven_digits(num)\n        \n        if num_len == 12:\n            return self.twelve_digits(num)\n        \n        if num_len == 13:\n            return self.thirteen_digits(num)\n        \n        if num_len == 14:\n            return self.fourteen_digits(num)\n        \n        if num_len == 15:\n            return self.fifteen_digits(num)\n        \n        if num_len == 16:\n            return self.sixteen_digits(num)\n        \n        if num_len == 17:\n            return self.seventeen_digits(num)\n        \n        if num_len == 18:\n            return self.eighteen_digits(num)\n        \n        if num_len == 19:\n            return self.nineteen_digits(num)\n        \n        if num_len == 20:\n            return self.twenty_digits(num)\n        \n        if num_len == 21:\n            return self.twenty_one_digits(num)\n        \n        if num_len == 22:\n            return self.twenty_two_digits(num)\n        \n        if num_len == 23:\n            return self.twenty_three_digits(num)\n        \n        if num_len == 24:\n            return self.twenty_four_digits(num)\n        \n        if num_len == 25:\n            return self.twenty_five_digits(num)\n        \n        if num_len == 26:\n            return self.twenty_six_digits(num)\n        \n        if num_len == 27:\n            return self.twenty_seven_digits(num)\n        \n        if num_len == 28:\n            return self.twenty_eight_digits(num)\n        \n        if num_len == 29:\n            return self.twenty_nine_digits(num)\n        \n        if num_len == 30:\n            return self.thirty_digits(num)\n        \n        if num_len == 31:\n            return self.thirty_one_digits(num)\n        \n        if num_len == 32:\n            return self.thirty_two_digits(num)\n        \n        if num_len == 33:\n            return self.thirty_three_digits(num)\n        \n        if num_len == 34:\n            return self.thirty_four_digits(num)\n        \n        if num_len == 35:\n            return self.thirty_five_digits(num)\n        \n        if num_len == 36:\n            return self.thirty_six_digits(num)\n        \n        if num_len == 37:\n            return self.thirty_seven_digits(num)\n        \n        if num_len == 38:\n            return self.thirty_eight_digits(num)\n        \n        if num_len == 39:"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the node with only one parent\n        # 3. find the node with only one child\n        # 4. find the node with only one child\n        # 5. find the node with only one child\n        # 6. find the node with only one child\n        # 7. find the node with only one child\n        # 8. find the node with only one child\n        # 9. find the node with only one child\n        # 10. find the node with only one child\n        # 11. find the node with only one child\n        # 12. find the node with only one child\n        # 13. find the node with only one child\n        # 14. find the node with only one child\n        # 15. find the node with only one child\n        # 16. find the node with only one child\n        # 17. find the node with only one child\n        # 18. find the node with only one child\n        # 19. find the node with only one child\n        # 20. find the node with only one child\n        # 21. find the node with only one child\n        # 22. find the node with only one child\n        # 23. find the node with only one child\n        # 24. find the node with only one child\n        # 25. find the node with only one child\n        # 26. find the node with only one child\n        # 27. find the node with only one child\n        # 28. find the node with only one child\n        # 29. find the node with only one child\n        # 30. find the node with only one child\n        # 31. find the node with only one child\n        # 32. find the node with only one child\n        # 33. find the node with only one child\n        # 34. find the node with only one child\n        # 35. find the node with only one child\n        # 36. find the node with only one child\n        # 37. find the node with only one child\n        # 38. find the node with only one child\n        # 39. find the node with only one child\n        # 40. find the node with only one child\n        # 41. find the node with only one child\n        # 42. find the node with only one child\n        # 43. find the node with only one child\n        # 44. find the node with only one child\n        # 45. find the node with only one child\n        # 46. find the node with only one child\n        # 47. find the node with only one child\n        # 48. find the node with only one child\n        # 49. find the node with only one child\n        # 50. find the node with only one child\n        # 51. find the node with only one child\n        # 52. find the node with only one child\n        # 53. find the node with only one child\n        # 54. find the node with only one child\n        # 55. find the node with only one child\n        # 56. find the node with only one child\n        # 57. find the node with only one child\n        # 58. find the node with only one child\n        # 59. find the node with only one child\n        # 60. find the node with only one child\n        # 61. find the node with only one child\n        # 62. find the node with only one child\n        # 63. find the node with only one child\n        # 64. find the node with only one child\n        # 65. find the node with only one child\n        # 66. find the node with only one child\n        # 67. find the node with only one child\n        # 68. find the node with only one child\n        # 69. find the node with only one child\n        # 70. find the node with only one child\n        # 71. find the node with only one child\n        # 72. find the node with only one child\n        # 73. find the node with only one child\n        # 74. find the node with only one"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            for i in range(first, n):\n                if nums[i] not in used:\n                    used.add(nums[i])\n                    nums[first], nums[i] = nums[i], nums[first]\n                    backtrack(first + 1)\n                    nums[first], nums[i] = nums[i], nums[first]\n        n = len(nums)\n        res = []\n        used = set()\n        backtrack()\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 2 ^ 2 = 0\n        ## 2 ^ 1 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 = 0\n        ## 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 ^ 1 ^ 2 = 1\n        ## 2 ^ 1 ^"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j][0] = -1\n                dp[i][j][n - 1] = -1\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                for k in range(n):\n                    for l in range(n):\n                        if grid[i][k] == -1 or grid[j][l] == -1:\n                            continue\n                        if k == l:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j + 1][k] + 1)\n                        else:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j + 1][k] + dp[i + 1][j + 1][l] + 1)\n        \n        return max(dp[0][0][n - 1], 0)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # edge cases\n        if target < nums[0]:\n            return 0\n        if target > nums[-1]:\n            return len(nums)\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # return the index where it would be if it were inserted in order\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211211131221\"\n        \n        if n == 13:\n            return \"1321132132111231131221123113112221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 15:\n            return \"31131122213213211231131221123113112221\"\n        \n        if n == 16:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 17:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 18:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 19:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 20:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 21:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 22:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 23:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 24:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 25:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 26:"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(mid):\n            cnt = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    cnt += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return cnt <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left = 0\n            right = len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        pivot = find_pivot(nums)\n        if pivot == -1:\n            return binary_search(nums, target)\n        if nums[pivot] == target:\n            return pivot\n        if nums[0] <= target:\n            return binary_search(nums[:pivot+1], target)\n        else:\n            return binary_search(nums[pivot+1:], target)"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                res.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def is_palindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        def get_palindrome(num):\n            return int(str(num)[:len(str(num))//2] + str(num)[::-1])\n        \n        def get_closest_palindrome(num):\n            if is_palindrome(num):\n                return num\n            else:\n                return get_palindrome(num)\n        \n        def get_closest_palindrome_to_n(n):\n            if is_palindrome(n):\n                return n\n            else:\n                return get_closest_palindrome(int(n) + 1)\n        \n        def get_closest_palindrome_to_n_minus_one(n):\n            if is_palindrome(n):\n                return n\n            else:\n                return get_closest_palindrome(int(n) - 1)\n        \n        if n == '1':\n            return '0'\n        elif n == '0':\n            return '1'\n        elif n == '9':\n            return '8'\n        elif n == '10':\n            return '9'\n        elif n == '11':\n            return '9'\n        elif n == '12':\n            return '9'\n        elif n == '13':\n            return '9'\n        elif n == '14':\n            return '9'\n        elif n == '15':\n            return '9'\n        elif n == '16':\n            return '9'\n        elif n == '17':\n            return '9'\n        elif n == '18':\n            return '9'\n        elif n == '19':\n            return '9'\n        elif n == '20':\n            return '9'\n        elif n == '21':\n            return '9'\n        elif n == '22':\n            return '9'\n        elif n == '23':\n            return '9'\n        elif n == '24':\n            return '9'\n        elif n == '25':\n            return '9'\n        elif n == '26':\n            return '9'\n        elif n == '27':\n            return '9'\n        elif n == '28':\n            return '9'\n        elif n == '29':\n            return '9'\n        elif n == '30':\n            return '9'\n        elif n == '31':\n            return '9'\n        elif n == '32':\n            return '9'\n        elif n == '33':\n            return '9'\n        elif n == '34':\n            return '9'\n        elif n == '35':\n            return '9'\n        elif n == '36':\n            return '9'\n        elif n == '37':\n            return '9'\n        elif n == '38':\n            return '9'\n        elif n == '39':\n            return '9'\n        elif n == '40':\n            return '9'\n        elif n == '41':\n            return '9'\n        elif n == '42':\n            return '9'\n        elif n == '43':\n            return '9'\n        elif n == '44':\n            return '9'\n        elif n == '45':\n            return '9'\n        elif n == '46':\n            return '9'\n        elif n == '47':\n            return '9'\n        elif n == '48':\n            return '9'\n        elif n == '49':\n            return '9'\n        elif n == '50':\n            return '9'\n        elif n == '51':\n            return '9'\n        elif n == '52':\n            return '9'\n        elif n == '53':\n            return '9'\n        elif n == '54':\n            return '9'\n        elif n == '55':\n            return '9'\n        elif n == '56':\n            return '9'\n        elif n == '57':\n            return '9'\n        elif n == '58':\n            return '9'\n        elif n == '59':"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = num\n                    num += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][col_start] = num\n                    num += 1\n                col_start += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        \n        rev = 0\n        \n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        \n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n                \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        stone_set = set(stones)\n        stone_set.add(stones[-1])\n        \n        q = collections.deque()\n        q.append((1, 1))\n        \n        while q:\n            curr_stone, curr_jump = q.popleft()\n            \n            for jump in range(curr_jump - 1, curr_jump + 2):\n                if jump > 0 and curr_stone + jump in stone_set:\n                    if curr_stone + jump == stones[-1]:\n                        return True\n                    q.append((curr_stone + jump, jump))\n        \n        return False"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array\n        score.sort()\n        \n        # create a dictionary\n        rank_dict = {}\n        \n        # create a list of the scores\n        score_list = []\n        \n        # create a list of the ranks\n        rank_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        curr_str = \"\"\n        \n        for i in range(len(s)):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n            else:\n                if curr_len > max_len:\n                    max_len = curr_len\n                curr_str = curr_str[curr_str.index(s[i])+1:] + s[i]\n                curr_len = len(curr_str)\n                \n        if curr_len > max_len:\n            max_len = curr_len\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_index = 0\n        word_dict_len_count_list_index_list = []\n        word_dict_len_count_list_index_list.append(word_dict_len_count_list_index)\n        \n        word_dict_len_count_list_index_list_index = 0\n        word_dict_len_count_list_index_list_index_list = []\n        word_dict_len_count_list_index_list_index_list.append(word_dict_len_count_list_index_list_index)\n        \n        word_dict_len_count_list_index_list_index_list_index = 0\n        word_dict_len_count_list_index_list_index_list_index_list = []\n        word_dict_len_count_list_index_list_index_list_index_list.append(word_dict_len_count_list_index_list_index_list_index)\n        \n        word_dict_len_count_list_index_list_index_list_index_list_index = 0\n        word_dict_len_count_list_index_list_index_list_index_list_index_list = []\n        word_dict_len_count_list_index_list_index_list_index_list_index_list.append(word_dict_len_count_list_index_list_index_list_index_list_index)\n        \n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index = 0\n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list = []\n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list.append(word_dict_len_count_list_index_list_index_list_index_list_index_list_index)\n        \n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index = 0\n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index_list = []\n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index_list.append(word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index)\n        \n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index_list_index = 0\n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list = []\n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list.append(word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index_list)\n        \n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list_index = 0\n        word_dict_len_count_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list = []"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the current element is less than the previous element\n        # 3. if it is, then we have a chunk\n        # 4. if it is not, then we have a new chunk\n        # 5. return the number of chunks\n        \n        arr.sort()\n        chunks = 0\n        prev = 0\n        for i in range(len(arr)):\n            if arr[i] < prev:\n                chunks += 1\n            prev = arr[i]\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\n        \n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n                    \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(len(v1)):\n            if len(v2) > i:\n                if int(v1[i]) > int(v2[i]):\n                    return 1\n                elif int(v1[i]) < int(v2[i]):\n                    return -1\n            else:\n                if int(v1[i]) > 0:\n                    return 1\n                else:\n                    return 0\n        \n        if len(v2) > len(v1):\n            return -1\n        else:\n            return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        \n        ##"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, end in courses:\n            # add to priority queue\n            heapq.heappush(pq, (-duration, end))\n            \n            # add to total time\n            total += duration\n            \n            # if total time exceeds end date, remove the longest course\n            if total > end:\n                total += heapq.heappop(pq)[0]\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            count = 0\n            while curr and count < k:\n                curr = curr.next\n                count += 1\n            if count == k:\n                prev.next = self.reverse(head, curr)\n                prev = head\n                head = curr\n            else:\n                prev.next = head\n                break\n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = None\n        curr = head\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        return curr"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. Hashmap\n        ## 3. Bit manipulation\n        ## 4. Bit manipulation\n        ## 5. Bit manipulation\n        ## 6. Bit manipulation\n        ## 7. Bit manipulation\n        ## 8. Bit manipulation\n        ## 9. Bit manipulation\n        ## 10. Bit manipulation\n        ## 11. Bit manipulation\n        ## 12. Bit manipulation\n        ## 13. Bit manipulation\n        ## 14. Bit manipulation\n        ## 15. Bit manipulation\n        ## 16. Bit manipulation\n        ## 17. Bit manipulation\n        ## 18. Bit manipulation\n        ## 19. Bit manipulation\n        ## 20. Bit manipulation\n        ## 21. Bit manipulation\n        ## 22. Bit manipulation\n        ## 23. Bit manipulation\n        ## 24. Bit manipulation\n        ## 25. Bit manipulation\n        ## 26. Bit manipulation\n        ## 27. Bit manipulation\n        ## 28. Bit manipulation\n        ## 29. Bit manipulation\n        ## 30. Bit manipulation\n        ## 31. Bit manipulation\n        ## 32. Bit manipulation\n        ## 33. Bit manipulation\n        ## 34. Bit manipulation\n        ## 35. Bit manipulation\n        ## 36. Bit manipulation\n        ## 37. Bit manipulation\n        ## 38. Bit manipulation\n        ## 39. Bit manipulation\n        ## 40. Bit manipulation\n        ## 41. Bit manipulation\n        ## 42. Bit manipulation\n        ## 43. Bit manipulation\n        ## 44. Bit manipulation\n        ## 45. Bit manipulation\n        ## 46. Bit manipulation\n        ## 47. Bit manipulation\n        ## 48. Bit manipulation\n        ## 49. Bit manipulation\n        ## 50. Bit manipulation\n        ## 51. Bit manipulation\n        ## 52. Bit manipulation\n        ## 53. Bit manipulation\n        ## 54. Bit manipulation\n        ## 55. Bit manipulation\n        ## 56. Bit manipulation\n        ## 57. Bit manipulation\n        ## 58. Bit manipulation\n        ## 59. Bit manipulation\n        ## 60. Bit manipulation\n        ## 61. Bit manipulation\n        ## 62. Bit manipulation\n        ## 63. Bit manipulation\n        ## 64. Bit manipulation\n        ## 65. Bit manipulation\n        ## 66. Bit manipulation\n        ## 67. Bit manipulation\n        ## 68. Bit manipulation\n        ## 69. Bit manipulation\n        ## 70. Bit manipulation\n        ## 71. Bit manipulation\n        ## 72. Bit manipulation\n        ## 73. Bit manipulation\n        ## 74. Bit manipulation\n        ## 75. Bit manipulation\n        ## 76. Bit manipulation\n        ## 77. Bit manipulation\n        ## 78. Bit manipulation\n        ## 79. Bit manipulation\n        ## 80. Bit manipulation\n        ## 81. Bit manipulation\n        ## 82. Bit manipulation\n        ## 83. Bit manipulation\n        ## 84. Bit manipulation\n        ## 85. Bit manipulation\n        ## 86. Bit manipulation\n        ## 87. Bit manipulation\n        ## 88. Bit manipulation\n        ## 89. Bit manipulation\n        ## 90. Bit manipulation\n        ## 91. Bit manipulation\n        ## 92. Bit manipulation\n        ## 93. Bit manipulation\n        ## 94. Bit manipulation"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not set(target).issubset(sticker):\n                    continue\n                res = min(res, dfs(target.replace(sticker, '', 1)) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid == x:\n                return mid\n            \n            elif mid * mid < x:\n                left = mid + 1\n            \n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        num = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                num -= roman_dict[s[i]]\n            else:\n                num += roman_dict[s[i]]\n        return num"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return nums\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7])]\n        \n        if len(nums) == 9:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8])]\n        \n        if len(nums) == 10:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9])]\n        \n        if len(nums) == 11:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10])]\n        \n        if len(nums) == 12:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11])]\n        \n        if len(nums) == 13:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12])]\n        \n        if len(nums) == 14:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13])]\n        \n        if len(nums) == 15:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13], nums[14])]\n        \n        if len(nums) == 16:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13], nums"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1])/2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1650,2401,2401,1650,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,432,1200,2640,4320,4320,2640,1200,432,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,405,1300,3003,5185,6765,6765,5185,3003,1300,405,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,455,1430,3603,6364,8442,8442,6364,3603,1430,455,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,486,1560,4032,7778,12290,16792,16792,12290,7778,4032,1560,486,102,18,1]\n        if rowIndex == 19:\n            return [1,19,103,532,1856,4862,10080,18560,24500,28032,24500,18560,10080,4862,1856,532,103,19,1]\n        if rowIndex == 20:\n            return [1,20,104,568,2180,5888,12690,24310,36456,42940,3"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def find_neighbors(word, wordList):\n            neighbors = []\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    if c != word[i]:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            neighbors.append(new_word)\n            return neighbors\n        \n        def find_shortest_path(beginWord, endWord, wordList):\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    return path\n                if word in visited:\n                    continue\n                visited.add(word)\n                for neighbor in find_neighbors(word, wordList):\n                    queue.append((neighbor, path + [neighbor]))\n            return []\n        \n        def find_all_paths(beginWord, endWord, wordList):\n            paths = []\n            queue = [(beginWord, [beginWord])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == endWord:\n                    paths.append(path)\n                    continue\n                if word in visited:\n                    continue\n                visited.add(word)\n                for neighbor in find_neighbors(word, wordList):\n                    queue.append((neighbor, path + [neighbor]))\n            return paths\n        \n        def find_all_paths_recursive(beginWord, endWord, wordList, path):\n            if beginWord == endWord:\n                return [path]\n            paths = []\n            for word in find_neighbors(beginWord, wordList):\n                new_path = path + [word]\n                new_paths = find_all_paths_recursive(word, endWord, wordList, new_path)\n                paths.extend(new_paths)\n            return paths\n        \n        def find_all_paths_recursive_with_memoization(beginWord, endWord, wordList, memo):\n            if beginWord == endWord:\n                return [[]]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            for word in find_neighbors(beginWord, wordList):\n                new_path = [word]\n                new_paths = find_all_paths_recursive_with_memoization(word, endWord, wordList, memo)\n                for path in new_paths:\n                    paths.append(new_path + path)\n            memo[beginWord] = paths\n            return paths\n        \n        def find_all_paths_recursive_with_memoization_with_backtracking(beginWord, endWord, wordList, memo):\n            if beginWord == endWord:\n                return [[]]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            for word in find_neighbors(beginWord, wordList):\n                new_path = [word]\n                new_paths = find_all_paths_recursive_with_memoization_with_backtracking(word, endWord, wordList, memo)\n                for path in new_paths:\n                    paths.append(new_path + path)\n            memo[beginWord] = paths\n            return paths\n        \n        def find_all_paths_recursive_with_memoization_with_backtracking_with_pruning(beginWord, endWord, wordList, memo):\n            if beginWord == endWord:\n                return [[]]\n            if beginWord in memo:\n                return memo[beginWord]\n            paths = []\n            for word in find_neighbors(beginWord, wordList):\n                new_path = [word]\n                new_paths = find_all_paths_recursive_with_memoization_with_backtracking_with_pruning(word, endWord, wordList, memo)\n                for path in new_paths:\n                    paths.append(new_path + path)\n            memo[beginWord] = paths\n            return paths\n        \n        def find_all_paths_recursive_with_memoization_with_back"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        \n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        for rect in rectangles:\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_min and rect[3] == y_min:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_max and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_min and rect[3] == y_min:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_max and rect[3] == y_max:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_max and rect[3] == y_max:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_min and rect[3] == y_min:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_max and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_min and rect[3] == y_min:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_max and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_min and rect[3] == y_max:"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        # 6. convert to base 10\n        # 7. convert to base 26\n        # 8. convert to base 10\n        # 9. convert to base 26\n        # 10. convert to base 10\n        # 11. convert to base 26\n        # 12. convert to base 10\n        # 13. convert to base 26\n        # 14. convert to base 10\n        # 15. convert to base 26\n        # 16. convert to base 10\n        # 17. convert to base 26\n        # 18. convert to base 10\n        # 19. convert to base 26\n        # 20. convert to base 10\n        # 21. convert to base 26\n        # 22. convert to base 10\n        # 23. convert to base 26\n        # 24. convert to base 10\n        # 25. convert to base 26\n        # 26. convert to base 10\n        # 27. convert to base 26\n        # 28. convert to base 10\n        # 29. convert to base 26\n        # 30. convert to base 10\n        # 31. convert to base 26\n        # 32. convert to base 10\n        # 33. convert to base 26\n        # 34. convert to base 10\n        # 35. convert to base 26\n        # 36. convert to base 10\n        # 37. convert to base 26\n        # 38. convert to base 10\n        # 39. convert to base 26\n        # 40. convert to base 10\n        # 41. convert to base 26\n        # 42. convert to base 10\n        # 43. convert to base 26\n        # 44. convert to base 10\n        # 45. convert to base 26\n        # 46. convert to base 10\n        # 47. convert to base 26\n        # 48. convert to base 10\n        # 49. convert to base 26\n        # 50. convert to base 10\n        # 51. convert to base 26\n        # 52. convert to base 10\n        # 53. convert to base 26\n        # 54. convert to base 10\n        # 55. convert to base 26\n        # 56. convert to base 10\n        # 57. convert to base 26\n        # 58. convert to base 10\n        # 59. convert to base 26\n        # 60. convert to base 10\n        # 61. convert to base 26\n        # 62. convert to base 10\n        # 63. convert to base 26\n        # 64. convert to base 10\n        # 65. convert to base 26\n        # 66. convert to base 10\n        # 67. convert to base 26\n        # 68. convert to base 10\n        # 69. convert to base 26\n        # 70. convert to base 10\n        # 71. convert to base 26\n        # 72. convert to base 10\n        # 73. convert to base 26\n        # 74. convert to base 10\n        # 75. convert to base 26\n        # 76. convert to base 10\n        # 77. convert to base 26\n        # 78. convert to base 10\n        # 79. convert to base 26\n        # 80. convert to base 10"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a string\n        board_str = \"\"\n        for row in board:\n            for num in row:\n                board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        if m == 1 and n == 1:\n            return 1\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        def count(root):\n            if not root:\n                return []\n            left = count(root.left)\n            right = count(root.right)\n            if root.val in left:\n                return [root.val] + left\n            elif root.val in right:\n                return [root.val] + right\n            else:\n                return [root.val] + left + right\n        \n        return count(root)"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the length of password\n        # 3. check the length of password\n        # 4. check the length of password\n        # 5. check the length of password\n        # 6. check the length of password\n        # 7. check the length of password\n        # 8. check the length of password\n        # 9. check the length of password\n        # 10. check the length of password\n        # 11. check the length of password\n        # 12. check the length of password\n        # 13. check the length of password\n        # 14. check the length of password\n        # 15. check the length of password\n        # 16. check the length of password\n        # 17. check the length of password\n        # 18. check the length of password\n        # 19. check the length of password\n        # 20. check the length of password\n        # 21. check the length of password\n        # 22. check the length of password\n        # 23. check the length of password\n        # 24. check the length of password\n        # 25. check the length of password\n        # 26. check the length of password\n        # 27. check the length of password\n        # 28. check the length of password\n        # 29. check the length of password\n        # 30. check the length of password\n        # 31. check the length of password\n        # 32. check the length of password\n        # 33. check the length of password\n        # 34. check the length of password\n        # 35. check the length of password\n        # 36. check the length of password\n        # 37. check the length of password\n        # 38. check the length of password\n        # 39. check the length of password\n        # 40. check the length of password\n        # 41. check the length of password\n        # 42. check the length of password\n        # 43. check the length of password\n        # 44. check the length of password\n        # 45. check the length of password\n        # 46. check the length of password\n        # 47. check the length of password\n        # 48. check the length of password\n        # 49. check the length of password\n        # 50. check the length of password\n        # 51. check the length of password\n        # 52. check the length of password\n        # 53. check the length of password\n        # 54. check the length of password\n        # 55. check the length of password\n        # 56. check the length of password\n        # 57. check the length of password\n        # 58. check the length of password\n        # 59. check the length of password\n        # 60. check the length of password\n        # 61. check the length of password\n        # 62. check the length of password\n        # 63. check the length of password\n        # 64. check the length of password\n        # 65. check the length of password\n        # 66. check the length of password\n        # 67. check the length of password\n        # 68. check the length of password\n        # 69. check the length of password\n        # 70. check the length of password\n        # 71. check the length of password\n        # 72. check the length of password\n        # 73. check the length of password\n        # 74. check the length of password\n        # 75. check the length of password\n        # 76. check the length of password\n        # 77. check the length of password\n        # 78. check the length of password\n        # 79. check the length of password\n        # 80. check the length of password\n        # 81. check the length of password\n        # 82. check the length of password\n        # 83. check the length of password\n        # 84. check the length of password\n        # 85. check the length of password\n        # 86. check the length of password"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        i = 0\n        down = True\n        for c in s:\n            res[i] += c\n            if i == numRows - 1:\n                down = False\n            elif i == 0:\n                down = True\n            if down:\n                i += 1\n            else:\n                i -= 1\n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 2022-09-22\n        ## 1. find the max height\n        ## 2. find the left max height\n        ## 3. find the right max height\n        ## 4. find the water\n        ## 5. update the left max height\n        ## 6. update the right max height\n        ## 7. repeat 4, 5\n        ## 8. return the water\n        \n        ## 20"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            \n            return result\n        \n        return [x[1] for x in mergeSort([(num, i) for i, num in en.umerate(nums)])]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max and min\n        max_num = -1\n        min_num = 10**9\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # update the max and min\n            max_num = max(max_num, interval[1])\n            min_num = min(min_num, interval[0])\n            \n            # update the result\n            res += (interval[1] - interval[0] + 1)\n            \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n            \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # iterate\n        while i < len(nums)-1:\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                if nums[i-1] < nums[i]:\n                    n = n - nums[i-1]\n                    count += 1\n                else:\n                    n = n - nums[i]\n                    count += 1\n            if n < 0:\n                break\n        return count"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 2. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 3. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 4. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 5. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 6. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 7. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 8. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 9. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 10. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 11. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 12. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 13. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\uc9c0 \uc54a\uc740 \uacbd\uc6b0"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        decimal_string = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            \n            if remainder in remainder_dict:\n                decimal_string = \"(\" + decimal_string + \")\"\n                break\n            \n            remainder_dict[remainder] = len(remainder_dict)\n            decimal_string += str(quotient)\n            \n        return str(sign * quotient) + \".\" + decimal_string"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width\n        envelopes.sort(key=lambda x: x[0])\n        \n        # find the longest increasing subsequence\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row_zero = False\n        col_zero = False\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    if i == 0:\n                        row_zero = True\n                    if j == 0:\n                        col_zero = True\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if row_zero:\n            for j in range(n):\n                matrix[0][j] = 0\n        \n        if col_zero:\n            for i in range(m):\n                matrix[i][0] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 12:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 13:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 14:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 15:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 16:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 17:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 18:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 19:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 20:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 21:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 22:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 23:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 24:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 25:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 26:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 27:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        ## Runtime: 124 ms, faster than 99.44% of Python online submissions for Intersection of Two Arrays.\n        ## Memory Usage: 14.1 MB, less than 99.44% of Python online submissions for Intersection of Two Arrays.\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25\n        ## 2022-09-25"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not machines:\n            return 0\n        \n        n = len(machines)\n        total = sum(machines)\n        if total % n:\n            return -1\n        \n        avg = total / n\n        curr = 0\n        ans = 0\n        for i in range(n):\n            curr += machines[i] - avg\n            ans = max(ans, abs(curr))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        max_area = 0\n        for i in range(n):\n            height = [0] * m\n            for j in range(m):\n                if matrix[j][i] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        for i in range(m):\n            height = [0] * n\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            height = [0] * n\n            for j in range(n-1, -1, -1):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for j in range(n):\n            height = [0] * m\n            for i in range(m-1, -1, -1):\n                if matrix[i][j] == '1':\n                    height[i] += 1\n                else:\n                    height[i] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        return max_area\n    \n    def largestRectangleArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n        \n        stack = []\n        max_area = 0\n        for i in range(len(height)):\n            while stack and height[i] <= height[stack[-1]]:\n                h = height[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = height[stack.pop()]\n            w = len(height) if not stack else len(height) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 5. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 6. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 7. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 8. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 9. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 10. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 11. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 12. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 13. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 14. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Inorder traversal\n        # Find the first node where the value is greater than the previous node\n        # Find the second node where the value is greater than the first node\n        # Swap the values of the two nodes\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        if num < 1:\n            return False\n        \n        for i in range(1, num):\n            if i * i == num:\n                return True\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, board, word, visited, res):\n            if len(word) == 0:\n                res.append(word)\n                return\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return\n            visited[i][j] = True\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                dfs(x, y, board, word+board[x][y], visited, res)\n            visited[i][j] = False\n        \n        res = []\n        visited = [[False] * len(board[0]) for _ in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        dfs(i, j, board, word, visited, res)\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n            \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n            \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                box = [board[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n                if len(set(box)) != len(box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert the string to a list\n        ## 2. reverse the list\n        ## 3. iterate through the list\n        ## 4. multiply the number by 26^(index)\n        ## 5. add the number to the total\n        ## 6. return the total\n        \n        ## 1. convert the string to a list\n        columnTitle = list(columnTitle)\n        \n        ## 2. reverse the list\n        columnTitle.reverse()\n        \n        ## 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle)):\n            \n            ## 4. multiply the number by 26^(index)\n            total += (26**i) * (ord(columnTitle[i]) - 64)\n            \n        ## 5. return the total\n        return total"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        # connect the first half back to the second half\n        first.next = second\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the length of pattern and words are equal\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # check if the pattern and word are already mapped\n            if pattern[i] in mapping:\n                # check if the pattern and word are mapped to the same word\n                if mapping[pattern[i]] != words[i]:\n                    return False\n            # check if the pattern and word are not already mapped\n            else:\n                # check if the word is already mapped to a different pattern\n                if words[i] in mapping.values():\n                    return False\n                # map the pattern and word\n                mapping[pattern[i]] = words[i]\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if matrix[i][j] == target:\n                        return True\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a new list node\n        head = ListNode()\n        # create a pointer to the new list node\n        ptr = head\n        # create a carry variable\n        carry = 0\n        # loop until both lists are empty\n        while l1 or l2:\n            # if both lists are empty, set the value to 0\n            if not l1 and not l2:\n                val = 0\n            # if only l1 is empty, set the value to l2.val\n            elif not l1:\n                val = l2.val\n            # if only l2 is empty, set the value to l1.val\n            elif not l2:\n                val = l1.val\n            # if both lists are not empty, add the values of l1 and l2\n            else:\n                val = l1.val + l2.val\n            # add the carry to the value\n            val += carry\n            # if the value is greater than 10, set the carry to 1\n            if val >= 10:\n                carry = 1\n            # set the value to the remainder of the value divided by 10\n            else:\n                carry = 0\n            # create a new list node with the value\n            ptr.next = ListNode(val % 10)\n            # move the pointer to the next node\n            ptr = ptr.next\n            # move the lists to the next node\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        # if the carry is still 1, create a new list node with the value 1\n        if carry == 1:\n            ptr.next = ListNode(1)\n        # return the new list node\n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        ## reverse the binary\n        binary = binary[::-1]\n        ## convert to decimal\n        decimal = int(binary, 2)\n        ## return the complement\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third max\n        # 3. if the third max is not in the list, return the last element\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}