{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = 0 if s"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Iterate through the array and check if the current number is positive and not in the range [1, len(nums)]\n        # 3. If the current number is positive and not in the range [1, len(nums)], return the current number\n        # 4. If the current number is positive and in the range [1, len(nums)], swap the current number with the number at the index of the current number - 1\n        # 5. Repeat step 4 until the array is sorted\n        # 6. If the last number is positive, return len(nums) + 1\n        # 7. If the last number is not positive, return 1\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Iterate through the array and check if the current number is positive and not in the range [1, len(nums)]\n        # 3. If the current number is positive and not in the range [1, len(nums)], return the current number\n        # 4. If the current number is positive and in the range [1, len(nums)], swap the current number with the number at the index of the current number - 1\n        # 5. Repeat step 4 until the array is sorted\n        # 6. If the last number is positive, return len(nums) + 1\n        # 7. If the last number is not positive, return 1\n        \n        # 2. Iterate through the array and check if the current number is positive and not in the range [1, len(nums)]\n        # 3. If the current number is positive and not in the range [1, len(nums)], return the current number\n        # 4. If the current number is positive and in the range [1, len(nums)], swap the current number with the number at the index of the current number - 1\n        # 5. Repeat step 4 until the array is sorted\n        # 6. If the last number is positive, return len(nums) + 1\n        # 7. If the last number is not positive, return 1\n        \n        # 2. Iterate through the array and check if the current number is positive and not in the range [1, len(nums)]\n        # 3. If the current number is positive and not in the range [1, len(nums)], return the current number\n        # 4. If the current number is positive and in the range [1, len(nums)], swap the current number with the number at the index of the current number - 1\n        # 5. Repeat step 4 until the array is sorted\n        # 6. If the last number is positive, return len(nums) + 1\n        # 7. If the last number is not positive, return 1\n        \n        # 2. Iterate through the array and check if the current number is positive and not in the range [1, len(nums)]\n        # 3. If the current number is positive and not in the range [1, len(nums)], return the current number\n        # 4. If the current number is positive and in the range [1, len(nums)], swap the current number with the number at the index of the current number - 1\n        # 5. Repeat step 4 until the array is sorted\n        # 6. If the last number is positive, return len(nums) + 1\n        # 7. If the last number is not positive, return 1\n        \n        # 2. Iterate through the array and check if the current number is positive and not in the range [1, len(nums)]\n        # 3. If the current number is positive and not in the range [1, len(nums)], return the current number\n        # 4. If the current number is positive and in the range [1, len(nums)], swap the current number with the number at the index of the current number - 1\n        # 5. Repeat step 4 until the array is sorted\n        # 6. If the last number is positive, return len(nums) + 1\n        # 7. If the last number is not positive, return 1\n        \n        # 2. Iterate through the array and check if the current number is positive and not in the range [1, len(nums)]\n        # 3."}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1,2,3,4,5,6,7,8,9\n        # 2. 1,2,3,4,5,6,7,8,9\n        # 3. 1,2,3,4,5,6,7,8,9\n        # 4. 1,2,3,4,5,6,7,8,9\n        # 5. 1,2,3,4,5,6,7,8,9\n        # 6. 1,2,3,4,5,6,7,8,9\n        # 7. 1,2,3,4,5,6,7,8,9\n        # 8. 1,2,3,4,5,6,7,8,9\n        # 9. 1,2,3,4,5,6,7,8,9\n        # 10. 1,2,3,4,5,6,7,8,9\n        # 11. 1,2,3,4,5,6,7,8,9\n        # 12. 1,2,3,4,5,6,7,8,9\n        # 13. 1,2,3,4,5,6,7,8,9\n        # 14. 1,2,3,4,5,6,7,8,9\n        # 15. 1,2,3,4,5,6,7,8,9\n        # 16. 1,2,3,4,5,6,7,8,9\n        # 17. 1,2,3,4,5,6,7,8,9\n        # 18. 1,2,3,4,5,6,7,8,9\n        # 19. 1,2,3,4,5,6,7,8,9\n        # 20. 1,2,3,4,5,6,7,8,9\n        # 21. 1,2,3,4,5,6,7,8,9\n        # 22. 1,2,3,4,5,6,7,8,9\n        # 23. 1,2,3,4,5,6,7,8,9\n        # 24. 1,2,3,4,5,6,7,8,9\n        # 25. 1,2,3,4,5,6,7,8,9\n        # 26. 1,2,3,4,5,6,7,8,9\n        # 27. 1,2,3,4,5,6,7,8,9\n        # 28. 1,2,3,4,5,6,7,8,9\n        # 29. 1,2,3,4,5,6,7,8,9\n        # 30. 1,2,3,4,5,6,7,8,9\n        # 31. 1,2,3,4,5,6,7,8,9\n        # 32. 1,2,3,4,5,6,7,8,9\n        # 33. 1,2,3,4,5,6,7,8,9\n        # 34. 1,2,3,4,5,6,7,8,9\n        # 35. 1,2,3,4,5,6,7,8,9\n        # 36. 1,2,3,4,5,6,7,8,9\n        # 37. 1,2,3,4,5,6,7,8,9\n        # 38. 1,2,3,4,5,6,7,8,9\n        # 39. 1,2,3,4,5,6,7,8,9\n        # 40. 1,2,3,4,5,6,7,8,9\n        # 41. 1,2,3,4,5,6,7,8,9\n        # 42. 1"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\ud55c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        # 2. \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc774\uae30 \uc704\ud574 \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 3. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc5f0\uacb0\ub41c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 4. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc5f0\uacb0\ub41c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        \n        # 1. \uc815\ub82c\ud55c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        # 2. \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc774\uae30 \uc704\ud574 \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 3. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc5f0\uacb0\ub41c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 4. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc5f0\uacb0\ub41c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        \n        # 1. \uc815\ub82c\ud55c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        # 2. \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc774\uae30 \uc704\ud574 \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 3. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc5f0\uacb0\ub41c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud55c\ub2e4.\n        # 4. \uc2dc\uc791\uc810\uacfc \ub05d\uc810\uc774 \uc5f0\uacb0\ub41c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        \n        # 1. \uc815\ub82c\ud55c \ubc30\uc5f4\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc778\ub2e4.\n        # 2. \uc2dc\uac04 \ubcf5\uc7a1\ub3c4\ub97c \uc904\uc774\uae30 \uc704\ud574 \uc2dc\uc791\uc810\uacfc \ub05d\ufffd"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            \n            if i == 0:\n                backtrack(i+1, curr, prev, res, op)\n            else:\n                backtrack(i+1, curr + int(num[i]), int(num[i]), res, op + \"+\" + num[i])\n                backtrack(i+1, curr - int(num[i]), -int(num[i]), res, op + \"-\" + num[i])\n                if prev != 0:\n                    backtrack(i+1, curr - prev + prev*int(num[i]), prev*int(num[i]), res, op + \"*\" + num[i])\n        \n        res = []\n        backtrack(0, 0, 0, res, \"\")\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr*10 + root.val\n            return dfs(root.left, curr*10 + root.val) + dfs(root.right, curr*10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        res = []\n        i = n - 1\n        while i >= 0:\n            if len(res) % (k + 1) == 0:\n                res.append('-')\n            res.append(s[i])\n            i -= 1\n        return ''.join(res[::-1])"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the total gas and cost\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        ## 2. If total gas is less than total cost, return -1\n        if total_gas < total_cost:\n            return -1\n        \n        ## 3. Find the starting point\n        start = 0\n        curr_gas = 0\n        \n        for i in range(len(gas)):\n            curr_gas += gas[i] - cost[i]\n            if curr_gas < 0:\n                start = i + 1\n                curr_gas = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Convert the list to a number\n        number = int(''.join(map(str, digits)))\n        \n        # 2. Increment the number by 1\n        number += 1\n        \n        # 3. Convert the number back to a list\n        return list(map(int, str(number)))"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return s and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] != '*':\n            if s and (s[0] == p[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p[1:])\n            else:\n                return False\n        else:\n            while s and (s[0] == p[0] or p[0] == '.'):\n                if self.isMatch(s, p[2:]):\n                    return True\n                s = s[1:]\n            return self.isMatch(s, p[2:])\n        \n        return False"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            # \u4ecenums\u4e2d\u6311\u9009\u51fak\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709k\u4e2a\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[m][n-1] = dp[m-1][n] = 1\n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j],1)\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a','e','i','o','u','A','E','I','O','U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list)-1\n        while left < right:\n            if s_list[left] in vowels and s_list[right] in vowels:\n                s_list[left],s_list[right] = s_list[right],s_list[left]\n                left += 1\n                right -= 1\n            elif s_list[left] not in vowels:\n                left += 1\n            elif s_list[right] not in vowels:\n                right -= 1\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 2. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 3. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 4. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 5. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 6. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 7. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 8. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 9. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 10. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 11. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 12. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 13. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 14. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 15. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 16. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 17. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 18. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 19. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 20. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 21. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 22. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 23. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 24. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 25. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 26. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 27. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 28. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 29. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 30. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 31. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 32. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 33. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 34. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 35. We can use the sum of the numbers from 0 to n to get the sum of the array\n        ## 36. We can"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Create a set of words from the wordList\n        wordSet = set(wordList)\n        \n        # Create a queue and add the beginWord\n        queue = collections.deque([beginWord])\n        \n        # Create a set to keep track of visited words\n        visited = set()\n        \n        # Create a variable to keep track of the number of transformations\n        transformations = 0\n        \n        # While the queue is not empty\n        while queue:\n            # Increment the number of transformations\n            transformations += 1\n            \n            # Get the number of elements in the queue\n            size = len(queue)\n            \n            # Iterate over the queue\n            for _ in range(size):\n                # Pop the first element from the queue\n                word = queue.popleft()\n                \n                # If the word is the endWord, return the number of transformations\n                if word == endWord:\n                    return transformations\n                \n                # Add the word to the visited set\n                visited.add(word)\n                \n                # Iterate over the word\n                for i in range(len(word)):\n                    # Generate all possible words by swapping the ith letter\n                    for letter in string.ascii_lowercase:\n                        # If the word is not in the set, continue\n                        if word[i] != letter:\n                            newWord = word[:i] + letter + word[i+1:]\n                            # If the new word is in the set, add it to the queue\n                            if newWord in wordSet:\n                                queue.append(newWord)\n                                # Remove the new word from the set\n                                wordSet.remove(newWord)\n        \n        # If the endWord is not in the set, return 0\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == '1' and b[i] == '1':\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n                        carry = 1\n                elif a[i] == '1' or b[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n            else:\n                if a[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n        \n        if carry == 1:\n            res.append('1')\n        \n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] < target or (left and nums[mid] == target):\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False) - 1\n        \n        if left_index == len(nums) or nums[left_index] != target:\n            return [-1, -1]\n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(0,len(prices)-1)) for i in range(0,len(prices)-1,2))\n        \n        dp = [[0]*k for i in range(len(prices))]\n        \n        for i in range(1,len(prices)):\n            for j in range(k):\n                if j == 0:\n                    dp[i][j] = max(dp[i-1][j],prices[i]-prices[i-1])\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]+prices[i]-prices[i-1])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Create a hashmap to store the frequency of each character in the string\n        # 2. Iterate through the string and for each character, check if it is in the hashmap\n        # 3. If it is, increment the frequency by 1\n        # 4. If it is not, add it to the hashmap with a frequency of 1\n        # 5. Iterate through the string again and return the index of the first character with a frequency of 1\n        # 6. If no character with a frequency of 1 is found, return -1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a hashmap to store the frequency of each character in the string\n        freq = {}\n        \n        # Iterate through the string and for each character, check if it is in the hashmap\n        for char in s:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n        \n        # Iterate through the string again and return the index of the first character with a frequency of 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # If no character with a frequency of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlog(n))\n        # Space Complexity: O(n)\n        \n        # Sort the array\n        nums.sort()\n        \n        # Iterate through the array\n        for i in range(len(nums)-1):\n            # Check if the difference between the current and next element is less than or equal to indexDiff\n            if abs(nums[i] - nums[i+1]) <= valueDiff:\n                # Return True if the difference is less than or equal to indexDiff\n                return True\n        \n        # Return False if the difference is greater than indexDiff\n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        # 3 -> left\n        # 4 -> right\n        # 5 -> left\n        # 6 -> right\n        # 7 -> left\n        # 8 -> right\n        # 9 -> left\n        # 10 -> right\n        # 11 -> left\n        # 12 -> right\n        # 13 -> left\n        # 14 -> right\n        # 15 -> left\n        # 16 -> right\n        # 17 -> left\n        # 18 -> right\n        # 19 -> left\n        # 20 -> right\n        # 21 -> left\n        # 22 -> right\n        # 23 -> left\n        # 24 -> right\n        # 25 -> left\n        # 26 -> right\n        # 27 -> left\n        # 28 -> right\n        # 29 -> left\n        # 30 -> right\n        # 31 -> left\n        # 32 -> right\n        # 33 -> left\n        # 34 -> right\n        # 35 -> left\n        # 36 -> right\n        # 37 -> left\n        # 38 -> right\n        # 39 -> left\n        # 40 -> right\n        # 41 -> left\n        # 42 -> right\n        # 43 -> left\n        # 44 -> right\n        # 45 -> left\n        # 46 -> right\n        # 47 -> left\n        # 48 -> right\n        # 49 -> left\n        # 50 -> right\n        # 51 -> left\n        # 52 -> right\n        # 53 -> left\n        # 54 -> right\n        # 55 -> left\n        # 56 -> right\n        # 57 -> left\n        # 58 -> right\n        # 59 -> left\n        # 60 -> right\n        # 61 -> left\n        # 62 -> right\n        # 63 -> left\n        # 64 -> right\n        # 65 -> left\n        # 66 -> right\n        # 67 -> left\n        # 68 -> right\n        # 69 -> left\n        # 70 -> right\n        # 71 -> left\n        # 72 -> right\n        # 73 -> left\n        # 74 -> right\n        # 75 -> left\n        # 76 -> right\n        # 77 -> left\n        # 78 -> right\n        # 79 -> left\n        # 80 -> right\n        # 81 -> left\n        # 82 -> right\n        # 83 -> left\n        # 84 -> right\n        # 85 -> left\n        # 86 -> right\n        # 87 -> left\n        # 88 -> right\n        # 89 -> left\n        # 90 -> right\n        # 91 -> left\n        # 92 -> right\n        # 93 -> left\n        # 94 -> right\n        # 95 -> left\n        # 96 -> right\n        # 97 -> left\n        # 98 -> right\n        # 99 -> left\n        # 100 -> right\n        # 101 -> left\n        # 102 -> right\n        # 103 -> left\n        # 104 -> right\n        # 105 -> left\n        # 106 -> right\n        # 107 -> left\n        # 108 -> right\n        # 109 -> left\n        # 110 -> right\n        # 111 -> left\n        # 112 -> right\n        # 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = \"\"\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res += str(carry % 10)\n            carry //= 10\n            i += 1\n        return res[::-1]"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                num = 0\n                sign = s[i]\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] == 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0,"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the index of the first number that is smaller than its next number\n        # if no such number exists, the array is sorted in descending order, so we need to reverse the array\n        # if the array is already sorted in descending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the next permutation is the last permutation\n        # if the array is sorted in ascending order, the next permutation is the first permutation\n        # if the array is sorted in ascending order, the"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Hashmap stores the value of the number and its index\n        # If the value of the number is already in the hashmap, then we check if the index of the number is within the range of k\n        # If it is, then we return True\n        # If it is not, then we add the number to the hashmap\n        # If the number is not in the hashmap, then we add the number to the hashmap\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if abs(hashmap[nums[i]] - i) <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i-1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples = [couple for couple in couples if couple[1] % 2 == 0]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 == 1]\n        couples.sort()\n        couples"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            \n            for letter in word:\n                if letter not in row:\n                    break\n            else:\n                res.append(word)\n        \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        tail = curr\n        while count < right:\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n            count += 1\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. If the concatenated string is a palindrome, return it\n        # 5. Otherwise, return the reversed substring\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_count = {}\n        for c in t:\n            t_count[c] = t_count.get(c, 0) + 1\n        \n        s_count = {}\n        for c in s:\n            s_count[c] = s_count.get(c, 0) + 1\n        \n        if t_count == s_count:\n            return t\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        while right < len(s):\n            c = s[right]\n            if c in t_count:\n                if s_count[c] < t_count[c]:\n                    s_count[c] += 1\n                else:\n                    s_count[c] += 1\n                    while s_count[c] > t_count[c]:\n                        s_count[s[left]] -= 1\n                        left += 1\n            right += 1\n        \n        if min_len > right - left:\n            min_len = right - left\n            min_left = left\n            min_right = right\n        \n        while right < len(s):\n            c = s[right]\n            if c in t_count:\n                if s_count[c] < t_count[c]:\n                    s_count[c] += 1\n                else:\n                    s_count[c] += 1\n                    while s_count[c] > t_count[c]:\n                        s_count[s[left]] -= 1\n                        left += 1\n            right += 1\n            \n            if right - left < min_len:\n                min_len = right - left\n                min_left = left\n                min_right = right\n            \n            if min_len == 1:\n                break\n        \n        return s[min_left:min_right]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] == distance[i+2] and distance[i+1] == distance[i+3] and distance[i+4] == distance[i+2]:\n                return True\n            if i >= 4 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] == distance[i+3]:\n                return True\n            if i >= 5 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] + distance[i+3] >= distance[i+5] and distance[i+1] == distance[i+3]:\n                return True\n            if i >= 6 and distance[i] + distance[i+2] >= distance[i+4] and distance[i+1] + distance[i+3] >= distance[i+5] and distance[i+1] + distance[i+3] >= distance[i+6] and distance[i+2] + distance[i+4] >= distance[i+6]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\n        # 2. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0 \ucd94\uac00\n        # 3. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud558\ub294 \ub515\uc154\ub108\ub9ac\uc5d0\uc11c \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    x, y = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] and (nx, ny) not in visited:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = []\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j]:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        start = (0, 0)\n        steps = 0\n        for height, x, y in trees:\n            steps += dfs(start, (x, y))\n            if steps < 0:\n                return -1\n            start = (x, y)\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc811\uadfc \ubc29\ubc95\n        # 2. \uc811\uadfc \ubc29\ubc95\n        # 3. \uc811\uadfc \ubc29\ubc95\n        # 4. \uc811\uadfc \ubc29\ubc95\n        # 5. \uc811\uadfc \ubc29\ubc95\n        # 6. \uc811\uadfc \ubc29\ubc95\n        # 7. \uc811\uadfc \ubc29\ubc95\n        # 8. \uc811\uadfc \ubc29\ubc95\n        # 9. \uc811\uadfc \ubc29\ubc95\n        # 10. \uc811\uadfc \ubc29\ubc95\n        # 11. \uc811\uadfc \ubc29\ubc95\n        # 12. \uc811\uadfc \ubc29\ubc95\n        # 13. \uc811\uadfc \ubc29\ubc95\n        # 14. \uc811\uadfc \ubc29\ubc95\n        # 15. \uc811\uadfc \ubc29\ubc95\n        # 16. \uc811\uadfc \ubc29\ubc95\n        # 17. \uc811\uadfc \ubc29\ubc95\n        # 18. \uc811\uadfc \ubc29\ubc95\n        # 19. \uc811\uadfc \ubc29\ubc95\n        # 20. \uc811\uadfc \ubc29\ubc95\n        # 21. \uc811\uadfc \ubc29\ubc95\n        # 22. \uc811\uadfc \ubc29\ubc95\n        # 23. \uc811\uadfc \ubc29\ubc95\n        # 24. \uc811\uadfc \ubc29\ubc95\n        # 25. \uc811\uadfc \ubc29\ubc95\n        # 26. \uc811\uadfc \ubc29\ubc95\n        # 27. \uc811\uadfc \ubc29\ubc95\n        # 28. \uc811\uadfc \ubc29\ubc95\n        # 29. \uc811\uadfc \ubc29\ubc95\n        # 30. \uc811\uadfc \ubc29\ubc95\n        # 31. \uc811\uadfc \ubc29\ubc95\n        # 32. \uc811\uadfc \ubc29\ubc95\n        # 33. \uc811\uadfc \ubc29\ubc95\n        # 34. \uc811\uadfc \ubc29\ubc95\n        # 35. \uc811\uadfc \ubc29\ubc95\n        # 36. \uc811\uadfc \ubc29\ubc95\n        # 37. \uc811\uadfc \ubc29\ubc95\n        # 38. \uc811\uadfc \ubc29\ubc95\n        # 39. \uc811\uadfc \ubc29\ubc95\n        # 40. \uc811\uadfc \ubc29\ubc95\n        # 41. \uc811\uadfc \ubc29\ubc95\n        # 42. \uc811\uadfc \ubc29\ubc95\n        # 43. \uc811\uadfc \ubc29\ubc95\n        # 44. \uc811\uadfc \ubc29\ubc95\n        # 45. \uc811\uadfc \ubc29\ubc95\n        # 46. \uc811\uadfc \ubc29\ubc95\n        # 47. \uc811\uadfc \ubc29\ubc95\n        # 48. \uc811\uadfc \ubc29\ubc95\n        # 49. \uc811\uadfc \ubc29\ubc95\n        # 5"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 2:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 3:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 4:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 5:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 6:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 7:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 8:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 9:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 10:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 11:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 12:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 13:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 14:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 15:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 16:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 17:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 18:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 19:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 20:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 21:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 22:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 23:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 24:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 25:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 26:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 27:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 28:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 29:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 30:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 31:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 32:"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            queue = temp\n            result.append(temp)\n        \n        return result[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        temp = x\n        \n        while temp > 0:\n            rev = rev * 10 + temp % 10\n            temp = temp // 10\n        \n        return rev == x"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        for i in range(1,n):\n            res.append(res[i]+2**i)\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False otherwise\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return isValidBSTUtil(root.left, min_val, root.val) and isValidBSTUtil(root.right, root.val, max_val)\n        \n        return isValidBSTUtil(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if intervals is empty\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is empty\n        if not newInterval:\n            return intervals\n        \n        # if newInterval is not overlapping with any interval\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if newInterval is overlapping with last interval\n        if newInterval[0] <= intervals[-1][1]:\n            intervals[-1][1] = max(newInterval[1], intervals[-1][1])\n            return intervals\n        \n        # if newInterval is overlapping with any interval\n        i = 0\n        while i < len(intervals):\n            if newInterval[0] <= intervals[i][1]:\n                intervals[i][0] = min(newInterval[0], intervals[i][0])\n                intervals[i][1] = max(newInterval[1], intervals[i][1])\n                break\n            i += 1\n        \n        # if newInterval is not overlapping with any interval\n        if i == len(intervals):\n            intervals.append(newInterval)\n        \n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, start, path, res):\n            if start == len(s):\n                res.append(path[:])\n                return\n            \n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i+1]):\n                    path.append(s[start:i+1])\n                    backtrack(s, i+1, path, res)\n                    path.pop()\n        \n        res = []\n        backtrack(s, 0, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val = float('inf')\n        max_val = float('-inf')\n        \n        # 2. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 11. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0\n        \n        # 12. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_idx = 0\n        max_val_idx = 0"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # BFS\n        q = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        while q:\n            curr_time, x, y = q.pop(0)\n            res = max(res, curr_time)\n            if x == n - 1 and y == n - 1:\n                return res\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if nx < 0 or nx >= n or ny < 0 or ny >= n or (nx, ny) in visited:\n                    continue\n                visited.add((nx, ny))\n                q.append((grid[nx][ny], nx, ny))\n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i == 0 and j == 0:\n        #             continue\n        #         if i == 0:\n        #             dp[i][j] = dp[i][j - 1]\n        #         elif j == 0:\n        #             dp[i][j] = dp[i - 1][j]\n        #         else:\n        #             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        # return dp[-1][-1]\n        \n        # 2. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 3. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 4. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 5. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 6. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 7. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 8. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 9. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 10. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 11. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # 12. 1D DP\n        # dp = [1] * n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j - 1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 2 pointer approach\n        # 3. 2 pointer approach\n        # 4. 2 pointer approach\n        # 5. 2 pointer approach\n        # 6. 2 pointer approach\n        # 7. 2 pointer approach\n        # 8. 2 pointer approach\n        # 9. 2 pointer approach\n        # 10. 2 pointer approach\n        # 11. 2 pointer approach\n        # 12. 2 pointer approach\n        # 13. 2 pointer approach\n        # 14. 2 pointer approach\n        # 15. 2 pointer approach\n        # 16. 2 pointer approach\n        # 17. 2 pointer approach\n        # 18. 2 pointer approach\n        # 19. 2 pointer approach\n        # 20. 2 pointer approach\n        # 21. 2 pointer approach\n        # 22. 2 pointer approach\n        # 23. 2 pointer approach\n        # 24. 2 pointer approach\n        # 25. 2 pointer approach\n        # 26. 2 pointer approach\n        # 27. 2 pointer approach\n        # 28. 2 pointer approach\n        # 29. 2 pointer approach\n        # 30. 2 pointer approach\n        # 31. 2 pointer approach\n        # 32. 2 pointer approach\n        # 33. 2 pointer approach\n        # 34. 2 pointer approach\n        # 35. 2 pointer approach\n        # 36. 2 pointer approach\n        # 37. 2 pointer approach\n        # 38. 2 pointer approach\n        # 39. 2 pointer approach\n        # 40. 2 pointer approach\n        # 41. 2 pointer approach\n        # 42. 2 pointer approach\n        # 43. 2 pointer approach\n        # 44. 2 pointer approach\n        # 45. 2 pointer approach\n        # 46. 2 pointer approach\n        # 47. 2 pointer approach\n        # 48. 2 pointer approach\n        # 49. 2 pointer approach\n        # 50. 2 pointer approach\n        # 51. 2 pointer approach\n        # 52. 2 pointer approach\n        # 53. 2 pointer approach\n        # 54. 2 pointer approach\n        # 55. 2 pointer approach\n        # 56. 2 pointer approach\n        # 57. 2 pointer approach\n        # 58. 2 pointer approach\n        # 59. 2 pointer approach\n        # 60. 2 pointer approach\n        # 61. 2 pointer approach\n        # 62. 2 pointer approach\n        # 63. 2 pointer approach\n        # 64. 2 pointer approach\n        # 65. 2 pointer approach\n        # 66. 2 pointer approach\n        # 67. 2 pointer approach\n        # 68. 2 pointer approach\n        # 69. 2 pointer approach\n        # 70. 2 pointer approach\n        # 71. 2 pointer approach\n        # 72. 2 pointer approach\n        # 73. 2 pointer approach\n        # 74. 2 pointer approach\n        # 75. 2 pointer approach\n        # 76. 2 pointer approach\n        # 77. 2 pointer approach\n        # 78. 2 pointer approach\n        # 79. 2 pointer approach\n        # 80. 2 pointer approach\n        # 81. 2 pointer approach\n        # 82. 2 pointer approach\n        # 83. 2 pointer approach\n        # 84. 2 pointer approach\n        # 85. 2 pointer approach\n        # 86. 2 pointer approach\n        # 87. 2 pointer approach\n        # 88. 2 pointer approach\n        # 89. 2 pointer approach\n        # 90. 2 pointer approach\n        # 91. 2 pointer approach\n        # 92. 2 pointer approach\n        # 93. 2 pointer approach\n        # 94. 2 pointer approach"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            while curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            result.append(curr.val)\n            curr = curr.right\n        \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        left = 0\n        right = len(s) - 1\n        while left < right and s[left] == '(':\n            left += 1\n        while right > left and s[right] == ')':\n            right -= 1\n        \n        res = []\n        while left <= right:\n            if isValid(s[left:right+1]):\n                res.append(s[left:right+1])\n            if s[left] == '(':\n                left += 1\n            else:\n                right -= 1\n        \n        return res"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Time Complexity: O(nlogk)\n        # Space Complexity: O(1)\n        \n        # Edge Case:\n        if not lists:\n            return None\n        \n        # Initialize the head of the merged list\n        head = ListNode()\n        curr = head\n        \n        # Loop through the lists and merge them\n        for l in lists:\n            if l:\n                curr.next = l\n                curr = curr.next\n        \n        # Sort the merged list\n        head = head.next\n        curr = head\n        while curr.next:\n            curr = curr.next\n            curr.next, curr.next.next, curr.next.next.next = curr.next.next, curr.next.next.next, None\n        \n        return head"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeroes(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 10**10\n        while left < right:\n            mid = (left + right) // 2\n            if count_zeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary with the words as keys and their indices as values\n        word_dict = {word: i for i, word in enumerate(words)}\n        \n        # Create a list to store the palindrome pairs\n        palindrome_pairs = []\n        \n        # Iterate through the words in the dictionary\n        for word, index in word_dict.items():\n            # Check if the word is a palindrome\n            if word == word[::-1]:\n                # If it is, add it to the list of palindrome pairs\n                palindrome_pairs.append([index, index])\n            \n            # Check if the word is a palindrome\n            for i in range(len(word)):\n                # Check if the substring of the word is a palindrome\n                if word[i:] == word[i:][::-1]:\n                    # If it is, add it to the list of palindrome pairs\n                    palindrome_pairs.append([index, word_dict[word[i:]]])\n            \n            # Check if the word is a palindrome\n            for i in range(len(word)):\n                # Check if the substring of the word is a palindrome\n                if word[:i] == word[:i][::-1]:\n                    # If it is, add it to the list of palindrome pairs\n                    palindrome_pairs.append([word_dict[word[i:]], index])\n        \n        # Return the list of palindrome pairs\n        return palindrome_pairs"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u5230\u6240\u6709\u611f\u67d3\u7684\u533a\u57df\n        # 2. \u627e\u5230\u611f\u67d3\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\n        # 3. \u5c06\u75c5\u6bd2\u611f\u67d3\u7684\u533a\u57df\u5168\u90e8\u611f\u67d3\n        # 4. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 5. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 6. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 7. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 8. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 9. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 10. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 11. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 12. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 13. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 14. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 15. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 16. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 17. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 18. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 19. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 20. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 21. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 22. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 23. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 24. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 25. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 26. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 27. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 28. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 29. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 30. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 31. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 32. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 33. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 34. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 35. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 36. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 37. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 38. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 39. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 40. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 41. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 42. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 43. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 44. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 45. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 46. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 47. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 48. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 49. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 50. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 51. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 52. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 53. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 54. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 55. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 56. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 57. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3\n        # 58. \u611f\u67d3\u75c5\u6bd2\u7684\u533a\u57df\u4e2d\u6700\u8fdc\u7684\u75c5\u6bd2\u611f\u67d3"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        max_len = 1\n        \n        for direction in directions:\n            x, y = i + direction[0], j + direction[1]\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] is a valid word\n        # dp[i] = False if s[:i] is not a valid word\n        # dp[0] = True\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True\n        #       for all j in wordDict and s[j:i] is a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is True\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is True\n        #       for all j in wordDict and s[j:i] is a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False if s[:i] is not a valid word and dp[j] is False\n        #       for all j in wordDict and s[j:i] is not a valid word\n        # dp[i] = False"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hour(hour):\n            if hour == 0:\n                return [0]\n            elif hour == 1:\n                return [1,2,4,8]\n            elif hour == 2:\n                return [5,10,20,40]\n            elif hour == 3:\n                return [6,12,24,48]\n            elif hour == 4:\n                return [9,18,36,72]\n            elif hour == 5:\n                return [11,22,44,88]\n            elif hour == 6:\n                return [13,26,52,104]\n            elif hour == 7:\n                return [15,29,58,116]\n            elif hour == 8:\n                return [17,34,68,136]\n            elif hour == 9:\n                return [19,38,76,152]\n            elif hour == 10:\n                return [21,42,84,168]\n            elif hour == 11:\n                return [23,46,92,184]\n            else:\n                return []\n        \n        def get_minute(minute):\n            if minute == 0:\n                return [0]\n            elif minute == 1:\n                return [1,2,4,8,16,32]\n            elif minute == 2:\n                return [5,10,20,40,80,160]\n            elif minute == 3:\n                return [6,12,24,48,96,192]\n            elif minute == 4:\n                return [9,18,36,72,144,288]\n            elif minute == 5:\n                return [11,22,44,88,176,352]\n            elif minute == 6:\n                return [13,26,52,104,208,416]\n            elif minute == 7:\n                return [15,29,58,116,232,464]\n            elif minute == 8:\n                return [17,34,68,136,272,544]\n            elif minute == 9:\n                return [19,38,76,152,288,576]\n            elif minute == 10:\n                return [21,42,84,168,336,672]\n            elif minute == 11:\n                return [23,46,92,184,368,736]\n            else:\n                return []\n        \n        if turnedOn == 0:\n            return []\n        elif turnedOn == 1:\n            return [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"0:64\",\"0:128\",\"0:256\",\"0:512\",\"0:1024\",\"0:2048\"]\n        else:\n            hour_list = get_hour(turnedOn)\n            minute_list = get_minute(turnedOn)\n            res = []\n            for h in hour_list:\n                for m in minute_list:\n                    if h + m < 12 and m < 60:\n                        res.append(str(h) + \":\" + str(m))\n            return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            self.max_sum = max(self.max_sum, left + root.val, right + root.val, left + right + root.val)\n            return max(root.val, root.val + max(left, right))\n        dfs(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = i+di, j+dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    if heightMap[ni][nj] < height:\n                        ans += height - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(heightMap[ni][nj], height), ni, nj))\n                    visited.add((ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 2-1. \uc9dd\uc218\uc77c \uacbd\uc6b0\n        if len(nums) % 2 == 0:\n            return [(nums[k//2 - 1] + nums[k//2]) / 2.0]\n        # 2-2. \ud640\uc218\uc77c \uacbd\uc6b0\n        else:\n            return [nums[k//2]]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the linked list, we need to rotate by k % length\n        k = k % length\n        \n        # if k is 0, we don't need to rotate\n        if k == 0:\n            return head\n        \n        # find the new head of the linked list\n        new_head = head\n        for i in range(length - k - 1):\n            new_head = new_head.next\n        \n        # find the new tail of the linked list\n        new_tail = new_head\n        while new_tail.next:\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = head\n        \n        # cut the old linked list off\n        new_head = new_head.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != \"O\":\n                return\n            board[i][j] = \"T\"\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    if board[i][j] == \"O\":\n                        dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == \"O\":\n                    board[i][j] = \"X\"\n                elif board[i][j] == \"T\":\n                    board[i][j] = \"O\""}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute Force\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i,j]\n        \n        ## Hashmap\n        hashmap = {}\n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                return [hashmap[nums[i]], i]\n            hashmap[target - nums[i]] = i\n        return [-1,-1]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards = [a + b, a - b, a * b, float(a) / b]\n                        elif op == '-':\n                            new_cards = [a - b, b - a, a * b, float(a) / b]\n                        elif op == '*':\n                            new_cards = [a + b, a - b, a * b, float(a) / b]\n                        else:\n                            new_cards = [a + b, a - b, float(a) / b, b - a]\n                        if dfs(new_cards, target):\n                            return True\n            return False\n        \n        return dfs(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if p[0] != '*':\n            # if s is empty, return false\n            if not s:\n                return False\n            # if the first character of s is not equal to the first character of p, return false\n            if s[0] != p[0] and p[0] != '?':\n                return False\n        \n        # if p is not empty and the first character of p is '*', then check if the rest of the string is a match\n        if p[0] == '*':\n            # if the rest of the string is a match, return true\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty and the first character of p is not '*', then check if the rest of the string is a match\n        return self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            \n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result\n        result = []\n\n        # initialize max height\n        max_height = 0\n\n        # initialize current building\n        current_building = None\n\n        # iterate through buildings\n        for building in buildings:\n            # if current building is None or current building is not the same as previous building\n            if current_building is None or current_building[0] != building[0]:\n                # if current building is not None\n                if current_building is not None:\n                    # add current building to result\n                    result.append([current_building[0], current_building[1]])\n                # set current building to building\n                current_building = building\n            # if current building is not None\n            else:\n                # set current building to building\n                current_building = building\n            # if current building is not None\n            if current_building is not None:\n                # if current building is not None\n                if current_building[2] > max_height:\n                    # set max height to current building height\n                    max_height = current_building[2]\n                # if current building is not None\n                if current_building[2] < max_height:\n                    # add current building to result\n                    result.append([current_building[0], max_height])\n\n        # add last building to result\n        result.append([current_building[0], current_building[1]])\n\n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s)-1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Dynamic Programming\n        # Base Case:\n        # If the triangle is empty, return 0\n        if not triangle:\n            return 0\n        \n        # Initialize the first row of the triangle\n        dp = triangle[-1]\n        \n        # Iterate over the rows of the triangle\n        for i in range(len(triangle) - 2, -1, -1):\n            # Iterate over the elements in the current row\n            for j in range(len(triangle[i])):\n                # Calculate the minimum sum of the current element and its neighbors\n                dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]\n        \n        # Return the minimum sum of the first element in the first row\n        return dp[0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(1, n + 1):\n            for j in range(0, min(i, k) + 1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return root.val == targetSum\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        # 2. Create two pointers\n        # 3. Traverse the list\n        # 4. If the node value is less than x, add it to the left list\n        # 5. If the node value is greater than or equal to x, add it to the right list\n        # 6. Connect the left list to the right list\n        # 7. Return the left list\n        \n        left = ListNode()\n        right = ListNode()\n        left_tail = left\n        right_tail = right\n        \n        while head:\n            if head.val < x:\n                left_tail.next = head\n                left_tail = left_tail.next\n            else:\n                right_tail.next = head\n                right_tail = right_tail.next\n            head = head.next\n        \n        left_tail.next = right.next\n        right_tail.next = None\n        \n        return left.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Find the node with two parents\n        # 2. Find the edge that connects the two parents\n        # 3. Find the edge that connects the node with two parents\n        # 4. Return the edge that connects the node with two parents\n        \n        # 1. Find the node with two parents\n        parent_map = {}\n        for edge in edges:\n            if edge[0] in parent_map:\n                parent_map[edge[0]].append(edge[1])\n            else:\n                parent_map[edge[0]] = [edge[1]]\n        \n        # 2. Find the edge that connects the two parents\n        for edge in edges:\n            if edge[1] in parent_map and edge[0] in parent_map[edge[1]]:\n                return edge\n        \n        # 3. Find the edge that connects the node with two parents\n        for edge in edges:\n            if edge[1] not in parent_map:\n                return edge\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        visited = [False] * len(nums)\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if visited[i]:\n                    continue\n                if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                    continue\n                visited[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                visited[i] = False\n        backtrack([])\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Using XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Using Hashmap\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 4. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 5. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 6. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 7. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 8. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 9. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 10. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 11. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 12. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 13. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 14. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 15. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 16. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 17. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 18. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 19. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 20. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 21. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 22. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 23. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 24. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 25. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 26. Using Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 27. Using Bit Manipulation\n        ## Time Complexity: O("}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(max(i, n - i - 1), n):\n                for k in range(max(j, n - j - 1), n):\n                    if grid[i][j] == -1 or grid[j][k] == -1:\n                        continue\n                    if i == j and j == k:\n                        dp[i][j][k] = dp[i - 1][j - 1][k - 1] + grid[i][j]\n                    else:\n                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k - 1], dp[i][j][k - 1], dp[i - 1][j - 1][k], dp[i - 1][j][k - 1], dp[i][j - 1][k], dp[i][j][k - 1]) + grid[i][j] + grid[j][k]\n        return dp[n - 1][n - 1][n - 1]"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 2\n        \n        for i in range(2, n+1):\n            dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % mod\n        \n        return dp[n]"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if nums[0] == 0:\n        #     return False\n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1,m):\n            grid[i][0] = grid[i][0] + grid[i-1][0]\n        \n        for j in range(1,n):\n            grid[0][j] = grid[0][j] + grid[0][j-1]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                grid[i][j] = min(grid[i][j-1],grid[i-1][j]) + grid[i][j]\n        \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211211131221\"\n        \n        if n == 13:\n            return \"1321132132112311312211211131221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 15:\n            return \"311311222132132112311312211211131221\"\n        \n        if n == 16:\n            return \"1321132132112311312211211131221\"\n        \n        if n == 17:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 18:\n            return \"311311222132132112311312211211131221\"\n        \n        if n == 19:\n            return \"1321132132112311312211211131221\"\n        \n        if n == 20:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 21:\n            return \"311311222132132112311312211211131221\"\n        \n        if n == 22:\n            return \"1321132132112311312211211131221\"\n        \n        if n == 23:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 24:\n            return \"311311222132132112311312211211131221\"\n        \n        if n == 25:\n            return \"1321132132112311312211211131221\"\n        \n        if n == 26:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 27:\n            return \"311311222132132112311312211"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the largest number"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the pivot\n        # 2. find the target\n        # 3. if target is in the left part, do binary search in the left part\n        # 4. if target is in the right part, do binary search in the right part\n        \n        # 1. find the pivot\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        pivot = left\n        \n        # 2. find the target\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            real_mid = (mid + pivot) % len(nums)\n            if nums[real_mid] == target:\n                return real_mid\n            elif nums[real_mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {\n            '2': ['a','b','c'],\n            '3': ['d','e','f'],\n            '4': ['g','h','i'],\n            '5': ['j','k','l'],\n            '6': ['m','n','o'],\n            '7': ['p','q','r','s'],\n            '8': ['t','u','v'],\n            '9': ['w','x','y','z']\n        }\n        \n        res = []\n        def backtrack(i, currStr):\n            if i == len(digits):\n                res.append(currStr)\n                return\n            \n            for c in phone[digits[i]]:\n                backtrack(i+1, currStr+c)\n        \n        backtrack(0, \"\")\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            if i >= len(candidates) or target < 0:\n                return\n            dfs(i, curr, target - candidates[i])\n            dfs(i + 1, curr + [candidates[i]], target)\n        \n        dfs(0, [], target)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the nearest palindrome\n        # 2. If the nearest palindrome is 0, return 10\n        # 3. If the nearest palindrome is n, return n-1\n        # 4. If the nearest palindrome is n+1, return n+1\n        # 5. If the nearest palindrome is n-1, return n-1\n        # 6. If the nearest palindrome is n+2, return n+2\n        # 7. If the nearest palindrome is n-2, return n-2\n        # 8. If the nearest palindrome is n+3, return n+3\n        # 9. If the nearest palindrome is n-3, return n-3\n        # 10. If the nearest palindrome is n+4, return n+4\n        # 11. If the nearest palindrome is n-4, return n-4\n        # 12. If the nearest palindrome is n+5, return n+5\n        # 13. If the nearest palindrome is n-5, return n-5\n        # 14. If the nearest palindrome is n+6, return n+6\n        # 15. If the nearest palindrome is n-6, return n-6\n        # 16. If the nearest palindrome is n+7, return n+7\n        # 17. If the nearest palindrome is n-7, return n-7\n        # 18. If the nearest palindrome is n+8, return n+8\n        # 19. If the nearest palindrome is n-8, return n-8\n        # 20. If the nearest palindrome is n+9, return n+9\n        # 21. If the nearest palindrome is n-9, return n-9\n        # 22. If the nearest palindrome is n+10, return n+10\n        # 23. If the nearest palindrome is n-10, return n-10\n        # 24. If the nearest palindrome is n+11, return n+11\n        # 25. If the nearest palindrome is n-11, return n-11\n        # 26. If the nearest palindrome is n+12, return n+12\n        # 27. If the nearest palindrome is n-12, return n-12\n        # 28. If the nearest palindrome is n+13, return n+13\n        # 29. If the nearest palindrome is n-13, return n-13\n        # 30. If the nearest palindrome is n+14, return n+14\n        # 31. If the nearest palindrome is n-14, return n-14\n        # 32. If the nearest palindrome is n+15, return n+15\n        # 33. If the nearest palindrome is n-15, return n-15\n        # 34. If the nearest palindrome is n+16, return n+16\n        # 35. If the nearest palindrome is n-16, return n-16\n        # 36. If the nearest palindrome is n+17, return n+17\n        # 37. If the nearest palindrome is n-17, return n-17\n        # 38. If the nearest palindrome is n+18, return n+18\n        # 39. If the nearest palindrome is n-18, return n-18\n        # 40. If the nearest palindrome is n+19, return n+19\n        # 41. If the nearest palindrome is n-19, return n-19\n        # 42. If the nearest palindrome is n+20, return n+20\n        # 43. If the nearest palindrome is n-20, return n-20\n        # 44. If the nearest palindrome is n+21, return n+21\n        # 45. If the nearest palindrome is n-21, return n-21\n        # 46. If"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        count = 1\n        i = 0\n        j = 0\n        while count <= n**2:\n            #right\n            while j < n-i:\n                matrix[i][j] = count\n                count += 1\n                j += 1\n            j -= 1\n            i += 1\n            #down\n            while i < n-j:\n                matrix[i][j] = count\n                count += 1\n                i += 1\n            i -= 1\n            j -= 1\n            #left\n            while j >= i:\n                matrix[i][j] = count\n                count += 1\n                j -= 1\n            j += 1\n            i -= 1\n            #up\n            while i > j:\n                matrix[i][j] = count\n                count += 1\n                i -= 1\n            i += 1\n            j += 1\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n            x = -x\n        else:\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]\n        \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr = nums[i]\n            temp_max = max(curr, max_prod * curr, min_prod * curr)\n            min_prod = min(curr, max_prod * curr, min_prod * curr)\n            max_prod = temp_max\n            result = max(result, max_prod)\n            \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        stone_set.add(stones[-1])\n        stone_set.add(stones[-1] + 1)\n        stone_set.add(stones[-1] + 2)\n        stone_set.add(stones[-1] + 3)\n        stone_set.add(stones[-1] + 4)\n        stone_set.add(stones[-1] + 5)\n        stone_set.add(stones[-1] + 6)\n        stone_set.add(stones[-1] + 7)\n        stone_set.add(stones[-1] + 8)\n        stone_set.add(stones[-1] + 9)\n        stone_set.add(stones[-1] + 10)\n        stone_set.add(stones[-1] + 11)\n        stone_set.add(stones[-1] + 12)\n        stone_set.add(stones[-1] + 13)\n        stone_set.add(stones[-1] + 14)\n        stone_set.add(stones[-1] + 15)\n        stone_set.add(stones[-1] + 16)\n        stone_set.add(stones[-1] + 17)\n        stone_set.add(stones[-1] + 18)\n        stone_set.add(stones[-1] + 19)\n        stone_set.add(stones[-1] + 20)\n        stone_set.add(stones[-1] + 21)\n        stone_set.add(stones[-1] + 22)\n        stone_set.add(stones[-1] + 23)\n        stone_set.add(stones[-1] + 24)\n        stone_set.add(stones[-1] + 25)\n        stone_set.add(stones[-1] + 26)\n        stone_set.add(stones[-1] + 27)\n        stone_set.add(stones[-1] + 28)\n        stone_set.add(stones[-1] + 29)\n        stone_set.add(stones[-1] + 30)\n        stone_set.add(stones[-1] + 31)\n        stone_set.add(stones[-1] + 32)\n        stone_set.add(stones[-1] + 33)\n        stone_set.add(stones[-1] + 34)\n        stone_set.add(stones[-1] + 35)\n        stone_set.add(stones[-1] + 36)\n        stone_set.add(stones[-1] + 37)\n        stone_set.add(stones[-1] + 38)\n        stone_set.add(stones[-1] + 39)\n        stone_set.add(stones[-1] + 40)\n        stone_set.add(stones[-1] + 41)\n        stone_set.add(stones[-1] + 42)\n        stone_set.add(stones[-1] + 43)\n        stone_set.add(stones[-1] + 44)\n        stone_set.add(stones[-1] + 45)\n        stone_set.add(stones[-1] + 46)\n        stone_set.add(stones[-1] + 47)\n        stone_set.add(stones[-1] + 48)\n        stone_set.add(stones[-1] + 49)\n        stone_set.add(stones[-1] + 50)\n        stone_set.add(stones[-1] + 51)\n        stone_set.add(stones[-1] + 52)\n        stone_set.add(stones[-1] + 53)\n        stone_set.add(stones[-1] + 54)\n        stone_set.add(stones[-1] + 55)\n        stone_set.add(stones[-1] + 56)\n        stone_set.add(stones[-1] + 57)\n        stone_set.add(stones[-1] + 58)\n        stone_set.add(stones[-1] +"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        rank_map = {score[i]: i+1 for i in range(len(score))}\n        \n        # create a list to store the result\n        result = []\n        \n        # loop through the score and add the rank to the result\n        for s in score:\n            if rank_map[s] == 1:\n                result.append(\"Gold Medal\")\n            elif rank_map[s] == 2:\n                result.append(\"Silver Medal\")\n            elif rank_map[s] == 3:\n                result.append(\"Bronze Medal\")\n            else:\n                result.append(str(rank_map[s]))\n        \n        return result"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        start = 0\n        seen = {}\n        for i, c in en.umerate(s):\n            if c in seen:\n                start = max(start, seen[c] + 1)\n            seen[c] = i\n            max_len = max(max_len, i - start + 1)\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n            if temp_dict == word_dict:\n                res.append(i)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = max(arr)\n        chunks = 0\n        for i in range(len(arr)):\n            if arr[i] == max_num:\n                chunks += 1\n                max_num = max(arr[i+1:])\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + i for i in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            nums[left:right + 1] = temp\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v2) > len(v1):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # priority queue\n        pq = []\n        # total time\n        total = 0\n        # iterate over courses\n        for duration, lastDay in courses:\n            # add course to priority queue\n            heapq.heappush(pq, (-duration, lastDay))\n            # update total time\n            total += duration\n            # if total time exceeds last day\n            if total > lastDay:\n                # pop from priority queue\n                total += heapq.heappop(pq)[0]\n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        \n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1]*2 + dp[i-2]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2\n        # dp[i] = dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i-1]*2 + dp[i-2]*2 + dp[i-3]*2 + ... + dp[0]*2 + dp[1]*2 + dp[2]*2 + ... + dp[i"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 260ms\n        # 2. 36ms\n        # 3. 13ms\n        # 4. 13ms\n        # 5. 13ms\n        # 6. 13ms\n        # 7. 13ms\n        # 8. 13ms\n        # 9. 13ms\n        # 10. 13ms\n        # 11. 13ms\n        # 12. 13ms\n        # 13. 13ms\n        # 14. 13ms\n        # 15. 13ms\n        # 16. 13ms\n        # 17. 13ms\n        # 18. 13ms\n        # 19. 13ms\n        # 20. 13ms\n        # 21. 13ms\n        # 22. 13ms\n        # 23. 13ms\n        # 24. 13ms\n        # 25. 13ms\n        # 26. 13ms\n        # 27. 13ms\n        # 28. 13ms\n        # 29. 13ms\n        # 30. 13ms\n        # 31. 13ms\n        # 32. 13ms\n        # 33. 13ms\n        # 34. 13ms\n        # 35. 13ms\n        # 36. 13ms\n        # 37. 13ms\n        # 38. 13ms\n        # 39. 13ms\n        # 40. 13ms\n        # 41. 13ms\n        # 42. 13ms\n        # 43. 13ms\n        # 44. 13ms\n        # 45. 13ms\n        # 46. 13ms\n        # 47. 13ms\n        # 48. 13ms\n        # 49. 13ms\n        # 50. 13ms\n        # 51. 13ms\n        # 52. 13ms\n        # 53. 13ms\n        # 54. 13ms\n        # 55. 13ms\n        # 56. 13ms\n        # 57. 13ms\n        # 58. 13ms\n        # 59. 13ms\n        # 60. 13ms\n        # 61. 13ms\n        # 62. 13ms\n        # 63. 13ms\n        # 64. 13ms\n        # 65. 13ms\n        # 66. 13ms\n        # 67. 13ms\n        # 68. 13ms\n        # 69. 13ms\n        # 70. 13ms\n        # 71. 13ms\n        # 72. 13ms\n        # 73. 13ms\n        # 74. 13ms\n        # 75. 13ms\n        # 76. 13ms\n        # 77. 13ms\n        # 78. 13ms\n        # 79. 13ms\n        # 80. 13ms\n        # 81. 13ms\n        # 82. 13ms\n        # 83. 13ms\n        # 84. 13ms\n        # 85. 13ms\n        # 86. 13ms\n        # 87. 13ms\n        # 88. 13ms\n        # 89. 13ms\n        # 90. 13ms\n        # 91. 13ms\n        # 92. 13ms\n        # 93. 13ms\n        # 94. 13"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to spell out target[0:i]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-len(stickers[j])] == stickers[j]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers and target[i-"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                    for k in range(i,j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        i = 0\n        while i < len(s):\n            if i+1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n            i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hash Table\n        # Create a hash table\n        # Iterate through the array\n        # If the element is already in the hash table, return True\n        # Otherwise, add the element to the hash table\n        # Return False if the loop completes\n        \n        hash_table = {}\n        \n        for num in nums:\n            if num in hash_table:\n                return True\n            hash_table[num] = 1\n        \n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\n        # 2. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 3. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 4. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 5. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 6. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 7. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 8. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 9. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 10. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 11. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 12. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 13. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 14. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \ufffd"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * (area / 2) = area\n        # 2. 2 * (area / 2) + 1 = area\n        # 3. 2 * (area / 2) + 1 - 1 = area\n        # 4. 2 * (area / 2) + 1 - 2 = area\n        # 5. 2 * (area / 2) + 1 - 3 = area\n        # 6. 2 * (area / 2) + 1 - 4 = area\n        # 7. 2 * (area / 2) + 1 - 5 = area\n        # 8. 2 * (area / 2) + 1 - 6 = area\n        # 9. 2 * (area / 2) + 1 - 7 = area\n        # 10. 2 * (area / 2) + 1 - 8 = area\n        # 11. 2 * (area / 2) + 1 - 9 = area\n        # 12. 2 * (area / 2) + 1 - 10 = area\n        # 13. 2 * (area / 2) + 1 - 11 = area\n        # 14. 2 * (area / 2) + 1 - 12 = area\n        # 15. 2 * (area / 2) + 1 - 13 = area\n        # 16. 2 * (area / 2) + 1 - 14 = area\n        # 17. 2 * (area / 2) + 1 - 15 = area\n        # 18. 2 * (area / 2) + 1 - 16 = area\n        # 19. 2 * (area / 2) + 1 - 17 = area\n        # 20. 2 * (area / 2) + 1 - 18 = area\n        # 21. 2 * (area / 2) + 1 - 19 = area\n        # 22. 2 * (area / 2) + 1 - 20 = area\n        # 23. 2 * (area / 2) + 1 - 21 = area\n        # 24. 2 * (area / 2) + 1 - 22 = area\n        # 25. 2 * (area / 2) + 1 - 23 = area\n        # 26. 2 * (area / 2) + 1 - 24 = area\n        # 27. 2 * (area / 2) + 1 - 25 = area\n        # 28. 2 * (area / 2) + 1 - 26 = area\n        # 29. 2 * (area / 2) + 1 - 27 = area\n        # 30. 2 * (area / 2) + 1 - 28 = area\n        # 31. 2 * (area / 2) + 1 - 29 = area\n        # 32. 2 * (area / 2) + 1 - 30 = area\n        # 33. 2 * (area / 2) + 1 - 31 = area\n        # 34. 2 * (area / 2) + 1 - 32 = area\n        # 35. 2 * (area / 2) + 1 - 33 = area\n        # 36. 2 * (area / 2) + 1 - 34 = area\n        # 37. 2 * (area / 2) + 1 - 35 = area\n        # 38. 2 * (area / 2) + 1 - 36 = area\n        # 39. 2 * (area / 2) + 1 - 37 = area\n        # 40. 2 * (area / 2) + 1 - 38 = area\n        # 41. 2 * (area / 2) + 1 - 39 = area\n        # 42. 2 * (area / 2) + 1 - 40 = area\n        # 43. 2 * (area / 2) + 1 - 41 = area\n        # 44. 2 * (area / 2) + 1 - 4"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    neighbor = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor_word in graph[neighbor]:\n                        if neighbor_word == endWord:\n                            res.append([beginWord, neighbor_word] + [neighbor_word])\n                        if neighbor_word not in visited:\n                            visited.add(neighbor_word)\n                            queue.append(neighbor_word)\n        \n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            if path not in res:\n                res.append(path)\n            for i in range(start, len(nums)):\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 2. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 3. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 4. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 5. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 6. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 7. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 8. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 9. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 10. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 11. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 12. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 13. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 14. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 15. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 16. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \uc800\uc7a5\ud558\ub294 \ub9ac\uc2a4\ud2b8\n        # 17. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uc778\ub371\uc2a4\ub97c \ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num = stack.pop()\n                stack.append(int(stack.pop() / num))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        if x_min < rectangles[0][0] or x_max > rectangles[-1][2] or y_min < rectangles[0][1] or y_max > rectangles[-1][3]:\n            return False\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square\n        # 3. 4 is the middle square\n        # 4. 2 is the second middle square\n        # 5. 3 is the third middle square\n        # 6. 1 is the first middle square\n        \n        # 1. 0 is the empty square\n        # 2. 5 is the last square"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False\n        \n        # if target is in nums, return True\n        # else return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        min_diff = float('inf')\n        for i in range(1, len(inorder_list)):\n            min_diff = min(min_diff, inorder_list[i] - inorder_list[i-1])\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        res = dfs(root)\n        max_count = max(res.count(x) for x in set(res))\n        return [x for x in set(res) if res.count(x) == max_count]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        if len(password) < 6:\n            return max(0, 6 - len(password))\n        if len(password) > 20:\n            return max(0, len(password) - 20)\n        \n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        lower = 0\n        upper = 0\n        digit = 0\n        for c in password:\n            if c.islower():\n                lower += 1\n            elif c.isupper():\n                upper += 1\n            else:\n                digit += 1\n        \n        if lower == 0 or upper == 0 or digit == 0:\n            return max(0, 3 - (lower + upper + digit))\n        \n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 3-1. \uc5f0\uc18d\ub41c \ubb38\uc790 \uc81c\uac70 \uc2dc \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3-2. \uc5f0\uc18d\ub41c \ubb38\uc790 \uc81c\uac70 \uc2dc \ucd5c\uc18c 2\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3-3. \uc5f0\uc18d\ub41c \ubb38\uc790 \uc81c\uac70 \uc2dc \ucd5c\uc18c 3\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3-4. \uc5f0\uc18d\ub41c \ubb38\uc790 \uc81c\uac70 \uc2dc \ucd5c\uc18c 4\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3-5. \uc5f0\uc18d\ub41c \ubb38\uc790 \uc81c\uac70 \uc2dc \ucd5c\uc18c 5\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3-6. \uc5f0\uc18d\ub41c \ubb38\uc790 \uc81c\uac70 \uc2dc \ucd5c\uc18c 6\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3-7. \uc5f0\uc18d\ub41c \ubb38\uc790 \uc81c\uac70 \uc2dc \ucd5c\uc18c 7\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3-8."}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            count += n//5\n            n = n//5\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = -1\n        \n        for c in s:\n            res[i] += c\n            if i == 0 or i == numRows - 1:\n                flag = -flag\n            i += flag\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ufffd"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Create a hashmap with the number as key and the value as 1\n        ## 2. Iterate through the array and for each number, check if the number is in the hashmap. If it is, increment the value by 1.\n        ## 3. Iterate through the hashmap and return the keys that have a value of 1.\n        \n        hashmap = {}\n        for num in nums:\n            hashmap[num] = 1\n        \n        res = []\n        for i in range(1, len(nums)+1):\n            if i not in hashmap:\n                res.append(i)\n        \n        return res"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                res.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            \n            return res\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        prev = -1\n        for interval in intervals:\n            if interval[0] > prev:\n                res += 2\n                prev = interval[1] - 1\n            else:\n                res += 1\n                prev -= 1\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(root1, root2):\n            if root1 is None and root2 is None:\n                return True\n            if root1 is None or root2 is None:\n                return False\n            if root1.val != root2.val:\n                return False\n            return isMirror(root1.left, root2.right) and isMirror(root1.right, root2.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + \"(\", ans)\n            if right > left:\n                generate(left, right - 1, s + \")\", ans)\n        \n        ans = []\n        generate(n, n, \"\", ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\ub97c \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc2a4\ud0dd\uc758 \ucd5c\uc0c1\ub2e8 \uc6d0\uc18c\uac00 \uc9dd\uc774 \ub9de\uc9c0 \ufffd"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder = remainder * 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        return sign + str(quotient) + \".\" + remainder_str"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        # print(envelopes)\n        dp = [envelopes[0][1]]\n        for i in range(1, len(envelopes)):\n            if envelopes[i][1] > dp[-1]:\n                dp.append(envelopes[i][1])\n            else:\n                left = 0\n                right = len(dp) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid\n                dp[left] = envelopes[i][1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        \n        row_zero = False\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    if i == 0:\n                        row_zero = True\n                    else:\n                        matrix[i][j] = 0\n        \n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if row_zero:\n            for i in range(rows):\n                matrix[i][0] = 0\n        \n        if matrix[0][0] == 0:\n            for i in range(cols):\n                matrix[0][i] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the nth node from the end\n        # 2.1 Find the nth node from the end\n        # 2.2 Remove the nth node from the end\n        # 2.3 Return the head\n        if length == n:\n            return head.next\n        \n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        curr.next = curr.next.next\n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                if i == 0 or nums1[i] != nums1[i-1]:\n                    res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return res"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u603b\u6570\n        total = sum(machines)\n        # 2. \u5982\u679c\u603b\u6570\u4e0d\u80fd\u88abn\u6574\u9664\uff0c\u5219\u65e0\u6cd5\u5b8c\u6210\n        if total % len(machines) != 0:\n            return -1\n        # 3. \u8ba1\u7b97\u51fa\u5e73\u5747\u6570\n        avg = total // len(machines)\n        # 4. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\n        diff = [machines[i] - avg for i in range(len(machines))]\n        # 5. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\n        abs_diff = [abs(diff[i]) for i in range(len(diff))]\n        # 6. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\n        abs_sum = sum(abs_diff)\n        # 7. \u5982\u679c\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u5927\u4e8e\u5e73\u5747\u6570\uff0c\u5219\u65e0\u6cd5\u5b8c\u6210\n        if abs_sum > avg:\n            return -1\n        # 8. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5927\u503c\n        max_abs_sum = max(abs_diff)\n        # 9. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\n        min_abs_sum = min(abs_diff)\n        # 10. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\n        min_abs_sum_abs = abs(min_abs_sum)\n        # 11. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\n        min_abs_sum_abs_sum = min_abs_sum_abs + abs_sum\n        # 12. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u548c\n        min_abs_sum_abs_sum_sum = min_abs_sum_abs_sum + min_abs_sum_abs\n        # 13. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u548c\u7684\u548c\n        min_abs_sum_abs_sum_sum_sum = min_abs_sum_abs_sum_sum + min_abs_sum_abs_sum\n        # 14. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\n        min_abs_sum_abs_sum_sum_sum_sum = min_abs_sum_abs_sum_sum_sum + min_abs_sum_abs_sum_sum\n        # 15. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\n        min_abs_sum_abs_sum_sum_sum_sum_sum = min_abs_sum_abs_sum_sum_sum_sum + min_abs_sum_abs_sum_sum_sum\n        # 16. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\n        min_abs_sum_abs_sum_sum_sum_sum_sum_sum = min_abs_sum_abs_sum_sum_sum_sum_sum + min_abs_sum_abs_sum_sum_sum_sum\n        # 17. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\n        min_abs_sum_abs_sum_sum_sum_sum_sum_sum_sum = min_abs_sum_abs_sum_sum_sum_sum_sum_sum + min_abs_sum_abs_sum_sum_sum_sum_sum\n        # 18. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668\u7684\u5dee\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u6700\u5c0f\u503c\u7684\u7edd\u5bf9\u503c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\u7684\u548c\n        min_abs_sum_abs_sum_sum_sum_sum_sum_sum_sum_sum = min_abs_sum_abs_sum_sum_sum_sum_sum_sum_sum_sum + min_abs_sum_abs_sum_sum_sum_sum_sum_sum\n        # 19. \u8ba1\u7b97\u51fa\u6240\u6709\u673a\u5668"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(x // i, n)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            temp = list1\n            list1 = list1.next\n            temp.next = self.mergeTwoLists(list1, list2)\n            return temp\n        else:\n            temp = list2\n            list2 = list2.next\n            temp.next = self.mergeTwoLists(list1, list2)\n            return temp"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[i][j] = (1 if i == 0 else dp[i-1][j]) + 1\n        \n        max_area = 0\n        for i in range(m):\n            max_area = max(max_area, self.largestRectangleArea(dp[i]))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = []\n        for i in range(2**len(nums)):\n            temp = []\n            for j in range(len(nums)):\n                if i & (1<<j):\n                    temp.append(nums[j])\n            res.append(temp)\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[-2] < nums[-3]:\n        #     return nums[-2]\n        # if nums[-3] < nums[-4]:\n        #     return nums[-3]\n        # if nums[-4] < nums[-5]:\n        #     return nums[-4]\n        # if nums[-5] < nums[-6]:\n        #     return nums[-5]\n        # if nums[-6] < nums[-7]:\n        #     return nums[-6]\n        # if nums[-7] < nums[-8]:\n        #     return nums[-7]\n        # if nums[-8] < nums[-9]:\n        #     return nums[-8]\n        # if nums[-9] < nums[-10]:\n        #     return nums[-9]\n        # if nums[-10] < nums[-11]:\n        #     return nums[-10]\n        # if nums[-11] < nums[-12]:\n        #     return nums[-11]\n        # if nums[-12] < nums[-13]:\n        #     return nums[-12]\n        # if nums[-13] < nums[-14]:\n        #     return nums[-13]\n        # if nums[-14] < nums[-15]:\n        #     return nums[-14]\n        # if nums[-15] < nums[-16]:\n        #     return nums[-15]\n        # if nums[-16] < nums[-17]:\n        #     return nums[-16]\n        # if nums[-17] < nums[-18]:\n        #     return nums[-17]\n        # if nums[-18] < nums[-19]:\n        #     return nums[-18]\n        # if nums[-19] < nums[-20]:\n        #     return nums[-19]\n        # if nums[-20] < nums[-21]:\n        #     return nums[-20]\n        # if nums[-21] < nums[-22]:\n        #     return nums[-21]\n        # if nums[-22] < nums[-23]:\n        #     return nums[-22]\n        # if nums[-23] < nums[-24]:\n        #     return nums[-23]\n        # if nums[-24] < nums[-25]:\n        #     return nums[-24]\n        # if nums[-25] < nums[-26]:\n        #     return nums[-25]\n        # if nums[-26] < nums[-27]:\n        #     return nums[-26]\n        # if nums[-27] < nums[-28]:\n        #     return nums[-27]\n        # if nums[-28] < nums[-29]:\n        #     return nums[-28]\n        # if nums[-29] < nums[-30]:\n        #     return nums[-29]\n        # if nums[-30] < nums[-31]:\n        #     return nums[-30]\n        # if nums[-31] < nums[-32]:\n        #     return nums[-31]\n        # if nums[-32] < nums[-33]:\n        #     return nums[-32]\n        # if nums[-33] < nums[-34]:\n        #     return nums[-33]\n        # if nums[-34] < nums[-35]:\n        #     return nums[-34]\n        # if nums[-35] < nums[-36]:\n        #     return nums[-35]\n        # if nums[-36] < nums[-37]:\n        #     return nums[-36]\n        # if nums[-37] < nums[-38]:"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_num = ''\n        \n        for key in roman_dict.keys():\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n                \n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and decrement the frequency of each character in the hashmap\n        ## 3. Return the character with a frequency of 1\n        \n        ## Edge Cases:\n        ## 1. If s is empty, return t\n        ## 2. If t is empty, return s\n        \n        ## Initialization:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and decrement the frequency of each character in the hashmap\n        \n        ## Algorithm:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and decrement the frequency of each character in the hashmap\n        ## 3. Return the character with a frequency of 1\n        \n        ## Code:\n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        for char in t:\n            if char not in hashmap:\n                return char\n            else:\n                hashmap[char] -= 1\n        \n        for key, value in hashmap.items():\n            if value == 1:\n                return key"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def solve(board):\n            # base case\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for k in range(1, 10):\n                            if isValid(board, i, j, str(k)):\n                                board[i][j] = str(k)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n\n        def isValid(board, row, col, num):\n            # check row\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n            # check col\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n            # check 3x3 box\n            box_row = row // 3\n            box_col = col // 3\n            for i in range(3):\n                for j in range(3):\n                    if board[box_row * 3 + i][box_col * 3 + j] == num:\n                        return False\n            return True\n\n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half with the second half\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        ans = [0,1]\n        i = 2\n        while i <= n:\n            ans.append(ans[i//2] + i%2)\n            i += 1\n        \n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # while head.val == val:\n        #     head = head.next\n        #     if head is None:\n        #         return None\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return head\n        \n        if head is None:\n            return None\n        \n        head.next = self.removeElements(head.next, val)\n        return head.next if head.val == val else head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 2. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 3. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 4. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 5. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 6. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 7. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 8. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 9. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 10. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 11. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 12. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 13. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 14. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 15. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 16. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 17. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 18. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 19. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 20. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 21. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 22. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 23. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 24. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 25. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 26. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 27. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 28. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 29. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 30. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 31. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 32. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 33. 2 for loops to check if there are any duplicates in each row, col, and 3x3 box\n        # 34. 2 for loops"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return \" \".join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        prev = None\n        curr = slow\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        # merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping of pattern to words\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern is not in the mapping, add it\n            if pattern[i] not in mapping:\n                mapping[pattern[i]] = words[i]\n            # if the pattern is in the mapping, check if the word is not the same as the mapping\n            elif mapping[pattern[i]] != words[i]:\n                return False\n        \n        # if all the pattern and words are mapped, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create a new linked list\n        # 2. Create a new node\n        # 3. Add the values of the linked lists\n        # 4. Add the values of the linked lists\n        # 5. Return the new linked list\n        \n        # 1. Create a new linked list\n        new_list = ListNode()\n        # 2. Create a new node\n        new_node = new_list\n        # 3. Add the values of the linked lists\n        carry = 0\n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            new_node.next = ListNode(carry % 10)\n            new_node = new_node.next\n            carry //= 10\n        # 4. Return the new linked list\n        return new_list.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the binary to decimal\n        # 4. Return the complement\n        \n        binary = bin(num)[2:]\n        binary = binary[::-1]\n        decimal = int(binary, 2)\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums) - 2:\n            if nums[i+1] - nums[i] == nums[i+2] - nums[i+1]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        cur_len = 0\n        cur_words = []\n        for word in words:\n            if cur_len + len(word) + len(cur_words) > maxWidth:\n                if len(cur_words) == 1:\n                    res.append(cur_words[0] + ' ' * (maxWidth - cur_len))\n                else:\n                    num_spaces = (maxWidth - cur_len) // (len(cur_words) - 1)\n                    extra_spaces = (maxWidth - cur_len) % (len(cur_words) - 1)\n                    res.append(''.join([cur_words[i] + ' ' * num_spaces + (' ' if i < extra_spaces else '') for i in range(len(cur_words))]))\n                cur_len = 0\n                cur_words = []\n            cur_len += len(word)\n            cur_words.append(word)\n        if cur_len > 0:\n            res.append(' '.join(cur_words) + ' ' * (maxWidth - cur_len - len(cur_words) + 1))\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n%4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(row):\n            if row == n:\n                self.count += 1\n                return\n            for col in range(n):\n                if is_valid(row, col):\n                    board[row][col] = 1\n                    backtrack(row + 1)\n                    board[row][col] = 0\n        \n        self.count = 0\n        board = [[0 for _ in range(n)] for _ in range(n)]\n        backtrack(0)\n        return self.count"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}