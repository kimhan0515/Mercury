{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right, top, bottom = 0, n-1, 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end += 1\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][j] = 1 if s[0] == t[j]\n        # dp[i][0] = 0 for all i\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] if s[i] != t[j]\n        # dp[i][j] = dp[i][j-1] if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t[j]\n        # dp[i][j] = 1 if s[i] == t[j]\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] if s[i] != t"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and all numbers larger than nums.length as 0\n        # 2. mark all numbers in the range [1, nums.length] as 1\n        # 3. iterate through the array and mark the corresponding numbers as -1\n        # 4. iterate through the array again and return the first number that is not -1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(1, n + 1):\n            if nums[i - 1] > 0:\n                return i\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        res = \"\"\n        nums = [i for i in range(1, n + 1)]\n        for i in range(n - 1, -1, -1):\n            # 2.1 calculate the index of the current digit\n            idx = k // fact\n            # 2.2 calculate the digit\n            res += str(nums[idx])\n            # 2.3 remove the digit from the nums\n            nums.pop(idx)\n            # 2.4 update k\n            k %= fact\n            # 2.5 update the factorial\n            fact //= i\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. use two pointers\n        # 2. if the sum is larger than target, move the right pointer to the left\n        # 3. if the sum is smaller than target, move the left pointer to the right\n        # 4. if the sum is equal to target, return the two pointers\n        \n        left, right = 0, len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] > target:\n                right -= 1\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                return [left + 1, right + 1]\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, prev, res, path, pos):\n            if not num:\n                if target == 0:\n                    res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                if i == 1 or num[0] != '0':\n                    cur = int(num[:i])\n                    if pos == 0:\n                        dfs(num[i:], target - cur, cur, res, path + str(cur), i)\n                    else:\n                        dfs(num[i:], target - prev + cur * pos, cur * pos, res, path + '*' + str(cur), i)\n        res = []\n        dfs(num, target, 0, res, '', 0)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        start = 0\n        tank = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return false if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if the first character matches\n        first_match = bool(s) and p[0] in (s[0], '?')\n        \n        # if p is longer than s, return false\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (first_match and self.isMatch(s[1:], p))\n        \n        # if p is longer than s, return false\n        return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_greater_element(nums1, nums2, k):\n            # pick the greater element from nums1\n            # if the length of nums1 is less than k, pick the greater element from nums2\n            # if the length of nums1 is greater than k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the length of nums1 is equal to k, pick the greater element from nums1\n            # if the length of nums1 is equal to k, pick the greater element from nums2\n            # if the"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a, b = 0, 1\n        for i in range(2, n + 1):\n            a, b = b, a + b\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if sum(bisect_right(nums, mid) - bisect_left(nums, mid) for x in (nums[i] + mid for i in range(n - 1))) >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 = 0\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 = 11\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 = 12\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 = 13\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 = 14\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 = 15\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 = 16\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 = 17\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 = 18\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 = 19\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 = 20\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 = 21\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 = 22\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 ^ 23 = 23\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n: number of nodes in the graph\n        # m: length of each word\n        # n:"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a, b = list(a), list(b)\n        \n        carry = 0\n        for i in range(len(a)):\n            if i < len(b):\n                carry += int(a[-i - 1]) + int(b[-i - 1])\n            else:\n                carry += int(a[-i - 1])\n            a[-i - 1] = str(carry % 2)\n            carry //= 2\n        \n        if carry:\n            a.append(str(carry))\n        \n        return ''.join(a[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return [-1, -1]\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        if nums[left] != target:\n            return [-1, -1]\n        else:\n            left = right\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        return [left, right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return len(nums)\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) / 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(len(prices) - 1))\n        \n        buy = [float('-inf')] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                buy[i] = max(buy[i], sell[i - 1] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n        \n        return sell[-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        if num < 0:\n            num = num + 2**32\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = ''\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a hashmap to store the frequency of each character\n        # 2. iterate through the string and update the frequency of each character\n        # 3. iterate through the string again and return the first character with frequency 1\n        \n        # 1. create a hashmap to store the frequency of each character\n        freq = {}\n        \n        # 2. iterate through the string and update the frequency of each character\n        for c in s:\n            if c not in freq:\n                freq[c] = 1\n            else:\n                freq[c] += 1\n        \n        # 3. iterate through the string again and return the first character with frequency 1\n        for i, c in enumerate(s):\n            if freq[c] == 1:\n                return i\n        \n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0: red, 1: white, 2: blue\n        red, white, blue = 0, 0, len(nums) - 1\n        \n        while white <= blue:\n            if nums[white] == 0:\n                nums[red], nums[white] = nums[white], nums[red]\n                red += 1\n                white += 1\n            elif nums[white] == 2:\n                nums[blue], nums[white] = nums[white], nums[blue]\n                blue -= 1\n            else:\n                white += 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        curr_count = 0\n        \n        for num in nums:\n            if num == 1:\n                curr_count += 1\n            else:\n                max_count = max(max_count, curr_count)\n                curr_count = 0\n                \n        return max(max_count, curr_count)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1, num2 = num1[::-1], num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            curr = int(num1[i]) + int(num2[i]) + carry\n            carry = curr // 10\n            res.append(str(curr % 10))\n        \n        for i in range(len(num1), len(num2)):\n            curr = int(num2[i]) + carry\n            carry = curr // 10\n            res.append(str(curr % 10))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u66ff\u6362\u6210\u7a7a\u683c\n        s = s.replace(' ', '')\n        \n        # 2. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u8d1f\u53f7\u66ff\u6362\u6210\u6b63\u53f7\n        s = s.replace('-', '+-')\n        \n        # 3. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u62ec\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace('(', '( ').replace(')', ' )')\n        \n        # 4. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace('+', ' + ')\n        \n        # 5. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 6. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in s]\n        \n        # 7. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace(' + ', ' +')\n        \n        # 8. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 9. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in s]\n        \n        # 10. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace(' + ', ' +')\n        \n        # 11. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 12. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in s]\n        \n        # 13. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace(' + ', ' +')\n        \n        # 14. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 15. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in s]\n        \n        # 16. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace(' + ', ' +')\n        \n        # 17. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 18. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in s]\n        \n        # 19. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace(' + ', ' +')\n        \n        # 20. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 21. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in s]\n        \n        # 22. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace(' + ', ' +')\n        \n        # 23. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 24. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in s]\n        \n        # 25. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace(' + ', ' +')\n        \n        # 26. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 27. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in s]\n        \n        # 28. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u52a0\u53f7\u8fdb\u884c\u66ff\u6362\n        s = s.replace(' + ', ' +')\n        \n        # 29. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u7a7a\u683c\u8fdb\u884c\u5206\u5272\n        s = s.split()\n        \n        # 30. \u5c06\u5b57\u7b26\u4e32\u4e2d\u7684\u6570\u5b57\u8fdb\u884c\u8f6c\u6362\n        s = [int(i) if i.isdigit() else i for i in"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort by capital\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # heap\n        heap = []\n        \n        # iterate over sorted capital\n        for c, p in sorted_capital:\n            # add to heap\n            heapq.heappush(heap, -p)\n            \n            # if we have enough capital\n            if len(heap) > k:\n                # pop the smallest\n                heapq.heappop(heap)\n        \n        # sum the profits\n        return sum([heapq.heappop(heap) for _ in range(k)])"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for c in s:\n            if c in '({[':\n                stack.append(c)\n            else:\n                if not stack:\n                    return False\n                if c == ')' and stack[-1] != '(':\n                    return False\n                if c == ']' and stack[-1] != '[':\n                    return False\n                if c == '}' and stack[-1] != '{':\n                    return False\n                stack.pop()\n        return not stack"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the point\n        \n        # find the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # find the first number that is larger than the next number\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers after the point\n        nums[i + 1:] = nums[len(nums) - 1: i - 1:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k == 0:\n            return False\n        \n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        \n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[0] == nums[2]\n        \n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[0] == nums[3]\n        \n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[0] == nums[4]\n        \n        if len(nums) == 6:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[0] == nums[5]\n        \n        if len(nums) == 7:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[0] == nums[6]\n        \n        if len(nums) == 8:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[0] == nums[7]\n        \n        if len(nums) == 9:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[0] == nums[8]\n        \n        if len(nums) == 10:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[0] == nums[9]\n        \n        if len(nums) == 11:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[9] == nums[10] or nums[0] == nums[10]\n        \n        if len(nums) == 12:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n <= 1:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n-1, 2)]\n        couples.sort()\n        \n        res = 0\n        for couple in couples:\n            if couple[0] != couple[1] - 1:\n                res += 1\n                row[couple[0]+1] = couple[1]\n                row[couple[1]] = couple[0] + 1\n        return res"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if not s1:\n            return s2 == s3\n        \n        if not s2:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first_row = set('qwertyuiop')\n        second_row = set('asdfghjkl')\n        third_row = set('zxcvbnm')\n        \n        return [word for word in words if set(word.lower()) <= first_row or set(word.lower()) <= second_row or set(word.lower()) <= third_row]"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right - left):\n            tmp = curr.next\n            curr.next = tmp.next\n            tmp.next = prev.next\n            prev.next = tmp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, the longest palindrome is itself\n        # if the string is not a palindrome, the longest palindrome is the longest palindrome that can be centered at the beginning of the"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        # build hashmap of t\n        t_map = {}\n        for c in t:\n            if c not in t_map:\n                t_map[c] = 0\n            t_map[c] += 1\n        \n        # build hashmap of s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # compare hashmaps\n        if s_map == t_map:\n            return s\n        \n        # initialize window\n        left = 0\n        right = 0\n        min_window = s\n        min_len = len(s)\n        \n        # iterate over s\n        while right < len(s):\n            # add right char to window\n            if s[right] in s_map:\n                s_map[s[right]] -= 1\n                if s_map[s[right]] == 0:\n                    del s_map[s[right]]\n            \n            # shrink window\n            while len(s_map) == len(t_map):\n                if right - left + 1 < min_len:\n                    min_window = s[left:right+1]\n                    min_len = len(min_window)\n                \n                if s[left] in s_map:\n                    s_map[s[left]] += 1\n                    if s_map[s[left]] > 0:\n                        s_map[s[left]] -= 1\n                left += 1\n            \n            right += 1\n        \n        return min_window"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] == distance[i - 3] and distance[i - 1] == distance[i - 4]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 6 and distance[i] + distance[i - 5] >= distance[i - 3] and distance[i - 2] == distance[i - 4] and distance[i - 1] == distance[i - 5]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 3. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 4. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 5. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 6. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 7. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 8. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 9. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 10. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 11. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 12. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 13. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 14. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 15. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 16. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 17. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 18. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 19. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 20. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 21. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 22. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 23. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 24. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 25. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 26. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 27. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 28. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 29. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 30. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 31. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 32. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5947\u6570\n        # 33. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f\u5ea6\u4e3a\u5076\u6570\n        # 34. \u5982\u679c\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u653e\u7f6e\u5728\u4e2d\u95f4\uff0c\u957f"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point\n        # 2. BFS from the starting point\n        # 3. return the number of steps\n        \n        # 1. find the starting point"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u53cc\u6307\u9488\uff0c\u5206\u522b\u4ece\u524d\u7f00\u548c\u6570\u7ec4\u7684\u5934\u5c3e\u5f00\u59cb\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u524d\u7f00\u548c - lower \u5728\u533a\u95f4\u5185\uff0c\u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper - lower - upper \u7684\u533a\u95f4\uff0c\n        # \u90a3\u4e48\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u524d\u7f00\u548c - upper - lower - upper -"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k = k(k+1)/2\n        # k^2 + k - 2n = 0\n        # k = (-1 + sqrt(1 + 8n))/2\n        return int((-1 + sqrt(1 + 8*n))/2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.insert(0, level)\n        \n        return res"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) > len(t):\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the last number of the sequence\n        # 2. 2^n - 1 is the first number of the sequence\n        # 3. 2^n - 1 is the last number of the sequence\n        # 4. 2^n - 1 is the first number of the sequence\n        # 5. 2^n - 1 is the last number of the sequence\n        # 6. 2^n - 1 is the first number of the sequence\n        # 7. 2^n - 1 is the last number of the sequence\n        # 8. 2^n - 1 is the first number of the sequence\n        # 9. 2^n - 1 is the last number of the sequence\n        # 10. 2^n - 1 is the first number of the sequence\n        # 11. 2^n - 1 is the last number of the sequence\n        # 12. 2^n - 1 is the first number of the sequence\n        # 13. 2^n - 1 is the last number of the sequence\n        # 14. 2^n - 1 is the first number of the sequence\n        # 15. 2^n - 1 is the last number of the sequence\n        # 16. 2^n - 1 is the first number of the sequence\n        # 17. 2^n - 1 is the last number of the sequence\n        # 18. 2^n - 1 is the first number of the sequence\n        # 19. 2^n - 1 is the last number of the sequence\n        # 20. 2^n - 1 is the first number of the sequence\n        # 21. 2^n - 1 is the last number of the sequence\n        # 22. 2^n - 1 is the first number of the sequence\n        # 23. 2^n - 1 is the last number of the sequence\n        # 24. 2^n - 1 is the first number of the sequence\n        # 25. 2^n - 1 is the last number of the sequence\n        # 26. 2^n - 1 is the first number of the sequence\n        # 27. 2^n - 1 is the last number of the sequence\n        # 28. 2^n - 1 is the first number of the sequence\n        # 29. 2^n - 1 is the last number of the sequence\n        # 30. 2^n - 1 is the first number of the sequence\n        # 31. 2^n - 1 is the last number of the sequence\n        # 32. 2^n - 1 is the first number of the sequence\n        # 33. 2^n - 1 is the last number of the sequence\n        # 34. 2^n - 1 is the first number of the sequence\n        # 35. 2^n - 1 is the last number of the sequence\n        # 36. 2^n - 1 is the first number of the sequence\n        # 37. 2^n - 1 is the last number of the sequence\n        # 38. 2^n - 1 is the first number of the sequence\n        # 39. 2^n - 1 is the last number of the sequence\n        # 40. 2^n - 1 is the first number of the sequence\n        # 41. 2^n - 1 is the last number of the sequence\n        # 42. 2^n - 1 is the first number of the sequence\n        # 43. 2^n - 1 is the last number of the sequence\n        # 44. 2^n - 1 is the first number of the sequence\n        # 45. 2^n - 1 is the last number of the sequence\n        # 46. 2^n - 1 is the first number of the sequence\n        # 47. 2^n - 1 is the last number of the sequence\n        # 48. 2^n - 1 is the first number of the sequence\n        # 49. 2^n - 1 is the last number of the sequence\n        # 5"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a, b = 1, 2\n        for i in range(3, n+1):\n            a, b = b, a+b\n        return b"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is larger than the last interval in the list,\n        # append the new interval to the end of the list\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if the new interval is smaller than the first interval in the list,\n        # insert the new interval at the beginning of the list\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if the new interval overlaps with the first interval in the list,\n        # merge the new interval with the first interval\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0] = newInterval\n            return intervals\n        \n        # if the new interval overlaps with the last interval in the list,\n        # merge the new interval with the last interval\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1] = newInterval\n            return intervals\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = newInterval\n                return intervals\n            \n            # if the new interval overlaps with an interval in the middle of the list,\n            # merge the new interval with the interval in the middle\n            elif newInterval[0] <= intervals[i][1] and newInterval[1] >= intervals[i][0]:\n                intervals[i] = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]\n                return intervals\n            \n        # if the new interval does not overlap with any interval in the list,\n        # insert the new interval at the end of the list\n        intervals.append(newInterval)\n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if is_palindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. use min heap to store the max of each list\n        # 3. use max heap to store the min of each list\n        # 4. compare the max of the min heap with the min of the max heap\n        # 5. if the max of the min heap is greater than the min of the max heap, update the min and max\n        # 6. if the max of the min heap is equal to the min of the max heap, return the result\n        \n        import heapq\n        min_heap = []\n        max_heap = []\n        for i in range(len(nums)):\n            heapq.heappush(min_heap, (nums[i][0], i, 0))\n            heapq.heappush(max_heap, (-nums[i][0], i, 0))\n        \n        min_val = min_heap[0][0]\n        max_val = max_heap[0][0] * -1\n        res = [min_val, max_val]\n        \n        while True:\n            cur_min = min_heap[0][0]\n            cur_max = -max_heap[0][0]\n            if cur_max - cur_min < res[1] - res[0]:\n                res = [cur_min, cur_max]\n            if len(min_heap) == len(max_heap):\n                break\n            if max_heap[0][1] == len(nums[max_heap[0][2]]):\n                heapq.heappop(max_heap)\n            heapq.heappush(min_heap, (nums[max_heap[0][2]][heapq.heappop(max_heap)[1] + 1], max_heap[0][2], heapq.heappop(max_heap)[1] + 1))\n            heapq.heappush(max_heap, (-nums[max_heap[0][2]][heapq.heappop(max_heap)[1] + 1], max_heap[0][2], heapq.heappop(max_heap)[1] + 1))\n        \n        return res"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 1 bucket, 2 pigs can test 2 buckets, 3 pigs can test 4 buckets, 4 pigs can test 8 buckets, 5 pigs can test 16 buckets, 6 pigs can test 32 buckets, 7 pigs can test 64 buckets, 8 pigs can test 128 buckets, 9 pigs can test 256 buckets, 10 pigs can test 512 buckets, 11 pigs can test 1024 buckets, 12 pigs can test 2048 buckets, 13 pigs can test 4096 buckets, 14 pigs can test 8192 buckets, 15 pigs can test 16384 buckets, 16 pigs can test 32768 buckets, 17 pigs can test 65536 buckets, 18 pigs can test 131072 buckets, 19 pigs can test 262144 buckets, 20 pigs can test 524288 buckets, 21 pigs can test 1048576 buckets, 22 pigs can test 2097152 buckets, 23 pigs can test 4194304 buckets, 24 pigs can test 8388608 buckets, 25 pigs can test 16777216 buckets, 26 pigs can test 33554432 buckets, 27 pigs can test 67108864 buckets, 28 pigs can test 134217728 buckets, 29 pigs can test 268435456 buckets, 30 pigs can test 536870912 buckets, 31 pigs can test 1073741824 buckets, 32 pigs can test 2147483648 buckets, 33 pigs can test 4294967296 buckets, 34 pigs can test 8589934592 buckets, 35 pigs can test 17179869184 buckets, 36 pigs can test 34359738368 buckets, 37 pigs can test 68719476736 buckets, 38 pigs can test 137438953472 buckets, 39 pigs can test 274877906944 buckets, 40 pigs can test 549755813888 buckets, 41 pigs can test 1099511627776 buckets, 42 pigs can test 2199023255552 buckets, 43 pigs can test 4398046511104 buckets, 44 pigs can test 8796093022208 buckets, 45 pigs can test 17592186044416 buckets, 46 pigs can test 35184372088832 buckets, 47 pigs can test 70368744177664 buckets, 48 pigs can test 140737488355328 buckets, 49 pigs can test 281474976710656 buckets, 50 pigs can test 562949952421312 buckets, 51 pigs can test 1125899904842624 buckets, 52 pigs can test 2251799809685248 buckets, 53 pigs can test 4503599619370496 buckets, 54 p"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        heap = [(grid[0][0], 0, 0)]\n        visited = set([(0, 0)])\n        res = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            res = max(res, t)\n            if i == j == n - 1:\n                return res\n            for ni, nj in [(i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)]:\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    visited.add((ni, nj))\n        \n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        # 5. BFS\n        # 6. DFS\n        # 7. Greedy\n        # 8. Backtracking\n        # 9. Bit Manipulation\n        # 10. Heap (Priority Queue)\n        # 11. Binary Search\n        # 12. Two Pointers\n        # 13. Sliding Window\n        # 14. Divide and Conquer\n        # 15. Recursion\n        # 16. Memoization\n        # 17. Backtracking\n        # 18. Sorting\n        # 19. Sorting (Advanced)\n        # 20. Graph\n        # 21. Binary Search Tree\n        # 22. Segment Tree\n        # 23. Union Find\n        # 24. Hash Table\n        # 25. Hash Function\n        # 26. Math\n        # 27. Math (Advanced)\n        # 28. Math (Advanced)\n        # 29. Math (Advanced)\n        # 30. Math (Advanced)\n        # 31. Math (Advanced)\n        # 32. Math (Advanced)\n        # 33. Math (Advanced)\n        # 34. Math (Advanced)\n        # 35. Math (Advanced)\n        # 36. Math (Advanced)\n        # 37. Math (Advanced)\n        # 38. Math (Advanced)\n        # 39. Math (Advanced)\n        # 40. Math (Advanced)\n        # 41. Math (Advanced)\n        # 42. Math (Advanced)\n        # 43. Math (Advanced)\n        # 44. Math (Advanced)\n        # 45. Math (Advanced)\n        # 46. Math (Advanced)\n        # 47. Math (Advanced)\n        # 48. Math (Advanced)\n        # 49. Math (Advanced)\n        # 50. Math (Advanced)\n        # 51. Math (Advanced)\n        # 52. Math (Advanced)\n        # 53. Math (Advanced)\n        # 54. Math (Advanced)\n        # 55. Math (Advanced)\n        # 56. Math (Advanced)\n        # 57. Math (Advanced)\n        # 58. Math (Advanced)\n        # 59. Math (Advanced)\n        # 60. Math (Advanced)\n        # 61. Math (Advanced)\n        # 62. Math (Advanced)\n        # 63. Math (Advanced)\n        # 64. Math (Advanced)\n        # 65. Math (Advanced)\n        # 66. Math (Advanced)\n        # 67. Math (Advanced)\n        # 68. Math (Advanced)\n        # 69. Math (Advanced)\n        # 70. Math (Advanced)\n        # 71. Math (Advanced)\n        # 72. Math (Advanced)\n        # 73. Math (Advanced)\n        # 74. Math (Advanced)\n        # 75. Math (Advanced)\n        # 76. Math (Advanced)\n        # 77. Math (Advanced)\n        # 78. Math (Advanced)\n        # 79. Math (Advanced)\n        # 80. Math (Advanced)\n        # 81. Math (Advanced)\n        # 82. Math (Advanced)\n        # 83. Math (Advanced)\n        # 84. Math (Advanced)\n        # 85. Math (Advanced)\n        # 86. Math (Advanced)\n        # 87. Math (Advanced)\n        # 88. Math (Advanced)\n        # 89. Math (Advanced)\n        # 90. Math (Advanced)\n        # 91"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i + j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res) - 1):\n            res[i + 1] += res[i] / 10\n            res[i] %= 10\n            \n        res = map(str, res)\n        \n        while len(res) > 1 and res[-1] == '0':\n            res.pop()\n            \n        return ''.join(res[::-1])"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, nums, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in xrange(start, len(nums)):\n            if nums[i] > target:\n                break\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper() and word[0].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        while root or stack:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                res.append(root.val)\n                root = root.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. find the left and right parentheses\n        # 2. remove the left parentheses\n        # 3. remove the right parentheses\n        # 4. repeat 2 and 3 until the left and right parentheses are equal\n        # 5. return the list\n        \n        # 1. find the left and right parentheses\n        left_count = 0\n        right_count = 0\n        for c in s:\n            if c == '(':\n                left_count += 1\n            elif c == ')':\n                if left_count > 0:\n                    left_count -= 1\n                else:\n                    right_count += 1\n        # 2. remove the left parentheses\n        left_list = []\n        self.dfs(s, 0, left_count, 0, left_list)\n        # 3. remove the right parentheses\n        right_list = []\n        self.dfs(s[::-1], 0, right_count, 0, right_list)\n        # 4. repeat 2 and 3 until the left and right parentheses are equal\n        left_list.sort()\n        right_list.sort(reverse=True)\n        # 5. return the list\n        return left_list if left_list[0] == right_list[0] else right_list\n        \n    def dfs(self, s, start, left_count, right_count, list):\n        if left_count == 0 and right_count == 0:\n            if self.is_valid(s):\n                list.append(s)\n            return\n        for i in range(start, len(s)):\n            if i > start and s[i] == s[i - 1]:\n                continue\n            if s[i] == '(':\n                if left_count > 0:\n                    self.dfs(s[:i] + s[i + 1:], i, left_count - 1, right_count, list)\n            elif s[i] == ')':\n                if right_count > 0:\n                    self.dfs(s[:i] + s[i + 1:], i, left_count, right_count - 1, list)\n\n    def is_valid(self, s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                if count > 0:\n                    count -= 1\n                else:\n                    return False\n        return count == 0"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a min heap\n        # 2. iterate through the lists\n        # 3. add the head of each list to the min heap\n        # 4. pop the min node from the min heap\n        # 5. add the next node of the popped node to the min heap\n        # 6. repeat step 4 until all the lists are empty\n        # 7. return the head of the min heap\n        \n        import heapq\n        min_heap = []\n        for l in lists:\n            if l:\n                heapq.heappush(min_heap, (l.val, l))\n        \n        dummy = ListNode()\n        curr = dummy\n        while min_heap:\n            val, node = heapq.heappop(min_heap)\n            curr.next = node\n            curr = curr.next\n            if curr.next:\n                heapq.heappush(min_heap, (curr.next.val, curr.next))\n        \n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^n <= k <= 10^n+1\n        # 2. 10^n <= k <= 10^n+1\n        # 3. 10^n <= k <= 10^n+1\n        # 4. 10^n <= k <= 10^n+1\n        # 5. 10^n <= k <= 10^n+1\n        # 6. 10^n <= k <= 10^n+1\n        # 7. 10^n <= k <= 10^n+1\n        # 8. 10^n <= k <= 10^n+1\n        # 9. 10^n <= k <= 10^n+1\n        # 10. 10^n <= k <= 10^n+1\n        # 11. 10^n <= k <= 10^n+1\n        # 12. 10^n <= k <= 10^n+1\n        # 13. 10^n <= k <= 10^n+1\n        # 14. 10^n <= k <= 10^n+1\n        # 15. 10^n <= k <= 10^n+1\n        # 16. 10^n <= k <= 10^n+1\n        # 17. 10^n <= k <= 10^n+1\n        # 18. 10^n <= k <= 10^n+1\n        # 19. 10^n <= k <= 10^n+1\n        # 20. 10^n <= k <= 10^n+1\n        # 21. 10^n <= k <= 10^n+1\n        # 22. 10^n <= k <= 10^n+1\n        # 23. 10^n <= k <= 10^n+1\n        # 24. 10^n <= k <= 10^n+1\n        # 25. 10^n <= k <= 10^n+1\n        # 26. 10^n <= k <= 10^n+1\n        # 27. 10^n <= k <= 10^n+1\n        # 28. 10^n <= k <= 10^n+1\n        # 29. 10^n <= k <= 10^n+1\n        # 30. 10^n <= k <= 10^n+1\n        # 31. 10^n <= k <= 10^n+1\n        # 32. 10^n <= k <= 10^n+1\n        # 33. 10^n <= k <= 10^n+1\n        # 34. 10^n <= k <= 10^n+1\n        # 35. 10^n <= k <= 10^n+1\n        # 36. 10^n <= k <= 10^n+1\n        # 37. 10^n <= k <= 10^n+1\n        # 38. 10^n <= k <= 10^n+1\n        # 39. 10^n <= k <= 10^n+1\n        # 40. 10^n <= k <= 10^n+1\n        # 41. 10^n <= k <= 10^n+1\n        # 42. 10^n <= k <= 10^n+1\n        # 43. 10^n <= k <= 10^n+1\n        # 44. 10^n <= k <= 10^n+1\n        # 45. 10^n <= k <= 10^n+1\n        # 46. 10^n <= k <= 10^n+1\n        # 47. 10^n <= k <= 10^n+1\n        # 48. 10^n <= k <= 10^n+1\n        # 49. 10^n <= k <= 10^n+1\n        # 5"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a hashmap for words\n        word_map = {word: i for i, word in enumerate(words)}\n        \n        # build a hashmap for reversed words\n        reverse_map = {v: k for k, v in word_map.items()}\n        \n        # build a result list\n        result = []\n        \n        # iterate over words\n        for i, word in enumerate(words):\n            # reverse the word\n            rev_word = word[::-1]\n            \n            # if the reversed word is in the hashmap, then we have a palindrome pair\n            if rev_word in word_map and word_map[rev_word] != i:\n                result.append([i, word_map[rev_word]])\n                \n            # if the word is a palindrome, then we have a palindrome pair with itself\n            if word in reverse_map and reverse_map[word] != i:\n                result.append([i, reverse_map[word]])\n                \n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        def spread(i, j):\n            if isInfected[i][j] == 1:\n                isInfected[i][j] = 2\n                for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                    if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 1:\n                        spread(x, y)\n        ans = 0\n        while True:\n            infected = set()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        spread(i, j)\n                        infected.add((i, j))\n            if not infected:\n                break\n            ans += 1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 2:\n                        isInfected[i][j] = 3\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 3:\n                        isInfected[i][j] = 1\n        return ans"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                res = max(res, self.dfs(matrix, dp, i, j))\n        \n        return res\n    \n    def dfs(self, matrix, dp, i, j):\n        if not dp[i][j]:\n            m, n = len(matrix), len(matrix[0])\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], self.dfs(matrix, dp, x, y))\n            dp[i][j] += 1\n        \n        return dp[i][j]"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 1:\n            return 0\n        if n < 10:\n            return 1\n        \n        # 10^i * i\n        i = 1\n        while n // (10 ** i) > 0:\n            i += 1\n        \n        # 10^i * i - 10^(i-1)\n        # 10^(i-1) * i\n        # 10^(i-1) * i + (n - 10^i * i + 1)\n        # 10^(i-1) * i + (n - 10^i * i)\n        # 10^(i-1) * i + (n - 10^i * i) + (n - 10^i * i - 10^(i-1) + 1)\n        # 10^(i-1) * i + (n - 10^i * i) + (n - 10^i * i - 10^(i-1))\n        # 10^(i-1) * i + (n - 10^i * i) + (n - 10^i * i - 10^(i-1)) + (n - 10^i * i - 10^(i-1) - 1)\n        # 10^(i-1) * i + (n - 10^i * i) + (n - 10^i * i - 10^(i-1)) + (n - 10^i * i - 10^(i-1) - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1)\n        # 10^(i-1) * i + (n - 10^i * i) + (n - 10^i * i - 10^(i-1)) + (n - 10^i * i - 10^(i-1) - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1 - 1)\n        # 10^(i-1) * i + (n - 10^i * i) + (n - 10^i * i - 10^(i-1)) + (n - 10^i * i - 10^(i-1) - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1 - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1 - 1 - 1)\n        # 10^(i-1) * i + (n - 10^i * i) + (n - 10^i * i - 10^(i-1)) + (n - 10^i * i - 10^(i-1) - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1 - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1 - 1 - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1 - 1 - 1 - 1)\n        # 10^(i-1) * i + (n - 10^i * i) + (n - 10^i * i - 10^(i-1)) + (n - 10^i * i - 10^(i-1) - 1) + (n - 10^i * i - 10^(i-1) - 1 - 1) + (n - 10"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        left_to_right = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(level)\n            left_to_right = not left_to_right\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return '%d:%02d' % (h, m)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m - 1), get_time(h + 2, m - 2), get_time(h + 3, m - 3), get_time(h + 4, m - 4), get_time(h + 5, m - 5), get_time(h + 6, m - 6), get_time(h + 7, m - 7), get_time(h + 8, m - 8), get_time(h + 9, m - 9)]\n        \n        if turnedOn == 0:\n            return []\n        if turnedOn > 10:\n            return []\n        \n        times = []\n        for h in range(12):\n            m = turnedOn - h\n            if m < 0:\n                break\n            times.extend(get_times(h, m))\n        return times"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        for i in range(2, numRows):\n            tmp = [1]\n            for j in range(1, len(res[-1])):\n                tmp.append(res[-1][j] + res[-1][j-1])\n            tmp.append(1)\n            res.append(tmp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set((0, 0)) | set((m-1, n-1))\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for ni, nj in (i-1, j), (i+1, j), (i, j-1), (i, j+1):\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                    ans += max(0, h - heightMap[ni][nj])\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n                    seen.add((ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the median\n        # 3. return the median\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. find the median\n        if len(nums) % 2 == 1:\n            return float(nums[len(nums) // 2])\n        else:\n            return (nums[len(nums) // 2] + nums[len(nums) // 2 - 1]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k % length - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = head\n        for i in range(length - k % length):\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        # 2. use a stack to store the heights of the current tallest stack\n        # 3. use a dict to store the heights of the current tallest stack\n        # 4. use a set to store the heights of the current tallest stack\n        # 5. use a dict to store the heights of the current tallest stack\n        # 6. use a set to store the heights of the current tallest stack\n        # 7. use a dict to store the heights of the current tallest stack\n        # 8. use a set to store the heights of the current tallest stack\n        # 9. use a dict to store the heights of the current tallest stack\n        # 10. use a set to store the heights of the current tallest stack\n        # 11. use a dict to store the heights of the current tallest stack\n        # 12. use a set to store the heights of the current tallest stack\n        # 13. use a dict to store the heights of the current tallest stack\n        # 14. use a set to store the heights of the current tallest stack\n        # 15. use a dict to store the heights of the current tallest stack\n        # 16. use a set to store the heights of the current tallest stack\n        # 17. use a dict to store the heights of the current tallest stack\n        # 18. use a set to store the heights of the current tallest stack\n        # 19. use a dict to store the heights of the current tallest stack\n        # 20. use a set to store the heights of the current tallest stack\n        # 21. use a dict to store the heights of the current tallest stack\n        # 22. use a set to store the heights of the current tallest stack\n        # 23. use a dict to store the heights of the current tallest stack\n        # 24. use a set to store the heights of the current tallest stack\n        # 25. use a dict to store the heights of the current tallest stack\n        # 26. use a set to store the heights of the current tallest stack\n        # 27. use a dict to store the heights of the current tallest stack\n        # 28. use a set to store the heights of the current tallest stack\n        # 29. use a dict to store the heights of the current tallest stack\n        # 30. use a set to store the heights of the current tallest stack\n        # 31. use a dict to store the heights of the current tallest stack\n        # 32. use a set to store the heights of the current tallest stack\n        # 33. use a dict to store the heights of the current tallest stack\n        # 34. use a set to store the heights of the current tallest stack\n        # 35. use a dict to store the heights of the current tallest stack\n        # 36. use a set to store the heights of the current tallest stack\n        # 37. use a dict to store the heights of the current tallest stack\n        # 38. use a set to store the heights of the current tallest stack\n        # 39. use a dict to store the heights of the current tallest stack\n        # 40. use a set to store the heights of the current tallest stack\n        # 41. use a dict to store the heights of the current tallest stack\n        # 42. use a set to store the heights of the current tallest stack\n        # 43. use a dict to store the heights of the current tallest stack\n        # 44. use a set to store the heights of the current tallest stack\n        # 45. use a dict to store the heights of the current tallest stack\n        # 46. use a set to store the heights of the current tallest stack\n        # 47. use a dict to store the heights of the current tallest stack\n        # 48. use a set to store the heights of the current tallest stack\n        # 49. use a dict to store the heights of the current tallest stack\n        # 50. use a set to store the heights of the current tallest stack\n        # 51. use a dict to store the heights of the current tallest stack\n        # 52. use a set to store the heights of the current tallest stack"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        ans = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                sums.sort()\n                j = bisect.bisect_left(sums, k - sums[0])\n                if j < m:\n                    ans = max(ans, sums[j] + sums[0] - k)\n                else:\n                    ans = max(ans, sums[-1] - sums[0])\n        return ans"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend / divisor)\n        \n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend) / abs(divisor))\n        \n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend) / abs(divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend) / abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'\n            \n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n            \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n            \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n            \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the number and its index\n        num_dict = {}\n        \n        # iterate through the list\n        for i, num in en\n            # check if the complement is in the dictionary\n            if target - num in num_dict:\n                # return the index of the complement and the current index\n                return [num_dict[target - num], i]\n            # add the number to the dictionary\n            num_dict[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_a, new_b = a + b, a - b\n                        elif op == '-':\n                            new_a, new_b = a - b, b - a\n                        elif op == '*':\n                            new_a, new_b = a * b, a / b\n                        else:\n                            new_a, new_b = b / a, a / b\n                        if backtrack(cards[:i] + [new_a] + cards[i + 1:j] + [new_b] + cards[j + 1:], target):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-beat-96/144600\n        # https://leetcode.com/problems"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for fromi, toi in sorted(tickets):\n            graph[fromi].append(toi)\n        \n        # dfs\n        res = []\n        def dfs(node):\n            # terminator\n            if node not in graph:\n                return\n            \n            # process current node\n            neighbors = graph[node]\n            neighbors.sort()\n            for neighbor in neighbors:\n                graph[node].remove(neighbor)\n                dfs(neighbor)\n            \n            # process current node\n            res.append(node)\n        \n        dfs('JFK')\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l+1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r-1]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. sort the buildings by left edge\n        # 2. use a priority queue to store the heights of the buildings\n        # 3. use a list to store the heights of the skyline\n        # 4. iterate through the buildings\n        # 5. if the current building is taller than the top of the queue, pop the top of the queue\n        # 6. if the current building is shorter than the top of the queue, add the height to the list\n        # 7. if the current building is the same as the top of the queue, add the height to the list\n        # 8. return the list\n        \n        if not buildings:\n            return []\n        \n        buildings.sort(key=lambda x: x[0])\n        pq = [(-buildings[0][2], buildings[0][1])]\n        result = [[0, 0]]\n        \n        for i in range(1, len(buildings)):\n            left, right, height = buildings[i]\n            while pq and pq[0][1] <= left:\n                heapq.heappop(pq)\n            if pq and pq[0][0] < -height:\n                heapq.heappush(pq, (-height, right))\n            if not pq or pq[0][0] > -height:\n                heapq.heappush(pq, (-height, right))\n            if pq[0][0] != -height:\n                result.append([left, -pq[0][0]])\n        \n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # reverse each word\n        for i in range(len(s)):\n            s[i] = s[i][::-1]"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return 'Zero'\n        \n        num_str = str(num)\n        num_len = len(num_str)\n        \n        if num_len < 4:\n            return self.convert_to_words(num_str)\n        \n        if num_len % 3 == 0:\n            num_len_3 = num_len // 3\n        else:\n            num_len_3 = num_len // 3 + 1\n        \n        num_str_3 = num_str[-num_len_3:]\n        num_str_2 = num_str[-num_len_3*2:-num_len_3]\n        num_str_1 = num_str[:-num_len_3*2]\n        \n        return self.convert_to_words(num_str_1) + ' Billion' + self.convert_to_words(num_str_2) + ' Million' + self.convert_to_words(num_str_3)\n        \n    def convert_to_words(self, num_str):\n        if num_str == '0':\n            return ''\n        \n        num_str_len = len(num_str)\n        \n        if num_str_len == 1:\n            return self.convert_to_words_1(num_str)\n        \n        if num_str_len == 2:\n            return self.convert_to_words_2(num_str)\n        \n        if num_str_len == 3:\n            return self.convert_to_words_3(num_str)\n        \n    def convert_to_words_1(self, num_str):\n        if num_str[0] == '1':\n            return ' One'\n        \n        if num_str[0] == '2':\n            return ' Two'\n        \n        if num_str[0] == '3':\n            return ' Three'\n        \n        if num_str[0] == '4':\n            return ' Four'\n        \n        if num_str[0] == '5':\n            return ' Five'\n        \n        if num_str[0] == '6':\n            return ' Six'\n        \n        if num_str[0] == '7':\n            return ' Seven'\n        \n        if num_str[0] == '8':\n            return ' Eight'\n        \n        if num_str[0] == '9':\n            return ' Nine'\n        \n    def convert_to_words_2(self, num_str):\n        if num_str[0] == '0':\n            return ''\n        \n        if num_str[0] == '1':\n            return ' Ten'\n        \n        if num_str[0] == '2':\n            return ' Twenty'\n        \n        if num_str[0] == '3':\n            return ' Thirty'\n        \n        if num_str[0] == '4':\n            return ' Forty'\n        \n        if num_str[0] == '5':\n            return ' Fifty'\n        \n        if num_str[0] == '6':\n            return ' Sixty'\n        \n        if num_str[0] == '7':\n            return ' Seventy'\n        \n        if num_str[0] == '8':\n            return ' Eighty'\n        \n        if num_str[0] == '9':\n            return ' Ninety'\n        \n    def convert_to_words_3(self, num_str):\n        if num_str[0] == '0':\n            return ''\n        \n        if num_str[0] == '1':\n            return ' One Hundred'\n        \n        if num_str[0] == '2':\n            return ' Two Hundred'\n        \n        if num_str[0] == '3':\n            return ' Three Hundred'\n        \n        if num_str[0] == '4':\n            return ' Four Hundred'\n        \n        if num_str[0] == '5':\n            return ' Five Hundred'\n        \n        if num_str[0] == '6':\n            return ' Six Hundred'\n        \n        if num_str[0] == '7':\n            return ' Seven Hundred'\n        \n        if num_str["}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] - dp[i-k-1][j-1]\n        # dp[i][j] = dp[i][j-1] - dp[i-k-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1] + dp[i-k-1][j-2]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-1][j-3]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-1][j-3] + dp[i-k-1][j-4]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-1][j-3] + dp[i-k-1][j-4] - dp[i-k-1][j-5]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-1][j-3] + dp[i-k-1][j-4] - dp[i-k-1][j-5] + dp[i-k-1][j-6]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-1][j-3] + dp[i-k-1][j-4] - dp[i-k-1][j-5] + dp[i-k-1][j-6] - dp[i-k-1][j-7]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-1][j-3] + dp[i-k-1][j-4] - dp[i-k-1][j-5] + dp[i-k-1][j-6] - dp[i-k-1][j-7] + dp[i-k-1][j-8]\n        # dp[i][j] = dp[i][j-1] + dp[i-k-1][j] - dp[i-k-1][j-1] + dp[i-k-1][j-2] - dp[i-k-1][j-3] + dp[i-k-1][j-4] - dp[i-k-1][j-5] + dp[i-k-1][j-6] - dp[i-k-1][j-7] + dp[i"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the edge that connects the two nodes\n        # 3. find the node that has the edge\n        # 4. find the edge that connects the two nodes\n        \n        # 1. find the node with two parents\n        parent_map = {}\n        for edge in edges:\n            if edge[0] not in parent_map:\n                parent_map[edge[0]] = edge[1]\n            else:\n                parent = parent_map[edge[0]]\n                if parent != edge[1]:\n                    return [parent, edge[1]]\n                else:\n                    return [edge[0], edge[1]]\n        \n        # 2. find the edge that connects the two nodes\n        for edge in edges:\n            if edge[0] not in parent_map and edge[1] not in parent_map:\n                return edge\n        \n        # 3. find the node that has the edge\n        for edge in edges:\n            if edge[0] in parent_map and edge[1] not in parent_map:\n                return edge\n        \n        # 4. find the edge that connects the two nodes\n        for edge in edges:\n            if edge[0] in parent_map and edge[1] in parent_map:\n                return edge\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        elif num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2*sum(set(nums))-sum(nums)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 28 ms, faster than 99.55% of Python online submissions for Length of Last Word.\n        ## Memory Usage: 13.9 MB, less than 99.55% of Python online submissions for Length of Last Word.\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n            dp[0][i] = dp[0][i - 1] + grid[0][i]\n        for i in range(1, n):\n            for j in range(1, n):\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n                if i + j != n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]) + grid[i][j]\n                    dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j])\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + grid[i][j])\n        return max(dp[n - 1][n - 1], 0)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        \n        for j in range(1, n):\n            grid[0][j] += grid[0][j-1]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211'\n        \n        if n == 13:\n            return '13211311123113112211'\n        \n        if n == 14:\n            return '111312211331121321332211'\n        \n        if n == 15:\n            return '31131122212321322211'\n        \n        if n == 16:\n            return '13211311123113112211'\n        \n        if n == 17:\n            return '111312211331121321332211'\n        \n        if n == 18:\n            return '31131122212321322211'\n        \n        if n == 19:\n            return '13211311123113112211'\n        \n        if n == 20:\n            return '111312211331121321332211'\n        \n        if n == 21:\n            return '31131122212321322211'\n        \n        if n == 22:\n            return '13211311123113112211'\n        \n        if n == 23:\n            return '111312211331121321332211'\n        \n        if n == 24:\n            return '31131122212321322211'\n        \n        if n == 25:\n            return '13211311123113112211'\n        \n        if n == 26:\n            return '111312211331121321332211'\n        \n        if n == 27:\n            return '31131122212321322211'\n        \n        if n == 28:\n            return '13211311123113112211'\n        \n        if n == 29:\n            return '111312211331121321332211'\n        \n        if n == 30:\n            return '31131122212321322211'\n        \n        if n == 31:\n            return '13211311123113112211'\n        \n        if n == 32:\n            return '111312211331121321332211'\n        \n        if n == 33:"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max sum of the subarray\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum\n        # find the max sum of the subarray\n        # binary search the max sum\n        # find the min sum of the subarray\n        # binary search the min sum"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] < nums[right]:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def dfs(digits, index, path, res):\n            if index == len(digits):\n                res.append(path)\n                return\n            \n            for letter in digit_to_letters[digits[index]]:\n                dfs(digits, index + 1, path + letter, res)\n        \n        res = []\n        dfs(digits, 0, '', res)\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of n\n        length = len(n)\n        \n        # 2. get the left and right part of n\n        left = n[:length//2]\n        right = n[length//2:]\n        \n        # 3. get the left and right part of n\n        left_num = int(left)\n        right_num = int(right)\n        \n        # 4. get the closest palindrome\n        closest_palindrome = self.get_closest_palindrome(left_num, right_num)\n        \n        # 5. return the closest palindrome\n        return str(closest_palindrome)\n    \n    def get_closest_palindrome(self, left_num, right_num):\n        \"\"\"\n        :type left_num: int\n        :type right_num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. get the closest palindrome\n        closest_palindrome = None\n        \n        # 2. get the closest palindrome\n        if left_num - 1 >= 0:\n            closest_palindrome = min(left_num - 1, closest_palindrome)\n        if right_num + 1 <= 9:\n            closest_palindrome = min(right_num + 1, closest_palindrome)\n        \n        # 3. return the closest palindrome\n        return closest_palindrome"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if sign * rev < -2**31 or sign * rev > 2**31 - 1:\n            return 0\n        else:\n            return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n // 2):\n            for j in range(i, n - i - 1):\n                matrix[i][j], matrix[j][n - i - 1], matrix[n - i - 1][n - j - 1], matrix[n - j - 1][i] = matrix[n - j - 1][i], matrix[i][j], matrix[j][n - i - 1], matrix[n - i - 1][n - j - 1]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a hashmap\n        score_hashmap = {}\n        for i, s in enumerate(score_sorted):\n            score_hashmap[s] = i\n        \n        # create the output list\n        output = [None] * len(score)\n        for i, s in enumerate(score):\n            if i == 0:\n                output[score_hashmap[s]] = \"Gold Medal\"\n            elif i == 1:\n                output[score_hashmap[s]] = \"Silver Medal\"\n            elif i == 2:\n                output[score_hashmap[s]] = \"Bronze Medal\"\n            else:\n                output[score_hashmap[s]] = str(i + 1)\n        \n        return output"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        cur_len = 0\n        cur_str = ''\n        for c in s:\n            if c not in cur_str:\n                cur_len += 1\n            else:\n                max_len = max(max_len, cur_len)\n                cur_str = cur_str[cur_str.index(c) + 1:] + c\n                cur_len = len(cur_str)\n            cur_str += c\n        return max(max_len, cur_len)"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_num = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            right = i\n            word_count = collections.Counter()\n            while right + word_len <= len(s):\n                word = s[right:right + word_len]\n                right += word_len\n                if word in word_dict:\n                    word_count[word] += 1\n                    while word_count[word] > word_dict[word]:\n                        word_count[s[left:left + word_len]] -= 1\n                        left += word_len\n                if right - left == word_len * word_num:\n                    res.append(left)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        cur = head\n        while cur:\n            if cur.next and cur.val > cur.next.val:\n                prev = dummy\n                while prev.next.val < cur.next.val:\n                    prev = prev.next\n                cur.next, cur.next.next, prev.next = cur.next.next, cur.next, prev.next\n            else:\n                cur = cur.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            nums[left:right + 1] = sorted(nums[left:right + 1])\n            return count\n        \n        def merge_sort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = merge_sort(nums, left, mid) + merge_sort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return merge_sort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return (sx == tx and sy <= ty) or (sy == ty and sx <= tx)"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i >= len(v1):\n                if v2[i] > 0:\n                    return -1\n            elif i >= len(v2):\n                if v1[i] > 0:\n                    return 1\n            else:\n                if v1[i] > v2[i]:\n                    return 1\n                elif v1[i] < v2[i]:\n                    return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for duration, end in courses:\n            # add course to queue\n            heapq.heappush(pq, -duration)\n            \n            # add course to total time\n            total += duration\n            \n            # if total time exceeds end date\n            if total > end:\n                # remove course from queue\n                total += heapq.heappop(pq)\n                \n        # return length of queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while True:\n            tail = prev\n            for i in range(k):\n                if not tail:\n                    return dummy.next\n                tail = tail.next\n            head = prev.next\n            tail = head.next\n            for i in range(k):\n                head.next, head = prev.next, head.next\n            prev.next.next, prev.next = tail, tail\n            prev = head\n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. if s is empty, return False\n        if not s:\n            return False\n        \n        # 2. if s is not a palindrome, return False\n        if len(s) < 2:\n            return False\n        \n        # 3. if s is a palindrome, return True\n        if s == s[::-1]:\n            return True\n        \n        # 4. if s is not a palindrome, check if s is a substring of itself\n        return s in s[1:] + s[:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] * 2 * (4i - 2) / (i + 1)\n        # dp[i] = dp[i-1] * 2 * (4i - 1) / (i + 1)\n        # dp[i] = dp[i-1] * 2 * (4i - 2) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 3) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 4) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 5) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 6) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 7) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 8) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 9) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 10) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 11) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 12) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 13) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 14) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 15) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 16) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 17) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 18) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 19) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 20) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 21) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 22) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 23) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 24) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 25) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 26) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 27) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 28) / (i + 2)\n        # dp[i] = dp[i-1] * 2 * (4i - 29) / (i + 2)\n        # dp[i] = dp[i-1"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use set to store the number\n        ## 2. use set to store the number\n        ## 3. use set to store the number\n        ## 4. use set to store the number\n        ## 5. use set to store the number\n        ## 6. use set to store the number\n        ## 7. use set to store the number\n        ## 8. use set to store the number\n        ## 9. use set to store the number\n        ## 10. use set to store the number\n        ## 11. use set to store the number\n        ## 12. use set to store the number\n        ## 13. use set to store the number\n        ## 14. use set to store the number\n        ## 15. use set to store the number\n        ## 16. use set to store the number\n        ## 17. use set to store the number\n        ## 18. use set to store the number\n        ## 19. use set to store the number\n        ## 20. use set to store the number\n        ## 21. use set to store the number\n        ## 22. use set to store the number\n        ## 23. use set to store the number\n        ## 24. use set to store the number\n        ## 25. use set to store the number\n        ## 26. use set to store the number\n        ## 27. use set to store the number\n        ## 28. use set to store the number\n        ## 29. use set to store the number\n        ## 30. use set to store the number\n        ## 31. use set to store the number\n        ## 32. use set to store the number\n        ## 33. use set to store the number\n        ## 34. use set to store the number\n        ## 35. use set to store the number\n        ## 36. use set to store the number\n        ## 37. use set to store the number\n        ## 38. use set to store the number\n        ## 39. use set to store the number\n        ## 40. use set to store the number\n        ## 41. use set to store the number\n        ## 42. use set to store the number\n        ## 43. use set to store the number\n        ## 44. use set to store the number\n        ## 45. use set to store the number\n        ## 46. use set to store the number\n        ## 47. use set to store the number\n        ## 48. use set to store the number\n        ## 49. use set to store the number\n        ## 50. use set to store the number\n        ## 51. use set to store the number\n        ## 52. use set to store the number\n        ## 53. use set to store the number\n        ## 54. use set to store the number\n        ## 55. use set to store the number\n        ## 56. use set to store the number\n        ## 57. use set to store the number\n        ## 58. use set to store the number\n        ## 59. use set to store the number\n        ## 60. use set to store the number\n        ## 61. use set to store the number\n        ## 62. use set to store the number\n        ## 63. use set to store the number\n        ## 64. use set to store the number\n        ## 65. use set to store the number\n        ## 66. use set to store the number\n        ## 67. use set to store the number\n        ## 68. use set to store the number\n        ## 69. use set to store the number\n        ## 70. use set to store the number\n        ## 71. use set to store the number\n        ## 72. use set to store the number\n        ## 73. use set to store the number\n        ## 74. use set to store"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict for each sticker\n        # 2. build a dict for each letter in target\n        # 3. for each letter in target, find the min stickers needed to form the target\n        # 4. return the min stickers needed to form the target\n        \n        # 1. build a dict for each sticker\n        sticker_dict = {}\n        for sticker in stickers:\n            sticker_dict[sticker] = {}\n            for letter in sticker:\n                sticker_dict[sticker][letter] = sticker_dict[sticker].get(letter, 0) + 1\n        \n        # 2. build a dict for each letter in target\n        target_dict = {}\n        for letter in target:\n            target_dict[letter] = target_dict.get(letter, 0) + 1\n        \n        # 3. for each letter in target, find the min stickers needed to form the target\n        # 4. return the min stickers needed to form the target\n        return self.helper(target_dict, sticker_dict)\n    \n    def helper(self, target_dict, sticker_dict):\n        # base case\n        if not target_dict:\n            return 0\n        \n        # recursive case\n        min_stickers = float('inf')\n        for letter, sticker_count in target_dict.items():\n            if sticker_count > 0:\n                for sticker, sticker_count in sticker_dict.items():\n                    if letter in sticker:\n                        sticker_dict[sticker][letter] -= 1\n                        if sticker_dict[sticker][letter] == 0:\n                            del sticker_dict[sticker][letter]\n                        if not sticker_dict[sticker]:\n                            del sticker_dict[sticker]\n                        min_stickers = min(min_stickers, self.helper(target_dict, sticker_dict) + 1)\n                        sticker_dict[sticker][letter] += 1\n                if not sticker_dict:\n                    return min_stickers\n            else:\n                return float('inf')\n        return min_stickers"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to map roman numerals to their integer values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # Initialize the result to the last value in the dictionary\n        result = roman_dict[s[-1]]\n        \n        # Iterate over the string in reverse order\n        for i in range(len(s) - 2, -1, -1):\n            # If the current value is less than the next value, subtract it\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # Otherwise, add it\n            else:\n                result += roman_dict[s[i]]\n        \n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        q = collections.deque()\n        res = []\n        \n        for i in range(len(nums)):\n            while q and q[0] < i - k + 1:\n                q.popleft()\n            \n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            \n            q.append(i)\n            \n            if i >= k - 1:\n                res.append(nums[q[0]])\n        \n        return res"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # 1. merge nums1 and nums2\n        # 2. find median\n        # 3. return median\n        \n        # 1. merge nums1 and nums2\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # 2. find median\n        if len(nums1) % 2 == 1:\n            median = nums1[len(nums1) // 2]\n        else:\n            median = (nums1[len(nums1) // 2 - 1] + nums1[len(nums1) // 2]) / 2.0\n        \n        # 3. return median\n        return median"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot point\n        # 2. find the min in the left part\n        # 3. find the min in the right part\n        # 4. compare the two\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 <= area <= 10^9\n        # 2. area is a perfect square\n        # 3. area is a multiple of 4\n        # 4. area is a multiple of 6\n        # 5. area is a multiple of 8\n        # 6. area is a multiple of 12\n        # 7. area is a multiple of 16\n        # 8. area is a multiple of 20\n        # 9. area is a multiple of 24\n        # 10. area is a multiple of 28\n        # 11. area is a multiple of 32\n        # 12. area is a multiple of 36\n        # 13. area is a multiple of 40\n        # 14. area is a multiple of 44\n        # 15. area is a multiple of 48\n        # 16. area is a multiple of 52\n        # 17. area is a multiple of 56\n        # 18. area is a multiple of 60\n        # 19. area is a multiple of 64\n        # 20. area is a multiple of 68\n        # 21. area is a multiple of 72\n        # 22. area is a multiple of 76\n        # 23. area is a multiple of 80\n        # 24. area is a multiple of 84\n        # 25. area is a multiple of 88\n        # 26. area is a multiple of 92\n        # 27. area is a multiple of 96\n        # 28. area is a multiple of 100\n        # 29. area is a multiple of 104\n        # 30. area is a multiple of 108\n        # 31. area is a multiple of 112\n        # 32. area is a multiple of 116\n        # 33. area is a multiple of 120\n        # 34. area is a multiple of 124\n        # 35. area is a multiple of 128\n        # 36. area is a multiple of 132\n        # 37. area is a multiple of 136\n        # 38. area is a multiple of 140\n        # 39. area is a multiple of 144\n        # 40. area is a multiple of 148\n        # 41. area is a multiple of 152\n        # 42. area is a multiple of 156\n        # 43. area is a multiple of 160\n        # 44. area is a multiple of 164\n        # 45. area is a multiple of 168\n        # 46. area is a multiple of 172\n        # 47. area is a multiple of 176\n        # 48. area is a multiple of 180\n        # 49. area is a multiple of 184\n        # 50. area is a multiple of 188\n        # 51. area is a multiple of 192\n        # 52. area is a multiple of 196\n        # 53. area is a multiple of 200\n        # 54. area is a multiple of 204\n        # 55. area is a multiple of 208\n        # 56. area is a multiple of 212\n        # 57. area is a multiple of 216\n        # 58. area is a multiple of 220\n        # 59. area is a multiple of 224\n        # 60. area is a multiple of 228\n        # 61. area is a multiple of 232\n        # 62. area is a multiple of 236\n        # 63. area is a multiple of 240\n        # 64. area is a multiple of 244\n        # 65. area is a multiple of 248\n        # 66. area is a multiple of 252\n        # 67. area is a"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build a queue and a set to record the shortest path\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        found = False\n        res = []\n        \n        # BFS\n        while queue:\n            # if the endWord is found, we can stop the BFS\n            if endWord in visited:\n                found = True\n                break\n            \n            # get the current level of the queue\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                \n                # get all the neighbors of the current word\n                for i in range(len(word)):\n                    for j in range(26):\n                        neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                        for nbr in graph[neighbor]:\n                            if nbr not in visited:\n                                visited.add(nbr)\n                                queue.append(nbr)\n            \n            # if the endWord is found, we can stop the BFS\n            if endWord in visited:\n                found = True\n                break\n        \n        # if the endWord is not found, we can return an empty list\n        if not found:\n            return res\n        \n        # BFS to find the shortest path\n        while queue:\n            # get the current level of the queue\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                \n                # if the endWord is found, we can stop the BFS\n                if endWord in word:\n                    found = True\n                    break\n                \n                # get all the neighbors of the current word\n                for i in range(len(word)):\n                    for j in range(26):\n                        neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                        for nbr in graph[neighbor]:\n                            if nbr not in visited:\n                                visited.add(nbr)\n                                queue.append(nbr)\n            \n            # if the endWord is found, we can stop the BFS\n            if endWord in visited:\n                found = True\n                break\n        \n        # if the endWord is not found, we can return an empty list\n        if not found:\n            return res\n        \n        # build the shortest path\n        path = [endWord]\n        while path[-1] != beginWord:\n            for nbr in graph[path[-1]]:\n                if nbr in visited:\n                    path.append(nbr)\n                    break\n        \n        # reverse the path to get the shortest path\n        path.reverse()\n        \n        # build the result\n        res.append(path)\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]] + r for r in res]\n            else:\n                res += [nums[i]] + [r[:] for r in res if r[:] != nums[i]]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u66b4\u529b\u6cd5\n        # 2. \u5355\u8c03\u6808\n        # 3. \u53cc\u6307\u9488\n        # 4. \u4e8c\u5206\u67e5\u627e\n        # 5. \u5355\u8c03\u6808 + \u53cc\u6307\u9488\n        # 6. \u5355\u8c03\u6808 + \u4e8c\u5206\u67e5\u627e\n        # 7. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e\n        # 8. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 9. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 10. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 11. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 12. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 13. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 14. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 15. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 16. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 17. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 18. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 19. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 20. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e\n        # 21. \u5355\u8c03\u6808 + \u53cc\u6307\u9488 + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e + \u4e8c\u5206\u67e5\u627e +"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(float(first) / second))\n        return stack.pop()"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        return area == (x_max - x_min) * (y_max - y_min) and area == (x_max - x_min) * (y_max - y_min) - sum(map(lambda x: (x[2] - x[0]) * (x[3] - x[1]), rectangles))"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a number\n        num = 0\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                num = num * 10 + board[i][j]\n        \n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number\n        # convert board to a number"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot point\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        pivot = left\n        \n        # find the target\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            real_mid = (mid + pivot) % len(nums)\n            if nums[real_mid] == target:\n                return True\n            elif nums[real_mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not obstacleGrid:\n            return 0\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        \n        dp = [0] * n\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                elif j == 0:\n                    dp[j] = 1\n                elif i == 0:\n                    dp[j] = 1\n                else:\n                    dp[j] = dp[j] + dp[j-1]\n        \n        return dp[-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        res = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == target:\n                    return s\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s > target:\n                    r -= 1\n                else:\n                    l += 1\n        return res"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        prev = None\n        min_diff = float('inf')\n        for n in inorder(root):\n            if prev:\n                min_diff = min(min_diff, n - prev)\n            prev = n\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.res = []\n        self.prev = None\n        self.count = 0\n        \n        self.inorder(root)\n        \n        return self.res\n        \n    def inorder(self, root):\n        if not root:\n            return\n        \n        self.inorder(root.left)\n        \n        if self.prev == root.val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        if self.count > self.max_count:\n            self.max_count = self.count\n            self.res = [root.val]\n        elif self.count == self.max_count:\n            self.res.append(root.val)\n        \n        self.prev = root.val\n        \n        self.inorder(root.right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.res = []\n        self.prev = None\n        self.count = 0\n        \n        self.inorder(root)\n        \n        return self.res\n        \n    def inorder(self, root):\n        if not root:\n            return\n        \n        self.inorder(root.left)\n        \n        if self.prev == root.val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        if self.count > self.max_count:\n            self.max_count = self.count\n            self.res = [root.val]\n        elif self.count == self.max_count:\n            self.res.append(root.val)\n        \n        self.prev = root.val\n        \n        self.inorder(root.right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.res = []\n        self.prev = None\n        self.count = 0\n        \n        self.inorder(root)\n        \n        return self.res\n        \n    def inorder(self, root):\n        if not root:\n            return\n        \n        self.inorder(root.left)\n        \n        if self.prev == root.val:\n            self.count += 1\n        else:\n            self.count = 1\n        \n        if self.count > self.max_count:\n            self.max_count = self.count\n            self.res = [root.val]\n        elif self.count == self.max_count:\n            self.res.append(root.val)\n        \n        self.prev = root.val\n        \n        self.inorder(root.right)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.res = []\n        self.prev = None\n        self.count = 0\n        \n        self.inorder(root)\n        \n        return self.res\n        \n    def inorder(self,"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the length of password\n        # 3. check the length of password\n        # 4. check the length of password\n        # 5. check the length of password\n        # 6. check the length of password\n        # 7. check the length of password\n        # 8. check the length of password\n        # 9. check the length of password\n        # 10. check the length of password\n        # 11. check the length of password\n        # 12. check the length of password\n        # 13. check the length of password\n        # 14. check the length of password\n        # 15. check the length of password\n        # 16. check the length of password\n        # 17. check the length of password\n        # 18. check the length of password\n        # 19. check the length of password\n        # 20. check the length of password\n        # 21. check the length of password\n        # 22. check the length of password\n        # 23. check the length of password\n        # 24. check the length of password\n        # 25. check the length of password\n        # 26. check the length of password\n        # 27. check the length of password\n        # 28. check the length of password\n        # 29. check the length of password\n        # 30. check the length of password\n        # 31. check the length of password\n        # 32. check the length of password\n        # 33. check the length of password\n        # 34. check the length of password\n        # 35. check the length of password\n        # 36. check the length of password\n        # 37. check the length of password\n        # 38. check the length of password\n        # 39. check the length of password\n        # 40. check the length of password\n        # 41. check the length of password\n        # 42. check the length of password\n        # 43. check the length of password\n        # 44. check the length of password\n        # 45. check the length of password\n        # 46. check the length of password\n        # 47. check the length of password\n        # 48. check the length of password\n        # 49. check the length of password\n        # 50. check the length of password\n        # 51. check the length of password\n        # 52. check the length of password\n        # 53. check the length of password\n        # 54. check the length of password\n        # 55. check the length of password\n        # 56. check the length of password\n        # 57. check the length of password\n        # 58. check the length of password\n        # 59. check the length of password\n        # 60. check the length of password\n        # 61. check the length of password\n        # 62. check the length of password\n        # 63. check the length of password\n        # 64. check the length of password\n        # 65. check the length of password\n        # 66. check the length of password\n        # 67. check the length of password\n        # 68. check the length of password\n        # 69. check the length of password\n        # 70. check the length of password\n        # 71. check the length of password\n        # 72. check the length of password\n        # 73. check the length of password\n        # 74. check the length of password\n        # 75. check the length of password\n        # 76. check the length of password\n        # 77. check the length of password\n        # 78. check the length of password\n        # 79. check the length of password\n        # 80. check the length of password\n        # 81. check the length of password\n        # 82. check the length of password\n        # 83. check the length of password\n        # 84. check the length of password\n        # 85. check the length of password\n        # 86. check the length of password"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        return n / 5 + self.trailingZeroes(n / 5)"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [''] * numRows\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return ''.join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1 pass\n        # 3. 2 pass\n        # 4. 3 pass\n        # 5. 4 pass\n        # 6. 5 pass\n        # 7. 6 pass\n        # 8. 7 pass\n        # 9. 8 pass\n        # 10. 9 pass\n        # 11. 10 pass\n        # 12. 11 pass\n        # 13. 12 pass\n        # 14. 13 pass\n        # 15. 14 pass\n        # 16. 15 pass\n        # 17. 16 pass\n        # 18. 17 pass\n        # 19. 18 pass\n        # 20. 19 pass\n        # 21. 20 pass\n        # 22. 21 pass\n        # 23. 22 pass\n        # 24. 23 pass\n        # 25. 24 pass\n        # 26. 25 pass\n        # 27. 26 pass\n        # 28. 27 pass\n        # 29. 28 pass\n        # 30. 29 pass\n        # 31. 30 pass\n        # 32. 31 pass\n        # 33. 32 pass\n        # 34. 33 pass\n        # 35. 34 pass\n        # 36. 35 pass\n        # 37. 36 pass\n        # 38. 37 pass\n        # 39. 38 pass\n        # 40. 39 pass\n        # 41. 40 pass\n        # 42. 41 pass\n        # 43. 42 pass\n        # 44. 43 pass\n        # 45. 44 pass\n        # 46. 45 pass\n        # 47. 46 pass\n        # 48. 47 pass\n        # 49. 48 pass\n        # 50. 49 pass\n        # 51. 50 pass\n        # 52. 51 pass\n        # 53. 52 pass\n        # 54. 53 pass\n        # 55. 54 pass\n        # 56. 55 pass\n        # 57. 56 pass\n        # 58. 57 pass\n        # 59. 58 pass\n        # 60. 59 pass\n        # 61. 60 pass\n        # 62. 61 pass\n        # 63. 62 pass\n        # 64. 63 pass\n        # 65. 64 pass\n        # 66. 65 pass\n        # 67. 66 pass\n        # 68. 67 pass\n        # 69. 68 pass\n        # 70. 69 pass\n        # 71. 70 pass\n        # 72. 71 pass\n        # 73. 72 pass\n        # 74. 73 pass\n        # 75. 74 pass\n        # 76. 75 pass\n        # 77. 76 pass\n        # 78. 77 pass\n        # 79. 78 pass\n        # 80. 79 pass\n        # 81. 80 pass\n        # 82. 81 pass\n        # 83. 82 pass\n        # 84. 83 pass\n        # 85. 84 pass\n        # 86. 85 pass\n        # 87. 86 pass\n        # 88. 87 pass\n        # 89. 88 pass\n        # 90. 89 pass\n        # 91. 90 pass\n        # 92. 91 pass\n        # 93. 92 pass\n        # 94. 93 pass\n        # 95."}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate the array again, if the number is not in the hashmap, add it to the result\n        ## 4. return the result\n        \n        ## 1. use the array as a hashmap to record the number of each number\n        ## 2. iterate the array, if the number is not in the hashmap, add it to the result\n        ## 3. iterate"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. use binary search to find the index of the number in the sorted array\n        # 3. count the number of smaller numbers to the right of the number\n        # 4. return the count\n        \n        # 1. sort the array\n        nums = [(num, i) for i, num in enumerate(nums)]\n        nums.sort()\n        \n        # 2. use binary search to find the index of the number in the sorted array\n        # 3. count the number of smaller numbers to the right of the number\n        # 4. return the count\n        ans = [0] * len(nums)\n        for num, i in nums:\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid][0] >= num:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            ans[i] = left\n        return ans"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = cur = 0\n        for i in intervals:\n            if i[0] > cur:\n                ans += 2\n                cur += 2\n            else:\n                ans += 1\n                cur = min(cur + 1, i[1])\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \u5148\u628a\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u63d0\u53d6\u51fa\u6765\n        # 2. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u63d0\u53d6\u51fa\u6765\n        # 3. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 4. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 5. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 6. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 7. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 8. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 9. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 10. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 11. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 12. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 13. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 14. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 15. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 16. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 17. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 18. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 19. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 20. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 21. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 22. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 23. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 24. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 25. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 26. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 27. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 28. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 29. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 30. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 31. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 32. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 33. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 34. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 35. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 36. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 37. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 38. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 39. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 40. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 41. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 42. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 43. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 44. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 45. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 46. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 47. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 48. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 49. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 50. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 51. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76\n        # 52. \u628a\u62ec\u53f7\u91cc\u7684\u5143\u7d20\u548c\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5408\u5e76"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            left = self.generateParenthesis(i)\n            right = self.generateParenthesis(n - i - 1)\n            for l in left:\n                for r in right:\n                    res.append('({}){}'.format(l, r))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        \n        # iterate\n        while i < len(nums):\n            if nums[i] <= n:\n                n += nums[i]\n                i += 1\n            else:\n                patches += 1\n                if n < nums[i]:\n                    break\n                n += n\n        \n        # return\n        return patches + (i == len(nums))"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return '0'\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        res = []\n        if numerator < 0 == denominator < 0:\n            res.append('-')\n        if numerator < 0:\n            numerator = -numerator\n        if denominator < 0:\n            denominator = -denominator\n        \n        res.append(str(numerator // denominator))\n        numerator %= denominator\n        if numerator == 0:\n            return ''.join(res)\n        \n        res.append('.')\n        seen = {}\n        while numerator:\n            if numerator in seen:\n                res.insert(seen[numerator], '(')\n                res.append(')')\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res.append(str(numerator // denominator))\n            numerator %= denominator\n        \n        return ''.join(res)"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        max_len = 1\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            max_len = max(max_len, dp[i])\n        return max_len"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. 2 pass\n        ## 2. 1 pass\n        ## 3. 1 pass\n        ## 4. 1 pass\n        ## 5. 1 pass\n        ## 6. 1 pass\n        ## 7. 1 pass\n        ## 8. 1 pass\n        ## 9. 1 pass\n        ## 10. 1 pass\n        ## 11. 1 pass\n        ## 12. 1 pass\n        ## 13. 1 pass\n        ## 14. 1 pass\n        ## 15. 1 pass\n        ## 16. 1 pass\n        ## 17. 1 pass\n        ## 18. 1 pass\n        ## 19. 1 pass\n        ## 20. 1 pass\n        ## 21. 1 pass\n        ## 22. 1 pass\n        ## 23. 1 pass\n        ## 24. 1 pass\n        ## 25. 1 pass\n        ## 26. 1 pass\n        ## 27. 1 pass\n        ## 28. 1 pass\n        ## 29. 1 pass\n        ## 30. 1 pass\n        ## 31. 1 pass\n        ## 32. 1 pass\n        ## 33. 1 pass\n        ## 34. 1 pass\n        ## 35. 1 pass\n        ## 36. 1 pass\n        ## 37. 1 pass\n        ## 38. 1 pass\n        ## 39. 1 pass\n        ## 40. 1 pass\n        ## 41. 1 pass\n        ## 42. 1 pass\n        ## 43. 1 pass\n        ## 44. 1 pass\n        ## 45. 1 pass\n        ## 46. 1 pass\n        ## 47. 1 pass\n        ## 48. 1 pass\n        ## 49. 1 pass\n        ## 50. 1 pass\n        ## 51. 1 pass\n        ## 52. 1 pass\n        ## 53. 1 pass\n        ## 54. 1 pass\n        ## 55. 1 pass\n        ## 56. 1 pass\n        ## 57. 1 pass\n        ## 58. 1 pass\n        ## 59. 1 pass\n        ## 60. 1 pass\n        ## 61. 1 pass\n        ## 62. 1 pass\n        ## 63. 1 pass\n        ## 64. 1 pass\n        ## 65. 1 pass\n        ## 66. 1 pass\n        ## 67. 1 pass\n        ## 68. 1 pass\n        ## 69. 1 pass\n        ## 70. 1 pass\n        ## 71. 1 pass\n        ## 72. 1 pass\n        ## 73. 1 pass\n        ## 74. 1 pass\n        ## 75. 1 pass\n        ## 76. 1 pass\n        ## 77. 1 pass\n        ## 78. 1 pass\n        ## 79. 1 pass\n        ## 80. 1 pass\n        ## 81. 1 pass\n        ## 82. 1 pass\n        ## 83. 1 pass\n        ## 84. 1 pass\n        ## 85. 1 pass\n        ## 86. 1 pass\n        ## 87. 1 pass\n        ## 88. 1 pass\n        ## 89. 1 pass\n        ## 90. 1 pass\n        ## 91. 1 pass\n        ## 92. 1 pass\n        ## 93. 1 pass\n        ## 94. 1 pass"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the node to remove\n        if length == n:\n            return head.next\n        \n        # 3. Find the node to remove\n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        curr.next = curr.next.next\n        \n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use collections.Counter\n        ## 4. use collections.defaultdict\n        ## 5. use collections.Counter\n        ## 6. use collections.Counter\n        ## 7. use collections.Counter\n        ## 8. use collections.Counter\n        ## 9. use collections.Counter\n        ## 10. use collections.Counter\n        ## 11. use collections.Counter\n        ## 12. use collections.Counter\n        ## 13. use collections.Counter\n        ## 14. use collections.Counter\n        ## 15. use collections.Counter\n        ## 16. use collections.Counter\n        ## 17. use collections.Counter\n        ## 18. use collections.Counter\n        ## 19. use collections.Counter\n        ## 20. use collections.Counter\n        ## 21. use collections.Counter\n        ## 22. use collections.Counter\n        ## 23. use collections.Counter\n        ## 24. use collections.Counter\n        ## 25. use collections.Counter\n        ## 26. use collections.Counter\n        ## 27. use collections.Counter\n        ## 28. use collections.Counter\n        ## 29. use collections.Counter\n        ## 30. use collections.Counter\n        ## 31. use collections.Counter\n        ## 32. use collections.Counter\n        ## 33. use collections.Counter\n        ## 34. use collections.Counter\n        ## 35. use collections.Counter\n        ## 36. use collections.Counter\n        ## 37. use collections.Counter\n        ## 38. use collections.Counter\n        ## 39. use collections.Counter\n        ## 40. use collections.Counter\n        ## 41. use collections.Counter\n        ## 42. use collections.Counter\n        ## 43. use collections.Counter\n        ## 44. use collections.Counter\n        ## 45. use collections.Counter\n        ## 46. use collections.Counter\n        ## 47. use collections.Counter\n        ## 48. use collections.Counter\n        ## 49. use collections.Counter\n        ## 50. use collections.Counter\n        ## 51. use collections.Counter\n        ## 52. use collections.Counter\n        ## 53. use collections.Counter\n        ## 54. use collections.Counter\n        ## 55. use collections.Counter\n        ## 56. use collections.Counter\n        ## 57. use collections.Counter\n        ## 58. use collections.Counter\n        ## 59. use collections.Counter\n        ## 60. use collections.Counter\n        ## 61. use collections.Counter\n        ## 62. use collections.Counter\n        ## 63. use collections.Counter\n        ## 64. use collections.Counter\n        ## 65. use collections.Counter\n        ## 66. use collections.Counter\n        ## 67. use collections.Counter\n        ## 68. use collections.Counter\n        ## 69. use collections.Counter\n        ## 70. use collections.Counter\n        ## 71. use collections.Counter\n        ## 72. use collections.Counter\n        ## 73. use collections.Counter\n        ## 74. use collections.Counter\n        ## 75. use collections.Counter\n        ## 76. use collections.Counter\n        ## 77. use collections.Counter\n        ## 78. use collections.Counter\n        ## 79. use collections.Counter\n        ## 80. use collections.Counter\n        ## 81. use collections.Counter\n        ## 82. use collections.Counter\n        ## 83. use collections.Counter\n        ## 84. use collections.Counter\n        ## 85. use collections.Counter\n        ## 86. use collections.Counter\n        ##"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if sum(machines) % n:\n            return -1\n        avg = sum(machines) // n\n        ans = 0\n        cur = 0\n        for i in machines:\n            cur += i - avg\n            ans = max(ans, abs(cur), i - avg)\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low, high = 1, m * n\n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        prev.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1, list2 = list1.next, list2\n        \n        head = list1\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                list1 = list1.next\n            else:\n                list1, list2 = list2, list1\n            list1 = list1.next\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = [-1]\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while len(stack) > 1:\n            h = heights[stack.pop()]\n            w = len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [curr + [num] for curr in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot point\n        # 2. find the min in the left part\n        # 3. find the min in the right part\n        # 4. compare the two\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5224\u65ad\u662f\u5426\u4e3a\u7a7a\n        if not s:\n            return False\n        \n        # 3. \u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 4. \u5224\u65ad\u662f\u5426\u4e3a\u6574\u6570\n        try:\n            int(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 5. \u5224\u65ad\u662f\u5426\u4e3a\u5c0f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 6. \u5224\u65ad\u662f\u5426\u4e3a\u79d1\u5b66\u8ba1\u6570\u6cd5\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 7. \u5224\u65ad\u662f\u5426\u4e3a\u6d6e\u70b9\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 8. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 9. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 10. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 11. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 12. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 13. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 14. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 15. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 16. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 17. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 18. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 19. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 20. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 21. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 22. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 23. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 24. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 25. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 26. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False\n        \n        # 27. \u5224\u65ad\u662f\u5426\u4e3a\u6b63\u8d1f\u6570\n        try:\n            float(s)\n            return True\n        except"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. use a dict to store the count of each char in s\n        ## 2. iterate over t and subtract the count of each char in s\n        ## 3. return the char that has a count of 1\n        \n        ## 1.\n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        ## 2.\n        for c in t:\n            if c not in s_dict:\n                return c\n            else:\n                s_dict[c] -= 1\n        \n        ## 3.\n        for k, v in s_dict.items():\n            if v == 1:\n                return k"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board, l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board, row, num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board, col, num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board, box_start_row, box_start_col, num):\n            for row in range(3):\n                for col in range(3):\n                    if board[row+box_start_row][col+box_start_col] == num:\n                        return True\n            return False\n        \n        def is_valid(board, row, col, num):\n            return not used_in_row(board, row, num) and not used_in_col(board, col, num) and not used_in_box(board, row - row % 3, col - col % 3, num)\n        \n        def solve_sudoku(board):\n            l = [0, 0]\n            if not find_empty_location(board, l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1, 10):\n                if is_valid(board, row, col, num):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 1\n        right = num\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0, 1]\n        \n        ans = [0, 1]\n        for i in range(2, n + 1):\n            ans.append(ans[i // 2] + i % 2)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node):\n            if not node:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return False\n            if board[i][j] != node.val:\n                return False\n            tmp = board[i][j]\n            board[i][j] = '#'\n            res = any([dfs(i + 1, j, node.next[c]) for c in 'abcdefghijklmnopqrstuvwxyz' if dfs(i + 1, j, node.next[c])])\n            board[i][j] = tmp\n            return res\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['#'] = True\n        \n        res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, trie):\n                    res.append(word)\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                sub = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(sub)) != len(sub):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n + 1):\n            if i % 15 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n < 2:\n            return n\n        \n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 1, 0, -1):\n            if ratings[i] < ratings[i - 1]:\n                candies[i - 1] = max(candies[i - 1], candies[i] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle node\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        second = slow.next\n        prev = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n        \n        # merge the two halves\n        first, second = head, prev\n        while second:\n            first.next, first = second, first.next\n            second.next, second = first.next, second.next\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is not equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is not in the mapping, add it\n            if letter not in mapping:\n                if word in mapping.values():\n                    return False\n                mapping[letter] = word\n            # if the letter is in the mapping, check if the word is the same as the word associated with the letter\n            else:\n                if mapping[letter] != word:\n                    return False\n        \n        # if we reach this point, all letters have been mapped to words, so the pattern is valid\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        \n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        left, right = 0, m*n-1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        dummy = ListNode(0)\n        curr = dummy\n        \n        while l1 or l2 or carry:\n            val1 = (l1.val if l1 else 0)\n            val2 = (l2.val if l2 else 0)\n            \n            carry, out = divmod(val1 + val2 + carry, 10)\n            \n            curr.next = ListNode(out)\n            curr = curr.next\n            \n            l1 = (l1.next if l1 else None)\n            l2 = (l2.next if l2 else None)\n            \n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip all the 0's to 1's and all the 1's to 0's\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip all the 0's to 1's and all the 1's to 0's\n        complement = ''\n        for c in binary:\n            if c == '0':\n                complement += '1'\n            else:\n                complement += '0'\n        \n        # 3. convert back to decimal\n        return int(complement, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n        \n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * ("}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a trie\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['#'] = True\n        \n        # dfs\n        res = []\n        for word in words:\n            if self.dfs(word, trie):\n                res.append(word)\n        return res\n    \n    def dfs(self, word, trie):\n        node = trie\n        for i, letter in en.umerate(word):\n            if letter not in node:\n                return False\n            if '#' in node and self.dfs(word[i+1:], node[letter]):\n                return True\n            node = node[letter]\n        return '#' in node"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = -num\n            sign = -1\n        else:\n            sign = 1\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res if sign == 1 else '-' + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, pie, na):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in pie and row - col not in na:\n                    count += backtrack(row + 1, cols | {col}, pie | {row + col}, na | {row - col})\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def dfs(board, row):\n            if row == n:\n                return [[''.join(board[i]) for i in range(n)]]\n            res = []\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    res.extend(dfs(board, row + 1))\n                    board[row][col] = '.'\n            return res\n        \n        board = [['.' for _ in range(n)] for _ in range(n)]\n        return dfs(board, 0)"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not board:\n            return False\n        \n        if not word:\n            return True\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.dfs(board, word, i, j):\n                    return True\n        \n        return False\n    \n    def dfs(self, board, word, i, j):\n        if len(word) == 0:\n            return True\n        \n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n            return False\n        \n        tmp = board[i][j]\n        board[i][j] = '#'\n        \n        res = self.dfs(board, word[1:], i + 1, j) or self.dfs(board, word[1:], i - 1, j) or self.dfs(board, word[1:], i, j + 1) or self.dfs(board, word[1:], i, j - 1)\n        \n        board[i][j] = tmp\n        \n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the third max\n        # 3. if the third max is not in the array, return the last max\n        # 4. if the third max is in the array, return the third max\n        \n        nums = sorted(set(nums))\n        return nums[-3] if len(nums) >= 3 else nums[-1]"}]}