{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        i, j = 0, 0\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        d = 0\n        \n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            x, y = i + dirs[d][0], j + dirs[d][1]\n            if 0 <= x < m and 0 <= y < n and not visited[x][y]:\n                i, j = x, y\n            else:\n                d = (d + 1) % 4\n                i, j = i + dirs[d][0], j + dirs[d][1]\n        \n        return ans"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = 0\n        end = 0\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                end += 1\n            else:\n                if start == end:\n                    res.append(str(nums[start]))\n                else:\n                    res.append(str(nums[start]) + \"->\" + str(nums[end]))\n                start = i\n                end = i\n        \n        if start == end:\n            res.append(str(nums[start]))\n        else:\n            res.append(str(nums[start]) + \"->\" + str(nums[end]))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the current number is positive and less than the length of the array\n        # 3. if the current number is positive and less than the length of the array, check if the current number is equal to the index of the current number\n        # 4. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, return the current number\n        # 5. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 6. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 7. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 8. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 9. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 10. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 11. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 12. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 13. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 14. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 15. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 16. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 17. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 18. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 19. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 20. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 21. if the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 22. if the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, swap the current number with the number at the index of the current number\n        # 23. if the current"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n\n        # 3. 1, 2, 3, ..., n\n        # 4. 1, 2, 3, ..., n\n        # 5. 1, 2, 3, ..., n\n        # 6. 1, 2, 3, ..., n\n        # 7. 1, 2, 3, ..., n\n        # 8. 1, 2, 3, ..., n\n        # 9. 1, 2, 3, ..., n\n        # 10. 1, 2, 3, ..., n\n        # 11. 1, 2, 3, ..., n\n        # 12. 1, 2, 3, ..., n\n        # 13. 1, 2, 3, ..., n\n        # 14. 1, 2, 3, ..., n\n        # 15. 1, 2, 3, ..., n\n        # 16. 1, 2, 3, ..., n\n        # 17. 1, 2, 3, ..., n\n        # 18. 1, 2, 3, ..., n\n        # 19. 1, 2, 3, ..., n\n        # 20. 1, 2, 3, ..., n\n        # 21. 1, 2, 3, ..., n\n        # 22. 1, 2, 3, ..., n\n        # 23. 1, 2, 3, ..., n\n        # 24. 1, 2, 3, ..., n\n        # 25. 1, 2, 3, ..., n\n        # 26. 1, 2, 3, ..., n\n        # 27. 1, 2, 3, ..., n\n        # 28. 1, 2, 3, ..., n\n        # 29. 1, 2, 3, ..., n\n        # 30. 1, 2, 3, ..., n\n        # 31. 1, 2, 3, ..., n\n        # 32. 1, 2, 3, ..., n\n        # 33. 1, 2, 3, ..., n\n        # 34. 1, 2, 3, ..., n\n        # 35. 1, 2, 3, ..., n\n        # 36. 1, 2, 3, ..., n\n        # 37. 1, 2, 3, ..., n\n        # 38. 1, 2, 3, ..., n\n        # 39. 1, 2, 3, ..., n\n        # 40. 1, 2, 3, ..., n\n        # 41. 1, 2, 3, ..., n\n        # 42. 1, 2, 3, ..., n\n        # 43. 1, 2, 3, ..., n\n        # 44. 1, 2, 3, ..., n\n        # 45. 1, 2, 3, ..., n\n        # 46. 1, 2, 3, ..., n\n        # 47. 1, 2, 3, ..., n\n        # 48. 1, 2, 3, ..., n\n        # 49. 1, 2, 3, ..., n\n        # 50. 1, 2, 3, ..., n\n        # 51. 1, 2, 3, ..., n\n        # 52. 1, 2, 3, ..., n\n        # 53. 1, 2, 3, ..., n\n        # 54. 1, 2, 3, ..., n\n        # 55."}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 124 ms, faster than 99.44% of Python online submissions for Two Sum II - Input Array Is Sorted.\n        ## Memory Usage: 14.5 MB, less than 99.44% of Python online submissions for Two Sum II - Input Array Is Sorted.\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05\n        ## 2022-05-05"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, prev + curr, res)\n                    backtrack(j+1, curr, prev - curr, prev - curr, res)\n                    backtrack(j+1, curr, prev * curr, prev * curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, 1, res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the sum of gas and cost\n        ## 2. Find the sum of gas and cost\n        ## 3. Find the sum of gas and cost\n        ## 4. Find the sum of gas and cost\n        ## 5. Find the sum of gas and cost\n        ## 6. Find the sum of gas and cost\n        ## 7. Find the sum of gas and cost\n        ## 8. Find the sum of gas and cost\n        ## 9. Find the sum of gas and cost\n        ## 10. Find the sum of gas and cost\n        ## 11. Find the sum of gas and cost\n        ## 12. Find the sum of gas and cost\n        ## 13. Find the sum of gas and cost\n        ## 14. Find the sum of gas and cost\n        ## 15. Find the sum of gas and cost\n        ## 16. Find the sum of gas and cost\n        ## 17. Find the sum of gas and cost\n        ## 18. Find the sum of gas and cost\n        ## 19. Find the sum of gas and cost\n        ## 20. Find the sum of gas and cost\n        ## 21. Find the sum of gas and cost\n        ## 22. Find the sum of gas and cost\n        ## 23. Find the sum of gas and cost\n        ## 24. Find the sum of gas and cost\n        ## 25. Find the sum of gas and cost\n        ## 26. Find the sum of gas and cost\n        ## 27. Find the sum of gas and cost\n        ## 28. Find the sum of gas and cost\n        ## 29. Find the sum of gas and cost\n        ## 30. Find the sum of gas and cost\n        ## 31. Find the sum of gas and cost\n        ## 32. Find the sum of gas and cost\n        ## 33. Find the sum of gas and cost\n        ## 34. Find the sum of gas and cost\n        ## 35. Find the sum of gas and cost\n        ## 36. Find the sum of gas and cost\n        ## 37. Find the sum of gas and cost\n        ## 38. Find the sum of gas and cost\n        ## 39. Find the sum of gas and cost\n        ## 40. Find the sum of gas and cost\n        ## 41. Find the sum of gas and cost\n        ## 42. Find the sum of gas and cost\n        ## 43. Find the sum of gas and cost\n        ## 44. Find the sum of gas and cost\n        ## 45. Find the sum of gas and cost\n        ## 46. Find the sum of gas and cost\n        ## 47. Find the sum of gas and cost\n        ## 48. Find the sum of gas and cost\n        ## 49. Find the sum of gas and cost\n        ## 50. Find the sum of gas and cost\n        ## 51. Find the sum of gas and cost\n        ## 52. Find the sum of gas and cost\n        ## 53. Find the sum of gas and cost\n        ## 54. Find the sum of gas and cost\n        ## 55. Find the sum of gas and cost\n        ## 56. Find the sum of gas and cost\n        ## 57. Find the sum of gas and cost\n        ## 58. Find the sum of gas and cost\n        ## 59. Find the sum of gas and cost\n        ## 60. Find the sum of gas and cost\n        ## 61. Find the sum of gas and cost\n        ## 62. Find the sum of gas and cost\n        ## 63. Find the sum of gas and cost\n        ## 64. Find the sum of gas and cost\n        ## 65. Find the sum of gas and cost\n        ## 66. Find the sum of gas and cost\n        ## 67. Find the sum of gas and cost\n        ## 68. Find the sum of gas and cost\n        ## 69. Find the sum of gas and"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. convert the list to a string\n        ## 2. convert the string to an integer\n        ## 3. add 1 to the integer\n        ## 4. convert the integer to a string\n        ## 5. convert the string to a list\n        \n        ## 1. convert the list to a string\n        digits_str = \"\"\n        for i in digits:\n            digits_str += str(i)\n        \n        ## 2. convert the string to an integer\n        digits_int = int(digits_str)\n        \n        ## 3. add 1 to the integer\n        digits_int += 1\n        \n        ## 4. convert the integer to a string\n        digits_str = str(digits_int)\n        \n        ## 5. convert the string to a list\n        digits_list = []\n        for i in digits_str:\n            digits_list.append(int(i))\n        \n        return digits_list"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] != '*':\n            if len(s) < 1:\n                return False\n            return (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p[1:])\n        \n        while len(s) > 0 and (s[0] == p[0] or p[0] == '.'):\n            if self.isMatch(s, p[2:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[2:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    out.append(nums1[i])\n                    i += 1\n                else:\n                    out.append(nums2[j])\n                    j += 1\n            out += nums1[i:]\n            out += nums2[j:]\n            return out\n        \n        def find_max(nums, k):\n            out = []\n            for i in range(len(nums)):\n                if len(out) < k:\n                    out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def find_max_k(nums1, nums2, k):\n            if len(nums1) < k:\n                return find_max(nums2, k)\n            if len(nums2) < k:\n                return find_max(nums1, k)\n            if len(nums1) == len(nums2) == k:\n                return nums1\n            if len(nums1) == len(nums2) == k + 1:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 2:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 3:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 4:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 5:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 6:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 7:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 8:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 9:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 10:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 11:\n                if nums1[0] > nums2[0]:\n                    return nums1\n                else:\n                    return nums2\n            if len(nums1) == len(nums2) == k + 12:\n                if"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i * i == num:\n                    sum += i\n                else:\n                    sum += i + num / i\n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1 - dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n                    \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_list = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_list.append(s_list[i])\n        vowel_list.reverse()\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. sum of all numbers from 0 to n\n        ## 4. difference\n        ## 5. return the missing number\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. sum of all numbers from 0 to n\n        ## 4. sum of all numbers from 0 to n\n        ## 5. difference\n        ## 6. return the missing number\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. sum of all numbers from 0 to n\n        ## 4. sum of all numbers from 0 to n\n        ## 5. sum of all numbers from 0 to n\n        ## 6. difference\n        ## 7. return the missing number\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. sum of all numbers from 0 to n\n        ## 4. sum of all numbers from 0 to n\n        ## 5. sum of all numbers from 0 to n\n        ## 6. sum of all numbers from 0 to n\n        ## 7. difference\n        ## 8. return the missing number\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. sum of all numbers from 0 to n\n        ## 4. sum of all numbers from 0 to n\n        ## 5. sum of all numbers from 0 to n\n        ## 6. sum of all numbers from 0 to n\n        ## 7. sum of all numbers from 0 to n\n        ## 8. difference\n        ## 9. return the missing number\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. sum of all numbers from 0 to n\n        ## 4. sum of all numbers from 0 to n\n        ## 5. sum of all numbers from 0 to n\n        ## 6. sum of all numbers from 0 to n\n        ## 7. sum of all numbers from 0 to n\n        ## 8. sum of all numbers from 0 to n\n        ## 9. difference\n        ## 10. return the missing number\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. sum of all numbers from 0 to n\n        ## 4. sum of all numbers from 0 to n\n        ## 5. sum of all numbers from 0 to n\n        ## 6. sum of all numbers from 0 to n\n        ## 7. sum of all numbers from 0 to n\n        ## 8. sum of all numbers from 0 to n\n        ## 9. sum of all numbers from 0 to n\n        ## 10. difference\n        ## 11. return the missing number\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        # BFS\n        # Time:"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == '1' and b[i] == '1':\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n                        carry = 1\n                elif a[i] == '1' or b[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n            else:\n                if a[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n        \n        if carry == 1:\n            res.append('1')\n        \n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] > target or (left and nums[mid] == target):\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            return low\n        \n        left_idx = binary_search(nums, target, True)\n        right_idx = binary_search(nums, target, False) - 1\n        \n        if left_idx <= right_idx and right_idx < len(nums) and nums[left_idx] == target and nums[right_idx] == target:\n            return [left_idx, right_idx]\n        return [-1, -1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n                \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for i in range(len(prices)-1))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k+1):\n                dp[j][0] = max(dp[j][0], dp[j-1][1] + prices[i])\n                dp[j][1] = max(dp[j][1], dp[j][0] - prices[i])\n        \n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-25\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-25\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-25\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-25\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-25\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-25\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-25\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.55% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-25\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.55% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB,"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i):\n            if i >= len(s):\n                return 0\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 2)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 2)\n            if s[i] == '(':\n                return helper(s, i + 1) + helper(s, helper(s, i + 1) + 1)\n            if s[i] == ')':\n                return helper(s, i + 1)\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 2)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 2)\n            if s[i] == '(':\n                return helper(s, i + 1) + helper(s, helper(s, i + 1) + 1)\n            if s[i] == ')':\n                return helper(s, i + 1)\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 2)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 2)\n            if s[i] == '(':\n                return helper(s, i + 1) + helper(s, helper(s, i + 1) + 1)\n            if s[i] == ')':\n                return helper(s, i + 1)\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 2)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 2)\n            if s[i] == '(':\n                return helper(s, i + 1) + helper(s, helper(s, i + 1) + 1)\n            if s[i] == ')':\n                return helper(s, i + 1)\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 2)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 2)\n            if s[i] == '(':\n                return helper(s, i + 1) + helper(s, helper(s, i + 1) + 1)\n            if s[i] == ')':\n                return helper(s, i + 1)\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 2)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 2)\n            if s[i] == '(':\n                return helper(s, i + 1) + helper(s, helper(s, i + 1) + 1)\n            if s[i] == ')':\n                return helper(s, i + 1)\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 2)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 2)\n            if s[i] == '(':\n                return helper(s, i + 1) + helper(s, helper(s, i + 1) + 1)\n            if s[i] == ')':\n                return helper(s, i + 1)\n            if s[i] =="}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else\n        # break\n        # return w\n        \n        # sort capital and profits\n        # sort capital and profits\n        # loop through capital\n        # if k > 0\n        # if capital[i] <= w\n        # add profits[i] to w\n        # k -= 1\n        # else"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n            elif i == '}':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n            elif i == ']':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # 1. Create a hashmap\n        # 2. Iterate through the array\n        # 3. If the element is already in the hashmap, return True\n        # 4. If the element is not in the hashmap, add it to the hashmap\n        # 5. If the difference between the current element and the element before it is greater than k, return True\n        # 6. If the difference between the current element and the element before it is less than or equal to k, return False\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if i - hashmap[nums[i]] <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Create a dictionary with the first row of the keyboard\n        # 2. Iterate through the words\n        # 3. Check if the word is in the dictionary\n        # 4. If it is, add it to the list\n        # 5. If it is not, remove it from the list\n        # 6. Return the list\n        \n        keyboard = {'qwertyuiop': 1, 'asdfghjkl': 2, 'zxcvbnm': 3}\n        result = []\n        \n        for word in words:\n            row = keyboard[word[0].lower()]\n            for letter in word:\n                if keyboard[letter.lower()] != row:\n                    break\n            else:\n                result.append(word)\n                \n        return result"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        prev.next = None\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = temp\n            count += 1\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the end of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest of the string to the beginning\n        # this is the same as finding the longest palindrome that can be made from the beginning of the string\n        # then add the rest of the string to the end\n        # the longest palindrome that can be made from the beginning of the string is the longest palindrome that can be made from the end of the string\n        # so we can use the same logic to find the longest palindrome that can be made from the end of the string\n        # and add the rest"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s)\n        min_left = 0\n        min_right = 0\n        min_s = \"\"\n        while right < len(s):\n            if s[right] in t_dict:\n                if s[right] in s_dict:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] = 1\n                if s_dict[s[right]] < t_dict[s[right]]:\n                    if right - left + 1 < min_len:\n                        min_len = right - left + 1\n                        min_left = left\n                        min_right = right\n                right += 1\n            else:\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    min_left = left\n                    min_right = right\n                left += 1\n                right += 1\n        \n        return s[min_left:min_right+1]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(postorder[-1])\n        \n        inorder_left = inorder[:root_index]\n        inorder_right = inorder[root_index+1:]\n        \n        postorder_left = postorder[:len(inorder_left)]\n        postorder_right = postorder[len(inorder_left):-1]\n        \n        root.left = self.buildTree(inorder_left, postorder_left)\n        root.right = self.buildTree(inorder_right, postorder_right)\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    x, y = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] > 0 and (nx, ny) not in visited:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = []\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        steps = 0\n        for tree, x, y in trees:\n            steps += bfs((0, 0), (x, y))\n            if steps < 0:\n                return steps\n            steps += 1\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 2:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 3:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 4:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 5:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 6:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 7:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 8:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 9:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 10:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 11:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 12:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 13:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 14:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 15:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 16:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 17:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 18:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 19:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 20:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 21:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 22:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 23:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 24:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 25:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 26:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 27:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 28:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 29:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 30:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 31:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Approach 32:"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        if n == 2:\n            return [0,1,3,2]\n        \n        if n == 3:\n            return [0,1,3,2,6,7,5,4]\n        \n        if n == 4:\n            return [0,1,3,2,6,7,5,4,12,13,10,9,8]\n        \n        if n == 5:\n            return [0,1,3,2,6,7,5,4,12,13,10,9,8,16,17,14,15]\n        \n        if n == 6:\n            return [0,1,3,2,6,7,5,4,12,13,10,9,8,16,17,14,15,24,25,22,23,20,19,18]\n        \n        if n == 7:\n            return [0,1,3,2,6,7,5,4,12,13,10,9,8,16,17,14,15,24,25,22,23,20,19,18,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,25,22,23,20,19,18,36,37,34,35,32,33,30,31,28,29,26,27,24,"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ##"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return inorder(root.left, min_val, root.val) and inorder(root.right, root.val, max_val)\n        \n        return inorder(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        ## 3. Merge the intervals\n        \n        ## 1. Find the index of the interval that the new interval will be inserted\n        ## 2. Insert the new interval\n        #"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val = float('inf')\n        max_val = float('-inf')\n        \n        # 2. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 11. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 12. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 13. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560 \ubcc0\uc218 \uc120\uc5b8\n        min_val_list = []\n        max_val_list = []\n        \n        # 14. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud560"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # BFS\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. BFS\n        ## 3. Math\n        ## 4. Recursion\n        ## 5. Backtracking\n        \n        ## 1. DP\n        ## 2. B"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n            \n        return \"\".join(map(str, res))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. DP with 2 variables\n        ## 4. DP with 3 variables\n        ## 5. DP with 4 variables\n        ## 6. DP with 5 variables\n        ## 7. DP with 6 variables\n        ## 8. DP with 7 variables\n        ## 9. DP with 8 variables\n        ## 10. DP with 9 variables\n        ## 11. DP with 10 variables\n        ## 12. DP with 11 variables\n        ## 13. DP with 12 variables\n        ## 14. DP with 13 variables\n        ## 15. DP with 14 variables\n        ## 16. DP with 15 variables\n        ## 17. DP with 16 variables\n        ## 18. DP with 17 variables\n        ## 19. DP with 18 variables\n        ## 20. DP with 19 variables\n        ## 21. DP with 20 variables\n        ## 22. DP with 21 variables\n        ## 23. DP with 22 variables\n        ## 24. DP with 23 variables\n        ## 25. DP with 24 variables\n        ## 26. DP with 25 variables\n        ## 27. DP with 26 variables\n        ## 28. DP with 27 variables\n        ## 29. DP with 28 variables\n        ## 30. DP with 29 variables\n        ## 31. DP with 30 variables\n        ## 32. DP with 31 variables\n        ## 33. DP with 32 variables\n        ## 34. DP with 33 variables\n        ## 35. DP with 34 variables\n        ## 36. DP with 35 variables\n        ## 37. DP with 36 variables\n        ## 38. DP with 37 variables\n        ## 39. DP with 38 variables\n        ## 40. DP with 39 variables\n        ## 41. DP with 40 variables\n        ## 42. DP with 41 variables\n        ## 43. DP with 42 variables\n        ## 44. DP with 43 variables\n        ## 45. DP with 44 variables\n        ## 46. DP with 45 variables\n        ## 47. DP with 46 variables\n        ## 48. DP with 47 variables\n        ## 49. DP with 48 variables\n        ## 50. DP with 49 variables\n        ## 51. DP with 50 variables\n        ## 52. DP with 51 variables\n        ## 53. DP with 52 variables\n        ## 54. DP with 53 variables\n        ## 55. DP with 54 variables\n        ## 56. DP with 55 variables\n        ## 57. DP with 56 variables\n        ## 58. DP with 57 variables\n        ## 59. DP with 58 variables\n        ## 60. DP with 59 variables\n        ## 61. DP with 60 variables\n        ## 62. DP with 61 variables\n        ## 63. DP with 62 variables\n        ## 64. DP with 63 variables\n        ## 65. DP with 64 variables\n        ## 66. DP with 65 variables\n        ## 67. DP with 66 variables\n        ## 68. DP with 67 variables\n        ## 69. DP with 68 variables\n        ## 70. DP with 69 variables"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Did the code run on Leetcode: Yes\n        ## Any problem you faced while coding this: No\n        \n        ## Approach:\n        ## 1. Iterate through the array and find the minimum price\n        ## 2. Iterate through the array and find the maximum profit\n        ## 3. Return the maximum profit\n        \n        ## Initialization\n        max_profit = 0\n        min_price = float('inf')\n        \n        ## Iterate through the array\n        for i in range(len(prices)):\n            ## Update the minimum price\n            min_price = min(min_price, prices[i])\n            ## Update the maximum profit\n            max_profit = max(max_profit, prices[i] - min_price)\n            \n        ## Return the maximum profit\n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        \n        left_preorder = preorder[1:root_index+1]\n        left_inorder = inorder[0:root_index]\n        right_preorder = preorder[root_index+1:]\n        right_inorder = inorder[root_index+1:]\n        \n        root.left = self.buildTree(left_preorder, left_inorder)\n        root.right = self.buildTree(right_preorder, right_inorder)\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, path, res):\n            if left == 0 and right == 0:\n                if isValid(path):\n                    res.append(path)\n                return\n            for i in range(len(s)):\n                if i > 0 and s[i] == s[i-1]:\n                    continue\n                if s[i] == '(' or s[i] == ')':\n                    if left > 0 and s[i] == '(':\n                        dfs(s[:i] + s[i+1:], left - 1, right, path + s[i], res)\n                    elif right > 0 and s[i] == ')':\n                        dfs(s[:i] + s[i+1:], left, right - 1, path + s[i], res)\n        \n        res = []\n        dfs(s, 0, 0, '', res)\n        return res"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # if lists is empty\n        if not lists:\n            return None\n        \n        # if there is only one list\n        if len(lists) == 1:\n            return lists[0]\n        \n        # if there are two lists\n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        # if there are more than two lists\n        else:\n            # find the middle index\n            mid = len(lists) // 2\n            \n            # recursively merge the lists\n            left = self.mergeKLists(lists[:mid])\n            right = self.mergeKLists(lists[mid:])\n            \n            # merge the two lists\n            return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if l1 is empty\n        if not l1:\n            return l2\n        \n        # if l2 is empty\n        if not l2:\n            return l1\n        \n        # if l1 is smaller than l2\n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        \n        # if l2 is smaller than l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x//5\n        \n        def binary_search(k):\n            left, right = 0, 10**10\n            while left < right:\n                mid = (left + right)//2\n                if f(mid) < k:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n        \n        return binary_search(k) - binary_search(k-1)"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPairs(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs2(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs3(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs4(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs5(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs6(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs7(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs8(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs9(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs10(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs11(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        def getPairs12(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPal"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                spread(isInfected, i + di, j + dj)\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = []\n                for i in range(len(isInfected)):\n                    for j in range(len(isInfected[0])):\n                        if isInfected[i][j] == 1:\n                            infected.append((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    spread(isInfected, i, j)\n                walls += 1\n            return walls\n        \n        return build_walls(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_result = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_result.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_result)\n            else:\n                result.append(level_result[::-1])\n            level += 1\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_time_list(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_2(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_3(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_4(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_5(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_6(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_7(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_8(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_9(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_10(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_11(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_12(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_13(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_14(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_15(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_16(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_17(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_18(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_19(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_20(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []\n        \n        def get_time_list_21(h, m):\n            if h < 12 and m < 60:\n                return [h, m]\n            else:\n                return []"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n            \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = curr_i + di, curr_j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and not visited[new_i][new_j]:\n                    visited[new_i][new_j] = True\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # reverse the string\n        s = s[::-1]\n        \n        # compare the original string with the reversed string\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the result list\n        result = []\n        \n        # 2. Initialize the window\n        window = []\n        \n        # 3. Initialize the median\n        median = 0\n        \n        # 4. Initialize the index\n        index = 0\n        \n        # 5. Initialize the window size\n        window_size = 0\n        \n        # 6. Initialize the window sum\n        window_sum = 0\n        \n        # 7. Initialize the window median\n        window_median = 0\n        \n        # 8. Initialize the window median list\n        window_median_list = []\n        \n        # 9. Initialize the window median list\n        window_median_list = []\n        \n        # 10. Initialize the window median list\n        window_median_list = []\n        \n        # 11. Initialize the window median list\n        window_median_list = []\n        \n        # 12. Initialize the window median list\n        window_median_list = []\n        \n        # 13. Initialize the window median list\n        window_median_list = []\n        \n        # 14. Initialize the window median list\n        window_median_list = []\n        \n        # 15. Initialize the window median list\n        window_median_list = []\n        \n        # 16. Initialize the window median list\n        window_median_list = []\n        \n        # 17. Initialize the window median list\n        window_median_list = []\n        \n        # 18. Initialize the window median list\n        window_median_list = []\n        \n        # 19. Initialize the window median list\n        window_median_list = []\n        \n        # 20. Initialize the window median list\n        window_median_list = []\n        \n        # 21. Initialize the window median list\n        window_median_list = []\n        \n        # 22. Initialize the window median list\n        window_median_list = []\n        \n        # 23. Initialize the window median list\n        window_median_list = []\n        \n        # 24. Initialize the window median list\n        window_median_list = []\n        \n        # 25. Initialize the window median list\n        window_median_list = []\n        \n        # 26. Initialize the window median list\n        window_median_list = []\n        \n        # 27. Initialize the window median list\n        window_median_list = []\n        \n        # 28. Initialize the window median list\n        window_median_list = []\n        \n        # 29. Initialize the window median list\n        window_median_list = []\n        \n        # 30. Initialize the window median list\n        window_median_list = []\n        \n        # 31. Initialize the window median list\n        window_median_list = []\n        \n        # 32. Initialize the window median list\n        window_median_list = []\n        \n        # 33. Initialize the window median list\n        window_median_list = []\n        \n        # 34. Initialize the window median list\n        window_median_list = []\n        \n        # 35. Initialize the window median list\n        window_median_list = []\n        \n        # 36. Initialize the window median list\n        window_median_list = []\n        \n        # 37. Initialize the window median list\n        window_median_list = []\n        \n        # 38. Initialize the window median list\n        window_median_list = []\n        \n        # 39. Initialize the window median list\n        window_median_list = []\n        \n        # 40. Initialize the window median list\n        window_median_list = []\n        \n        # 41. Initialize the window median list\n        window_median_list = []\n        \n        # 42. Initialize the window median list\n        window_median_list = []\n        \n        # 43. Initialize the window median list\n        window_median_list ="}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the kth node from the end\n        kth = head\n        for i in range(length - k - 1):\n            kth = kth.next\n        \n        # find the new head\n        new_head = kth.next\n        \n        # break the list\n        kth.next = None\n        \n        # find the new tail\n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        # connect the new tail to the old head\n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n            else:\n                return False\n        \n        return True"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.left.val + root.right.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            if not matrix:\n                return 0\n            m, n = len(matrix), len(matrix[0])\n            maxSum = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    maxSum = max(maxSum, self.maxSumSubarray(sums, k))\n            return maxSum\n        \n        def maxSumSubarray(nums, k):\n            \"\"\"\n            :type nums: List[int]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            if not nums:\n                return 0\n            maxSum = float('-inf')\n            sums = [0]\n            for num in nums:\n                sums.append(sums[-1] + num)\n            for i in range(len(sums)):\n                for j in range(i):\n                    if sums[i] - sums[j] <= k:\n                        maxSum = max(maxSum, sums[i] - sums[j])\n            return maxSum\n        \n        return maxSumSubmatrix(matrix, k)"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i,j]\n        \n        ## Hashmap\n        hashmap = {}\n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                return [hashmap[nums[i]], i]\n            else:\n                hashmap[target - nums[i]] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if dfs(new_cards, 24):\n                                return True\n            return False\n        \n        return dfs(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, then check if there is a star in p\n        if len(p) > 1 and p[1] == '*':\n            # if there is a star in p, then check if there is a star in s\n            if s and (s[0] == p[0] or p[0] == '?'):\n                return self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p) or self.isMatch(s, p[1:])\n            else:\n                return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if there is a star in p\n        if len(p) > 1 and p[1] == '*':\n            # if there is a star in p, then check if there is a star in s\n            if s and (s[0] == p[0] or p[0] == '?'):\n                return self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p) or self.isMatch(s, p[1:])\n            else:\n                return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if there is a star in p\n        if len(p) > 1 and p[1] == '*':\n            # if there is a star in p, then check if there is a star in s\n            if s and (s[0] == p[0] or p[0] == '?'):\n                return self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p) or self.isMatch(s, p[1:])\n            else:\n                return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if there is a star in p\n        if len(p) > 1 and p[1] == '*':\n            # if there is a star in p, then check if there is a star in s\n            if s and (s[0] == p[0] or p[0] == '?'):\n                return self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p) or self.isMatch(s, p[1:])\n            else:\n                return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if there is a star in p\n        if len(p) > 1 and p[1] == '*':\n            # if there is a star in p, then check if there is a star in s\n            if s and (s[0] == p[0] or p[0] == '?'):\n                return self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p) or self.isMatch(s, p[1:])\n            else:\n                return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if there is a star in p\n        if len(p) > 1 and p[1] == '*':\n            # if there is a star in p, then check if there is a star in s\n            if s and (s[0] == p[0] or p[0] == '?'):\n                return self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p) or self.isMatch(s, p[1:])\n            else:\n                return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if there is a star in p\n        if len(p) > 1 and p[1] == '*':\n            # if there is a star in p, then check if there is a star in s\n            if s and (s[0] == p[0] or p[0] == '?'):\n                return self.isMatch(s[1:], p[1:]) or self.isMatch(s[1:], p) or self.isMatch(s, p[1:])\n            else"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=YXKj68j88Ks\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # sort the graph\n        for key in graph:\n            graph[key].sort()\n        \n        # dfs\n        res = []\n        def dfs(node):\n            if len(res) == len(tickets) + 1:\n                return True\n            if node not in graph:\n                return False\n            for i in range(len(graph[node])):\n                temp = graph[node][i]\n                graph[node].pop(i)\n                if dfs(temp):\n                    res.append(temp)\n                    return True\n                graph[node].insert(i, temp)\n            return False\n        \n        dfs(\"JFK\")\n        return res"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the max height\n        max_height = 0\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None\n            if current_building is None:\n                # set the current building\n                current_building = building\n            # if the current building is not None\n            else:\n                # if the current building is not the same as the previous building\n                if current_building[0] != building[0]:\n                    # if the current edge is None\n                    if current_edge is None:\n                        # set the current edge\n                        current_edge = building[0]\n                    # if the current edge is not None\n                    else:\n                        # if the current edge is not the same as the previous edge\n                        if current_edge != building[0]:\n                            # if the current height is greater than the max height\n                            if current_height > max_height:\n                                # set the max height\n                                max_height = current_height\n                                # append the current edge and max height to the result list\n                                result.append([current_edge, max_height])\n                                # set the current edge\n                                current_edge = building[0]\n                            # if the current height is less than the max height\n                            else:\n                                # set the current edge\n                                current_edge = building[0]\n                        # if the current edge is the same as the previous edge\n                        else:\n                            # set the current edge\n                            current_edge = building[0]\n                    # if the current building is not the same as the previous building\n                    if current_building[1] != building[1]:\n                        # if the current height is greater than the max height\n                        if current_height > max_height:\n                            # set the max height\n                            max_height = current_height\n                            # append the current edge and max height to the result list\n                            result.append([current_edge, max_height])\n                            # set the current edge\n                            current_edge = building[0]\n                        # if the current height is less than the max height\n                        else:\n                            # set the current edge\n                            current_edge = building[0]\n                    # if the current building is the same as the previous building\n                    else:\n                        # set the current edge\n                        current_edge = building[0]\n                # if the current building is the same as the previous building\n                else:\n                    # if the current height is greater than the max height\n                    if current_height > max_height:\n                        # set the max height\n                        max_height = current_height\n                        # append the current edge and max height to the result list\n                        result.append([current_edge, max_height])\n                        # set the current edge\n                        current_edge = building[0]\n                    # if the current height is less than the max height\n                    else:\n                        # set the current edge\n                        current_edge = building[0]\n            # if the current building is not None\n            if current_building is not None:\n                # if the current building is the same as the previous building\n                if current_building[1] == building[1]:\n                    # set the current building\n                    current_building = building\n                # if the current building is not the same as the previous building\n                else:\n                    # if the current height is greater than the max height\n                    if current_height > max_height:\n                        # set the max height\n                        max_height = current_height\n                        # append the current edge and max height to the result list\n                        result.append([current_edge, max_height])\n                        # set the current edge\n                        current_edge = building[0]\n                    # if the current height is less than the max height\n                    else:\n                        # set the current edge\n                        current_edge = building[0]\n        # if the current edge is not None\n        if current_edge is not None:\n            # if the current height is greater than the max height\n            if current_height > max_height:\n                # set the max height\n                max_height = current_height\n                # append the current edge and max height to the result list\n                result.append(["}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n            if num < 1000000000000000:\n                return helper(num // 1000000000000) + \" Trillion \" + helper(num % 1000000000000)\n            if num < 1000000000000000000:\n                return helper(num // 1000000000000000) + \" Quadrillion \" + helper(num % 1000000000000000)\n            if num < 10000000000000000000000:\n                return helper(num // 1000000000000000000) + \" Quintillion \" + helper(num % 1000000000000000000)\n            if num < 100000000000000000000000000:\n                return helper(num // 10000000000000000000000) + \" Sextillion \" + helper(num % 1000000000000000000000)\n            if num < 1000000000000000000000000000000:\n                return helper(num // 10000000000000000000000000) + \" Septillion \" + helper(num % 10000000000000000000000000)\n            if num < 100000000000000000000000000000000000:\n                return helper(num // 100000000000000000000000000000) + \" Octillion \" + helper(num % 100000000000000000000000000000)\n            if num < 10000000000000000000000000"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return root.val == targetSum\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Find the node with two parents\n        # 2. Find the edge that connects the two parents\n        # 3. Find the node with only one parent\n        # 4. Find the edge that connects the node with only one parent to the node with two parents\n        # 5. Return the edge that connects the node with only one parent to the node with two parents\n        \n        # 1. Find the node with two parents\n        parent_node_1 = None\n        parent_node_2 = None\n        for edge in edges:\n            if parent_node_1 is None and edge[1] in edges:\n                parent_node_1 = edge[1]\n            elif parent_node_2 is None and edge[0] in edges:\n                parent_node_2 = edge[0]\n            elif parent_node_1 is not None and parent_node_2 is not None:\n                break\n        \n        # 2. Find the edge that connects the two parents\n        edge_1 = None\n        edge_2 = None\n        for edge in edges:\n            if edge[0] == parent_node_1 and edge[1] == parent_node_2:\n                edge_1 = edge\n            elif edge[0] == parent_node_2 and edge[1] == parent_node_1:\n                edge_2 = edge\n            elif edge[0] == parent_node_1 and edge[1] != parent_node_2:\n                edge_2 = edge\n            elif edge[0] == parent_node_2 and edge[1] != parent_node_1:\n                edge_1 = edge\n            elif edge[0] != parent_node_1 and edge[1] == parent_node_2:\n                edge_1 = edge\n            elif edge[0] != parent_node_2 and edge[1] == parent_node_1:\n                edge_2 = edge\n        \n        # 3. Find the node with only one parent\n        node_1 = None\n        node_2 = None\n        for edge in edges:\n            if edge[0] == parent_node_1:\n                node_1 = edge[1]\n            elif edge[0] == parent_node_2:\n                node_2 = edge[1]\n            elif edge[0] != parent_node_1 and edge[0] != parent_node_2:\n                node_1 = edge[0]\n            elif edge[0] != parent_node_1 and edge[0] != parent_node_2:\n                node_2 = edge[0]\n        \n        # 4. Find the edge that connects the node with only one parent to the node with two parents\n        edge_3 = None\n        for edge in edges:\n            if edge[0] == node_1 and edge[1] == parent_node_2:\n                edge_3 = edge\n            elif edge[0] == node_2 and edge[1] == parent_node_1:\n                edge_3 = edge\n            elif edge[0] == node_1 and edge[1] != parent_node_2:\n                edge_3 = edge\n            elif edge[0] == node_2 and edge[1] != parent_node_1:\n                edge_3 = edge\n        \n        # 5. Return the edge that connects the node with only one parent to the node with two parents\n        if edge_1 is not None:\n            return edge_1\n        else:\n            return edge_3"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Using set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 104 ms, faster than 98.42% of Python online submissions for Single Number.\n        ## Memory Usage: 14.8 MB, less than 98.42% of Python online submissions for Single Number.\n        ## set() is a built-in data structure in Python that allows you to store a collection of unique elements.\n        ## It is a set, which means that it contains only unique elements.\n        ## The set() constructor takes a list of elements as an argument and creates a new set with those elements.\n        ## The set() function returns a new set object.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create a new set.\n        ## The set() function is used to create"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 12:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 13:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 14:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 15:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 16:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 17:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 18:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 19:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 20:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 21:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 22:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 23:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 24:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 25:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 26:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 27:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, find the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n                    \n        return dp[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211'\n        \n        if n == 13:\n            return '13211311123113112211'\n        \n        if n == 14:\n            return '111312211331121321332211'\n        \n        if n == 15:\n            return '31131122212321322211'\n        \n        if n == 16:\n            return '13211311123113112211'\n        \n        if n == 17:\n            return '111312211331121321332211'\n        \n        if n == 18:\n            return '31131122212321322211'\n        \n        if n == 19:\n            return '13211311123113112211'\n        \n        if n == 20:\n            return '111312211331121321332211'\n        \n        if n == 21:\n            return '31131122212321322211'\n        \n        if n == 22:\n            return '13211311123113112211'\n        \n        if n == 23:\n            return '111312211331121321332211'\n        \n        if n == 24:\n            return '31131122212321322211'\n        \n        if n == 25:\n            return '13211311123113112211'\n        \n        if n == 26:\n            return '111312211331121321332211'\n        \n        if n == 27:\n            return '31131122212321322211'\n        \n        if n == 28:\n            return '13211311123113112211'\n        \n        if n == 29:\n            return '111312211331121321332211'\n        \n        if n == 30:\n            return '31131122212321322211'\n        \n        if n == 31:\n            return '13211311123113112211'\n        \n        if n == 32:\n            return '111312211331121321332211'\n        \n        if n == 33:"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(target):\n            count = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1\n        \n        # find the pivot\n        # if pivot is not found, return -1\n        # if pivot is found, find the target\n        # if target is found, return the index\n        # if target is not found, return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        d = {'2':['a','b','c'],\n            '3':['d','e','f'],\n            '4':['g','h','i'],\n            '5':['j','k','l'],\n            '6':['m','n','o'],\n            '7':['p','q','r','s'],\n            '8':['t','u','v'],\n            '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(i, curr):\n            if i == len(digits):\n                res.append(curr)\n                return\n            \n            for c in d[digits[i]]:\n                backtrack(i+1, curr+c)\n        \n        backtrack(0, \"\")\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the same as n, return the nearest palindrome\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is not the"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        count = 1\n        i = 0\n        j = 0\n        while count <= n**2:\n            #right\n            while j < n-i:\n                matrix[i][j] = count\n                count += 1\n                j += 1\n            j -= 1\n            i += 1\n            #down\n            while i < n-j:\n                matrix[i][j] = count\n                count += 1\n                i += 1\n            i -= 1\n            j -= 1\n            #left\n            while j >= i:\n                matrix[i][j] = count\n                count += 1\n                j -= 1\n            j += 1\n            i -= 1\n            #up\n            while i > j:\n                matrix[i][j] = count\n                count += 1\n                i -= 1\n            i += 1\n            j += 1\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        x = x * sign\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Sliding window\n        ## 4. DP + Sliding window\n        ## 5. DP + Sliding window + Prefix and Suffix"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in encompress(score_sorted):\n            score_rank[s] = i\n        \n        # create a list of the ranks\n        rank = []\n        for s in score:\n            rank.append(score_rank[s])\n        \n        # create a list of the ranks\n        rank_str = []\n        for i in rank:\n            if i == 1:\n                rank_str.append(\"Gold Medal\")\n            elif i == 2:\n                rank_str.append(\"Silver Medal\")\n            elif i == 3:\n                rank_str.append(\"Bronze Medal\")\n            else:\n                rank_str.append(str(i))\n        \n        return rank_str"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_dict = {}\n        for word in word_dict:\n            word_dict_len_count_dict[word] = 0\n        \n        word_dict_len_count_dict[words[0]] += 1\n        \n        word_dict_len_count_dict_len = len(word_dict_len_count_dict)\n        \n        word_dict_len_count_dict_len_count = {}\n        for word in word_dict_len_count_dict:\n            word_dict_len_count_dict_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len = len(word_dict_len_count_dict_len_count)\n        \n        word_dict_len_count_dict_len_count_len_count = {}\n        for word in word_dict_len_count_dict_len_count:\n            word_dict_len_count_dict_len_count_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len_count_len = len(word_dict_len_count_dict_len_count_len_count)\n        \n        word_dict_len_count_dict_len_count_len_count_len_count = {}\n        for word in word_dict_len_count_dict_len_count_len_count:\n            word_dict_len_count_dict_len_count_len_count_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count_len_count_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len = len(word_dict_len_count_dict_len_count_len_count_len_count)\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count = {}\n        for word in word_dict_len_count_dict_len_count_len_count_len_count:\n            word_dict_len_count_dict_len_count_len_count_len_count_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count_len = len(word_dict_len_count_dict_len_count_len_count_len_count_len_count)\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count = {}\n        for word in word_dict_len_count_dict_len_count_len_count_len_count_len_count:\n            word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count[word] = 0\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count[words[0]] += 1\n        \n        word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count_len = len(word_dict_len_count_dict_len_count_len_count_len_count_len_count_len_count)\n        \n        word_dict_len_count_"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and keep track of the max\n        # 3. if the max is equal to the current index, then we have a chunk\n        # 4. if the max is less than the current index, then we have a chunk\n        # 5. if the max is greater than the current index, then we have a chunk\n        # 6. if the max is greater than the current index, then we have a chunk\n        # 7. if the max is greater than the current index, then we have a chunk\n        # 8. if the max is greater than the current index, then we have a chunk\n        # 9. if the max is greater than the current index, then we have a chunk\n        # 10. if the max is greater than the current index, then we have a chunk\n        # 11. if the max is greater than the current index, then we have a chunk\n        # 12. if the max is greater than the current index, then we have a chunk\n        # 13. if the max is greater than the current index, then we have a chunk\n        # 14. if the max is greater than the current index, then we have a chunk\n        # 15. if the max is greater than the current index, then we have a chunk\n        # 16. if the max is greater than the current index, then we have a chunk\n        # 17. if the max is greater than the current index, then we have a chunk\n        # 18. if the max is greater than the current index, then we have a chunk\n        # 19. if the max is greater than the current index, then we have a chunk\n        # 20. if the max is greater than the current index, then we have a chunk\n        # 21. if the max is greater than the current index, then we have a chunk\n        # 22. if the max is greater than the current index, then we have a chunk\n        # 23. if the max is greater than the current index, then we have a chunk\n        # 24. if the max is greater than the current index, then we have a chunk\n        # 25. if the max is greater than the current index, then we have a chunk\n        # 26. if the max is greater than the current index, then we have a chunk\n        # 27. if the max is greater than the current index, then we have a chunk\n        # 28. if the max is greater than the current index, then we have a chunk\n        # 29. if the max is greater than the current index, then we have a chunk\n        # 30. if the max is greater than the current index, then we have a chunk\n        # 31. if the max is greater than the current index, then we have a chunk\n        # 32. if the max is greater than the current index, then we have a chunk\n        # 33. if the max is greater than the current index, then we have a chunk\n        # 34. if the max is greater than the current index, then we have a chunk\n        # 35. if the max is greater than the current index, then we have a chunk\n        # 36. if the max is greater than the current index, then we have a chunk\n        # 37. if the max is greater than the current index, then we have a chunk\n        # 38. if the max is greater than the current index, then we have a chunk\n        # 39. if the max is greater than the current index, then we have a chunk\n        # 40. if the max is greater than the current index, then we have a chunk\n        # 41. if the max is greater than the current index, then we have a chunk\n        # 42. if the max is greater than the current index, then we have a chunk\n        # 43. if the max is greater than the current index, then we have a chunk\n        # 44. if the max is greater than the current index, then we have a chunk\n        # 45. if the max is greater than the current index, then we have a chunk\n        # 46. if the max is greater than the current index, then we have a chunk\n        # 47. if the max is greater than the current index, then we have a chunk\n        # 48. if the max is greater than the current index"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        \n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n            \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the matrix with the length of word1 + 1 and word2 + 1\n        # The matrix will have the following structure:\n        #\n        # word1:\n        #\n        #  0 1 2 3 4 5 6 7 8 9 10\n        #\n        # word2:\n        #\n        #  0 1 2 3 4 5 6 7 8 9 10\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n                \n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n                \n        for i in range(max(len(v1), len(v2))):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n            \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        if len(prices) <= 1:\n            return 0\n        \n        max_profit = 0\n        min_price = prices[0]\n        \n        for i in range(1, len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n            else:\n                max_profit = max(max_profit, prices[i] - min_price)\n        \n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total time\n            total += course[0]\n            \n            # if total time exceeds course duration\n            if total > course[1]:\n                # pop from priority queue\n                total -= heapq.heappop(pq)\n                \n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        while curr:\n            next_node = curr.next\n            i = 0\n            while curr and i < k:\n                curr = curr.next\n                i += 1\n            if i == k:\n                prev.next = self.reverse(head, curr)\n                prev = head\n                head = curr\n            else:\n                prev.next = head\n                break\n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = None\n        curr = head\n        while curr != tail:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return curr"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## TLE\n        ## for i in range(len(s)//2):\n        ##     if len(s)%(i+1) == 0 and s[:i+1]*(len(s)//(i+1)) == s:\n        ##         return True\n        ## return False\n        \n        ## KMP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100758/Python-KMP-solution-with-"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 2. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 3. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 4. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 5. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 6. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 7. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 8. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 9. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 10. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 11. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 12. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 13. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 14. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 15. 1, 2"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1st method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 2nd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 3rd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 4th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 5th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 6th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 7th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 8th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 9th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 10th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.44% of Python online submissions for Single Number.\n        ## Memory Usage: 15.4 MB, less than 98.44% of Python online submissions for Single Number.\n        ## 11th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 98.4"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict of all the stickers\n        # 2. build a dict of all the letters in the target\n        # 3. build a dict of all the letters in the target\n        # 4. build a dict of all the letters in the target\n        # 5. build a dict of all the letters in the target\n        # 6. build a dict of all the letters in the target\n        # 7. build a dict of all the letters in the target\n        # 8. build a dict of all the letters in the target\n        # 9. build a dict of all the letters in the target\n        # 10. build a dict of all the letters in the target\n        # 11. build a dict of all the letters in the target\n        # 12. build a dict of all the letters in the target\n        # 13. build a dict of all the letters in the target\n        # 14. build a dict of all the letters in the target\n        # 15. build a dict of all the letters in the target\n        # 16. build a dict of all the letters in the target\n        # 17. build a dict of all the letters in the target\n        # 18. build a dict of all the letters in the target\n        # 19. build a dict of all the letters in the target\n        # 20. build a dict of all the letters in the target\n        # 21. build a dict of all the letters in the target\n        # 22. build a dict of all the letters in the target\n        # 23. build a dict of all the letters in the target\n        # 24. build a dict of all the letters in the target\n        # 25. build a dict of all the letters in the target\n        # 26. build a dict of all the letters in the target\n        # 27. build a dict of all the letters in the target\n        # 28. build a dict of all the letters in the target\n        # 29. build a dict of all the letters in the target\n        # 30. build a dict of all the letters in the target\n        # 31. build a dict of all the letters in the target\n        # 32. build a dict of all the letters in the target\n        # 33. build a dict of all the letters in the target\n        # 34. build a dict of all the letters in the target\n        # 35. build a dict of all the letters in the target\n        # 36. build a dict of all the letters in the target\n        # 37. build a dict of all the letters in the target\n        # 38. build a dict of all the letters in the target\n        # 39. build a dict of all the letters in the target\n        # 40. build a dict of all the letters in the target\n        # 41. build a dict of all the letters in the target\n        # 42. build a dict of all the letters in the target\n        # 43. build a dict of all the letters in the target\n        # 44. build a dict of all the letters in the target\n        # 45. build a dict of all the letters in the target\n        # 46. build a dict of all the letters in the target\n        # 47. build a dict of all the letters in the target\n        # 48. build a dict of all the letters in the target\n        # 49. build a dict of all the letters in the target\n        # 50. build a dict of all the letters in the target\n        # 51. build a dict of all the letters in the target\n        # 52. build a dict of all the letters in the target\n        # 53. build a dict of all the letters in the target\n        # 54. build a dict of all the letters in the target\n        # 55. build a dict of all the letters in the target\n        # 56. build a dict of all the letters in the target\n        # 57. build a dict of all the letters in the target\n        # 58. build a dict of all the letters in the target\n        # 59. build a dict of all the letters in the target\n        # 60. build a dict of all the letters in the target\n        # 61. build a dict of all the letters in the"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + 1)\n        # dp[i][j] ="}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        i = 0\n        while i < len(s):\n            if i+1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n            i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## O(n) time and O(n) space\n        ## return True if any value appears at least twice in the array, and return false if every element is distinct.\n        ## \n        ## \n        ## Example 1:\n        ## Input: nums = [1,2,3,1]\n        ## Output: true\n        ## Example 2:\n        ## Input: nums = [1,2,3,4]\n        ## Output: false\n        ## Example 3:\n        ## Input: nums = [1,1,1,3,3,4,3,2,4,2]\n        ## Output: true\n        ## \n        ## \n        ## Constraints:\n        ## \n        ## \n        ## 1 <= nums.length <= 10\u2075\n        ## -10\u2079 <= nums[i] <= 10\u2079\n        ## \n        ## \n        ## \n        ## Follow up: Could you do it in one pass?\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # if len(nums) == 2:\n        #     return [max(nums[0], nums[1]), max(nums[0], nums[1])]\n        \n        # if len(nums) == 3:\n        #     return [max(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), max(nums[0], nums[2])]\n        \n        # if len(nums) == 4:\n        #     return [max(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), max(nums[0], nums[3])]\n        \n        # if len(nums) == 5:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), max(nums[0], nums[3], nums[4]), max(nums[0], nums[1], nums[4])]\n        \n        # if len(nums) == 6:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), max(nums[0], nums[3], nums[4], nums[5]), max(nums[0], nums[1], nums[4], nums[5]), max(nums[0], nums[1], nums[2], nums[4], nums[5]), max(nums[0], nums[1], nums[2], nums[3], nums[5]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[0], nums[1], num"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # 1. merge the two arrays\n        # 2. find the median\n        # 3. return the median\n        \n        # 1. merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # 2. find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        # 3. return the median\n        return median"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1430,2001,2001,1430,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1260,2640,4320,5606,5606,4320,2640,1260,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,486,1365,3003,5005,6660,6660,5005,3003,1365,486,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,560,1680,3888,6886,9240,9240,6886,3888,1680,560,102,18,1]\n        if rowIndex == 19:\n            return [1,19,103,600,2002,4860,9240,12310,12310,9240,4860,2002,600,103,19,1]\n        if rowIndex == 20:\n            return [1,20,104,645,2112,5005,9240,12310,12310,9240,5005,2112,645,104,20,1]\n        if rowIndex == 21:"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                graph[pattern].append(word)\n        \n        # build the queue\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        found = False\n        \n        while queue and not found:\n            word = queue.popleft()\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                for next_word in graph[pattern]:\n                    if next_word == endWord:\n                        found = True\n                    if next_word not in visited:\n                        visited[next_word] = word\n                        queue.append(next_word)\n        \n        # build the result\n        res = []\n        if found:\n            while endWord:\n                res.append(endWord)\n                endWord = visited[endWord]\n            res.reverse()\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if root is None:\n                return 0\n            return 1 + max(height(root.left), height(root.right))\n        \n        if root is None:\n            return True\n        \n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        if n == 1:\n            return True\n        else:\n            return False"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n            else:\n                res += [r + [nums[i]] for r in res if r[-1] != nums[i]]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 3. \uc624\ub978\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 4. \uc624\ub978\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc67c\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc67c\ucabd \uac12\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 6. \uc67c\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc67c\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc67c\ucabd \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc67c\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc67c\ucabd \uac12\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 8. \uc67c\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc67c\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc67c\ucabd \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \uac12\uc774 \uc791\uc744 \ub54c\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. find the min and max x and y\n        min_x = float('inf')\n        max_x = float('-inf')\n        min_y = float('inf')\n        max_y = float('-inf')\n        for rect in rectangles:\n            min_x = min(min_x, rect[0])\n            max_x = max(max_x, rect[2])\n            min_y = min(min_y, rect[1])\n            max_y = max(max_y, rect[3])\n            \n        ## 2. check if the area is equal to the sum of the areas of the rectangles\n        area = 0\n        for rect in rectangles:\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (max_x - min_x) * (max_y - min_y):\n            return False\n        \n        ## 3. check if the rectangles are all covered\n        rectangles_set = set()\n        for rect in rectangles:\n            rectangles_set.add((rect[0], rect[1]))\n            rectangles_set.add((rect[2], rect[1]))\n            rectangles_set.add((rect[2], rect[3]))\n            rectangles_set.add((rect[0], rect[3]))\n        if len(rectangles_set) != len(rectangles):\n            return False\n        \n        ## 4. check if the rectangles are all covered\n        for rect in rectangles:\n            if rect[0] == min_x and rect[2] == max_x and rect[1] == min_y and rect[3] == max_y:\n                continue\n            if (rect[0], rect[1]) in rectangles_set or (rect[2], rect[1]) in rectangles_set or (rect[2], rect[3]) in rectangles_set or (rect[0], rect[3]) in rectangles_set:\n                continue\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 3. 26\u8fdb\u5236\u8f6c\u6362\n        # 4. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 5. 26\u8fdb\u5236\u8f6c\u6362\n        # 6. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 7. 26\u8fdb\u5236\u8f6c\u6362\n        # 8. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 9. 26\u8fdb\u5236\u8f6c\u6362\n        # 10. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 11. 26\u8fdb\u5236\u8f6c\u6362\n        # 12. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 13. 26\u8fdb\u5236\u8f6c\u6362\n        # 14. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 15. 26\u8fdb\u5236\u8f6c\u6362\n        # 16. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 17. 26\u8fdb\u5236\u8f6c\u6362\n        # 18. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 19. 26\u8fdb\u5236\u8f6c\u6362\n        # 20. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 21. 26\u8fdb\u5236\u8f6c\u6362\n        # 22. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 23. 26\u8fdb\u5236\u8f6c\u6362\n        # 24. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 25. 26\u8fdb\u5236\u8f6c\u6362\n        # 26. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 27. 26\u8fdb\u5236\u8f6c\u6362\n        # 28. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 29. 26\u8fdb\u5236\u8f6c\u6362\n        # 30. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 31. 26\u8fdb\u5236\u8f6c\u6362\n        # 32. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 33. 26\u8fdb\u5236\u8f6c\u6362\n        # 34. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 35. 26\u8fdb\u5236\u8f6c\u6362\n        # 36. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 37. 26\u8fdb\u5236\u8f6c\u6362\n        # 38. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 39. 26\u8fdb\u5236\u8f6c\u6362\n        # 40. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 41. 26\u8fdb\u5236\u8f6c\u6362\n        # 42. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 43. 26\u8fdb\u5236\u8f6c\u6362\n        # 44. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 45. 26\u8fdb\u5236\u8f6c\u6362\n        # 46. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 47. 26\u8fdb\u5236\u8f6c\u6362\n        # 48. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 49. 26\u8fdb\u5236\u8f6c\u6362\n        # 50. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 51. 26\u8fdb\u5236\u8f6c\u6362\n        # 52. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 53. 26\u8fdb\u5236\u8f6c\u6362\n        # 54. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 55. 26\u8fdb\u5236\u8f6c\u6362\n        # 56. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 57. 26\u8fdb\u5236\u8f6c\u6362\n        # 58. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 59. 26\u8fdb\u5236\u8f6c\u6362\n        # 60. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 61. 26\u8fdb\u5236\u8f6c\u6362\n        # 62. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 63. 26\u8fdb\u5236\u8f6c\u6362\n        # 64. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 65. 26\u8fdb\u5236\u8f6c\u6362\n        # 66. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 67. 26\u8fdb\u5236\u8f6c\u6362\n        # 68. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 69. 26\u8fdb\u5236\u8f6c\u6362\n        # 70. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 71. 26\u8fdb\u5236\u8f6c\u6362\n        # 72. \u4ece\u540e\u5f80\u524d\u904d\u5386\n        # 73. 26\u8fdb\u5236\u8f6c\u6362\n        # 74. \u4ece\u540e\u5f80\u524d"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a string\n        board_str = \"\"\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                board_str += str(board[i][j])\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)\n        \n        # convert board_tuple to a string\n        board_str = str(board_tuple)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a tuple\n        board_tuple = tuple(board_list)"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n                \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if target is in nums, return True\n        # if target is not in num"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        if m == 1 and n == 1:\n            return 1\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                \n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                \n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n                \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root, min_diff, prev):\n            if root is None:\n                return\n            \n            inorder(root.left, min_diff, prev)\n            \n            if prev is not None:\n                min_diff = min(min_diff, root.val - prev)\n            \n            prev = root.val\n            \n            inorder(root.right, min_diff, prev)\n            \n            return min_diff\n        \n        return inorder(root, float('inf'), None)"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        def count(root):\n            if root is None:\n                return []\n            return [(root.val, 1 + count(root.left).count(root.val), count(root.right).count(root.val))]\n        \n        def max(root):\n            if root is None:\n                return []\n            return max(root.left) + [root.val] + max(root.right)\n        \n        def max_count(root):\n            if root is None:\n                return []\n            return max_count(root.left) + [root.val] + max_count(root.right)\n        \n        def max_count_count(root):\n            if root is None:\n                return []\n            return max_count_count(root.left) + [root.val] + max_count_count(root.right)\n        \n        def max_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count(root.left) + [root.val] + max_count_count_count(root.right)\n        \n        def max_count_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count_count(root.left) + [root.val] + max_count_count_count_count(root.right)\n        \n        def max_count_count_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count_count_count(root.left) + [root.val] + max_count_count_count_count_count(root.right)\n        \n        def max_count_count_count_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count_count_count_count(root.left) + [root.val] + max_count_count_count_count_count_count(root.right)\n        \n        def max_count_count_count_count_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count_count_count_count_count(root.left) + [root.val] + max_count_count_count_count_count_count_count(root.right)\n        \n        def max_count_count_count_count_count_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count_count_count_count_count_count(root.left) + [root.val] + max_count_count_count_count_count_count_count_count(root.right)\n        \n        def max_count_count_count_count_count_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count_count_count_count_count_count_count(root.left) + [root.val] + max_count_count_count_count_count_count_count_count_count(root.right)\n        \n        def max_count_count_count_count_count_count_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count_count_count_count_count_count_count_count(root.left) + [root.val] + max_count_count_count_count_count_count_count_count_count_count(root.right)\n        \n        def max_count_count_count_count_count_count_count_count_count(root):\n            if root is None:\n                return []\n            return max_count_count_count_count_count_count_count_count_count_count_count(root.left) + [root.val] + max_count_count_count_count_count_count_count_count_count_count(root.right)\n        \n        def max_count_count_count_count_count_count_count_count_count(root):\n            if root is None:"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1. check if the password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with the first character\n        # 4. repeat the above steps until the password is strong\n        \n        # 1"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        row = 0\n        down = False\n        \n        for i in range(len(s)):\n            res[row] += s[i]\n            if row == 0:\n                down = True\n            elif row == numRows - 1:\n                down = False\n            if down:\n                row += 1\n            else:\n                row -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Did not pass all test cases\n        ## TLE\n        ## 2022-05-25\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        #"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 5. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 6. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 7. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 8. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 9. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 10. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 11. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 12. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 13. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 14. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 15. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 16. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 17. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 18. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 19. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 20. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 21. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 22. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 23. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 24. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 25. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 26. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 27. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 28. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 29. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 30. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 31. Using extra space\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 32. Using"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. return the result\n        \n        # 1. sort the array\n        sorted_nums = sorted(nums)\n        \n        # 2. for each element, find the number of smaller elements to the right\n        # 3. return the result\n        result = []\n        for num in nums:\n            # 2.1 find the number of smaller elements to the right\n            # 2.2 add the number of smaller elements to the result\n            result.append(self.countSmallerHelper(sorted_nums, num))\n            \n        return result\n    \n    def countSmallerHelper(self, sorted_nums, num):\n        # 2.1 find the number of smaller elements to the right\n        # 2.2 add the number of smaller elements to the result\n        # 2.3 return the number of smaller elements to the right\n        # 2.4 binary search the number of smaller elements to the right\n        # 2.5 return the number of smaller elements to the right\n        # 2.6 if the number is not found, return 0\n        # 2.7 if the number is found, return the number of smaller elements to the right\n        \n        # 2.1 find the number of smaller elements to the right\n        # 2.2 add the number of smaller elements to the result\n        # 2.3 return the number of smaller elements to the right\n        # 2.4 binary search the number of smaller elements to the right\n        # 2.5 return the number of smaller elements to the right\n        # 2.6 if the number is not found, return 0\n        # 2.7 if the number is found, return the number of smaller elements to the right\n        \n        # 2.1 find the number of smaller elements to the right\n        # 2.2 add the number of smaller elements to the result\n        # 2.3 return the number of smaller elements to the right\n        # 2.4 binary search the number of smaller elements to the right\n        # 2.5 return the number of smaller elements to the right\n        # 2.6 if the number is not found, return 0\n        # 2.7 if the number is found, return the number of smaller elements to the right\n        \n        # 2.1 find the number of smaller elements to the right\n        # 2.2 add the number of smaller elements to the result\n        # 2.3 return the number of smaller elements to the right\n        # 2.4 binary search the number of smaller elements to the right\n        # 2.5 return the number of smaller elements to the right\n        # 2.6 if the number is not found, return 0\n        # 2.7 if the number is found, return the number of smaller elements to the right\n        \n        # 2.1 find the number of smaller elements to the right\n        # 2.2 add the number of smaller elements to the result\n        # 2.3 return the number of smaller elements to the right\n        # 2.4 binary search the number of smaller elements to the right\n        # 2.5 return the number of smaller elements to the right\n        # 2.6 if the number is not found, return 0\n        # 2.7 if the number is found, return the number of smaller elements to the right\n        \n        # 2.1 find the number of smaller elements to the right\n        # 2.2 add the number of smaller elements to the result\n        # 2.3 return the number of smaller elements to the right\n        # 2.4 binary search the number of smaller elements to the right\n        # 2.5 return the number of smaller elements to the right\n        # 2.6 if the number is not found, return 0\n        # 2.7 if the number is found, return the number of smaller elements to the right\n        \n        # 2.1 find the number of smaller elements to the right\n        # 2.2 add the number of smaller elements to the result\n        # 2.3 return the number of smaller elements to the right\n        # 2.4 binary search the number of smaller elements to the right\n        # 2.5 return the number of smaller elements to the right\n        # 2.6 if the number is not found, return 0\n        # 2.7 if the number is found, return"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by the start of the interval\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max and min values\n        max_val = -1\n        min_val = 10**9\n        \n        # iterate through the intervals\n        for interval in intervals:\n            # if the max value is less than the start of the interval\n            if max_val < interval[0]:\n                # set the max value to the start of the interval\n                max_val = interval[0]\n                # increment the result by 2\n                res += 2\n            # if the min value is greater than the end of the interval\n            if min_val > interval[1]:\n                # set the min value to the end of the interval\n                min_val = interval[1]\n                # increment the result by 1\n                res += 1\n        \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            if left.val != right.val:\n                return False\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return result"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n            \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 4. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 5. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 6. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 7. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 8. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 9. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 10. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 11. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 12. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 13. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 14. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 15. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 16. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 17. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 18. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 19. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 20. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 21. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 22. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 23. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 24. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 25. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 26. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 27. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 28. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 29. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 30. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder = remainder * 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str = str(quotient) + remainder_str\n        if remainder == 0:\n            remainder_str = \"\"\n        return sign + str(quotient) + remainder_str"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Initialize a list to store the maximum number of envelopes\n        max_envelopes = [envelopes[0][1]]\n        \n        # Iterate through the envelopes\n        for i in range(1, len(envelopes)):\n            # If the current envelope's height is greater than the last envelope's height, add it to the list\n            if envelopes[i][1] > max_envelopes[-1]:\n                max_envelopes.append(envelopes[i][1])\n            # Otherwise, binary search for the index of the last envelope with a height less than or equal to the current envelope's height\n            else:\n                left, right = 0, len(max_envelopes) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if max_envelopes[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                max_envelopes[left] = envelopes[i][1]\n        \n        # Return the length of the list\n        return len(max_envelopes)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 3. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 4. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 5. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 6. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 7. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 8. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 9. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 10. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 11. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 12. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 13. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 14. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 15. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 16. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 17. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 18. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 19. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 20. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 21. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 22. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 23. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 24. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 25. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 26. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 27. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 28. Using"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        ## 2. Find the nth node from the end\n        ## 2.1 Find the nth node from the end\n        ## 2.2 Find the nth node from the end\n        ## 2.3 Find the nth node from the end\n        ## 2.4 Find the nth node from the end\n        ## 2.5 Find the nth node from the end\n        ## 2.6 Find the nth node from the end\n        ## 2.7 Find the nth node from the end\n        ## 2.8 Find the nth node from the end\n        ## 2.9 Find the nth node from the end\n        ## 2.10 Find the nth node from the end\n        ## 2.11 Find the nth node from the end\n        ## 2.12 Find the nth node from the end\n        ## 2.13 Find the nth node from the end\n        ## 2.14 Find the nth node from the end\n        ## 2.15 Find the nth node from the end\n        ## 2.16 Find the nth node from the end\n        ## 2.17 Find the nth node from the end\n        ## 2.18 Find the nth node from the end\n        ## 2.19 Find the nth node from the end\n        ## 2.20 Find the nth node from the end\n        ## 2.21 Find the nth node from the end\n        ## 2.22 Find the nth node from the end\n        ## 2.23 Find the nth node from the end\n        ## 2.24 Find the nth node from the end\n        ## 2.25 Find the nth node from the end\n        ## 2.26 Find the nth node from the end\n        ## 2.27 Find the nth node from the end\n        ## 2.28 Find the nth node from the end\n        ## 2.29 Find the nth node from the end\n        ## 2.30 Find the nth node from the end\n        ## 2.31 Find the nth node from the end\n        ## 2.32 Find the nth node from the end\n        ## 2.33 Find the nth node from the end\n        ## 2.34 Find the nth node from the end\n        ## 2.35 Find the nth node from the end\n        ## 2.36 Find the nth node from the end\n        ## 2.37 Find the nth node from the end\n        ## 2.38 Find the nth node from the end\n        ## 2.39 Find the nth node from the end\n        ## 2.40 Find the nth node from the end\n        ## 2.41 Find the nth node from the end\n        ## 2.42 Find the nth node from the end\n        ## 2.43 Find the nth node from the end\n        ## 2.44 Find the nth node from the end\n        ## 2.45 Find the nth node from the end\n        ## 2.46 Find the nth node from the end\n        ## 2.47 Find the nth node from the end\n        ## 2.48 Find the nth node from the end\n        ## 2.49 Find the nth node from the end\n        ## 2.50 Find the nth node from the end\n        ## 2.51 Find the nth node from the end\n        ## 2.52 Find the nth node from the end\n        ## 2.53 Find the nth node from the end\n        ## 2.54 Find the nth node from the end\n        ## 2.55 Find the nth node from the end\n        ## 2.56 Find the nth node from the end\n        ## 2.57 Find the nth node from the end\n        #"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use collections.Counter\n        ## 4. use collections.defaultdict\n        ## 5. use collections.Counter\n        ## 6. use collections.defaultdict\n        ## 7. use collections.Counter\n        ## 8. use collections.defaultdict\n        ## 9. use collections.Counter\n        ## 10. use collections.defaultdict\n        ## 11. use collections.Counter\n        ## 12. use collections.defaultdict\n        ## 13. use collections.Counter\n        ## 14. use collections.defaultdict\n        ## 15. use collections.Counter\n        ## 16. use collections.defaultdict\n        ## 17. use collections.Counter\n        ## 18. use collections.defaultdict\n        ## 19. use collections.Counter\n        ## 20. use collections.defaultdict\n        ## 21. use collections.Counter\n        ## 22. use collections.defaultdict\n        ## 23. use collections.Counter\n        ## 24. use collections.defaultdict\n        ## 25. use collections.Counter\n        ## 26. use collections.defaultdict\n        ## 27. use collections.Counter\n        ## 28. use collections.defaultdict\n        ## 29. use collections.Counter\n        ## 30. use collections.defaultdict\n        ## 31. use collections.Counter\n        ## 32. use collections.defaultdict\n        ## 33. use collections.Counter\n        ## 34. use collections.defaultdict\n        ## 35. use collections.Counter\n        ## 36. use collections.defaultdict\n        ## 37. use collections.Counter\n        ## 38. use collections.defaultdict\n        ## 39. use collections.Counter\n        ## 40. use collections.defaultdict\n        ## 41. use collections.Counter\n        ## 42. use collections.defaultdict\n        ## 43. use collections.Counter\n        ## 44. use collections.defaultdict\n        ## 45. use collections.Counter\n        ## 46. use collections.defaultdict\n        ## 47. use collections.Counter\n        ## 48. use collections.defaultdict\n        ## 49. use collections.Counter\n        ## 50. use collections.defaultdict\n        ## 51. use collections.Counter\n        ## 52. use collections.defaultdict\n        ## 53. use collections.Counter\n        ## 54. use collections.defaultdict\n        ## 55. use collections.Counter\n        ## 56. use collections.defaultdict\n        ## 57. use collections.Counter\n        ## 58. use collections.defaultdict\n        ## 59. use collections.Counter\n        ## 60. use collections.defaultdict\n        ## 61. use collections.Counter\n        ## 62. use collections.defaultdict\n        ## 63. use collections.Counter\n        ## 64. use collections.defaultdict\n        ## 65. use collections.Counter\n        ## 66. use collections.defaultdict\n        ## 67. use collections.Counter\n        ## 68. use collections.defaultdict\n        ## 69. use collections.Counter\n        ## 70. use collections.defaultdict\n        ## 71. use collections.Counter\n        ## 72. use collections.defaultdict\n        ## 73. use collections.Counter\n        ## 74. use collections.defaultdict\n        ## 75. use collections.Counter\n        ## 76. use collections.defaultdict\n        ## 77. use collections.Counter\n        ## 78. use collections.defaultdict\n        ## 79. use collections.Counter\n        ## 80. use collections.defaultdict\n        ## 81. use collections.Counter\n        ## 82. use collections.defaultdict\n        ## 83. use collections.Counter"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(machines) == 1:\n            return 0\n        \n        total = sum(machines)\n        if total % len(machines) != 0:\n            return -1\n        \n        avg = total // len(machines)\n        curr = 0\n        ans = 0\n        for i in range(len(machines)):\n            curr += machines[i]\n            machines[i] -= avg\n            ans = max(ans, abs(curr))\n            if machines[i] > 0:\n                curr -= machines[i]\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[1]:\n        #     return nums[0]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 2nd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 3rd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 4th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 5th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 6th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 7th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 8th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 9th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## 10th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.95% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def is_valid(board,row,col,num):\n            return not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row - row%3,col - col%3,num)\n        \n        def solve_sudoku(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if is_valid(board,row,col,str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the first node where the value is greater than the previous node\n        ## Find the second node where the value is greater than the first node\n        ## Swap the values of the two nodes\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## In"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        if num < 4:\n            return False\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # while head and head.val == val:\n        #     head = head.next\n        \n        # if head is None:\n        #     return None\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited,board):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited,board) or dfs(i-1,j,word[1:],visited,board) or dfs(i,j+1,word[1:],visited,board) or dfs(i,j-1,word[1:],visited,board)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for i in range(len(board[0]))] for j in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited,board):\n                        res.append(word)\n                        break\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # 2. check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # 3. check 3x3 sub-boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                sub_box = [board[i][j], board[i][j+1], board[i][j+2],\n                           board[i+1][j], board[i+1][j+1], board[i+1][j+2],\n                           board[i+2][j], board[i+2][j+1], board[i+2][j+2]]\n                if len(set(sub_box)) != len(sub_box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        # restore the original list\n        first.next = None\n        return first"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern and the length of the words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping of pattern to words\n        mapping = {}\n        \n        # iterate over the pattern\n        for i, c in enumerate(pattern):\n            # if the pattern is not in the mapping, add it to the mapping\n            if c not in mapping:\n                mapping[c] = words[i]\n            # if the pattern is in the mapping, check if the word is not the same as the word in the mapping\n            elif mapping[c] != words[i]:\n                return False\n        \n        # if all the words are mapped, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers of nums are used\n            # we print the current permutation\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result list\n        result = ListNode()\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Loop through the lists\n        while l1 or l2 or carry:\n            # Calculate the sum\n            sum = carry\n            if l1:\n                sum += l1.val\n            if l2:\n                sum += l2.val\n            # Calculate the new carry\n            carry = sum // 10\n            # Calculate the new digit\n            digit = sum % 10\n            # Create a new node with the digit\n            current.next = ListNode(digit)\n            # Move to the next node\n            current = current.next\n            # Move to the next node\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        # Return the result list\n        return result.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert to binary\n        ## 2. reverse the binary\n        ## 3. convert back to decimal\n        \n        ## 1. convert to binary\n        binary = \"\"\n        while num > 0:\n            binary = str(num % 2) + binary\n            num = num // 2\n            \n        ## 2. reverse the binary\n        binary = binary[::-1]\n        \n        ## 3. convert back to decimal\n        decimal = 0\n        for i in range(len(binary)):\n            decimal += int(binary[i]) * (2 ** i)\n            \n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Did this code successfully run on Leetcode : Yes\n        ## Any problem you faced while coding this : No\n        \n        ## Approach:\n        ## 1. Iterate through the array and find the max area\n        ## 2. Find the area of the rectangle formed by the two pointers\n        ## 3. Update the max area if the area is greater\n        ## 4. Move the pointer with the smaller height\n        ## 5. Continue until the pointers meet\n        \n        ## Initialization\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        ## Iterate through the array\n        while left < right:\n            ## Find the area of the rectangle formed by the two pointers\n            area = min(height[left], height[right]) * (right - left)\n            ## Update the max area if the area is greater\n            max_area = max(max_area, area)\n            ## Move the pointer with the smaller height\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max element\n        # 3. if the list has 3 elements, return the third element\n        # 4. if the list has more than 3 elements, return the third element\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}