{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        #edge case\n        if len(matrix) == 0:\n            return []\n        \n        #initialize variables\n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left = 0\n        right = n - 1\n        top = 0\n        bottom = m - 1\n        \n        #loop until left and right cross\n        while left <= right and top <= bottom:\n            #top row\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            #right col\n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            #bottom row\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            #left col\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) < len(t):\n        #     return 0\n        # if len(s) == len(t):\n        #     return 1 if s == t else 0\n        # if len(s) == 1:\n        #     return 1 if s == t else 0\n        # if len(s) == 2:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] else 0\n        # if len(s) == 3:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] else 0\n        # if len(s) == 4:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] else 0\n        # if len(s) == 5:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] else 0\n        # if len(s) == 6:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] else 0\n        # if len(s) == 7:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] else 0\n        # if len(s) == 8:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] else 0\n        # if len(s) == 9:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] else 0\n        # if len(s) == 10:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] else 0\n        # if len(s) == 11:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] and s[10] == t[10] else 0\n        # if len(s) == 12:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 sum\n        # 3. 2 sum\n        # 4. 2 sum\n        # 5. 2 sum\n        # 6. 2 sum\n        # 7. 2 sum\n        # 8. 2 sum\n        # 9. 2 sum\n        # 10. 2 sum\n        # 11. 2 sum\n        # 12. 2 sum\n        # 13. 2 sum\n        # 14. 2 sum\n        # 15. 2 sum\n        # 16. 2 sum\n        # 17. 2 sum\n        # 18. 2 sum\n        # 19. 2 sum\n        # 20. 2 sum\n        # 21. 2 sum\n        # 22. 2 sum\n        # 23. 2 sum\n        # 24. 2 sum\n        # 25. 2 sum\n        # 26. 2 sum\n        # 27. 2 sum\n        # 28. 2 sum\n        # 29. 2 sum\n        # 30. 2 sum\n        # 31. 2 sum\n        # 32. 2 sum\n        # 33. 2 sum\n        # 34. 2 sum\n        # 35. 2 sum\n        # 36. 2 sum\n        # 37. 2 sum\n        # 38. 2 sum\n        # 39. 2 sum\n        # 40. 2 sum\n        # 41. 2 sum\n        # 42. 2 sum\n        # 43. 2 sum\n        # 44. 2 sum\n        # 45. 2 sum\n        # 46. 2 sum\n        # 47. 2 sum\n        # 48. 2 sum\n        # 49. 2 sum\n        # 50. 2 sum\n        # 51. 2 sum\n        # 52. 2 sum\n        # 53. 2 sum\n        # 54. 2 sum\n        # 55. 2 sum\n        # 56. 2 sum\n        # 57. 2 sum\n        # 58. 2 sum\n        # 59. 2 sum\n        # 60. 2 sum\n        # 61. 2 sum\n        # 62. 2 sum\n        # 63. 2 sum\n        # 64. 2 sum\n        # 65. 2 sum\n        # 66. 2 sum\n        # 67. 2 sum\n        # 68. 2 sum\n        # 69. 2 sum\n        # 70. 2 sum\n        # 71. 2 sum\n        # 72. 2 sum\n        # 73. 2 sum\n        # 74. 2 sum\n        # 75. 2 sum\n        # 76. 2 sum\n        # 77. 2 sum\n        # 78. 2 sum\n        # 79. 2 sum\n        # 80. 2 sum\n        # 81. 2 sum\n        # 82. 2 sum\n        # 83. 2 sum\n        # 84. 2 sum\n        # 85. 2 sum\n        # 86. 2 sum\n        # 87. 2 sum\n        # 88. 2 sum\n        # 89. 2 sum\n        # 90. 2 sum\n        # 91. 2 sum\n        # 92. 2 sum\n        # 93. 2 sum\n        # 94. 2 sum\n        # 95. 2 sum\n        # 96. 2 sum\n        # 97. 2 sum\n        # 98. 2 sum\n        # 99. 2 sum\n        # 100. 2 sum\n        # 101. 2 sum\n        # 102. 2 sum\n        # 103."}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, res, curr, prev):\n            if not num:\n                if curr == target:\n                    res.append(op)\n                return\n            for i in range(1, len(num) + 1):\n                if i == 1 or (i > 1 and num[0] != '0'):\n                    curr = curr * 10 + int(num[:i])\n                    op = op + '*' + num[:i]\n                    backtrack(num[i:], target, op, res, curr, curr)\n                    op = op[:-i]\n                    curr = curr - int(num[:i])\n                elif i == 2 and num[0] == '0':\n                    break\n                else:\n                    break\n        \n        res = []\n        if not num:\n            return res\n        backtrack(num, target, '', res, 0, 0)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## Recursive solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. Morris traversal solution\n        ## 4. Binary tree inorder traversal solution\n        ## 5. Binary tree preorder traversal solution\n        ## 6. Binary tree postorder traversal solution\n        ## 7. Binary tree level order traversal solution\n        ## 8. Binary tree level order traversal solution\n        ## 9. Binary tree level order traversal solution\n        ## 10. Binary tree level order traversal solution\n        ## 11. Binary tree level order traversal solution\n        ## 12. Binary tree level order traversal solution\n        ## 13. Binary tree level order traversal solution\n        ## 14. Binary tree level order traversal solution\n        ## 15. Binary tree level order traversal solution\n        ## 16. Binary tree level order traversal solution\n        ## 17. Binary tree level order traversal solution\n        ## 18. Binary tree level order traversal solution\n        ## 19. Binary tree level order traversal solution\n        ## 20. Binary tree level order traversal solution\n        ## 21. Binary tree level order traversal solution\n        ## 22. Binary tree level order traversal solution\n        ## 23. Binary tree level order traversal solution\n        ## 24. Binary tree level order traversal solution\n        ## 25. Binary tree level order traversal solution\n        ## 26. Binary tree level order traversal solution\n        ## 27. Binary tree level order traversal solution\n        ## 28. Binary tree level order traversal solution\n        ## 29. Binary tree level order traversal solution\n        ## 30. Binary tree level order traversal solution\n        ## 31. Binary tree level order traversal solution\n        ## 32. Binary tree level order traversal solution\n        ## 33. Binary tree level order traversal solution\n        ## 34. Binary tree level order traversal solution\n        ## 35. Binary tree level order traversal solution\n        ## 36. Binary tree level order traversal solution\n        ## 37. Binary tree level order traversal solution\n        ## 38. Binary tree level order traversal solution\n        ## 39. Binary tree level order traversal solution\n        ## 40. Binary tree level order traversal solution\n        ## 41. Binary tree level order traversal solution\n        ## 42. Binary tree level order traversal solution\n        ## 43. Binary tree level order traversal solution\n        ## 44. Binary tree level order traversal solution\n        ## 45. Binary tree level order traversal solution\n        ## 46. Binary tree level order traversal solution\n        ## 47. Binary tree level order traversal solution\n        ## 48. Binary tree level order traversal solution\n        ## 49. Binary tree level order traversal solution\n        ## 50. Binary tree level order traversal solution\n        ## 51. Binary tree level order traversal solution\n        ## 52. Binary tree level order traversal solution\n        ## 53. Binary tree level order traversal solution\n        ## 54. Binary tree level order traversal solution\n        ## 55. Binary tree level order traversal solution\n        ## 56. Binary tree level order traversal solution\n        ## 57. Binary tree level order traversal solution\n        ## 58. Binary tree level order traversal solution\n        ## 59. Binary tree level order traversal solution\n        ## 60. Binary tree level order traversal"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        ## 1. Convert all uppercase letters to lowercase letters\n        s = s.lower()\n        \n        ## 2. Remove all dashes\n        s = s.replace('-', '')\n        \n        ## 3. Get the length of the string\n        n = len(s)\n        \n        ## 4. Get the number of groups\n        num_groups = n // k\n        \n        ## 5. Get the number of characters in the last group\n        num_chars_last_group = n % k\n        \n        ## 6. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 7. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 8. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 9. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 10. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 11. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 12. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 13. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 14. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 15. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 16. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 17. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 18. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 19. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 20. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 21. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 22. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 23. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 24. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 25. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 26. Get the number of characters in the first group\n        num_chars_first_group = k - num_chars_last_group\n        \n        ## 27. Get the number of characters in the last group\n        num_chars_last_group = k - num_chars_last_group\n        \n        ## 28. Get the number of characters in the first group\n        num"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the total gas and cost\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        ## 2. If total gas is less than total cost, return -1\n        if total_gas < total_cost:\n            return -1\n        \n        ## 3. Find the starting point\n        start = 0\n        curr_gas = 0\n        for i in range(len(gas)):\n            curr_gas += gas[i] - cost[i]\n            if curr_gas < 0:\n                start = i + 1\n                curr_gas = 0\n        \n        ## 4. If the starting point is the last station, return the starting point\n        if start == len(gas):\n            return start\n        \n        ## 5. If the starting point is not the last station, return -1\n        return -1"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then return false if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', then check if the first character of s is '*'\n            if self.isMatch(s, p[2:]):\n                return True\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', then check if the first character of s is '*'\n            if self.isMatch(s, p[2:]):\n                return True\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', then check if the first character of s is '*'\n            if self.isMatch(s, p[2:]):\n                return True\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', then check if the first character of s is '*'\n            if self.isMatch(s, p[2:]):\n                return True\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', then check if the first character of s is '*'\n            if self.isMatch(s, p[2:]):\n                return True\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            # if the first character of p is not '*', then check if the first character of s is not '*'\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then check if the first character of p is '*'\n        if len(p) > 1 and p"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i * i == num:\n                    sum += i\n                else:\n                    sum += i + num // i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        # 1. 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30\n        # 2. 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494427, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729889, 956722026041, 1548008755920, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077078050, 3416454621906707, 5527939709074868, 8944394331971585, 14472334041046462, 23416728373018047, 37889062414064508, 6130"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], 1)\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i-1][j] - dungeon[i][j])\n        # dp[i][j] = min(dp[i][j], dp[i][j-1] - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dp[i][j-1] - dun"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the left and right pointers\n        left, right = 0, len(nums) - 1\n        \n        # initialize the count variable\n        count = 0\n        \n        # loop until the left pointer is less than the right pointer\n        while left < right:\n            \n            # calculate the distance between the left and right elements\n            distance = nums[right] - nums[left]\n            \n            # if the distance is less than the kth smallest distance, increment the count\n            if distance < k:\n                count += right - left\n                left += 1\n            else:\n                # if the distance is greater than the kth smallest distance, decrement the right pointer\n                right -= 1\n        \n        # return the count\n        return count"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in range(len(s)):\n        #     if s[i] != \" \" and s[i-1] == \" \":\n        #         count += 1\n        # return count\n        \n        # if s == \"\":\n        #     return 0\n        # count = 0\n        # for i in"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowels_list = []\n        vowels_dict = {}\n        for i in range(len(s)):\n            if s[i] in vowels:\n                vowels_list.append(s[i])\n                vowels_dict[s[i]] = i\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)\n        # print(vowels_dict)\n        \n        # print(vowels_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Edge Case:\n        if len(nums) == 0:\n            return 0\n        \n        # Create a hashmap to store the number and its index\n        num_map = {}\n        for i in range(len(nums)):\n            num_map[nums[i]] = i\n        \n        # Create a set to store the visited numbers\n        visited = set()\n        \n        # Create a variable to store the longest consecutive sequence\n        longest_seq = 0\n        \n        # Iterate through the hashmap\n        for num in num_map:\n            # If the number is not visited, then continue\n            if num not in visited:\n                # Create a variable to store the current number\n                curr_num = num\n                # Create a variable to store the current sequence\n                curr_seq = 1\n                # Create a variable to store the next number\n                next_num = num + 1\n                # Create a variable to store the next number\n                prev_num = num - 1\n                \n                # While the next number is in the hashmap and not visited\n                while next_num in num_map and next_num not in visited:\n                    # Add the next number to the visited set\n                    visited.add(next_num)\n                    # Increment the current sequence by 1\n                    curr_seq += 1\n                    # Update the current number to the next number\n                    curr_num = next_num\n                    # Update the next number to the next number + 1\n                    next_num += 1\n                \n                # While the previous number is in the hashmap and not visited\n                while prev_num in num_map and prev_num not in visited:\n                    # Add the previous number to the visited set\n                    visited.add(prev_num)\n                    # Increment the current sequence by 1\n                    curr_seq += 1\n                    # Update the current number to the previous number\n                    curr_num = prev_num\n                    # Update the previous number to the previous number - 1\n                    prev_num -= 1\n                \n                # Update the longest sequence if the current sequence is greater than the current longest sequence\n                longest_seq = max(longest_seq, curr_seq)\n        \n        # Return the longest sequence\n        return longest_seq"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the property of XOR to find the missing number.\n        ## 2. We can use the property of XOR to find the missing number.\n        ## 3. We can use the property of XOR to find the missing number.\n        ## 4. We can use the property of XOR to find the missing number.\n        ## 5. We can use the property of XOR to find the missing number.\n        ## 6. We can use the property of XOR to find the missing number.\n        ## 7. We can use the property of XOR to find the missing number.\n        ## 8. We can use the property of XOR to find the missing number.\n        ## 9. We can use the property of XOR to find the missing number.\n        ## 10. We can use the property of XOR to find the missing number.\n        ## 11. We can use the property of XOR to find the missing number.\n        ## 12. We can use the property of XOR to find the missing number.\n        ## 13. We can use the property of XOR to find the missing number.\n        ## 14. We can use the property of XOR to find the missing number.\n        ## 15. We can use the property of XOR to find the missing number.\n        ## 16. We can use the property of XOR to find the missing number.\n        ## 17. We can use the property of XOR to find the missing number.\n        ## 18. We can use the property of XOR to find the missing number.\n        ## 19. We can use the property of XOR to find the missing number.\n        ## 20. We can use the property of XOR to find the missing number.\n        ## 21. We can use the property of XOR to find the missing number.\n        ## 22. We can use the property of XOR to find the missing number.\n        ## 23. We can use the property of XOR to find the missing number.\n        ## 24. We can use the property of XOR to find the missing number.\n        ## 25. We can use the property of XOR to find the missing number.\n        ## 26. We can use the property of XOR to find the missing number.\n        ## 27. We can use the property of XOR to find the missing number.\n        ## 28. We can use the property of XOR to find the missing number.\n        ## 29. We can use the property of XOR to find the missing number.\n        ## 30. We can use the property of XOR to find the missing number.\n        ## 31. We can use the property of XOR to find the missing number.\n        ## 32. We can use the property of XOR to find the missing number.\n        ## 33. We can use the property of XOR to find the missing number.\n        ## 34. We can use the property of XOR to find the missing number.\n        ## 35. We can use the property of XOR to find the missing number.\n        ## 36. We can use the property of XOR to find the missing number.\n        ## 37. We can use the property of XOR to find the missing number.\n        ## 38. We can use the property of XOR to find the missing number.\n        ## 39. We can use the property of XOR to find the missing number.\n        ## 40. We can use the property of XOR to find the missing number.\n        ## 41. We can use the property of XOR to find the missing number.\n        ## 42. We can use the property of XOR to find the missing number.\n        ## 43. We can use the property of XOR to find the missing number.\n        ## 44. We can use the property of XOR to find the missing number.\n        ## 45. We can use the property of XOR to find the missing number."}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        ## BFS\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## Create a graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        ## Create a queue\n        queue = deque([beginWord])\n        ## Create a set to keep track of visited nodes\n        visited = set([beginWord])\n        ## Create a counter to keep track of the number of steps\n        steps = 1\n        \n        ## BFS\n        while queue:\n            ## Get the number of nodes in the queue\n            size = len(queue)\n            ## Iterate through the nodes in the queue\n            for _ in range(size):\n                ## Get the current node\n                node = queue.popleft()\n                ## Get the neighbors of the current node\n                for i in range(len(node)):\n                    ## Get the neighbor\n                    neighbor = node[:i] + \"*\" + node[i+1:]\n                    ## Get the neighbors of the neighbor\n                    neighbors = graph[neighbor]\n                    ## Iterate through the neighbors\n                    for neighbor in neighbors:\n                        ## If the neighbor is the end word, return the number of steps + 1\n                        if neighbor == endWord:\n                            return steps + 1\n                        ## If the neighbor has not been visited, add it to the queue and add it to the visited set\n                        if neighbor not in visited:\n                            queue.append(neighbor)\n                            visited.add(neighbor)\n            ## Increment the number of steps\n            steps += 1\n        \n        ## If the end word is not in the graph, return 0\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # if len(a) < len(b):\n        #     a, b = b, a\n        #     # print(a, b)\n        #     # print(len(a), len(b))\n        #     # print(a[::-1], b[::-1])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # binary search"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if k > len(prices) / 2:\n        #     return sum(max(prices[i+1] - prices[i], 0) for i in range(len(prices) - 1))\n        \n        # if k == 0:\n        #     return 0\n        \n        # if len(prices) == 1:\n        #     return 0\n        \n        # if len(prices) == 2:\n        #     return max(prices[1] - prices[0], 0)\n        \n        # if len(prices) == 3:\n        #     return max(prices[2] - prices[0], max(prices[1] - prices[0], max(prices[2] - prices[1], 0)))\n        \n        # if len(prices) == 4:\n        #     return max(prices[3] - prices[0], max(prices[2] - prices[1], max(prices[3] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], 0)))))\n        \n        # if len(prices) == 5:\n        #     return max(prices[4] - prices[0], max(prices[3] - prices[1], max(prices[4] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[4] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], 0))))))))))\n        \n        # if len(prices) == 6:\n        #     return max(prices[5] - prices[0], max(prices[4] - prices[1], max(prices[5] - prices[4], max(prices[5] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[5] - prices[4], max(prices[5] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[5] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[4] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[4] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[4] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[4] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[4] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[3] - prices[1], max(prices[2] - prices[0], max(prices[4] - prices[3], max(prices[4] - prices[2], max(prices[3] - prices[1], max(prices[2"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {\n            0:\"0\",\n            1:\"1\",\n            2:\"2\",\n            3:\"3\",\n            4:\"4\",\n            5:\"5\",\n            6:\"6\",\n            7:\"7\",\n            8:\"8\",\n            9:\"9\",\n            10:\"a\",\n            11:\"b\",\n            12:\"c\",\n            13:\"d\",\n            14:\"e\",\n            15:\"f\"\n        }\n        \n        hex_str = \"\"\n        while num > 0:\n            remainder = num % 16\n            hex_str = hex_dict[remainder] + hex_str\n            num = num // 16\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Create a hashmap to store the frequency of each character in the string\n        ## 2. Iterate through the string and for each character, check if it is in the hashmap\n        ## 3. If it is, increment the frequency by 1\n        ## 4. If it is not, add it to the hashmap with frequency 1\n        ## 5. Iterate through the string again and for each character, check if the frequency is 1\n        ## 6. If it is, return the index of the character\n        ## 7. If it is not, return -1\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Create a hashmap to store the frequency of each character in the string\n        hashmap = {}\n        \n        ## Iterate through the string and for each character, check if it is in the hashmap\n        ## If it is, increment the frequency by 1\n        ## If it is not, add it to the hashmap with frequency 1\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        ## Iterate through the string again and for each character, check if the frequency is 1\n        ## If it is, return the index of the character\n        ## If it is not, return -1\n        for i, char in enumerate(s):\n            if hashmap[char] == 1:\n                return i\n        \n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # if indexDiff < 0:\n        #     return False\n        \n        # if valueDiff < 0:\n        #     return False\n        \n        # if indexDiff >= len(nums):\n        #     return False\n        \n        # if valueDiff >= len(nums):\n        #     return False\n        \n        # if valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0:\n        #     return False\n        \n        # if indexDiff == 1:\n        #     return False\n        \n        # if indexDiff == 2:\n        #     return False\n        \n        # if indexDiff == 3:\n        #     return False\n        \n        # if indexDiff == 4:\n        #     return False\n        \n        # if indexDiff == 5:\n        #     return False\n        \n        # if indexDiff == 6:\n        #     return False\n        \n        # if indexDiff == 7:\n        #     return False\n        \n        # if indexDiff == 8:\n        #     return False\n        \n        # if indexDiff == 9:\n        #     return False\n        \n        # if indexDiff == 10:\n        #     return False\n        \n        # if indexDiff == 11:\n        #     return False\n        \n        # if indexDiff == 12:\n        #     return False\n        \n        # if indexDiff == 13:\n        #     return False\n        \n        # if indexDiff == 14:\n        #     return False\n        \n        # if indexDiff == 15:\n        #     return False\n        \n        # if indexDiff == 16:\n        #     return False\n        \n        # if indexDiff == 17:\n        #     return False\n        \n        # if indexDiff == 18:\n        #     return False\n        \n        # if indexDiff == 19:\n        #     return False\n        \n        # if indexDiff == 20:\n        #     return False\n        \n        # if indexDiff == 21:\n        #     return False\n        \n        # if indexDiff == 22:\n        #     return False\n        \n        # if indexDiff == 23:\n        #     return False\n        \n        # if indexDiff == 24:\n        #     return False\n        \n        # if indexDiff == 25:\n        #     return False\n        \n        # if indexDiff == 26:\n        #     return False\n        \n        # if indexDiff == 27:\n        #     return False\n        \n        # if indexDiff == 28:\n        #     return False\n        \n        # if indexDiff == 29:\n        #     return False\n        \n        # if indexDiff == 30:\n        #     return False\n        \n        # if indexDiff == 31:\n        #     return False\n        \n        # if indexDiff == 32:\n        #     return False\n        \n        # if indexDiff == 33:\n        #     return False\n        \n        # if indexDiff == 34:\n        #     return False\n        \n        # if indexDiff == 35:\n        #     return False\n        \n        # if indexDiff == 36:\n        #     return False\n        \n        # if indexDiff == 37:\n        #     return False\n        \n        # if indexDiff == 38:\n        #     return False\n        \n        # if indexDiff == 39:\n        #     return False\n        \n        # if indexDiff == 40:\n        #     return False\n        \n        # if indexDiff == 41:\n        #     return False\n        \n        # if indexDiff == 42:\n        #     return False\n        \n        # if indexDiff == 43:\n        #     return False\n        \n        # if indexDiff == 44:\n        #     return False\n        \n        # if indexDiff == 45:\n        #     return False\n        \n        # if indexDiff == 46:\n        #     return False\n        \n        # if indexDiff == 47:\n        #     return False\n        \n        # if indexDiff == 48:\n        #     return False\n        \n        # if indexDiff == 49:\n        #     return False\n        \n        # if indexDiff == 50:\n        #     return False\n        \n        # if indexDiff"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        # 3 -> left\n        # 4 -> right\n        # 5 -> left\n        # 6 -> right\n        # 7 -> left\n        # 8 -> right\n        # 9 -> left\n        # 10 -> right\n        # 11 -> left\n        # 12 -> right\n        # 13 -> left\n        # 14 -> right\n        # 15 -> left\n        # 16 -> right\n        # 17 -> left\n        # 18 -> right\n        # 19 -> left\n        # 20 -> right\n        # 21 -> left\n        # 22 -> right\n        # 23 -> left\n        # 24 -> right\n        # 25 -> left\n        # 26 -> right\n        # 27 -> left\n        # 28 -> right\n        # 29 -> left\n        # 30 -> right\n        # 31 -> left\n        # 32 -> right\n        # 33 -> left\n        # 34 -> right\n        # 35 -> left\n        # 36 -> right\n        # 37 -> left\n        # 38 -> right\n        # 39 -> left\n        # 40 -> right\n        # 41 -> left\n        # 42 -> right\n        # 43 -> left\n        # 44 -> right\n        # 45 -> left\n        # 46 -> right\n        # 47 -> left\n        # 48 -> right\n        # 49 -> left\n        # 50 -> right\n        # 51 -> left\n        # 52 -> right\n        # 53 -> left\n        # 54 -> right\n        # 55 -> left\n        # 56 -> right\n        # 57 -> left\n        # 58 -> right\n        # 59 -> left\n        # 60 -> right\n        # 61 -> left\n        # 62 -> right\n        # 63 -> left\n        # 64 -> right\n        # 65 -> left\n        # 66 -> right\n        # 67 -> left\n        # 68 -> right\n        # 69 -> left\n        # 70 -> right\n        # 71 -> left\n        # 72 -> right\n        # 73 -> left\n        # 74 -> right\n        # 75 -> left\n        # 76 -> right\n        # 77 -> left\n        # 78 -> right\n        # 79 -> left\n        # 80 -> right\n        # 81 -> left\n        # 82 -> right\n        # 83 -> left\n        # 84 -> right\n        # 85 -> left\n        # 86 -> right\n        # 87 -> left\n        # 88 -> right\n        # 89 -> left\n        # 90 -> right\n        # 91 -> left\n        # 92 -> right\n        # 93 -> left\n        # 94 -> right\n        # 95 -> left\n        # 96 -> right\n        # 97 -> left\n        # 98 -> right\n        # 99 -> left\n        # 100 -> right\n        # 101 -> left\n        # 102 -> right\n        # 103 -> left\n        # 104 -> right\n        # 105 -> left\n        # 106 -> right\n        # 107 -> left\n        # 108 -> right\n        # 109 -> left\n        # 110 -> right\n        # 111 -> left\n        # 112 -> right\n        # 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. Sliding Window\n        ## Time"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        height = 0\n        while root:\n            height += 1\n            root = root.left\n        return height"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc22b\uc790\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\n        nums = []\n        # 2. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\n        ops = []\n        # 3. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op = ''\n        # 4. \uc22b\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        num = 0\n        # 5. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num = 0\n        # 6. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_2 = 0\n        # 7. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_3 = 0\n        # 8. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_4 = 0\n        # 9. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_5 = 0\n        # 10. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_6 = 0\n        # 11. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_7 = 0\n        # 12. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_8 = 0\n        # 13. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_9 = 0\n        # 14. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_10 = 0\n        # 15. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_11 = 0\n        # 16. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_12 = 0\n        # 17. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_13 = 0\n        # 18. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_14 = 0\n        # 19. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_15 = 0\n        # 20. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_16 = 0\n        # 21. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_17 = 0\n        # 22. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ud560 \ubcc0\uc218\n        op_num_18 = 0\n        # 23. \uc5f0\uc0b0\uc790\ub97c \uc800\uc7a5\ufffd"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits = [profits[i] for i in range(len(profits))]\n        # capital = [capital[i] for i in range(len(capital))]\n        # profits.sort()\n        # capital.sort()\n        # print(profits)\n        # print(capital)\n        # print(profits[0])\n        # print(capital[0])\n        # print(profits[1])\n        # print(capital[1])\n        # print(profits[2])\n        # print(capital[2])\n        # print(profits[3])\n        # print(capital[3])\n        # print(profits[4])\n        # print(capital[4])\n        # print(profits[5])\n        # print(capital[5])\n        # print(profits[6])\n        # print(capital[6])\n        # print(profits[7])\n        # print(capital[7])\n        # print(profits[8])\n        # print(capital[8])\n        # print(profits[9])\n        # print(capital[9])\n        # print(profits[10])\n        # print(capital[10])\n        # print(profits[11])\n        # print(capital[11])\n        # print(profits[12])\n        # print(capital[12])\n        # print(profits[13])\n        # print(capital[13])\n        # print(profits[14])\n        # print(capital[14])\n        # print(profits[15])\n        # print(capital[15])\n        # print(profits[16])\n        # print(capital[16])\n        # print(profits[17])\n        # print(capital[17])\n        # print(profits[18])\n        # print(capital[18])\n        # print(profits[19])\n        # print(capital[19])\n        # print(profits[20])\n        # print(capital[20])\n        # print(profits[21])\n        # print(capital[21])\n        # print(profits[22])\n        # print(capital[22])\n        # print(profits[23])\n        # print(capital[23])\n        # print(profits[24])\n        # print(capital[24])\n        # print(profits[25])\n        # print(capital[25])\n        # print(profits[26])\n        # print(capital[26])\n        # print(profits[27])\n        # print(capital[27])\n        # print(profits[28])\n        # print(capital[28])\n        # print(profits[29])\n        # print(capital[29])\n        # print(profits[30])\n        # print(capital[30])\n        # print(profits[31])\n        # print(capital[31])\n        # print(profits[32])\n        # print(capital[32])\n        # print(profits[33])\n        # print(capital[33])\n        # print(profits[34])\n        # print(capital[34])\n        # print(profits[35])\n        # print(capital[35])\n        # print(profits[36])\n        # print(capital[36])\n        # print(profits[37])\n        # print(capital[37])\n        # print(profits[38])\n        # print(capital[38])\n        # print(profits[39])\n        # print(capital[39])\n        # print(profits[40])\n        # print(capital[40])\n        # print(profits[41])\n        # print(capital[41])\n        # print(profits[42])\n        # print(capital[42])\n        # print(profits[43])\n        # print(capital"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets.values():\n        #         stack.append(char)\n        #     elif char in brackets.keys():\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        # return True if not stack else False\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets.values():\n        #         stack.append(char)\n        #     elif char in brackets.keys():\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        # return True if not stack else False\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets.values():\n        #         stack.append(char)\n        #     elif char in brackets.keys():\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        # return True if not stack else False\n        \n        if len(s) % 2 != 0:\n            return False\n        \n        stack = []\n        brackets = {\n            ')': '(',\n            ']': '[',\n            '}': '{',\n        }\n        \n        for char in s:\n            if char in brackets.values():\n                stack.append(char)\n            elif char in brackets.keys():\n                if stack and stack[-1] == brackets[char]:\n                    stack.pop()\n                else:\n                    return False\n        return True if not stack else False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap\n        \n        # Create a hashmap to store the number and its index\n        # Iterate through the array\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        # If the number is not in the hashmap, add the number to the hashmap"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        # find min and max\n        min_num = min(nums)\n        max_num = max(nums)\n        \n        # if min and max are the same, return 0\n        if min_num == max_num:\n            return 0\n        \n        # calculate the range\n        range_ = max_num - min_num\n        \n        # calculate the bucket size\n        bucket_size = range_ // (len(nums) - 1) or 1\n        \n        # calculate the bucket count\n        bucket_count = range_ // bucket_size + 1\n        \n        # initialize the buckets\n        buckets = [None] * bucket_count\n        \n        # fill the buckets\n        for num in nums:\n            bucket_index = (num - min_num) // bucket_size\n            if buckets[bucket_index] is None:\n                buckets[bucket_index] = [num, num]\n            else:\n                buckets[bucket_index][0] = min(buckets[bucket_index][0], num)\n                buckets[bucket_index][1] = max(buckets[bucket_index][1], num)\n        \n        # find the max gap\n        max_gap = 0\n        prev_max = buckets[0][1]\n        for bucket in buckets[1:]:\n            if bucket is None:\n                continue\n            max_gap = max(max_gap, bucket[0] - prev_max)\n            prev_max = bucket[1]\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2n couples, 2n/2 swaps\n        # 2. 2n couples, 2n/2 swaps\n        # 3. 2n couples, 2n/2 swaps\n        # 4. 2n couples, 2n/2 swaps\n        # 5. 2n couples, 2n/2 swaps\n        # 6. 2n couples, 2n/2 swaps\n        # 7. 2n couples, 2n/2 swaps\n        # 8. 2n couples, 2n/2 swaps\n        # 9. 2n couples, 2n/2 swaps\n        # 10. 2n couples, 2n/2 swaps\n        # 11. 2n couples, 2n/2 swaps\n        # 12. 2n couples, 2n/2 swaps\n        # 13. 2n couples, 2n/2 swaps\n        # 14. 2n couples, 2n/2 swaps\n        # 15. 2n couples, 2n/2 swaps\n        # 16. 2n couples, 2n/2 swaps\n        # 17. 2n couples, 2n/2 swaps\n        # 18. 2n couples, 2n/2 swaps\n        # 19. 2n couples, 2n/2 swaps\n        # 20. 2n couples, 2n/2 swaps\n        # 21. 2n couples, 2n/2 swaps\n        # 22. 2n couples, 2n/2 swaps\n        # 23. 2n couples, 2n/2 swaps\n        # 24. 2n couples, 2n/2 swaps\n        # 25. 2n couples, 2n/2 swaps\n        # 26. 2n couples, 2n/2 swaps\n        # 27. 2n couples, 2n/2 swaps\n        # 28. 2n couples, 2n/2 swaps\n        # 29. 2n couples, 2n/2 swaps\n        # 30. 2n couples, 2n/2 swaps\n        # 31. 2n couples, 2n/2 swaps\n        # 32. 2n couples, 2n/2 swaps\n        # 33. 2n couples, 2n/2 swaps\n        # 34. 2n couples, 2n/2 swaps\n        # 35. 2n couples, 2n/2 swaps\n        # 36. 2n couples, 2n/2 swaps\n        # 37. 2n couples, 2n/2 swaps\n        # 38. 2n couples, 2n/2 swaps\n        # 39. 2n couples, 2n/2 swaps\n        # 40. 2n couples, 2n/2 swaps\n        # 41. 2n couples, 2n/2 swaps\n        # 42. 2n couples, 2n/2 swaps\n        # 43. 2n couples, 2n/2 swaps\n        # 44. 2n couples, 2n/2 swaps\n        # 45. 2n couples, 2n/2 swaps\n        # 46. 2n couples, 2n/2 swaps\n        # 47. 2n couples, 2n/2 swaps\n        # 48. 2n couples, 2n/2 swaps\n        # 49. 2n couples, 2n/2 swaps\n        # 50. 2n couples, 2n/2 swaps\n        # 51. 2n couples, 2n/2 swaps\n        # 52. 2n couples, 2n/2 swaps\n        # 53. 2n couples, 2n/2 swaps\n        # 54. 2n couples, 2n/2 swaps\n        # 55."}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        if s1[0] == s3[0]:\n            return self.isInterleave(s1[1:], s2, s3[1:])\n        \n        if s2[0] == s3[0]:\n            return self.isInterleave(s1, s2[1:], s3[1:])\n        \n        return False"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the greed factors and sizes\n        g.sort()\n        s.sort()\n        \n        # initialize the number of children and cookies\n        num_children = len(g)\n        num_cookies = len(s)\n        \n        # initialize the number of cookies that can be given to children\n        num_cookies_given = 0\n        \n        # iterate through the greed factors and sizes\n        for i in range(num_children):\n            # iterate through the sizes\n            for j in range(num_cookies):\n                # if the size is greater than or equal to the greed factor, increment the number of cookies that can be given to children\n                if s[j] >= g[i]:\n                    num_cookies_given += 1\n                    break\n        \n        # return the number of cookies that can be given to children\n        return num_cookies_given"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Create a dictionary with the letters of the alphabet\n        # 2. Create a list of the rows of the keyboard\n        # 3. Iterate through the words\n        # 4. Check if the word is in the same row as the first letter\n        # 5. If it is, add it to the list of words that can be typed using the keyboard\n        # 6. If it is not, add it to the list of words that can't be typed using the keyboard\n        \n        keyboard = {\n            'q': [1, 2, 3],\n            'w': [1, 2, 3],\n            'e': [1, 2, 3],\n            'r': [1, 2, 3],\n            't': [1, 2, 3],\n            'y': [1, 2, 3],\n            'u': [1, 2, 3],\n            'i': [1, 2, 3],\n            'o': [1, 2, 3],\n            'p': [1, 2, 3],\n            'a': [4, 5, 6],\n            's': [4, 5, 6],\n            'd': [4, 5, 6],\n            'f': [4, 5, 6],\n            'g': [4, 5, 6],\n            'h': [4, 5, 6],\n            'j': [4, 5, 6],\n            'k': [4, 5, 6],\n            'l': [4, 5, 6],\n            'z': [7, 8, 9],\n            'x': [7, 8, 9],\n            'c': [7, 8, 9],\n            'v': [7, 8, 9],\n            'b': [7, 8, 9],\n            'n': [7, 8, 9],\n            'm': [7, 8, 9]\n        }\n        \n        # 1. Create a list of the rows of the keyboard\n        rows = [keyboard[word[0].lower()] for word in words]\n        \n        # 2. Iterate through the words\n        # 3. Check if the word is in the same row as the first letter\n        # 4. If it is, add it to the list of words that can be typed using the keyboard\n        # 5. If it is not, add it to the list of words that can't be typed using the keyboard\n        res = []\n        for word in words:\n            if rows[0] == keyboard[word[0].lower()]:\n                res.append(word)\n            else:\n                for row in rows[1:]:\n                    if set(row).issubset(set(keyboard[word[0].lower()])):\n                        res.append(word)\n                        break\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if left == right:\n        #     return head\n        \n        # if left == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # prev = dummy\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     prev = curr\n        #     curr = curr.next\n        #     count += 1\n        \n        # prev.next = None\n        # curr = curr.next\n        # count = 1\n        # while count < right:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        #     count += 1\n        \n        # head = prev\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     curr = curr.next\n        #     count += 1\n        \n        # curr.next = prev\n        # return head\n        \n        # if left == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # prev = dummy\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     prev = curr\n        #     curr = curr.next\n        #     count += 1\n        \n        # prev.next = None\n        # curr = curr.next\n        # count = 1\n        # while count < right:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        #     count += 1\n        \n        # head = prev\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     curr = curr.next\n        #     count += 1\n        \n        # curr.next = prev\n        # return head\n        \n        # if left == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # prev = dummy\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     prev = curr\n        #     curr = curr.next\n        #     count += 1\n        \n        # prev.next = None\n        # curr = curr.next\n        # count = 1\n        # while count < right:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        #     count += 1\n        \n        # head = prev\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     curr = curr.next\n        #     count += 1\n        \n        # curr.next = prev\n        # return head\n        \n        # if left == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # prev = dummy\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     prev = curr\n        #     curr = curr.next\n        #     count += 1\n        \n        # prev.next = None\n        # curr = curr.next\n        # count = 1\n        # while count < right:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        #     count += 1\n        \n        # head = prev\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     curr = curr.next\n        #     count += 1\n        \n        # curr.next = prev\n        # return head\n        \n        # if left == 1:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # prev = dummy\n        # curr = head\n        # count = 1\n        # while count < left:\n        #     prev = curr\n        #     curr = curr"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. Otherwise, return the concatenated string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # Edge case\n        if len(s) < len(t):\n            return \"\"\n        \n        # Initialize the hashmap for t\n        t_map = {}\n        for c in t:\n            if c not in t_map:\n                t_map[c] = 0\n            t_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map[c] += 1\n        \n        # Initialize the hashmap for s\n        s_map = {}\n        for c in s:\n            if c not in s_map:\n                s_map[c] = 0\n            s_map["}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 1st case: \n        # 2. 2nd case: \n        # 3. 3rd case: \n        # 4. 4th case: \n        # 5. 5th case: \n        # 6. 6th case: \n        # 7. 7th case: \n        # 8. 8th case: \n        # 9. 9th case: \n        # 10. 10th case: \n        # 11. 11th case: \n        # 12. 12th case: \n        # 13. 13th case: \n        # 14. 14th case: \n        # 15. 15th case: \n        # 16. 16th case: \n        # 17. 17th case: \n        # 18. 18th case: \n        # 19. 19th case: \n        # 20. 20th case: \n        # 21. 21th case: \n        # 22. 22th case: \n        # 23. 23th case: \n        # 24. 24th case: \n        # 25. 25th case: \n        # 26. 26th case: \n        # 27. 27th case: \n        # 28. 28th case: \n        # 29. 29th case: \n        # 30. 30th case: \n        # 31. 31th case: \n        # 32. 32th case: \n        # 33. 33th case: \n        # 34. 34th case: \n        # 35. 35th case: \n        # 36. 36th case: \n        # 37. 37th case: \n        # 38. 38th case: \n        # 39. 39th case: \n        # 40. 40th case: \n        # 41. 41th case: \n        # 42. 42th case: \n        # 43. 43th case: \n        # 44. 44th case: \n        # 45. 45th case: \n        # 46. 46th case: \n        # 47. 47th case: \n        # 48. 48th case: \n        # 49. 49th case: \n        # 50. 50th case: \n        # 51. 51th case: \n        # 52. 52th case: \n        # 53. 53th case: \n        # 54. 54th case: \n        # 55. 55th case: \n        # 56. 56th case: \n        # 57. 57th case: \n        # 58. 58th case: \n        # 59. 59th case: \n        # 60. 60th case: \n        # 61. 61th case: \n        # 62. 62th case: \n        # 63. 63th case: \n        # 64. 64th case: \n        # 65. 65th case: \n        # 66. 66th case: \n        # 67. 67th case: \n        # 68. 68th case: \n        # 69. 69th case: \n        # 70. 70th case: \n        # 71. 71th case: \n        # 72. 72th case: \n        # 73. 73th case: \n        # 74. 74th case: \n        # 75."}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next.val:\n        #     head = head.next\n        #     return self.deleteDuplicates(head)\n        \n        # head.next = self.deleteDuplicates(head.next)\n        # return head\n        \n        # if head.next is None:\n        #     return head\n        \n        # if head.val == head.next"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5\ub41c \ubb38\uc790\ub97c \uc81c\uc678\ud55c \ubb38\uc790\ub4e4\uc758 \uac1c\uc218\ub97c \uc138\uc5b4\uc900\ub2e4.\n        # 2. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ube7c\uc900\ub2e4.\n        # 3. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 1\uc744 \ube7c\uc900\ub2e4.\n        # 4. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 5. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 6. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 7. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 8. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 9. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 10. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 11. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc5c6\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4.\n        # 12. \uc911\ubcf5\ub41c \ubb38\uc790\uac00 \uc788\ub2e4\uba74 \uc911\ubcf5\ub41c \ubb38\uc790\uc758 \uac1c\uc218\uc5d0\uc11c 2\ub97c \ub354\ud574\uc900\ub2e4."}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        left_inorder = inorder[:root_index]\n        right_inorder = inorder[root_index+1:]\n        left_postorder = postorder[:len(left_inorder)]\n        right_postorder = postorder[len(left_inorder):-1]\n        \n        root.left = self.buildTree(left_inorder, left_postorder)\n        root.right = self.buildTree(right_inorder, right_postorder)\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add the shortest path to the total path\n        \n        # 1. find the starting point\n        # 2. find the shortest path from the starting point to all the trees\n        # 3. find the shortest path from the starting point to the tree with the shortest path\n        # 4. add"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return self.minDepth(root.right) + 1\n        \n        if root.right is None:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 2:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 3:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 4:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 5:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 6:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 7:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 8:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 9:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 10:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 11:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 12:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 13:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 14:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 15:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 16:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 17:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 18:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 19:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 20:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 21:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 22:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 23:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 24:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 25:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 26:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 27:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 28:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 29:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 30:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 31:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 32:"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        \n        if len(a) > len(b):\n            return len(a)\n        elif len(a) < len(b):\n            return len(b)\n        else:\n            return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)\n        \n        # if len(a) > len(b):\n        #     return len(a)\n        # elif len(a) < len(b):\n        #     return len(b)\n        # else:\n        #     return len(a)"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        if x < 100:\n            return True\n        \n        if x < 1000:\n            if x % 11 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 10000:\n            if x % 111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 100000:\n            if x % 1111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 1000000:\n            if x % 11111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 10000000:\n            if x % 111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 100000000:\n            if x % 1111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 1000000000:\n            if x % 11111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 10000000000:\n            if x % 111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 100000000000:\n            if x % 1111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 1000000000000:\n            if x % 11111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 10000000000000:\n            if x % 111111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 100000000000000:\n            if x % 1111111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 1000000000000000:\n            if x % 11111111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 10000000000000000:\n            if x % 111111111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 100000000000000000:\n            if x % 1111111111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 1000000000000000000:\n            if x % 11111111111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 10000000000000000000:\n            if x % 111111111111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 100000000000000000000:\n            if x % 1111111111111111111 == 0:\n                return True\n            else:\n                return False\n        \n        if x < 1000000000000000000000:"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the max number that can be represented by n bits\n        # 2. 2^n - 1 - 2^(n-1) is the min number that can be represented by n bits\n        # 3. 2^n - 1 - 2^(n-1) + 1 is the max number that can be represented by n bits\n        # 4. 2^n - 1 - 2^(n-1) + 2 is the min number that can be represented by n bits\n        # 5. 2^n - 1 - 2^(n-1) + 3 is the max number that can be represented by n bits\n        # 6. 2^n - 1 - 2^(n-1) + 4 is the min number that can be represented by n bits\n        # 7. 2^n - 1 - 2^(n-1) + 5 is the max number that can be represented by n bits\n        # 8. 2^n - 1 - 2^(n-1) + 6 is the min number that can be represented by n bits\n        # 9. 2^n - 1 - 2^(n-1) + 7 is the max number that can be represented by n bits\n        # 10. 2^n - 1 - 2^(n-1) + 8 is the min number that can be represented by n bits\n        # 11. 2^n - 1 - 2^(n-1) + 9 is the max number that can be represented by n bits\n        # 12. 2^n - 1 - 2^(n-1) + 10 is the min number that can be represented by n bits\n        # 13. 2^n - 1 - 2^(n-1) + 11 is the max number that can be represented by n bits\n        # 14. 2^n - 1 - 2^(n-1) + 12 is the min number that can be represented by n bits\n        # 15. 2^n - 1 - 2^(n-1) + 13 is the max number that can be represented by n bits\n        # 16. 2^n - 1 - 2^(n-1) + 14 is the min number that can be represented by n bits\n        # 17. 2^n - 1 - 2^(n-1) + 15 is the max number that can be represented by n bits\n        # 18. 2^n - 1 - 2^(n-1) + 16 is the min number that can be represented by n bits\n        # 19. 2^n - 1 - 2^(n-1) + 17 is the max number that can be represented by n bits\n        # 20. 2^n - 1 - 2^(n-1) + 18 is the min number that can be represented by n bits\n        # 21. 2^n - 1 - 2^(n-1) + 19 is the max number that can be represented by n bits\n        # 22. 2^n - 1 - 2^(n-1) + 20 is the min number that can be represented by n bits\n        # 23. 2^n - 1 - 2^(n-1) + 21 is the max number that can be represented by n bits\n        # 24. 2^n - 1 - 2^(n-1) + 22 is the min number that can be represented by n bits\n        # 25. 2^n - 1 - 2^(n-1) + 23 is the max number that can be represented by n bits\n        # 26. 2^n - 1 - 2^(n-1) + 24 is the min number that can be represented by n bits\n        # 27. 2^n - 1 - 2^(n-1) + 25 is the max number that can be represented by n bits\n        # 28. 2^n - 1 - 2^(n-1) + 26 is the min number that can be represented by n bits\n        # 29. 2^n - 1 - 2^(n-1"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # return self.climbStairs(n-1) + self.climbStairs(n-2)\n        \n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 5\n        # if n == 5:\n        #     return 8\n        # if n == 6:\n        #     return 13\n        # if n == 7:\n        #     return 21\n        # if n == 8:\n        #     return 34\n        # if n == 9:\n        #     return 55\n        # if n == 10:\n        #     return 89\n        # if n == 11:\n        #     return 144\n        # if n == 12:\n        #     return 233\n        # if n == 13:\n        #     return 377\n        # if n == 14:\n        #     return 610\n        # if n == 15:\n        #     return 987\n        # if n == 16:\n        #     return 1597\n        # if n == 17:\n        #     return 2584\n        # if n == 18:\n        #     return 4181\n        # if n == 19:\n        #     return 6765\n        # if n == 20:\n        #     return 10946\n        # if n == 21:\n        #     return 17711\n        # if n == 22:\n        #     return 28657\n        # if n == 23:\n        #     return 46368\n        # if n == 24:\n        #     return 75025\n        # if n == 25:\n        #     return 121393\n        # if n == 26:\n        #     return 196418\n        # if n == 27:\n        #     return 317811\n        # if n == 28:\n        #     return 514229\n        # if n == 29:\n        #     return 832040\n        # if n == 30:\n        #     return 1346269\n        # if n == 31:\n        #     return 2178309\n        # if n == 32:\n        #     return 3524578\n        # if n == 33:\n        #     return 5702887\n        # if n == 34:\n        #     return 9237416\n        # if n == 35:\n        #     return 14930352\n        # if n == 36:\n        #     return 24157817\n        # if n == 37:\n        #     return 39088169\n        # if n == 38:\n        #     return 63245986\n        # if n == 39:\n        #     return 102334155\n        # if n == 40:\n        #     return 165580141\n        # if n == 41:\n        #     return 267914296\n        # if n == 42:\n        #     return 433494437\n        # if n == 43:\n        #     return 701408733\n        # if n == 44:\n        #     return 1134903170\n        # if n == 45:\n        #     return 1836311903\n        \n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 5\n        #"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## 1. Create a list of all the possible words\n        ## 2. Iterate through the string and check if the substring is in the list\n        ## 3. If it is, then check if the substring is in the list\n        ## 4. If it is, then check if the substring is in the list\n        ## 5. If it is, then check if the substring is in the list\n        ## 6. If it is, then check if the substring is in the list\n        ## 7. If it is, then check if the substring is in the list\n        ## 8. If it is, then check if the substring is in the list\n        ## 9. If it is, then check if the substring is in the list\n        ## 10. If it is, then check if the substring is in the list\n        ## 11. If it is, then check if the substring is in the list\n        ## 12. If it is, then check if the substring is in the list\n        ## 13. If it is, then check if the substring is in the list\n        ## 14. If it is, then check if the substring is in the list\n        ## 15. If it is, then check if the substring is in the list\n        ## 16. If it is, then check if the substring is in the list\n        ## 17. If it is, then check if the substring is in the list\n        ## 18. If it is, then check if the substring is in the list\n        ## 19. If it is, then check if the substring is in the list\n        ## 20. If it is, then check if the substring is in the list\n        ## 21. If it is, then check if the substring is in the list\n        ## 22. If it is, then check if the substring is in the list\n        ## 23. If it is, then check if the substring is in the list\n        ## 24. If it is, then check if the substring is in the list\n        ## 25. If it is, then check if the substring is in the list\n        ## 26. If it is, then check if the substring is in the list\n        ## 27. If it is, then check if the substring is in the list\n        ## 28. If it is, then check if the substring is in the list\n        ## 29. If it is, then check if the substring is in the list\n        ## 30. If it is, then check if the substring is in the list\n        ## 31. If it is, then check if the substring is in the list\n        ## 32. If it is, then check if the substring is in the list\n        ## 33. If it is, then check if the substring is in the list\n        ## 34. If it is, then check if the substring is in the list\n        ## 35. If it is, then check if the substring is in the list\n        ## 36. If it is, then check if the substring is in the list\n        ## 37. If it is, then check if the substring is in the list\n        ## 38. If it is, then check if the substring is in the list\n        ## 39. If it is, then check if the substring is in the list\n        ## 40. If it is, then check if the substring is in the list\n        ## 41. If it is, then check if the substring is in the list\n        ## 42. If it is, then check if the substring is in the list\n        ## 43. If it is, then check if the substring is in the list\n        ## 44. If it is, then check if the substring is in the list\n        ## 45. If it is, then check if the substring is in the list\n        ## 46. If it is, then check if the substring is in"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return inorder(root.left, min_val, root.val) and inorder(root.right, root.val, max_val)\n        \n        return inorder(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # edge case\n        if len(intervals) == 0:\n            return [newInterval]\n        \n        # edge case\n        if len(intervals) == 1:\n            if newInterval[0] <= intervals[0][0]:\n                return [newInterval]\n            else:\n                return [intervals[0]]\n        \n        # edge case\n        if newInterval[0] > intervals[-1][0]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[1] >= intervals[-1][0]:\n            intervals[-1][1] = newInterval[1]\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] >= intervals[-1][0]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] > intervals[-1][0]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] > intervals[0][0] and newInterval[1] > intervals[-1][0]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] > intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] > intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] > intervals[0][0] and newInterval[1] > intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] > intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] > intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0][0] and newInterval[1] < intervals[-1][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] < intervals[0"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val = float('inf')\n        max_val = float('-inf')\n        \n        # 2. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list = []\n        max_val_list = []\n        \n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list.append(nums[0][0])\n        max_val_list.append(nums[0][0])\n        \n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list.append(nums[0][0])\n        max_val_list.append(nums[0][0])\n        \n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list.append(nums[0][0])\n        max_val_list.append(nums[0][0])\n        \n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list.append(nums[0][0])\n        max_val_list.append(nums[0][0])\n        \n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list.append(nums[0][0])\n        max_val_list.append(nums[0][0])\n        \n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list.append(nums[0][0])\n        max_val_list.append(nums[0][0])\n        \n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list.append(nums[0][0])\n        max_val_list.append(nums[0][0])\n        \n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        min_val_list.append(nums[0][0])\n        max_val_list.append(nums[0][0])\n        \n        # 11. \ucd5c\ufffd"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # BFS\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # Dijkstra\n        # Time Complexity: O(n^2 * log(n^2))\n        # Space Complexity: O(n^2"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the sum\n        sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # loop through the array\n        while index < len(candidates):\n            \n            # if the sum is less than the target\n            if sum < target:\n                \n                # push the candidate to the stack\n                stack.append(candidates[index])\n                \n                # increment the sum\n                sum += candidates[index]\n                \n                # increment the index\n                index += 1\n                \n            # if the sum is greater than the target\n            elif sum > target:\n                \n                # pop the last element from the stack\n                sum -= stack.pop()\n                \n            # if the sum is equal to the target\n            else:\n                \n                # add the stack to the result\n                result.append(stack.copy())\n                \n                # pop the last element from the stack\n                sum -= stack.pop()\n                \n                # increment the index\n                index += 1\n                \n            # if the sum is equal to the target\n            if sum == target:\n                \n                # add the stack to the result\n                result.append(stack.copy())\n                \n                # pop the last element from the stack\n                sum -= stack.pop()\n                \n                # increment the index\n                index += 1\n                \n            # if the sum is greater than the target\n            if sum > target:\n                \n                # pop the last element from the stack\n                sum -= stack.pop()\n                \n            # if the sum is less than the target\n            else:\n                \n                # increment the index\n                index += 1\n                \n        # return the result\n        return result"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(word) == 1:\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return False\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return False\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return False\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return False\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return False\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return False\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return False\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return False\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return False\n        \n        # if word[0"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = []\n        # res = []\n        # while root or stack:\n        #     while root:\n        #         stack.append(root)\n        #         root = root.left\n        #     root = stack.pop()\n        #     res.append(root.val)\n        #     root = root.right\n        # return res\n        \n        # Recursive solution\n        if root is None:\n            return []\n        res = []\n        if root.left:\n            res += self.inorderTraversal(root.left)\n        res.append(root.val)\n        if root.right:\n            res += self.inorderTraversal(root.right)\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        \n        left_preorder = preorder[1:root_index+1]\n        right_preorder = preorder[root_index+1:]\n        \n        left_inorder = inorder[:root_index]\n        right_inorder = inorder[root_index+1:]\n        \n        root.left = self.buildTree(left_preorder, left_inorder)\n        root.right = self.buildTree(right_preorder, right_inorder)\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. find the left and right parentheses\n        # 2. find the number of left and right parentheses\n        # 3. find the number of left and right parentheses that are not matched\n        # 4. find the number of left and right parentheses that are not matched\n        # 5. find the number of left and right parentheses that are not matched\n        # 6. find the number of left and right parentheses that are not matched\n        # 7. find the number of left and right parentheses that are not matched\n        # 8. find the number of left and right parentheses that are not matched\n        # 9. find the number of left and right parentheses that are not matched\n        # 10. find the number of left and right parentheses that are not matched\n        # 11. find the number of left and right parentheses that are not matched\n        # 12. find the number of left and right parentheses that are not matched\n        # 13. find the number of left and right parentheses that are not matched\n        # 14. find the number of left and right parentheses that are not matched\n        # 15. find the number of left and right parentheses that are not matched\n        # 16. find the number of left and right parentheses that are not matched\n        # 17. find the number of left and right parentheses that are not matched\n        # 18. find the number of left and right parentheses that are not matched\n        # 19. find the number of left and right parentheses that are not matched\n        # 20. find the number of left and right parentheses that are not matched\n        # 21. find the number of left and right parentheses that are not matched\n        # 22. find the number of left and right parentheses that are not matched\n        # 23. find the number of left and right parentheses that are not matched\n        # 24. find the number of left and right parentheses that are not matched\n        # 25. find the number of left and right parentheses that are not matched\n        # 26. find the number of left and right parentheses that are not matched\n        # 27. find the number of left and right parentheses that are not matched\n        # 28. find the number of left and right parentheses that are not matched\n        # 29. find the number of left and right parentheses that are not matched\n        # 30. find the number of left and right parentheses that are not matched\n        # 31. find the number of left and right parentheses that are not matched\n        # 32. find the number of left and right parentheses that are not matched\n        # 33. find the number of left and right parentheses that are not matched\n        # 34. find the number of left and right parentheses that are not matched\n        # 35. find the number of left and right parentheses that are not matched\n        # 36. find the number of left and right parentheses that are not matched\n        # 37. find the number of left and right parentheses that are not matched\n        # 38. find the number of left and right parentheses that are not matched\n        # 39. find the number of left and right parentheses that are not matched\n        # 40. find the number of left and right parentheses that are not matched\n        # 41. find the number of left and right parentheses that are not matched\n        # 42. find the number of left and right parentheses that are not matched\n        # 43. find the number of left and right parentheses that are not matched\n        # 44. find the number of left and right parentheses that are not matched\n        # 45. find the number of left and right parentheses that are not matched\n        # 46. find the number of left and right parentheses that are not matched\n        # 47. find the number of left and right parentheses that are not matched\n        # 48. find the number of left and right parentheses that are not matched\n        # 49. find the number of left and right parentheses that are not matched\n        # 50. find the number of left and right parent"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # Time Complexity: O(nlogk)\n        # Space Complexity: O(1)\n        \n        # Edge Case:\n        # If the list is empty, return None\n        if not lists:\n            return None\n        \n        # If the list has only one element, return that element\n        if len(lists) == 1:\n            return lists[0]\n        \n        # If the list has more than one element, merge them\n        while len(lists) > 1:\n            # Create a new list to store the merged lists\n            merged_list = []\n            \n            # Iterate through the lists\n            for i in range(0, len(lists), 2):\n                # If the list has an odd number of elements, add the last element to the merged list\n                if i + 1 >= len(lists):\n                    merged_list.append(lists[i])\n                    break\n                \n                # Merge the two lists\n                merged_list.append(self.mergeTwoLists(lists[i], lists[i + 1]))\n            \n            # Update the lists to the merged list\n            lists = merged_list\n        \n        # Return the first element of the merged list\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Edge Case:\n        # If either list is empty, return the other list\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        \n        # Create a new list node to store the merged list\n        merged_list = ListNode()\n        \n        # Create a pointer to the merged list\n        merged_list_ptr = merged_list\n        \n        # Iterate through the lists\n        while l1 and l2:\n            # If the first list is smaller than the second list, add the first list to the merged list\n            if l1.val < l2.val:\n                merged_list_ptr.next = l1\n                l1 = l1.next\n            # If the second list is smaller than the first list, add the second list to the merged list\n            else:\n                merged_list_ptr.next = l2\n                l2 = l2.next\n            \n            # Move the merged list pointer to the next node\n            merged_list_ptr = merged_list_ptr.next\n        \n        # If the first list is longer than the second list, add the remaining elements of the first list to the merged list\n        if l1:\n            merged_list_ptr.next = l1\n        # If the second list is longer than the first list, add the remaining elements of the second list to the merged list\n        if l2:\n            merged_list_ptr.next = l2\n        \n        # Return the merged list\n        return merged_list.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^5 = 10^4 * 5 + 1\n        # 2. 10^5 = 10^4 * 5 + 1\n        # 3. 10^5 = 10^4 * 5 + 1\n        # 4. 10^5 = 10^4 * 5 + 1\n        # 5. 10^5 = 10^4 * 5 + 1\n        # 6. 10^5 = 10^4 * 5 + 1\n        # 7. 10^5 = 10^4 * 5 + 1\n        # 8. 10^5 = 10^4 * 5 + 1\n        # 9. 10^5 = 10^4 * 5 + 1\n        # 10. 10^5 = 10^4 * 5 + 1\n        # 11. 10^5 = 10^4 * 5 + 1\n        # 12. 10^5 = 10^4 * 5 + 1\n        # 13. 10^5 = 10^4 * 5 + 1\n        # 14. 10^5 = 10^4 * 5 + 1\n        # 15. 10^5 = 10^4 * 5 + 1\n        # 16. 10^5 = 10^4 * 5 + 1\n        # 17. 10^5 = 10^4 * 5 + 1\n        # 18. 10^5 = 10^4 * 5 + 1\n        # 19. 10^5 = 10^4 * 5 + 1\n        # 20. 10^5 = 10^4 * 5 + 1\n        # 21. 10^5 = 10^4 * 5 + 1\n        # 22. 10^5 = 10^4 * 5 + 1\n        # 23. 10^5 = 10^4 * 5 + 1\n        # 24. 10^5 = 10^4 * 5 + 1\n        # 25. 10^5 = 10^4 * 5 + 1\n        # 26. 10^5 = 10^4 * 5 + 1\n        # 27. 10^5 = 10^4 * 5 + 1\n        # 28. 10^5 = 10^4 * 5 + 1\n        # 29. 10^5 = 10^4 * 5 + 1\n        # 30. 10^5 = 10^4 * 5 + 1\n        # 31. 10^5 = 10^4 * 5 + 1\n        # 32. 10^5 = 10^4 * 5 + 1\n        # 33. 10^5 = 10^4 * 5 + 1\n        # 34. 10^5 = 10^4 * 5 + 1\n        # 35. 10^5 = 10^4 * 5 + 1\n        # 36. 10^5 = 10^4 * 5 + 1\n        # 37. 10^5 = 10^4 * 5 + 1\n        # 38. 10^5 = 10^4 * 5 + 1\n        # 39. 10^5 = 10^4 * 5 + 1\n        # 40. 10^5 = 10^4 * 5 + 1\n        # 41. 10^5 = 10^4 * 5 + 1\n        # 42. 10^5 = 10^4 * 5 + 1\n        # 43. 10^5 = 10^4 * 5 + 1\n        # 44. 10^5 = 10^4 * 5 + 1\n        # 45. 10^5 = 10^4 * 5 + 1\n        # 46. 10^5 = 10^4 * 5 + 1\n        # 47. 10^5 = 10^4 * 5 + 1"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. build a hashmap of words\n        # 2. build a hashmap of words reversed\n        # 3. build a hashmap of words reversed and their index\n        # 4. build a hashmap of words and their index\n        # 5. build a hashmap of words and their index reversed\n        # 6. build a hashmap of words and their index reversed reversed\n        # 7. build a hashmap of words and their index reversed reversed and their index\n        # 8. build a hashmap of words and their index reversed reversed and their index reversed\n        # 9. build a hashmap of words and their index reversed reversed and their index reversed reversed\n        # 10. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index\n        # 11. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed\n        # 12. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed\n        # 13. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed\n        # 14. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed\n        # 15. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed\n        # 16. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed\n        # 17. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed\n        # 18. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed\n        # 19. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 20. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 21. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 22. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 23. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 24. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 25. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 26. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 27. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed reversed\n        # 28. build a hashmap of words and their index reversed reversed and their index reversed reversed and their index reversed revers"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u51fa\u6240\u6709\u611f\u67d3\u7684\u533a\u57df\n        # 2. \u627e\u51fa\u611f\u67d3\u533a\u57df\u7684\u8fb9\u754c\n        # 3. \u5c06\u8fb9\u754c\u4e0a\u7684\u75c5\u6bd2\u611f\u67d3\n        # 4. \u611f\u67d3\u75c5\u6bd2\n        # 5. \u611f\u67d3\u75c5\u6bd2\n        # 6. \u611f\u67d3\u75c5\u6bd2\n        # 7. \u611f\u67d3\u75c5\u6bd2\n        # 8. \u611f\u67d3\u75c5\u6bd2\n        # 9. \u611f\u67d3\u75c5\u6bd2\n        # 10. \u611f\u67d3\u75c5\u6bd2\n        # 11. \u611f\u67d3\u75c5\u6bd2\n        # 12. \u611f\u67d3\u75c5\u6bd2\n        # 13. \u611f\u67d3\u75c5\u6bd2\n        # 14. \u611f\u67d3\u75c5\u6bd2\n        # 15. \u611f\u67d3\u75c5\u6bd2\n        # 16. \u611f\u67d3\u75c5\u6bd2\n        # 17. \u611f\u67d3\u75c5\u6bd2\n        # 18. \u611f\u67d3\u75c5\u6bd2\n        # 19. \u611f\u67d3\u75c5\u6bd2\n        # 20. \u611f\u67d3\u75c5\u6bd2\n        # 21. \u611f\u67d3\u75c5\u6bd2\n        # 22. \u611f\u67d3\u75c5\u6bd2\n        # 23. \u611f\u67d3\u75c5\u6bd2\n        # 24. \u611f\u67d3\u75c5\u6bd2\n        # 25. \u611f\u67d3\u75c5\u6bd2\n        # 26. \u611f\u67d3\u75c5\u6bd2\n        # 27. \u611f\u67d3\u75c5\u6bd2\n        # 28. \u611f\u67d3\u75c5\u6bd2\n        # 29. \u611f\u67d3\u75c5\u6bd2\n        # 30. \u611f\u67d3\u75c5\u6bd2\n        # 31. \u611f\u67d3\u75c5\u6bd2\n        # 32. \u611f\u67d3\u75c5\u6bd2\n        # 33. \u611f\u67d3\u75c5\u6bd2\n        # 34. \u611f\u67d3\u75c5\u6bd2\n        # 35. \u611f\u67d3\u75c5\u6bd2\n        # 36. \u611f\u67d3\u75c5\u6bd2\n        # 37. \u611f\u67d3\u75c5\u6bd2\n        # 38. \u611f\u67d3\u75c5\u6bd2\n        # 39. \u611f\u67d3\u75c5\u6bd2\n        # 40. \u611f\u67d3\u75c5\u6bd2\n        # 41. \u611f\u67d3\u75c5\u6bd2\n        # 42. \u611f\u67d3\u75c5\u6bd2\n        # 43. \u611f\u67d3\u75c5\u6bd2\n        # 44. \u611f\u67d3\u75c5\u6bd2\n        # 45. \u611f\u67d3\u75c5\u6bd2\n        # 46. \u611f\u67d3\u75c5\u6bd2\n        # 47. \u611f\u67d3\u75c5\u6bd2\n        # 48. \u611f\u67d3\u75c5\u6bd2\n        # 49. \u611f\u67d3\u75c5\u6bd2\n        # 50. \u611f\u67d3\u75c5\u6bd2\n        # 51. \u611f\u67d3\u75c5\u6bd2\n        # 52. \u611f\u67d3\u75c5\u6bd2\n        # 53. \u611f\u67d3\u75c5\u6bd2\n        # 54. \u611f\u67d3\u75c5\u6bd2\n        # 55. \u611f\u67d3\u75c5\u6bd2\n        # 56. \u611f\u67d3\u75c5\u6bd2\n        # 57. \u611f\u67d3\u75c5\u6bd2\n        # 58. \u611f\u67d3\u75c5\u6bd2\n        # 59. \u611f\u67d3\u75c5\u6bd2\n        # 60. \u611f\u67d3\u75c5\u6bd2\n        # 61. \u611f\u67d3\u75c5\u6bd2\n        # 62. \u611f\u67d3\u75c5\u6bd2\n        # 63. \u611f\u67d3\u75c5\u6bd2\n        # 64. \u611f\u67d3\u75c5\u6bd2\n        # 65. \u611f\u67d3\u75c5\u6bd2\n        # 66. \u611f\u67d3\u75c5\u6bd2\n        # 67. \u611f\u67d3\u75c5\u6bd2\n        # 68. \u611f\u67d3\u75c5\u6bd2\n        # 69. \u611f\u67d3\u75c5\u6bd2\n        # 70. \u611f\u67d3\u75c5\u6bd2\n        # 71. \u611f\u67d3\u75c5\u6bd2\n        # 72. \u611f\u67d3\u75c5\u6bd2\n        # 73. \u611f\u67d3\u75c5\u6bd2\n        # 74. \u611f\u67d3\u75c5\u6bd2\n        # 75. \u611f\u67d3\u75c5\u6bd2\n        # 76. \u611f\u67d3\u75c5\u6bd2\n        # 77. \u611f\u67d3\u75c5\u6bd2\n        # 78. \u611f\u67d3\u75c5\u6bd2\n        # 79. \u611f\u67d3\u75c5\u6bd2\n        # 80. \u611f\u67d3\u75c5\u6bd2\n        # 81. \u611f\u67d3\u75c5\u6bd2\n        # 82. \u611f\u67d3\u75c5\u6bd2\n        # 83. \u611f\u67d3\u75c5\u6bd2\n        # 84. \u611f\u67d3\u75c5\u6bd2\n        # 85. \u611f\u67d3\u75c5\u6bd2\n        # 86. \u611f\u67d3\u75c5\u6bd2\n        # 87. \u611f\u67d3\u75c5\u6bd2\n        # 88. \u611f\u67d3\u75c5\u6bd2\n        # 89. \u611f\u67d3\u75c5\u6bd2\n        # 90. \u611f\u67d3\u75c5\u6bd2\n        # 91. \u611f\u67d3\u75c5\u6bd2\n        # 92. \u611f\u67d3\u75c5\u6bd2\n        # 93. \u611f\u67d3\u75c5\u6bd2\n        # 94. \u611f\u67d3\u75c5\u6bd2\n        # 95. \u611f\u67d3\u75c5\u6bd2\n        # 96. \u611f\u67d3\u75c5\u6bd2\n        # 97. \u611f\u67d3\u75c5\u6bd2\n        # 98. \u611f\u67d3\u75c5\u6bd2\n        # 99. \u611f\u67d3\u75c5\u6bd2\n        # 100. \u611f\u67d3\u75c5\u6bd2\n        # 101. \u611f\u67d3\u75c5\u6bd2\n        # 102."}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j, m, n))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j, m, n):\n        if dp[i][j] != 0:\n            return dp[i][j]\n        \n        max_len = 1\n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni = i + di\n            nj = j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj, m, n))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level += 1\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                level_nodes.reverse()\n            result.append(level_nodes)\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        # 2D array to store the pascal triangle\n        pascal = [[1] * (numRows) for _ in range(numRows)]\n        \n        # fill the first row\n        for i in range(numRows):\n            pascal[0][i] = 1\n        \n        # fill the second row\n        for i in range(numRows):\n            pascal[1][i] = 1\n        \n        # fill the rest of the rows\n        for i in range(2, numRows):\n            for j in range(1, i):\n                pascal[i][j] = pascal[i-1][j-1] + pascal[i-1][j]\n        \n        return pascal"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Recursive solution\n        ## 2. DFS\n        ## 3. BFS\n        ## 4. DFS + cache\n        ## 5. DFS + cache + pruning\n        ## 6. DFS + cache + pruning + memoization\n        ## 7. DFS + cache + pruning + memoization + bottom up\n        ## 8. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up\n        ## 9. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 10. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 11. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 12. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 13. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 14. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 15. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 16. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 17. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 18. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 19. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 20. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 21. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 22. DFS + cache + pruning + memoization + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up + bottom up\n        ## 23. DFS"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc19f\uac12\uacfc \ucd5c\ub313\uac12 \ucc3e\uae30\n        min_height = float('inf')\n        max_height = float('-inf')\n        for i in range(len(heightMap)):\n            for j in range(len(heightMap[0])):\n                if heightMap[i][j] < min_height:\n                    min_height = heightMap[i][j]\n                if heightMap[i][j] > max_height:\n                    max_height = heightMap[i][j]\n        \n        # 2. \ucd5c\uc19f\uac12\uacfc \ucd5c\ub313\uac12\uc744 \uae30\uc900\uc73c\ub85c \uc0c1\ud558\uc88c\uc6b0\ub85c \uc5f0\uacb0\ub41c \uac12\ub4e4\uc744 \ucc3e\uae30\n        # \uc0c1\ud558\uc88c\uc6b0\ub85c \uc5f0\uacb0\ub41c \uac12\ub4e4\uc744 \ucc3e\uae30 \uc704\ud574 \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8 \uc0dd\uc131\n        # \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\ub97c \uc0dd\uc131\ud558\uace0 \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\ub97c \uc0dd\uc131\ud558\uace0 \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\ub97c \uc0dd\uc131\ud558\uace0 \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\ub97c \uc0dd\uc131\ud558\uace0 \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\ub97c \uc0dd\uc131\ud558\uace0 \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\ub97c \uc0dd\uc131\ud558\uace0 \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc5d0 \ucd94\uac00\n        # \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\ub97c \uc0dd\uc131\ud558\uace0 \uc0c1\ud558\uc88c\uc6b0\ub97c \uc800\uc7a5\ud560 \ub9ac\uc2a4\ud2b8\uc5d0"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        # convert to lowercase\n        s = s.lower()\n        # reverse the string\n        s = s[::-1]\n        # compare the original string with the reversed string\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Create a min heap of size k\n        # 2. Add the first k elements to the min heap\n        # 3. For each element in the range [k, len(nums)]\n        # 4. If the element is greater than the min element in the min heap, remove the min element\n        # 5. Add the element to the min heap\n        # 6. Add the median to the result list\n        # 7. Return the result list\n        \n        # 1. Create a min heap of size k\n        min_heap = []\n        \n        # 2. Add the first k elements to the min heap\n        for i in range(k):\n            heapq.heappush(min_heap, nums[i])\n        \n        # 3. For each element in the range [k, len(nums)]\n        for i in range(k, len(nums)):\n            # 4. If the element is greater than the min element in the min heap, remove the min element\n            if nums[i] > min_heap[0]:\n                heapq.heappop(min_heap)\n            # 5. Add the element to the min heap\n            heapq.heappush(min_heap, nums[i])\n        \n        # 6. Add the median to the result list\n        result = []\n        if k % 2 == 0:\n            result.append((min_heap[0] + min_heap[1]) / 2)\n        else:\n            result.append(min_heap[0])\n        \n        # 7. Return the result list\n        return result"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the linked list, we need to rotate by k % length\n        k = k % length\n        \n        # if k is 0, we don't need to rotate\n        if k == 0:\n            return head\n        \n        # find the new head and the new tail\n        new_head = head\n        new_tail = head\n        for i in range(1, length - k):\n            new_tail = new_tail.next\n            new_head = new_head.next\n        \n        # set the new tail's next to None\n        new_tail.next = None\n        \n        # set the new head's next to the old head\n        new_head = new_head.next\n        new_tail.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n == 1:\n            return True\n        \n        if n % 2 == 0:\n            return self.isUgly(n // 2)\n        \n        if n % 3 == 0:\n            return self.isUgly(n // 3)\n        \n        if n % 5 == 0:\n            return self.isUgly(n // 5)\n        \n        return False"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.left)\n        \n        return root.left.val + self.sumOfLeftLeaves(root.right) + self.sumOfLeftLeaves(root.left)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if dividend == 0:\n            return 0\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        # edge case\n        if dividend == 1:\n            return dividend\n        if dividend == -1:\n            if divisor == 1:\n                return -1\n            if divisor == -1:\n                return 1\n        \n        # edge case\n        if divisor == 1:\n            return dividend\n        if divisor == -1:\n            if dividend == -2147483648:\n                return 2147483647\n            if dividend == 2147483647:\n                return -2147483648\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == 1:\n                return -2147483648\n            if divisor == -1:\n                return 2147483647\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == 1:\n                return 2147483647\n            if divisor == -1:\n                return -2147483648\n        \n        # edge case\n        if divisor == 2147483647:\n            if dividend == -1:\n                return -1\n            if dividend == 1:\n                return 1\n        \n        # edge case\n        if divisor == -2147483648:\n            if dividend == -1:\n                return 1\n            if dividend == 1:\n                return -1\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == -1:\n                return 1\n            if divisor == 1:\n                return -1\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == -1:\n                return -1\n            if divisor == 1:\n                return 1\n        \n        # edge case\n        if divisor == 2147483647:\n            if dividend == -1:\n                return -1\n            if dividend == 1:\n                return 1\n        \n        # edge case\n        if dividend == 0:\n            return 0\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == -1:\n                return 2147483647\n            if divisor == 1:\n                return -2147483648\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == -1:\n                return -2147483648\n            if divisor == 1:\n                return 2147483647\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == -1:\n                return 2147483647\n            if divisor == 1:\n                return -2147483648\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == -1:\n                return -2147483648\n            if divisor == 1:\n                return 2147483647\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == -1:\n                return 2147483647\n            if divisor == 1:\n                return -2147483648\n        \n        # edge case\n        if dividend == 2147483"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. Find all the O's on the border\n        # 2. Mark all the O's on the border as visited\n        # 3. For each O, check if it is connected to the border\n        # 4. If it is, mark it as visited\n        # 5. If it is not, mark it as visited\n        # 6. If it is not, mark it as visited\n        # 7. If it is not, mark it as visited\n        # 8. If it is not, mark it as visited\n        # 9. If it is not, mark it as visited\n        # 10. If it is not, mark it as visited\n        # 11. If it is not, mark it as visited\n        # 12. If it is not, mark it as visited\n        # 13. If it is not, mark it as visited\n        # 14. If it is not, mark it as visited\n        # 15. If it is not, mark it as visited\n        # 16. If it is not, mark it as visited\n        # 17. If it is not, mark it as visited\n        # 18. If it is not, mark it as visited\n        # 19. If it is not, mark it as visited\n        # 20. If it is not, mark it as visited\n        # 21. If it is not, mark it as visited\n        # 22. If it is not, mark it as visited\n        # 23. If it is not, mark it as visited\n        # 24. If it is not, mark it as visited\n        # 25. If it is not, mark it as visited\n        # 26. If it is not, mark it as visited\n        # 27. If it is not, mark it as visited\n        # 28. If it is not, mark it as visited\n        # 29. If it is not, mark it as visited\n        # 30. If it is not, mark it as visited\n        # 31. If it is not, mark it as visited\n        # 32. If it is not, mark it as visited\n        # 33. If it is not, mark it as visited\n        # 34. If it is not, mark it as visited\n        # 35. If it is not, mark it as visited\n        # 36. If it is not, mark it as visited\n        # 37. If it is not, mark it as visited\n        # 38. If it is not, mark it as visited\n        # 39. If it is not, mark it as visited\n        # 40. If it is not, mark it as visited\n        # 41. If it is not, mark it as visited\n        # 42. If it is not, mark it as visited\n        # 43. If it is not, mark it as visited\n        # 44. If it is not, mark it as visited\n        # 45. If it is not, mark it as visited\n        # 46. If it is not, mark it as visited\n        # 47. If it is not, mark it as visited\n        # 48. If it is not, mark it as visited\n        # 49. If it is not, mark it as visited\n        # 50. If it is not, mark it as visited\n        # 51. If it is not, mark it as visited\n        # 52. If it is not, mark it as visited\n        # 53. If it is not, mark it as visited\n        # 54. If it is not, mark it as visited\n        # 55. If it is not, mark it as visited\n        # 56. If it is not, mark it as visited\n        # 57. If it is not, mark it as visited\n        # 58. If it is not, mark it as visited\n        # 59. If it is not, mark it as visited\n        # 60. If it is not, mark it as visited\n        # 61. If it is not, mark it as visited\n        # 62. If it is not, mark it as visited\n        # 63. If it is not, mark it as visited\n        # 64. If it is not, mark it as visited\n        # 65"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force solution\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ##\n        ## for i in range(len(nums)):\n        ##     for j in range(i+1, len(nums)):\n        ##         if nums[i] + nums[j] == target:\n        ##             return [i, j]\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ##\n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap solution\n        ## Time complexity: O(n"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if not p:\n            return not s\n        \n        # if p is not empty, then s must not be empty\n        if not s:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if not s and not p:\n            return True\n        \n        # if p is not empty, then s must not be empty\n        if not s and p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if s and not p:\n            return False\n        \n        # if p is not empty, then s must"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        #"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # build the itinerary\n        itinerary = []\n        self.dfs(graph, \"JFK\", itinerary)\n        return itinerary\n    \n    def dfs(self, graph, node, itinerary):\n        # base case\n        if node not in graph:\n            return\n        \n        # recursive case\n        while graph[node]:\n            self.dfs(graph, graph[node].pop(0), itinerary)\n        \n        # add the node to the itinerary\n        itinerary.append(node)"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, n-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = n-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize result\n        result = [[0,0]]\n        \n        # initialize max height\n        max_height = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index = 0\n        \n        # initialize max height index\n        max_height_index ="}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        # s.reverse()\n        \n        # reverse the string using two pointers\n        # left = 0\n        # right = len(s) - 1\n        # while left < right:\n        #     s[left], s[right] = s[right], s[left]\n        #     left += 1\n        #     right -= 1\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse(0, len(s) - 1)\n        \n        # reverse the string using recursion\n        # def reverse(left, right):\n        #     if left >= right:\n        #         return\n        #     s[left], s[right] = s[right], s[left]\n        #     reverse(left + 1, right - 1)\n        # reverse("}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        # return prev\n        \n        # recursive\n        if not head:\n            return None\n        if not head.next:\n            return head\n        new_head = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return new_head"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # 1. We can use the same array to store the minimum sum of each row.\n        # 2. We can use the same array to store the minimum sum of each row.\n        # 3. We can use the same array to store the minimum sum of each row.\n        # 4. We can use the same array to store the minimum sum of each row.\n        # 5. We can use the same array to store the minimum sum of each row.\n        # 6. We can use the same array to store the minimum sum of each row.\n        # 7. We can use the same array to store the minimum sum of each row.\n        # 8. We can use the same array to store the minimum sum of each row.\n        # 9. We can use the same array to store the minimum sum of each row.\n        # 10. We can use the same array to store the minimum sum of each row.\n        # 11. We can use the same array to store the minimum sum of each row.\n        # 12. We can use the same array to store the minimum sum of each row.\n        # 13. We can use the same array to store the minimum sum of each row.\n        # 14. We can use the same array to store the minimum sum of each row.\n        # 15. We can use the same array to store the minimum sum of each row.\n        # 16. We can use the same array to store the minimum sum of each row.\n        # 17. We can use the same array to store the minimum sum of each row.\n        # 18. We can use the same array to store the minimum sum of each row.\n        # 19. We can use the same array to store the minimum sum of each row.\n        # 20. We can use the same array to store the minimum sum of each row.\n        # 21. We can use the same array to store the minimum sum of each row.\n        # 22. We can use the same array to store the minimum sum of each row.\n        # 23. We can use the same array to store the minimum sum of each row.\n        # 24. We can use the same array to store the minimum sum of each row.\n        # 25. We can use the same array to store the minimum sum of each row.\n        # 26. We can use the same array to store the minimum sum of each row.\n        # 27. We can use the same array to store the minimum sum of each row.\n        # 28. We can use the same array to store the minimum sum of each row.\n        # 29. We can use the same array to store the minimum sum of each row.\n        # 30. We can use the same array to store the minimum sum of each row.\n        # 31. We can use the same array to store the minimum sum of each row.\n        # 32. We can use the same array to store the minimum sum of each row.\n        # 33. We can use the same array to store the minimum sum of each row.\n        # 34. We can use the same array to store the minimum sum of each row.\n        # 35. We can use the same array to store the minimum sum of each row.\n        # 36. We can use the same array to store the minimum sum of each row.\n        # 37. We can use the same array to store the minimum sum of each row.\n        # 38. We can use the same array to store the minimum sum of each row.\n        # 39. We can use the same array to store the minimum sum of each row.\n        # 40. We can use the same array to store the minimum sum of each row.\n        # 41. We can use the same array to store the minimum sum of each row.\n        # 42. We can use the same array to store the minimum sum of each row.\n        # 43. We can use the same array to store the minimum sum of each row.\n        # 44. We can use the same array to store the minimum sum of each row.\n        # 45. We can use the same array to store the minimum sum of each row.\n        # 46. We can use"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        # 1000 - 999\n        # 1000000 - 999999\n        # 1000000000 - 999999999\n        # 1000000000000 - 999999999999\n        # 1000000000000000 - 999999999999999\n        # 1000000000000000000 - 999999999999999999\n        # 1000000000000000000000 - 999999999999999999999\n        # 1000000000000000000000000 - 999999999999999999999999\n        # 1000000000000000000000000000 - 9999999999999999999999999999\n        # 1000000000000000000000000000000 - 9999999999999999999999999999999\n        # 1000000000000000000000000000000000 - 9999999999999999999999999999999999\n        # 1000000000000000000000000000000000000 - 9999999999999999999999999999999999999\n        # 100000000000000000000000000000000000000 - 999999999999999999999999999999999999999\n        # 10000000000000000000000000000000000000000 - 99999999999999999999999999999999999999999\n        # 1000000000000000000000000000000000000000000 - 99999999999999999999999999999999999999999999\n        # 1000000000000000000000000000000000000000000000 - 99999999999999999999999999999999999999999999999\n        # 1000000000000000000000000000000000000000000000000 - 99999999999999999999999999999999999"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 <= n <= 1000\n        # 2. 0 <= k <= 1000\n        # 3. 1 <= n <= 1000\n        # 4. 0 <= k <= 1000\n        # 5. 1 <= n <= 1000\n        # 6. 0 <= k <= 1000\n        # 7. 1 <= n <= 1000\n        # 8. 0 <= k <= 1000\n        # 9. 1 <= n <= 1000\n        # 10. 0 <= k <= 1000\n        # 11. 1 <= n <= 1000\n        # 12. 0 <= k <= 1000\n        # 13. 1 <= n <= 1000\n        # 14. 0 <= k <= 1000\n        # 15. 1 <= n <= 1000\n        # 16. 0 <= k <= 1000\n        # 17. 1 <= n <= 1000\n        # 18. 0 <= k <= 1000\n        # 19. 1 <= n <= 1000\n        # 20. 0 <= k <= 1000\n        # 21. 1 <= n <= 1000\n        # 22. 0 <= k <= 1000\n        # 23. 1 <= n <= 1000\n        # 24. 0 <= k <= 1000\n        # 25. 1 <= n <= 1000\n        # 26. 0 <= k <= 1000\n        # 27. 1 <= n <= 1000\n        # 28. 0 <= k <= 1000\n        # 29. 1 <= n <= 1000\n        # 30. 0 <= k <= 1000\n        # 31. 1 <= n <= 1000\n        # 32. 0 <= k <= 1000\n        # 33. 1 <= n <= 1000\n        # 34. 0 <= k <= 1000\n        # 35. 1 <= n <= 1000\n        # 36. 0 <= k <= 1000\n        # 37. 1 <= n <= 1000\n        # 38. 0 <= k <= 1000\n        # 39. 1 <= n <= 1000\n        # 40. 0 <= k <= 1000\n        # 41. 1 <= n <= 1000\n        # 42. 0 <= k <= 1000\n        # 43. 1 <= n <= 1000\n        # 44. 0 <= k <= 1000\n        # 45. 1 <= n <= 1000\n        # 46. 0 <= k <= 1000\n        # 47. 1 <= n <= 1000\n        # 48. 0 <= k <= 1000\n        # 49. 1 <= n <= 1000\n        # 50. 0 <= k <= 1000\n        # 51. 1 <= n <= 1000\n        # 52. 0 <= k <= 1000\n        # 53. 1 <= n <= 1000\n        # 54. 0 <= k <= 1000\n        # 55. 1 <= n <= 1000\n        # 56. 0 <= k <= 1000\n        # 57. 1 <= n <= 1000\n        # 58. 0 <= k <= 1000\n        # 59. 1 <= n <= 1000\n        # 60. 0 <= k <= 1000\n        # 61. 1 <= n <= 1000\n        # 62. 0 <= k <= 1000\n        # 63. 1 <= n <= 1000\n        # 64. 0 <= k <= 1000\n        # 65. 1 <="}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        #edge case\n        if not head or not head.next:\n            return head\n        \n        #initialize the dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        #initialize the current node\n        curr = dummy\n        \n        #loop through the list\n        while curr.next and curr.next.next:\n            #initialize the first node\n            first = curr.next\n            \n            #initialize the second node\n            second = curr.next.next\n            \n            #swap the nodes\n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            #move the current node to the next node\n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        #"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create two dummy nodes\n        # 2. Create two pointers\n        # 3. Traverse the list and insert nodes into the dummy nodes\n        # 4. Insert the nodes into the dummy nodes\n        # 5. Insert the dummy nodes into the original list\n        # 6. Return the original list\n        \n        # 1. Create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # 2. Create two pointers\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        # 3. Traverse the list and insert nodes into the dummy nodes\n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        # 4. Insert the nodes into the dummy nodes\n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        # 5. Insert the dummy nodes into the original list\n        curr = dummy1.next\n        \n        # 6. Return the original list\n        return curr"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # edge 1: (1,2)\n        # edge 2: (2,3)\n        # edge 3: (3,4)\n        # edge 4: (4,1)\n        # edge 5: (1,5)\n        \n        # edge 1: (1,2)\n        # edge 2: (2,3)\n        # edge 3: (3,4)\n        # edge 4: (4,1)\n        # edge 5: (1,5)\n        # edge 6: (5,6)\n        # edge 7: (6,7)\n        # edge 8: (7,8)\n        # edge 9: (8,9)\n        # edge 10: (9,10)\n        # edge 11: (10,11)\n        # edge 12: (11,12)\n        # edge 13: (12,13)\n        # edge 14: (13,14)\n        # edge 15: (14,15)\n        # edge 16: (15,16)\n        # edge 17: (16,17)\n        # edge 18: (17,18)\n        # edge 19: (18,19)\n        # edge 20: (19,20)\n        # edge 21: (20,21)\n        # edge 22: (21,22)\n        # edge 23: (22,23)\n        # edge 24: (23,24)\n        # edge 25: (24,25)\n        # edge 26: (25,26)\n        # edge 27: (26,27)\n        # edge 28: (27,28)\n        # edge 29: (28,29)\n        # edge 30: (29,30)\n        # edge 31: (30,31)\n        # edge 32: (31,32)\n        # edge 33: (32,33)\n        # edge 34: (33,34)\n        # edge 35: (34,35)\n        # edge 36: (35,36)\n        # edge 37: (36,37)\n        # edge 38: (37,38)\n        # edge 39: (38,39)\n        # edge 40: (39,40)\n        # edge 41: (40,41)\n        # edge 42: (41,42)\n        # edge 43: (42,43)\n        # edge 44: (43,44)\n        # edge 45: (44,45)\n        # edge 46: (45,46)\n        # edge 47: (46,47)\n        # edge 48: (47,48)\n        # edge 49: (48,49)\n        # edge 50: (49,50)\n        # edge 51: (50,51)\n        # edge 52: (51,52)\n        # edge 53: (52,53)\n        # edge 54: (53,54)\n        # edge 55: (54,55)\n        # edge 56: (55,56)\n        # edge 57: (56,57)\n        # edge 58: (57,58)\n        # edge 59: (58,59)\n        # edge 60: (59,60)\n        # edge 61: (60,61)\n        # edge 62: (61,62)\n        # edge 63: (62,63)\n        # edge 64: (63,64)\n        # edge 65: (64,65)\n        # edge 66: (65,66)"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the list\n        nums.sort()\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the current list\n        curr = []\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the visited list\n        visited = [False] * len(nums)\n        \n        # initialize the"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        #"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. XOR\n        ## 2. XOR of a number with itself is 0\n        ## 3. XOR of a number with 0 is the number itself\n        ## 4. XOR of a number with 0 is the number itself\n        ## 5. XOR of a number with itself is 0\n        ## 6. XOR of a number with 0 is the number itself\n        ## 7. XOR of a number with 0 is the number itself\n        ## 8. XOR of a number with itself is 0\n        ## 9. XOR of a number with 0 is the number itself\n        ## 10. XOR of a number with 0 is the number itself\n        ## 11. XOR of a number with itself is 0\n        ## 12. XOR of a number with 0 is the number itself\n        ## 13. XOR of a number with 0 is the number itself\n        ## 14. XOR of a number with itself is 0\n        ## 15. XOR of a number with 0 is the number itself\n        ## 16. XOR of a number with 0 is the number itself\n        ## 17. XOR of a number with itself is 0\n        ## 18. XOR of a number with 0 is the number itself\n        ## 19. XOR of a number with 0 is the number itself\n        ## 20. XOR of a number with itself is 0\n        ## 21. XOR of a number with 0 is the number itself\n        ## 22. XOR of a number with 0 is the number itself\n        ## 23. XOR of a number with itself is 0\n        ## 24. XOR of a number with 0 is the number itself\n        ## 25. XOR of a number with 0 is the number itself\n        ## 26. XOR of a number with itself is 0\n        ## 27. XOR of a number with 0 is the number itself\n        ## 28. XOR of a number with 0 is the number itself\n        ## 29. XOR of a number with itself is 0\n        ## 30. XOR of a number with 0 is the number itself\n        ## 31. XOR of a number with 0 is the number itself\n        ## 32. XOR of a number with itself is 0\n        ## 33. XOR of a number with 0 is the number itself\n        ## 34. XOR of a number with 0 is the number itself\n        ## 35. XOR of a number with itself is 0\n        ## 36. XOR of a number with 0 is the number itself\n        ## 37. XOR of a number with 0 is the number itself\n        ## 38. XOR of a number with itself is 0\n        ## 39. XOR of a number with 0 is the number itself\n        ## 40. XOR of a number with 0 is the number itself\n        ## 41. XOR of a number with itself is 0\n        ## 42. XOR of a number with 0 is the number itself\n        ## 43. XOR of a number with 0 is the number itself\n        ## 44. XOR of a number with itself is 0\n        ## 45. XOR of a number with 0 is the number itself\n        ## 46. XOR of a number with 0 is the number itself\n        ## 47. XOR of a number with itself is 0\n        ## 48. XOR of a number with 0 is the number itself\n        ## 49. XOR of a number with 0 is the number itself\n        ## 50. XOR of a number with itself is 0\n        ## 51. XOR of a number with 0 is the number itself\n        ## 52. XOR of a number with 0 is the number itself\n        ## 53. XOR of a number with itself is 0\n        ## 54. XOR of a number with 0 is the number itself"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # If the string is empty, return 0\n        if not words:\n            return 0\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 20210320\n        # 2. 20210321\n        # 3. 20210322\n        # 4. 20210323\n        # 5. 20210324\n        # 6. 20210325\n        # 7. 20210326\n        # 8. 20210327\n        # 9. 20210328\n        # 10. 20210329\n        # 11. 20210330\n        # 12. 20210331\n        # 13. 20210332\n        # 14. 20210333\n        # 15. 20210334\n        # 16. 20210335\n        # 17. 20210336\n        # 18. 20210337\n        # 19. 20210338\n        # 20. 20210339\n        # 21. 20210340\n        # 22. 20210341\n        # 23. 20210342\n        # 24. 20210343\n        # 25. 20210344\n        # 26. 20210345\n        # 27. 20210346\n        # 28. 20210347\n        # 29. 20210348\n        # 30. 20210349\n        # 31. 20210350\n        # 32. 20210351\n        # 33. 20210352\n        # 34. 20210353\n        # 35. 20210354\n        # 36. 20210355\n        # 37. 20210356\n        # 38. 20210357\n        # 39. 20210358\n        # 40. 20210359\n        # 41. 20210360\n        # 42. 20210361\n        # 43. 20210362\n        # 44. 20210363\n        # 45. 20210364\n        # 46. 20210365\n        # 47. 20210366\n        # 48. 20210367\n        # 49. 20210368\n        # 50. 20210369\n        # 51. 20210370\n        # 52. 20210371\n        # 53. 20210372\n        # 54. 20210373\n        # 55. 20210374\n        # 56. 20210375\n        # 57. 20210376\n        # 58. 20210377\n        # 59. 20210378\n        # 60. 20210379\n        # 61. 20210380\n        # 62. 20210381\n        # 63. 20210382\n        # 64. 20210383\n        # 65. 20"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is less than the first element, return 0\n        # if target is greater than the last element, return len(nums)\n        # if target is in the middle, return the index\n        # if target is less than the middle element, search left\n        # if target is greater than the middle element, search right\n        \n        # if target is less than the first element, return 0\n        if target < nums[0]:\n            return 0\n        \n        # if target is greater than the last element, return len(nums)\n        if target > nums[-1]:\n            return len(nums)\n        \n        # if target is in the middle, return the index\n        if target in nums:\n            return nums.index(target)\n        \n        # if target is less than the middle element, search left\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # if target is greater than the middle element, search right\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 1:\n        #     return True\n        # if nums[0] > len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:\n        #     return False\n        # if nums[0] < len(nums) - 1:"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"31131122212321321121141211\"\n        \n        if n == 13:\n            return \"132113111231131122112131221131211\"\n        \n        if n == 14:\n            return \"111312211331121321332112311312211211\"\n        \n        if n == 15:\n            return \"31131122212321321121141211232123112111312211211\"\n        \n        if n == 16:\n            return \"132113111231131122112131221131211231131221121123213211\"\n        \n        if n == 17:\n            return \"111312211331121321332112311312211211232132112311322211211\"\n        \n        if n == 18:\n            return \"3113112221232132112114121123212311211232211211312211211\"\n        \n        if n == 19:\n            return \"13211311123113112211213122113121123221121131221121123213211\"\n        \n        if n == 20:\n            return \"11131221133112132133211231132221121131221121123213211232113212211\"\n        \n        if n == 21:\n            return \"311311222123213211211412112321231121123221121131221121123213211232113212211211\"\n        \n        if n == 22:\n            return \"1321131112311311221121312211312112322112113122112112321321123211321221121123213211232113212211211\""}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max number in the array\n        # find the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the array\n        # binary search the min number in the array\n        # binary search the max number in the"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if nums is empty, return -1\n        if len(nums) == 0:\n            return -1\n        \n        # if nums has only one element, return the index of target if it is in nums, or -1 if it is not in nums\n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        # if nums has more than one element, find the pivot index\n        pivot_index = self.find_pivot_index(nums)\n        \n        # if pivot_index is -1, it means that nums is not rotated, so return the index of target if it is in nums, or -1 if it is not in nums\n        if pivot_index == -1:\n            return self.binary_search(nums, target)\n        \n        # if pivot_index is 0, it means that nums is rotated, so find the index of target in nums\n        if pivot_index == 0:\n            return self.binary_search(nums, target)\n        \n        # if target is less than the first element of nums, search the right part of nums\n        if target < nums[0]:\n            return self.binary_search(nums[pivot_index:], target)\n        \n        # if target is greater than the first element of nums, search the left part of nums\n        else:\n            return self.binary_search(nums[:pivot_index], target)\n        \n        \n    def find_pivot_index(self, nums):\n        # if nums is empty, return -1\n        if len(nums) == 0:\n            return -1\n        \n        # if nums has only one element, return -1\n        if len(nums) == 1:\n            return -1\n        \n        # if nums has more than one element, find the pivot index\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return mid + 1\n            \n            elif nums[mid] < nums[mid - 1]:\n                return mid\n            \n            elif nums[mid] > nums[left]:\n                left = mid + 1\n            \n            elif nums[mid] < nums[left]:\n                right = mid - 1\n            \n            else:\n                left += 1\n        \n        return -1\n        \n        \n    def binary_search(self, nums, target):\n        # if nums is empty, return -1\n        if len(nums) == 0:\n            return -1\n        \n        # if nums has only one element, return the index of target if it is in nums, or -1 if it is not in nums\n        if len(nums) == 1:\n            if nums[0] == target:\n                return 0\n            else:\n                return -1\n        \n        # if nums has more than one element, find the pivot index\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            elif nums[mid] < target:\n                left = mid + 1\n            \n            else:\n                right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        # 2 -> 3\n        # 3 -> 4\n        # 4 -> 5\n        # 5 -> 6\n        # 6 -> 7\n        # 7 -> 8\n        # 8 -> 9\n        # 9 -> 9\n        # 0 -> None\n        \n        # 2 -> ['a', 'b', 'c']\n        # 3 -> ['d', 'e', 'f']\n        # 4 -> ['g', 'h', 'i']\n        # 5 -> ['j', 'k', 'l']\n        # 6 -> ['m', 'n', 'o']\n        # 7 -> ['p', 'q', 'r', 's']\n        # 8 -> ['t', 'u', 'v']\n        # 9 -> ['w', 'x', 'y', 'z']\n        \n        # 2 -> ['a', 'b', 'c']\n        # 3 -> ['d', 'e', 'f']\n        # 4 -> ['g', 'h', 'i']\n        # 5 -> ['j', 'k', 'l']\n        # 6 -> ['m', 'n', 'o']\n        # 7 -> ['p', 'q', 'r', 's']\n        # 8 -> ['t', 'u', 'v']\n        # 9 -> ['w', 'x', 'y', 'z']\n        \n        # 2 -> ['a', 'b', 'c']\n        # 3 -> ['d', 'e', 'f']\n        # 4 -> ['g', 'h', 'i']\n        # 5 -> ['j', 'k', 'l']\n        # 6 -> ['m', 'n', 'o']\n        # 7 -> ['p', 'q', 'r', 's']\n        # 8 -> ['t', 'u', 'v']\n        # 9 -> ['w', 'x', 'y', 'z']\n        \n        # 2 -> ['a', 'b', 'c']\n        # 3 -> ['d', 'e', 'f']\n        # 4 -> ['g', 'h', 'i']\n        # 5 -> ['j', 'k', 'l']\n        # 6 -> ['m', 'n', 'o']\n        # 7 -> ['p', 'q', 'r', 's']\n        # 8 -> ['t', 'u', 'v']\n        # 9 -> ['w', 'x', 'y', 'z']\n        \n        # 2 -> ['a', 'b', 'c']\n        # 3 -> ['d', 'e', 'f']\n        # 4 -> ['g', 'h', 'i']\n        # 5 -> ['j', 'k', 'l']\n        # 6 -> ['m', 'n', 'o']\n        # 7 -> ['p', 'q', 'r', 's']\n        # 8 -> ['t', 'u', 'v']\n        # 9 -> ['w', 'x', 'y', 'z']\n        \n        # 2 -> ['a', 'b', 'c']\n        # 3 -> ['d', 'e', 'f']\n        # 4 -> ['g', 'h', 'i']\n        # 5 -> ['j', 'k', 'l']\n        # 6 -> ['m', 'n', 'o']\n        # 7 -> ['p', 'q', 'r', 's']\n        # 8 -> ['t', 'u', 'v']\n        # 9 -> ['w', 'x', 'y', 'z']\n        \n        # 2 -> ['a', 'b', 'c']\n        # 3 -> ['d', 'e', 'f']\n        # 4 -> ['g', 'h', 'i']\n        # 5 -> ['j', 'k', 'l']\n        # 6 -> ['m', 'n', 'o']\n        # 7 -> ['p', 'q', 'r', 's']\n        # 8 -> ['t', 'u', 'v']\n        #"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the candidates\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the stack\n        stack = []\n        \n        # initialize the sum\n        sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # loop through the candidates\n        while index < len(candidates):\n            \n            # if the sum is less than the target\n            if sum < target:\n                \n                # add the candidate to the stack\n                stack.append(candidates[index])\n                \n                # add the candidate to the sum\n                sum += candidates[index]\n                \n                # if the sum is equal to the target\n                if sum == target:\n                    \n                    # add the stack to the result\n                    result.append(stack[:])\n                    \n                    # pop the stack\n                    stack.pop()\n                    \n                    # subtract the candidate from the sum\n                    sum -= candidates[index]\n                    \n                    # increment the index\n                    index += 1\n                    \n                # if the sum is greater than the target\n                elif sum > target:\n                    \n                    # pop the stack\n                    stack.pop()\n                    \n                    # subtract the candidate from the sum\n                    sum -= candidates[index]\n                    \n                # if the sum is equal to the target\n                else:\n                    \n                    # increment the index\n                    index += 1\n                    \n            # if the sum is greater than the target\n            else:\n                \n                # break the loop\n                break\n        \n        # return the result\n        return result"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of the number\n        # 2. get the number of digits\n        # 3. get the number of digits\n        # 4. get the number of digits\n        # 5. get the number of digits\n        # 6. get the number of digits\n        # 7. get the number of digits\n        # 8. get the number of digits\n        # 9. get the number of digits\n        # 10. get the number of digits\n        # 11. get the number of digits\n        # 12. get the number of digits\n        # 13. get the number of digits\n        # 14. get the number of digits\n        # 15. get the number of digits\n        # 16. get the number of digits\n        # 17. get the number of digits\n        # 18. get the number of digits\n        # 19. get the number of digits\n        # 20. get the number of digits\n        # 21. get the number of digits\n        # 22. get the number of digits\n        # 23. get the number of digits\n        # 24. get the number of digits\n        # 25. get the number of digits\n        # 26. get the number of digits\n        # 27. get the number of digits\n        # 28. get the number of digits\n        # 29. get the number of digits\n        # 30. get the number of digits\n        # 31. get the number of digits\n        # 32. get the number of digits\n        # 33. get the number of digits\n        # 34. get the number of digits\n        # 35. get the number of digits\n        # 36. get the number of digits\n        # 37. get the number of digits\n        # 38. get the number of digits\n        # 39. get the number of digits\n        # 40. get the number of digits\n        # 41. get the number of digits\n        # 42. get the number of digits\n        # 43. get the number of digits\n        # 44. get the number of digits\n        # 45. get the number of digits\n        # 46. get the number of digits\n        # 47. get the number of digits\n        # 48. get the number of digits\n        # 49. get the number of digits\n        # 50. get the number of digits\n        # 51. get the number of digits\n        # 52. get the number of digits\n        # 53. get the number of digits\n        # 54. get the number of digits\n        # 55. get the number of digits\n        # 56. get the number of digits\n        # 57. get the number of digits\n        # 58. get the number of digits\n        # 59. get the number of digits\n        # 60. get the number of digits\n        # 61. get the number of digits\n        # 62. get the number of digits\n        # 63. get the number of digits\n        # 64. get the number of digits\n        # 65. get the number of digits\n        # 66. get the number of digits\n        # 67. get the number of digits\n        # 68. get the number of digits\n        # 69. get the number of digits\n        # 70. get the number of digits\n        # 71. get the number of digits\n        # 72. get the number of digits\n        # 73. get the number of digits\n        # 74. get the number of digits\n        # 75. get the number of digits\n        # 76. get the number of digits\n        # 77. get the number of digits\n        # 78. get the number of digits\n        # 79. get the number of digits\n        # 80."}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Initialize the matrix with zeros\n        matrix = [[0] * n for _ in range(n)]\n        \n        # 2. Initialize the direction\n        #    - 0: right\n        #    - 1: down\n        #    - 2: left\n        #    - 3: up\n        direction = 0\n        \n        # 3. Initialize the row and col\n        row, col = 0, 0\n        \n        # 4. Initialize the counter\n        counter = 1\n        \n        # 5. Initialize the limit\n        limit = n\n        \n        # 6. Loop until the counter is equal to n^2\n        while counter <= n**2:\n            \n            # 7. If the direction is 0, move right\n            if direction == 0:\n                matrix[row][col] = counter\n                counter += 1\n                col += 1\n                \n                # 8. If the col is equal to limit, change direction to 1\n                if col == limit:\n                    direction = 1\n                    limit -= 1\n                    \n            # 9. If the direction is 1, move down\n            elif direction == 1:\n                matrix[row][col] = counter\n                counter += 1\n                row += 1\n                \n                # 10. If the row is equal to limit, change direction to 2\n                if row == limit:\n                    direction = 2\n                    limit -= 1\n                    \n            # 11. If the direction is 2, move left\n            elif direction == 2:\n                matrix[row][col] = counter\n                counter += 1\n                col -= 1\n                \n                # 12. If the col is equal to -1, change direction to 3\n                if col == -1:\n                    direction = 3\n                    limit -= 1\n                    \n            # 13. If the direction is 3, move up\n            elif direction == 3:\n                matrix[row][col] = counter\n                counter += 1\n                row -= 1\n                \n                # 14. If the row is equal to -1, change direction to 0\n                if row == -1:\n                    direction = 0\n                    limit -= 1\n                    \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x * sign\n        \n        # if x < -2**31 or x > 2**31 - 1:\n        #     return 0\n        # else:\n        #     return x\n        \n        # if x < 0:\n        #     sign = -1\n        #     x = -x\n        # else:\n        #     sign = 1\n        \n        # x = str(x)\n        # x = x[::-1]\n        # x = int(x)\n        # x = x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. 2D matrix is a square matrix\n        ## 2. 2D matrix is a square matrix\n        ## 3. 2D matrix is a square matrix\n        ## 4. 2D matrix is a square matrix\n        ## 5. 2D matrix is a square matrix\n        ## 6. 2D matrix is a square matrix\n        ## 7. 2D matrix is a square matrix\n        ## 8. 2D matrix is a square matrix\n        ## 9. 2D matrix is a square matrix\n        ## 10. 2D matrix is a square matrix\n        ## 11. 2D matrix is a square matrix\n        ## 12. 2D matrix is a square matrix\n        ## 13. 2D matrix is a square matrix\n        ## 14. 2D matrix is a square matrix\n        ## 15. 2D matrix is a square matrix\n        ## 16. 2D matrix is a square matrix\n        ## 17. 2D matrix is a square matrix\n        ## 18. 2D matrix is a square matrix\n        ## 19. 2D matrix is a square matrix\n        ## 20. 2D matrix is a square matrix\n        ## 21. 2D matrix is a square matrix\n        ## 22. 2D matrix is a square matrix\n        ## 23. 2D matrix is a square matrix\n        ## 24. 2D matrix is a square matrix\n        ## 25. 2D matrix is a square matrix\n        ## 26. 2D matrix is a square matrix\n        ## 27. 2D matrix is a square matrix\n        ## 28. 2D matrix is a square matrix\n        ## 29. 2D matrix is a square matrix\n        ## 30. 2D matrix is a square matrix\n        ## 31. 2D matrix is a square matrix\n        ## 32. 2D matrix is a square matrix\n        ## 33. 2D matrix is a square matrix\n        ## 34. 2D matrix is a square matrix\n        ## 35. 2D matrix is a square matrix\n        ## 36. 2D matrix is a square matrix\n        ## 37. 2D matrix is a square matrix\n        ## 38. 2D matrix is a square matrix\n        ## 39. 2D matrix is a square matrix\n        ## 40. 2D matrix is a square matrix\n        ## 41. 2D matrix is a square matrix\n        ## 42. 2D matrix is a square matrix\n        ## 43. 2D matrix is a square matrix\n        ## 44. 2D matrix is a square matrix\n        ## 45. 2D matrix is a square matrix\n        ## 46. 2D matrix is a square matrix\n        ## 47. 2D matrix is a square matrix\n        ## 48. 2D matrix is a square matrix\n        ## 49. 2D matrix is a square matrix\n        ## 50. 2D matrix is a square matrix\n        ## 51. 2D matrix is a square matrix\n        ## 52. 2D matrix is a square matrix\n        ## 53. 2D matrix is a square matrix\n        ## 54. 2D matrix is a square matrix\n        ## 55. 2D matrix is a square matrix\n        ## 56. 2D matrix is a square matrix\n        ## 57. 2D matrix is a square matrix\n        ## 58. 2D matrix is a square matrix\n        ## 59. 2D matrix is a square matrix\n        ## 60. 2D matrix is a square matrix\n        ## 61. 2D matrix is a square matrix\n        ## 62. 2D matrix is a square matrix\n        ## 63. 2D matrix is a square matrix\n        ## 64. 2D matrix is a square matrix\n        ## 65. 2"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score array in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, score in enio enumerate(score_sorted):\n            rank_dict[score] = i + 1\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for score in score_sorted:\n            rank = rank_dict[score]\n            if rank == 1:\n                rank_list.append(\"Gold Medal\")\n            elif rank == 2:\n                rank_list.append(\"Silver Medal\")\n            elif rank == 3:\n                rank_list.append(\"Bronze Medal\")\n            else:\n                rank_list.append(str(rank))\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for score in score_sorted:\n            rank = rank_dict[score]\n            if rank == 1:\n                rank_list.append(\"Gold Medal\")\n            elif rank == 2:\n                rank_list.append(\"Silver Medal\")\n            elif rank == 3:\n                rank_list.append(\"Bronze Medal\")\n            else:\n                rank_list.append(str(rank))\n        \n        return rank_list"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # 1. set up a window\n        # 2. keep track of the max length\n        # 3. keep track of the max substring\n        # 4. keep track of the start of the substring\n        # 5. keep track of the end of the substring\n        # 6. keep track of the character\n        # 7. keep track of the character's index\n        # 8. keep track of the character's index\n        # 9. keep track of the character's index\n        # 10. keep track of the character's index\n        # 11. keep track of the character's index\n        # 12. keep track of the character's index\n        # 13. keep track of the character's index\n        # 14. keep track of the character's index\n        # 15. keep track of the character's index\n        # 16. keep track of the character's index\n        # 17. keep track of the character's index\n        # 18. keep track of the character's index\n        # 19. keep track of the character's index\n        # 20. keep track of the character's index\n        # 21. keep track of the character's index\n        # 22. keep track of the character's index\n        # 23. keep track of the character's index\n        # 24. keep track of the character's index\n        # 25. keep track of the character's index\n        # 26. keep track of the character's index\n        # 27. keep track of the character's index\n        # 28. keep track of the character's index\n        # 29. keep track of the character's index\n        # 30. keep track of the character's index\n        # 31. keep track of the character's index\n        # 32. keep track of the character's index\n        # 33. keep track of the character's index\n        # 34. keep track of the character's index\n        # 35. keep track of the character's index\n        # 36. keep track of the character's index\n        # 37. keep track of the character's index\n        # 38. keep track of the character's index\n        # 39. keep track of the character's index\n        # 40. keep track of the character's index\n        # 41. keep track of the character's index\n        # 42. keep track of the character's index\n        # 43. keep track of the character's index\n        # 44. keep track of the character's index\n        # 45. keep track of the character's index\n        # 46. keep track of the character's index\n        # 47. keep track of the character's index\n        # 48. keep track of the character's index\n        # 49. keep track of the character's index\n        # 50. keep track of the character's index\n        # 51. keep track of the character's index\n        # 52. keep track of the character's index\n        # 53. keep track of the character's index\n        # 54. keep track of the character's index\n        # 55. keep track of the character's index\n        # 56. keep track of the character's index\n        # 57. keep track of the character's index\n        # 58. keep track of the character's index\n        # 59. keep track of the character's index\n        # 60. keep track of the character's index\n        # 61. keep track of the character's index\n        # 62. keep track of the character's index\n        # 63. keep track of the character's index\n        # 64. keep track of the character's index\n        # 65. keep track of the character's index\n        # 66. keep track of the character's index\n        # 67. keep track of the character's index\n        # 68. keep track of the character's index\n        # 69. keep track of the character's index"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Edge case\n        if len(words) == 0:\n            return []\n        \n        # Edge case\n        if len(s) == 0:\n            return []\n        \n        # Edge case\n        if len(words) * len(words[0]) > len(s):\n            return []\n        \n        # Edge case\n        if len(words) == 1:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0]]\n        \n        # Edge case\n        if len(words) == 2:\n            if s[0:len(words[0])] == words[0] and s[len(words[0]):len(words[0])+len(words[1])] == words[1]:\n                return [0]\n            else:\n                return []\n        \n        # Edge case\n        if len(words) == 3:\n            if s[0:len(words[0])] == words[0] and s[len(words[0]):len(words[0])+len(words[1])] == words[1] and s[len(words[0])+len(words[1]):len(words[0])+len(words[1])+len(words[2])] == words[2]:\n                return [0]\n            else:\n                return []\n        \n        # Edge case\n        if len(words) == 4:\n            if s[0:len(words[0])] == words[0] and s[len(words[0]):len(words[0])+len(words[1])] == words[1] and s[len(words[0])+len(words[1]):len(words[0])+len(words[1])+len(words[2])] == words[2] and s[len(words[0])+len(words[1])+len(words[2]):len(words[0])+len(words[1])+len(words[2])+len(words[3])] == words[3]:\n                return [0]\n            else:\n                return []\n        \n        # Edge case\n        if len(words) == 5:\n            if s[0:len(words[0])] == words[0] and s[len(words[0]):len(words[0])+len(words[1])] == words[1] and s[len(words[0])+len(words[1]):len(words[0])+len(words[1])+len(words[2])] == words[2] and s[len(words[0])+len(words[1])+len(words[2]):len(words[0])+len(words[1])+len(words[2])+len(words[3])] == words[3] and s[len(words[0])+len(words[1])+len(words[2])+len(words[3]):len(words[0])+len(words[1])+len(words[2])+len(words[3])+len(words[4])] == words[4]:\n                return [0]\n            else:\n                return []\n        \n        # Edge case\n        if len(words) == 6:\n            if s[0:len(words[0])] == words[0] and s[len(words[0]):len(words[0])+len(words[1])] == words[1] and s[len(words[0])+len(words[1]):len(words[0])+len(words[1])+len(words[2])] == words[2] and s[len(words[0])+len(words[1])+len(words[2]):len(words[0])+len(words[1])+len(words[2])+len(words[3])] == words[3] and s[len(words[0])+len(words[1])+len(words[2])+len(words[3]):len(words[0])+len(words[1])+len(words[2])+len(words[3])+len(words[4])] == words[4] and s[len(words[0])+len(words[1])+len(words[2])+len(words[3])+len(words[4]):len"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         if curr == head:\n        #             head = temp\n        #         else:\n        #             prev.next = temp\n        #         curr = dummy.next\n        # return head\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         if curr == head:\n        #             head = temp\n        #         else:\n        #             prev.next = temp\n        #         curr = dummy.next\n        # return head\n        \n        if head is None or head.next is None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n                if curr == head:\n                    head = temp\n                else:\n                    prev.next = temp\n                curr = dummy.next\n        return head"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # prev = dummy\n        # curr = head\n        \n        # while curr:\n        #     if curr.next and curr.val == curr.next.val:\n        #         while curr.next and curr.val == curr.next.val:\n        #             curr = curr.next\n        #         prev.next = curr.next\n        #         curr = curr.next\n        #     else:\n        #         prev = curr\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # prev = dummy\n        # curr = head\n        \n        # while curr:\n        #     if curr.next and curr.val == curr.next.val:\n        #         while curr.next and curr.val == curr.next.val:\n        #             curr = curr.next\n        #         prev.next = curr.next\n        #         curr = curr.next\n        #     else:\n        #         prev = curr\n        #         curr = curr.next\n        # return dummy.next\n        \n        if head is None or head.next is None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n                curr = curr.next\n            else:\n                prev = curr\n                curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        if len(word1) == 0:\n            return len(word2)\n        \n        # if word2 is empty, then we need to delete all the characters of word1\n        if len(word2) == 0:\n            return len(word1)\n        \n        # create a 2D array of size (len(word1)+1) x (len(word2)+1)\n        # where the first row and column are initialized with 0\n        dp = [[0 for i in range(len(word2)+1)] for j in range(len(word1)+1)]\n        \n        # fill the first row with the number of insertions\n        for i in range(len(word2)+1):\n            dp[0][i] = i\n        \n        # fill the first column with the number of deletions\n        for i in range(len(word1)+1):\n            dp[i][0] = i\n        \n        # fill the rest of the array\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                # if the characters at the current indices are the same, then no operation is required\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    # if the characters at the current indices are different, then we need to perform one of the following operations:\n                    # 1. insert the character at the current index of word2\n                    # 2. delete the character at the current index of word1\n                    # 3. replace the character at the current index of word1 with the character at the current index of word2\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        \n        # return the last element of the last row\n        return dp[len(word1)][len(word2)]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and y\n        # xor of x and"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        \n        left_paths = self.binaryTreePaths(root.left)\n        right_paths = self.binaryTreePaths(root.right)\n        \n        paths = []\n        for left_path in left_paths:\n            paths.append(str(root.val) + '->' + left_path)\n            \n        for right_path in right_paths:\n            paths.append(str(root.val) + '->' + right_path)\n            \n        return paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                if ty > sy:\n                    tx %= ty\n                else:\n                    tx = tx - ty + sy\n            else:\n                if tx > sx:\n                    ty %= tx\n                else:\n                    ty = ty - tx + sx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        if len(v1) > len(v2):\n            v2.extend(['0'] * (len(v1) - len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend(['0'] * (len(v2) - len(v1)))\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # loop through courses\n        for duration, lastDay in courses:\n            \n            # add to priority queue\n            heapq.heappush(pq, (-duration, lastDay))\n            \n            # add to total time\n            total += duration\n            \n            # if total time is greater than last day\n            if total > lastDay:\n                \n                # pop from priority queue\n                total -= heapq.heappop(pq)[0]\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # create dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a pointer to the dummy node\n        ptr = dummy\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list\n        orig_head = head\n        \n        # create a pointer to the tail of the original list\n        orig_tail = None\n        \n        # create a pointer to the head of the reversed list\n        rev_head = None\n        \n        # create a pointer to the tail of the reversed list\n        rev_tail = None\n        \n        # create a pointer to the head of the original list"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # if len(s) == 2:\n        #     return False\n        \n        # if len(s) == 1:\n        #     return False\n        \n        # if len(s) == 3:\n        #     return False\n        \n        # if len(s) == 4:\n        #     return False\n        \n        # if len(s) == 5:\n        #     return False\n        \n        # if len(s) == 6:\n        #     return False\n        \n        # if len(s) == 7:\n        #     return False\n        \n        # if len(s) == 8:\n        #     return False\n        \n        # if len(s) == 9:\n        #     return False\n        \n        # if len(s) == 10:\n        #     return False\n        \n        # if len(s) == 11:\n        #     return False\n        \n        # if len(s) == 12:\n        #     return False\n        \n        # if len(s) == 13:\n        #     return False\n        \n        # if len(s) == 14:\n        #     return False\n        \n        # if len(s) == 15:\n        #     return False\n        \n        # if len(s) == 16:\n        #     return False\n        \n        # if len(s) == 17:\n        #     return False\n        \n        # if len(s) == 18:\n        #     return False\n        \n        # if len(s) == 19:\n        #     return False\n        \n        # if len(s) == 20:\n        #     return False\n        \n        # if len(s) == 21:\n        #     return False\n        \n        # if len(s) == 22:\n        #     return False\n        \n        # if len(s) == 23:\n        #     return False\n        \n        # if len(s) == 24:\n        #     return False\n        \n        # if len(s) == 25:\n        #     return False\n        \n        # if len(s) == 26:\n        #     return False\n        \n        # if len(s) == 27:\n        #     return False\n        \n        # if len(s) == 28:\n        #     return False\n        \n        # if len(s) == 29:\n        #     return False\n        \n        # if len(s) == 30:\n        #     return False\n        \n        # if len(s) == 31:\n        #     return False\n        \n        # if len(s) == 32:\n        #     return False\n        \n        # if len(s) == 33:\n        #     return False\n        \n        # if len(s) == 34:\n        #     return False\n        \n        # if len(s) == 35:\n        #     return False\n        \n        # if len(s) == 36:\n        #     return False\n        \n        # if len(s) == 37:\n        #     return False\n        \n        # if len(s) == 38:\n        #     return False\n        \n        # if len(s) == 39:\n        #     return False\n        \n        # if len(s) == 40:\n        #     return False\n        \n        # if len(s) == 41:\n        #     return False\n        \n        # if len(s) == 42:\n        #     return False\n        \n        # if len(s) == 43:\n        #     return False\n        \n        # if len(s) == 44:\n        #     return False\n        \n        # if len(s) == 45:\n        #     return False\n        \n        # if len(s) == 46:\n        #     return False\n        \n        # if len(s) == 47:\n        #     return False\n        \n        # if len(s) == 48:\n        #     return False\n        \n        # if len(s) == 49:\n        #     return False\n        \n        # if len(s) == 50:\n        #     return False\n        \n        # if len(s) == 51"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 2. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 3. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 4. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 5. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 6. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 7. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 8. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 9. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 10. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 11. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 12. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 13. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 14. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 15. 1, 2"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build the dict\n        # 2. build the graph\n        # 3. bfs\n        # 4. dfs\n        # 5. dp\n        \n        # build the dict\n        sticker_dict = {}\n        for sticker in stickers:\n            for letter in sticker:\n                if letter not in sticker_dict:\n                    sticker_dict[letter] = 0\n                sticker_dict[letter] += 1\n        \n        # build the graph\n        graph = {}\n        for sticker in stickers:\n            for letter in sticker:\n                if letter not in graph:\n                    graph[letter] = []\n                graph[letter].append(sticker)\n        \n        # build the target dict\n        target_dict = {}\n        for letter in target:\n            if letter not in target_dict:\n                target_dict[letter] = 0\n            target_dict[letter] += 1\n        \n        # build the queue\n        queue = []\n        for letter in target_dict:\n            if target_dict[letter] > 0:\n                queue.append(letter)\n        \n        # build the visited dict\n        visited = {}\n        for letter in sticker_dict:\n            visited[letter] = 0\n        \n        # build the distance dict\n        distance = {}\n        for letter in sticker_dict:\n            distance[letter] = float('inf')\n        \n        # build the parent dict\n        parent = {}\n        for letter in sticker_dict:\n            parent[letter] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent[target] = None\n        \n        # build the distance dict\n        distance[target] = 0\n        \n        # build the queue\n        queue.append(target)\n        \n        # build the visited dict\n        visited[target] = 1\n        \n        # build the parent dict\n        parent["}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid == x:\n                return mid\n            \n            if mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Create a dictionary with the roman numerals and their values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # 2. Initialize the result variable\n        result = 0\n        \n        # 3. Iterate through the string\n        for i in range(len(s)):\n            # 4. If the current character is less than the next character, subtract the current character from the next character\n            if i < len(s) - 1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # 5. Otherwise, add the current character to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # 6. Return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. sort the array\n        ## 2. check if the adjacent elements are same\n        ## 3. if yes, return True\n        ## 4. else return False\n        \n        ## 1. sort the array\n        nums.sort()\n        \n        ## 2. check if the adjacent elements are same\n        for i in range(len(nums)-1):\n            if nums[i] == nums[i+1]:\n                return True\n        \n        ## 3. if yes, return True\n        return False\n        \n        ## 4. else return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_nums = []\n        # max_nums.append(max(nums[0:k]))\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_nums[0]:\n        #         max_nums[0] = nums[i]\n        #     elif nums[i] > max_nums[len(max_nums)-1]:\n        #         max_nums.append(nums[i])\n        #     else:\n        #         max_nums.append(max_nums[len(max_nums)-1])\n        # return max_nums\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_nums = []\n        # max_nums.append(max(nums[0:k]))\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_nums[0]:\n        #         max_nums[0] = nums[i]\n        #     elif nums[i] > max_nums[len(max_nums)-1]:\n        #         max_nums.append(nums[i])\n        #     else:\n        #         max_nums.append(max_nums[len(max_nums)-1])\n        # return max_nums\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_nums = []\n        # max_nums.append(max(nums[0:k]))\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_nums[0]:\n        #         max_nums[0] = nums[i]\n        #     elif nums[i] > max_nums[len(max_nums)-1]:\n        #         max_nums.append(nums[i])\n        #     else:\n        #         max_nums.append(max_nums[len(max_nums)-1])\n        # return max_nums\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_nums = []\n        # max_nums.append(max(nums[0:k]))\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_nums[0]:\n        #         max_nums[0] = nums[i]\n        #     elif nums[i] > max_nums[len(max_nums)-1]:\n        #         max_nums.append(nums[i])\n        #     else:\n        #         max_nums.append(max_nums[len(max_nums)-1])\n        # return max_nums\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # max_nums = []\n        # max_nums.append(max(nums[0:k]))\n        # for i in range(k, len(nums)):\n        #     if nums[i] > max_nums[0]:\n        #         max_nums[0] = nums[i]\n        #     elif nums[i] > max_nums[len(max_nums)-1]:\n        #         max_nums.append(nums[i])\n        #     else:\n        #         max_nums.append(max_nums[len(max_nums)-1])\n        # return max_nums\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1,"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        \n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left = 0\n        # right = len(nums) - 1\n        \n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[right]:\n        #         right = mid\n        #     elif nums[mid] > nums[right]:\n        #         left = mid + 1\n        #     else:\n        #         right -= 1\n        \n        # return nums[left]\n        \n        # if nums[0] <"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # if rowIndex == 2:\n        #     return [1,2,1]\n        # if rowIndex == 3:\n        #     return [1,3,3,1]\n        # if rowIndex == 4:\n        #     return [1,4,6,4,1]\n        # if rowIndex == 5:\n        #     return [1,5,10,10,5,1]\n        # if rowIndex == 6:\n        #     return [1,6,15,20,15,6,1]\n        # if rowIndex == 7:\n        #     return [1,7,21,35,35,21,7,1]\n        # if rowIndex == 8:\n        #     return [1,8,28,56,70,56,28,8,1]\n        # if rowIndex == 9:\n        #     return [1,9,36,84,126,126,84,36,9,1]\n        # if rowIndex == 10:\n        #     return [1,10,45,120,210,252,210,120,45,10,1]\n        # if rowIndex == 11:\n        #     return [1,11,55,165,320,435,435,320,165,55,11,1]\n        # if rowIndex == 12:\n        #     return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        # if rowIndex == 13:\n        #     return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        # if rowIndex == 14:\n        #     return [1,14,88,343,864,1650,2435,2800,2435,1650,864,343,88,14,1]\n        # if rowIndex == 15:\n        #     return [1,15,99,441,1231,2640,4365,5782,5782,4365,2640,1231,441,99,15,1]\n        # if rowIndex == 16:\n        #     return [1,16,100,495,1406,3145,5314,7273,8292,8292,7273,5314,3145,1406,495,100,16,1]\n        # if rowIndex == 17:\n        #     return [1,17,101,560,1856,4365,8040,12160,16060,16060,12160,8040,4365,1856,560,101,17,1]\n        # if rowIndex == 18:\n        #     return [1,18,102,610,2182,5314,10080,16060,22520,28000,28000,22520,16060,10080,5314,2182,610,102,18,1]\n        # if rowIndex == 19:\n        #     return [1,19,103,645,2520,6562,12960,20792,30032"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * L = area\n        # 2. L >= W\n        # 3. L - W = area - L\n        # 4. L >= W\n        # 5. L * W = area\n        # 6. L = area / W\n        # 7. L = sqrt(area)\n        # 8. L = sqrt(area)\n        # 9. L = sqrt(area)\n        # 10. L = sqrt(area)\n        # 11. L = sqrt(area)\n        # 12. L = sqrt(area)\n        # 13. L = sqrt(area)\n        # 14. L = sqrt(area)\n        # 15. L = sqrt(area)\n        # 16. L = sqrt(area)\n        # 17. L = sqrt(area)\n        # 18. L = sqrt(area)\n        # 19. L = sqrt(area)\n        # 20. L = sqrt(area)\n        # 21. L = sqrt(area)\n        # 22. L = sqrt(area)\n        # 23. L = sqrt(area)\n        # 24. L = sqrt(area)\n        # 25. L = sqrt(area)\n        # 26. L = sqrt(area)\n        # 27. L = sqrt(area)\n        # 28. L = sqrt(area)\n        # 29. L = sqrt(area)\n        # 30. L = sqrt(area)\n        # 31. L = sqrt(area)\n        # 32. L = sqrt(area)\n        # 33. L = sqrt(area)\n        # 34. L = sqrt(area)\n        # 35. L = sqrt(area)\n        # 36. L = sqrt(area)\n        # 37. L = sqrt(area)\n        # 38. L = sqrt(area)\n        # 39. L = sqrt(area)\n        # 40. L = sqrt(area)\n        # 41. L = sqrt(area)\n        # 42. L = sqrt(area)\n        # 43. L = sqrt(area)\n        # 44. L = sqrt(area)\n        # 45. L = sqrt(area)\n        # 46. L = sqrt(area)\n        # 47. L = sqrt(area)\n        # 48. L = sqrt(area)\n        # 49. L = sqrt(area)\n        # 50. L = sqrt(area)\n        # 51. L = sqrt(area)\n        # 52. L = sqrt(area)\n        # 53. L = sqrt(area)\n        # 54. L = sqrt(area)\n        # 55. L = sqrt(area)\n        # 56. L = sqrt(area)\n        # 57. L = sqrt(area)\n        # 58. L = sqrt(area)\n        # 59. L = sqrt(area)\n        # 60. L = sqrt(area)\n        # 61. L = sqrt(area)\n        # 62. L = sqrt(area)\n        # 63. L = sqrt(area)\n        # 64. L = sqrt(area)\n        # 65. L = sqrt(area)\n        # 66. L = sqrt(area)\n        # 67. L = sqrt(area)\n        # 68. L = sqrt(area)\n        # 69. L = sqrt(area)\n        # 70. L = sqrt(area)\n        # 71. L = sqrt(area)\n        # 72. L = sqrt(area)\n        # 73. L = sqrt(area)\n        # 74. L = sqrt(area)\n        # 75. L = sqrt"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # build the queue\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for i in range(len(curr)):\n                    neighbor = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor_word in graph[neighbor]:\n                        if neighbor_word == endWord:\n                            return self.build_path(graph, neighbor, endWord)\n                        if neighbor_word not in visited:\n                            visited.add(neighbor_word)\n                            queue.append(neighbor_word)\n        \n        return []\n    \n    def build_path(self, graph, neighbor, endWord):\n        path = [endWord]\n        while neighbor != beginWord:\n            for neighbor_word in graph[neighbor]:\n                if neighbor_word.startswith(neighbor[:-1]):\n                    path.append(neighbor_word)\n                    neighbor = neighbor[:-1]\n                    break\n            else:\n                return []\n        path.reverse()\n        return path"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # while n % 2 == 0:\n        #     n = n / 2\n        # if n == 1:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n / 2)\n        # else:\n        #     return"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the result array\n        result = [[]]\n        \n        # initialize the current subset\n        current_subset = []\n        \n        # initialize the index\n        i = 0\n        \n        # loop through the array\n        while i < len(nums):\n            \n            # if the current subset is empty\n            if not current_subset:\n                \n                # add the current element to the current subset\n                current_subset.append(nums[i])\n                \n                # add the current subset to the result array\n                result.append(current_subset)\n                \n                # increment the index\n                i += 1\n                \n            # if the current element is not the same as the previous element\n            elif nums[i] != nums[i-1]:\n                \n                # add the current element to the current subset\n                current_subset.append(nums[i])\n                \n                # add the current subset to the result array\n                result.append(current_subset)\n                \n                # reset the current subset\n                current_subset = []\n                \n                # increment the index\n                i += 1\n                \n            # if the current element is the same as the previous element\n            else:\n                \n                # increment the index\n                i += 1\n                \n        # return the result array\n        return result"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 2. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 3. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 4. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 5. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 6. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 7. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 8. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 9. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 10. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 11. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 12. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 13. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 14. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube7c\ub0b4\uace0, \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 15. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. Find the four corners of the rectangle\n        ## 2. Find the area of the rectangle\n        ## 3. Find the area of the rectangle minus the area of the corners\n        ## 4. If the area of the rectangle minus the area of the corners is not zero, return False\n        ## 5. If the area of the rectangle minus the area of the corners is zero, return True\n        \n        ## 1. Find the four corners of the rectangle\n        x1, y1, x2, y2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n        for x, y, a, b in rectangles:\n            x1 = min(x1, x)\n            y1 = min(y1, y)\n            x2 = max(x2, a)\n            y2 = max(y2, b)\n        \n        ## 2. Find the area of the rectangle\n        area = (x2 - x1) * (y2 - y1)\n        \n        ## 3. Find the area of the rectangle minus the area of the corners\n        corners = set()\n        corners.add((x1, y1))\n        corners.add((x1, y2))\n        corners.add((x2, y1))\n        corners.add((x2, y2))\n        \n        area_minus_corners = area\n        for x, y in corners:\n            area_minus_corners -= (x2 - x) * (y2 - y)\n        \n        ## 4. If the area of the rectangle minus the area of the corners is not zero, return False\n        if area_minus_corners != 0:\n            return False\n        \n        ## 5. If the area of the rectangle minus the area of the corners is zero, return True\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Divide and Conquer\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 1. Brute force\n        ## Time Complexity: O(n^2"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the empty square\n        # 2. Find the 5-tile square\n        # 3. Swap the 5-tile square with the empty square\n        # 4. If the board is solved, return the number of moves\n        # 5. Otherwise, repeat steps 1-4\n        \n        # 1. Find the empty square\n        empty_square = None\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 0:\n                    empty_square = (i, j)\n                    break\n        \n        # 2. Find the 5-tile square\n        five_tile_square = None\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 5:\n                    five_tile_square = (i, j)\n                    break\n        \n        # 3. Swap the 5-tile square with the empty square\n        board[five_tile_square[0]][five_tile_square[1]] = board[empty_square[0]][empty_square[1]]\n        board[empty_square[0]][empty_square[1]] = 0\n        \n        # 4. If the board is solved, return the number of moves\n        if board == [[1,2,3],[4,5,0]]:\n            return 0\n        \n        # 5. Otherwise, repeat steps 1-4\n        return self.slidingPuzzle(board)"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        \n        # if nums is empty, return False\n        if not nums:\n            return False\n        \n        # if nums has only one element, return True if target is equal to that element\n        if len(nums) == 1:\n            return True if nums[0] == target else False\n        \n        # if nums has more than one element, find the pivot index\n        pivot_index = self.find_pivot(nums)\n        \n        # if target is less than the first element, search the right side of the array\n        if target < nums[0]:\n            return self.binary_search(nums[pivot_index:], target)\n        \n        # if target is greater than the first element, search the left side of the array\n        else:\n            return self.binary_search(nums[:pivot_index], target)\n        \n    def find_pivot(self, nums):\n        # find the pivot index\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left\n    \n    def binary_search(self, nums, target):\n        # binary search the target\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s[0] == '0':\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 3:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 4:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 5:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 6:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 7:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 8:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 9:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 10:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 11:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 12:\n        #     if s[1] == '0':"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the closest sum\n        closest_sum = nums[0] + nums[1] + nums[2]\n        \n        # initialize the closest difference\n        closest_diff = abs(closest_sum - target)\n        \n        # loop through the array\n        for i in range(len(nums) - 2):\n            \n            # initialize the left and right pointers\n            left = i + 1\n            right = len(nums) - 1\n            \n            # loop through the array\n            while left < right:\n                \n                # calculate the sum\n                sum = nums[i] + nums[left] + nums[right]\n                \n                # calculate the difference\n                diff = abs(sum - target)\n                \n                # if the difference is less than the closest difference, update the closest difference and closest sum\n                if diff < closest_diff:\n                    closest_diff = diff\n                    closest_sum = sum\n                \n                # if the sum is less than the target, increment the left pointer\n                if sum < target:\n                    left += 1\n                \n                # if the sum is greater than the target, decrement the right pointer\n                else:\n                    right -= 1\n                \n        # return the closest sum\n        return closest_sum"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     return self.intersect(nums2, nums1)\n        \n        # if len(nums2) == 0:\n        #     return []\n        \n        # if len(nums1) == 0:\n        #     return []\n        \n        # if len(nums1) == 1 and len(nums2) == 1:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 1:\n        #     if nums1[0] in nums2:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums2) == 1:\n        #     if nums2[0] in nums1:\n        #         return [nums2[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 2 and len(nums2) == 2:\n        #     if nums1[0] == nums2[0] and nums1[1] == nums2[1]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 2:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums2) == 2:\n        #     if nums2[0] == nums1[0]:\n        #         return [nums2[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 3 and len(nums2) == 3:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 3:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums2) == 3:\n        #     if nums2[0] == nums1[0]:\n        #         return [nums2[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 4 and len(nums2) == 4:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 4:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums2) == 4:\n        #     if nums2[0] == nums1[0]:\n        #         return [nums2[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 5 and len(nums2) == 5:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 5:\n        #     if nums1[0] == nums2[0]:\n        #         return [nums1[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums2) == 5:\n        #     if nums2[0] == nums1[0]:\n        #         return [nums2[0]]\n        #     else:\n        #         return []\n        \n        # if len(nums1) == 6 and len(nums2) == 6:\n        #     if nums1[0] == nums"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal\n        # find the min and max value in the tree\n        # find the min difference\n        \n        # inorder traversal"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with the max frequency\n        ## 3. return the nodes\n        \n        ## 1. find the max frequency of the tree\n        ## 2. find the nodes with"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        if len(haystack) == len(needle):\n            if haystack == needle:\n                return 0\n            else:\n                return -1\n        \n        if len(haystack) > len(needle):\n            if haystack[0:len(needle)] == needle:\n                return 0\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 1:\n            if haystack[0:len(needle)] == needle:\n                return 0\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) - 1:\n            if haystack[1:len(needle) + 1] == needle:\n                return 1\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 2:\n            if haystack[1:len(needle) + 1] == needle:\n                return 1\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 3:\n            if haystack[2:len(needle) + 2] == needle:\n                return 2\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 4:\n            if haystack[3:len(needle) + 3] == needle:\n                return 3\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 5:\n            if haystack[4:len(needle) + 4] == needle:\n                return 4\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 6:\n            if haystack[5:len(needle) + 5] == needle:\n                return 5\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 7:\n            if haystack[6:len(needle) + 6] == needle:\n                return 6\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 8:\n            if haystack[7:len(needle) + 7] == needle:\n                return 7\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 9:\n            if haystack[8:len(needle) + 8] == needle:\n                return 8\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 10:\n            if haystack[9:len(needle) + 9] == needle:\n                return 9\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 11:\n            if haystack[10:len(needle) + 10] == needle:\n                return 10\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 12:\n            if haystack[11:len(needle) + 11] == needle:\n                return 11\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 13:\n            if haystack[12:len(needle) + 12] == needle:\n                return 12\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 14:\n            if haystack[13:len(needle) + 13] == needle:\n                return 13\n            else:\n                return -1\n        \n        if len(haystack) == len(needle) + 15:\n            if haystack[14:len(needle) + 14] == needle:\n                return 14\n            else:\n                return -1\n        \n        if len(haystack) == len(need"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc18c\ubb38\uc790, \ucd5c\uc18c 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        \n        #"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 2. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 3. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 4. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 5. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 6. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 7. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 8. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 9. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 10. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 11. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100\n        # 12. 2, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 6"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        # initialize the list of lists\n        rows = [[] for _ in range(numRows)]\n        \n        # initialize the direction\n        direction = 1\n        \n        # initialize the row index\n        row_index = 0\n        \n        # loop through the string\n        for char in s:\n            # add the character to the row\n            rows[row_index].append(char)\n            \n            # if the row index is at the end of the list, change the direction\n            if row_index == numRows - 1:\n                direction = -1\n            # if the row index is at the beginning of the list, change the direction\n            if row_index == 0:\n                direction = 1\n            \n            # increment or decrement the row index based on the direction\n            row_index += direction\n        \n        # initialize the result string\n        result = \"\"\n        \n        # loop through the rows\n        for row in rows:\n            # loop through the characters in the row\n            for char in row:\n                # add the character to the result string\n                result += char\n        \n        # return the result string\n        return result"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Create a hashmap with the number as key and the value as 1\n        ## 2. Iterate through the array and for each number, check if the number is in the hashmap. If it is, increment the value by 1.\n        ## 3. Iterate through the hashmap and return the keys that have a value of 1.\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Create a hashmap with the number as key and the value as 1\n        hashmap = {}\n        for i in range(1, len(nums) + 1):\n            hashmap[i] = 1\n        \n        ## Iterate through the array and for each number, check if the number is in the hashmap. If it is, increment the value by 1.\n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                hashmap[nums[i]] += 1\n        \n        ## Iterate through the hashmap and return the keys that have a value of 1.\n        result = []\n        for i in range(1, len(nums) + 1):\n            if i not in hashmap:\n                result.append(i)\n        \n        return result"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by start and end\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max and min\n        max_num = -1\n        min_num = 10**9\n        \n        # iterate through the intervals\n        for interval in intervals:\n            # if the interval is not sorted\n            if interval[0] > max_num:\n                # update the max and min\n                max_num = interval[1]\n                min_num = interval[0]\n                # update the result\n                res += 2\n            # if the interval is sorted\n            else:\n                # update the max\n                max_num = max(max_num, interval[1])\n                # update the result\n                res += 1\n        \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            if left.val != right.val:\n                return False\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        if not root:\n            return True\n        return isMirror(root.left, root.right)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n                \n        return result"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # while n % 4 == 0:\n        #     n = n / 4\n        # if n == 1:\n        #     return True\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 4 != 0:\n        #     return False\n        # return self.isPowerOfFour(n / 4)\n        \n        # if n == 0:"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap left and right child\n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        # recursively invert left and right child\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # if n is 0, return []\n        if n == 0:\n            return []\n        \n        # if n is 1, return ['()']\n        if n == 1:\n            return ['()']\n        \n        # if n is 2, return ['()()', '(())']\n        if n == 2:\n            return ['()()', '(())']\n        \n        # if n is 3, return ['()()()', '(())()', '()(())']\n        if n == 3:\n            return ['()()()', '(())()', '()(())']\n        \n        # if n is 4, return ['()()()()', '(())()()', '()(())()', '(())()()', '()()(())', '()(())()']\n        if n == 4:\n            return ['()()()()', '(())()()', '()(())()', '(())()()', '()()(())', '()(())()']\n        \n        # if n is 5, return ['()()()()()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()()(())()', '(())()()()', '()(())()()', '(())()()()', '()"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[0] == 1:\n            return 1\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1]"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 2. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 3. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 4. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 5. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 6. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 7. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 8. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 9. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 10. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 11. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 12. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 13. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 14. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 15. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 16. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 17. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 18. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 19. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 20. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 21. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 22. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 23. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 24. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 25. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 26. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 27. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 28. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 29. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 30. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 31. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 32. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 33. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 34. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 35. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 36. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 37. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 38. \uc2a4\ud0dd\uc73c\ub85c \ud480\uae30\n        # 39."}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        # edge case\n        if denominator == 0:\n            return \"NaN\"\n        \n        # edge case\n        if numerator == 0:\n            return \"0\"\n        \n        # edge case\n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        \n        # edge case\n        if numerator < 0 and denominator > 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return \"-\" + str(numerator // denominator) + \".\" + self.fractionToDecimal(numerator % denominator, denominator)\n        \n        # edge case\n        if numerator > 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return \"-\" + str(numerator // denominator) + \".\" + self.fractionToDecimal(numerator % denominator, denominator)\n        \n        # edge case\n        if numerator < 0 and denominator > 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return str(numerator // denominator) + \".\" + self.fractionToDecimal(numerator % denominator, denominator)\n        \n        # edge case\n        if numerator > 0 and denominator > 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return str(numerator // denominator) + \".\" + self.fractionToDecimal(numerator % denominator, denominator)\n        \n        # edge case\n        if numerator == 0:\n            return \"0\"\n        \n        # edge case\n        if numerator == 1:\n            return \"1\"\n        \n        # edge case\n        if numerator == 2:\n            return \"0.5\"\n        \n        # edge case\n        if numerator == 3:\n            return \"0.(03)\"\n        \n        # edge case\n        if numerator == 4:\n            return \"0.25\"\n        \n        # edge case\n        if numerator == 5:\n            return \"0.2\"\n        \n        # edge case\n        if numerator == 6:\n            return \"0.(06)\"\n        \n        # edge case\n        if numerator == 7:\n            return \"0.(07)\"\n        \n        # edge case\n        if numerator == 8:\n            return \"0.125\"\n        \n        # edge case\n        if numerator == 9:\n            return \"0.1(09)\"\n        \n        # edge case\n        if numerator == 10:\n            return \"0.1\"\n        \n        # edge case\n        if numerator == 11:\n            return \"0.(011)\"\n        \n        # edge case\n        if numerator == 12:\n            return \"0.0625\"\n        \n        # edge case\n        if numerator == 13:\n            return \"0.(013)\"\n        \n        # edge case\n        if numerator == 14:\n            return \"0.05\"\n        \n        # edge case\n        if numerator == 15:\n            return \"0.(015)\"\n        \n        # edge case\n        if numerator == 16:\n            return \"0.04\"\n        \n        # edge case\n        if numerator == 17:\n            return \"0.(017)\"\n        \n        # edge case\n        if numerator == 18:\n            return \"0.03\"\n        \n        # edge case\n        if numerator == 19:\n            return \"0.(019)\"\n        \n        # edge case\n        if numerator == 20:\n            return \"0.02\"\n        \n        # edge case\n        if numerator == 21:\n            return \"0.(021)\"\n        \n        # edge case\n        if numerator == 22:\n            return \"0.0125\"\n        \n        # edge case\n        if numerator == 23:\n            return \"0.(023)\"\n        \n        # edge case\n        if numerator == 24:\n            return \"0.01(024)\"\n        \n        # edge case\n        if numerator == 25:\n            return \"0"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if the list is empty or has only one node, return the same list\n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add the remaining nodes from the left half\n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # find longest increasing subsequence\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] < envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] > envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] <= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] <= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] > envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] < envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] >= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] >= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] < envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] > envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] <= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] <= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] > envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] < envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] >= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] >= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] < envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] > envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] <= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] <= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] > envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] < envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] >= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] >= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] < envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] > envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] <= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] <= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end of the linked list\n        ## 3. Remove the nth node from the end of the linked list\n        ## 4. Return the head of the linked list\n        \n        ## 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        ## 2. Find the nth node from the end of the linked list\n        ## 3. Remove the nth node from the end of the linked list\n        ## 4. Return the head of the linked list\n        if length == 1:\n            return None\n        elif length == n:\n            return head.next\n        else:\n            curr = head\n            for i in range(length - n - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n            return head\n        \n        ## 4. Return the head of the linked list\n        ## 3. Remove the nth node from the end of the linked list\n        ## 2. Return the head of the linked list\n        ## 1. Find the length of the linked list\n        ## 4. Find the nth node from the end of the linked list\n        ## 3. Remove the nth node from the end of the linked list\n        ## 2. Return the head of the linked list\n        ## 1. Find the length of the linked list\n        ## 3. Find the nth node from the end of the linked list\n        ## 2. Remove the nth node from the end of the linked list\n        ## 1. Return the head of the linked list\n        ## 4. Return the head of the linked list\n        ## 3. Remove the nth node from the end of the linked list\n        ## 2. Return the head of the linked list\n        ## 4. Return the head of the linked list\n        ## 2. Find the length of the linked list\n        ## 3. Find the nth node from the end of the linked list\n        ## 2. Remove the nth node from the end of the linked list\n        ## 1. Return the head of the linked list\n        ## 3. Remove the nth node from the end of the linked list\n        ## 1. Return the head of the linked list\n        ## 2. Find the length of the linked list\n        ## 3. Find the nth node from the end of the linked list\n        ## 3. Remove the nth node from the end of the linked list\n        ## 2. Return the head of the linked list\n        ## 1. Find the length of the linked list\n        ## 2. Find the nth node from the end of the linked list\n        ## 1. Remove the nth node from the end of the linked list\n        ## 2. Return the head of the linked list\n        ## 1. Find the length of the linked list\n        ## 1. Find the nth node from the end of the linked list\n        ## 1. Remove the nth node from the end of the linked list\n        ## 2. Return the head of the linked list\n        ## 1. Find the length of the linked list\n        ## 1. Find the nth node from the end of the linked list\n        ## 1. Remove the nth node from the end of the linked list\n        ## 1. Return the head of the linked list\n        ## 1. Find the length of the linked list\n        ## 1. Find the nth node from the end of the linked list\n        ## 1. Remove the nth node from the end of the linked list\n        ## 1. Return the head of the linked list\n        ## 1. Find the length of the linked list\n        ## 1. Find the nth node from the end of the linked list\n        ## 1. Remove the nth node from the end of the linked list\n        ## 1. Return the head of the linked list\n        ## 1. Find the length of the linked list\n        ## 1. Find the nth node from the end of the linked list\n        ## 1. Remove the nth node from the"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. sort the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        ## 2. set the two pointers\n        i = 0\n        j = 0\n        \n        ## 3. initialize the result\n        result = []\n        \n        ## 4. loop through the arrays\n        while i < len(nums1) and j < len(nums2):\n            \n            ## 5. if the two numbers are the same, add it to the result\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n                \n            ## 6. if the first number is smaller, move the pointer to the next number\n            elif nums1[i] < nums2[j]:\n                i += 1\n                \n            ## 7. if the second number is smaller, move the pointer to the next number\n            else:\n                j += 1\n                \n        ## 8. return the result\n        return result"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum(machines)\n        # max_sum = 0\n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     max_sum = max(max_sum, abs(left_sum - right_sum))\n        #     machines[i] = avg\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        # return max_sum\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum(machines)\n        # max_sum = 0\n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     max_sum = max(max_sum, abs(left_sum - right_sum))\n        #     machines[i] = avg\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        # return max_sum\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum(machines)\n        # max_sum = 0\n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     max_sum = max(max_sum, abs(left_sum - right_sum))\n        #     machines[i] = avg\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        # return max_sum\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum(machines)\n        # max_sum = 0\n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        #     max_sum = max(max_sum, abs(left_sum - right_sum))\n        #     machines[i] = avg\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n        # return max_sum\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        low = 1\n        high = m * n\n        \n        while low < high:\n            mid = (low + high) // 2\n            c = count(mid)\n            if c < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # if head.next is None:\n        #     return TreeNode(head.val)\n        \n        # slow = head\n        # fast = head\n        # prev = None\n        # while fast and fast.next:\n        #     prev = slow\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # prev.next = None\n        # root = TreeNode(slow.val)\n        # root.left = self.sortedListToBST(head)\n        # root.right = self.sortedListToBST(slow.next)\n        # return root\n        \n        # if head is None:\n        #     return None\n        \n        # if head.next is None:\n        #     return TreeNode(head.val)\n        \n        # slow = head\n        # fast = head\n        # prev = None\n        # while fast and fast.next:\n        #     prev = slow\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # prev.next = None\n        # root = TreeNode(slow.val)\n        # root.left = self.sortedListToBST(head)\n        # root.right = self.sortedListToBST(slow.next)\n        # return root\n        \n        # if head is None:\n        #     return None\n        \n        # if head.next is None:\n        #     return TreeNode(head.val)\n        \n        # slow = head\n        # fast = head\n        # prev = None\n        # while fast and fast.next:\n        #     prev = slow\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # prev.next = None\n        # root = TreeNode(slow.val)\n        # root.left = self.sortedListToBST(head)\n        # root.right = self.sortedListToBST(slow.next)\n        # return root\n        \n        # if head is None:\n        #     return None\n        \n        # if head.next is None:\n        #     return TreeNode(head.val)\n        \n        # slow = head\n        # fast = head\n        # prev = None\n        # while fast and fast.next:\n        #     prev = slow\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # prev.next = None\n        # root = TreeNode(slow.val)\n        # root.left = self.sortedListToBST(head)\n        # root.right = self.sortedListToBST(slow.next)\n        # return root\n        \n        # if head is None:\n        #     return None\n        \n        # if head.next is None:\n        #     return TreeNode(head.val)\n        \n        # slow = head\n        # fast = head\n        # prev = None\n        # while fast and fast.next:\n        #     prev = slow\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # prev.next = None\n        # root = TreeNode(slow.val)\n        # root.left = self.sortedListToBST(head)\n        # root.right = self.sortedListToBST(slow.next)\n        # return root\n        \n        # if head is None:\n        #     return None\n        \n        # if head.next is None:\n        #     return TreeNode(head.val)\n        \n        # slow = head\n        # fast = head\n        # prev = None\n        # while fast and fast.next:\n        #     prev = slow\n        #     slow = slow.next\n        #     fast = fast.next.next\n        \n        # prev.next = None\n        # root = TreeNode(slow.val)\n        # root.left = self.sortedListToBST(head)\n        # root.right = self.sortedListToBST(slow.next)\n        # return root\n        \n        # if head is None:\n        #     return None\n        \n        # if head.next is None:\n        #     return TreeNode(head.val)\n        \n        # slow = head\n        # fast = head"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 57. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        #"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[mid + 1]:\n        #         left = mid + 1\n        #     elif nums[mid] > nums[mid + 1]:\n        #         right = mid\n        #     else:\n        #         left += 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[mid + 1]:\n        #         left = mid + 1\n        #     elif nums[mid] > nums[mid + 1]:\n        #         right = mid\n        #     else:\n        #         left += 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[mid + 1]:\n        #         left = mid + 1\n        #     elif nums[mid] > nums[mid + 1]:\n        #         right = mid\n        #     else:\n        #         left += 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[mid + 1]:\n        #         left = mid + 1\n        #     elif nums[mid] > nums[mid + 1]:\n        #         right = mid\n        #     else:\n        #         left += 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[mid + 1]:\n        #         left = mid + 1\n        #     elif nums[mid] > nums[mid + 1]:\n        #         right = mid\n        #     else:\n        #         left += 1\n        # return nums[left]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < nums[mid + 1]:\n        #         left = mid + 1\n        #     elif nums[mid] > nums[mid + 1]:\n        #         right = mid\n        #     else:\n        #         left += 1\n        # return nums[left]\n        \n        # if nums[0] < num"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n        # Symbol       Value\n        # I             1\n        # V             5\n        # X             10\n        # L             50\n        # C             100\n        # D             500\n        # M             1000\n        \n        # Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        # I can be placed before V (5) and X (10) to make 4 and 9.\n        # X can be placed before L (50) and C (100) to make 40 and 90.\n        # C can be placed before D (500) and M (1000) to make 400 and 900.\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and decrement the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hashmap\n        ## 3. Return the character with frequency 1\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ##\n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in s\n        ## 2. Iterate through t and increment the frequency of each character in the hash"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            # check row\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n            # check col\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n            # check 3x3 box\n            box_row = row // 3\n            box_col = col // 3\n            for i in range(box_row * 3, box_row * 3 + 3):\n                for j in range(box_col * 3, box_col * 3 + 3):\n                    if board[i][j] == num:\n                        return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recover the tree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. binary search\n        # 2. 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401, 2500, 2601, 2704, 2809, 2916, 3025, 3136, 3249, 3364, 3481, 3600, 3721, 3844, 3969, 4096, 4225, 4356, 4489, 4624, 4761, 4900, 5041, 5184, 5329, 5476, 5625, 5776, 5929, 6084, 6241, 6400, 6561, 6724, 6889, 7056, 7225, 7396, 7569, 7744, 7921, 8100, 8281, 8464, 8649, 8836, 9025, 9216, 9409, 9604, 9801, 10000\n        # 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401, 2500, 2601, 2704, 2809, 2916, 3025, 3136, 3249, 3364, 3481, 3600, 3721, 3844, 3969, 4096, 4225, 4356, 4489, 4624, 4761, 4900, 5041, 5184, 5329, 5476, 5625, 5776, 5929, 6084, 6241, 6400, 6561, 6724, 6"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if n == 0:\n        #     return [0]\n        # if n == 1:\n        #     return [0,1]\n        # if n == 2:\n        #     return [0,1,1]\n        # if n == 3:\n        #     return [0,1,1,2]\n        # if n == 4:\n        #     return [0,1,1,2,2]\n        # if n == 5:\n        #     return [0,1,1,2,2,3]\n        # if n == 6:\n        #     return [0,1,1,2,2,3,3]\n        # if n == 7:\n        #     return [0,1,1,2,2,3,3,4]\n        # if n == 8:\n        #     return [0,1,1,2,2,3,3,4,4]\n        # if n == 9:\n        #     return [0,1,1,2,2,3,3,4,4,5]\n        # if n == 10:\n        #     return [0,1,1,2,2,3,3,4,4,5,5]\n        # if n == 11:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6]\n        # if n == 12:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        # if n == 13:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        # if n == 14:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        # if n == 15:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        # if n == 16:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        # if n == 17:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        # if n == 18:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10]\n        # if n == 19:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10]\n        # if n == 20:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11]\n        # if n == 21:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11]\n        # if n == 22:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11,12]\n        # if n == 23:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,11,12,12]\n        # if n == 24:\n        #     return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        if len(set(s1)) == 1:\n            return True\n        \n        # if len(set(s1)) == 2:\n        #     return s1[0] == s2[0] and s1[1] == s2[1]\n        \n        # if len(set(s1)) == 3:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2]\n        \n        # if len(set(s1)) == 4:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3]\n        \n        # if len(set(s1)) == 5:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4]\n        \n        # if len(set(s1)) == 6:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4] and s1[5] == s2[5]\n        \n        # if len(set(s1)) == 7:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4] and s1[5] == s2[5] and s1[6] == s2[6]\n        \n        # if len(set(s1)) == 8:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4] and s1[5] == s2[5] and s1[6] == s2[6] and s1[7] == s2[7]\n        \n        # if len(set(s1)) == 9:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4] and s1[5] == s2[5] and s1[6] == s2[6] and s1[7] == s2[7] and s1[8] == s2[8]\n        \n        # if len(set(s1)) == 10:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4] and s1[5] == s2[5] and s1[6] == s2[6] and s1[7] == s2[7] and s1[8] == s2[8] and s1[9] == s2[9]\n        \n        # if len(set(s1)) == 11:\n        #     return s1[0] == s2[0] and s1[1] == s2[1] and s1[2] == s2[2] and s1[3] == s2[3] and s1[4] == s2[4] and s1[5] == s2[5] and s1[6] == s2[6] and s1[7] == s2[7] and s1[8"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of strings\n        path_list = path.split('/')\n        \n        # initialize a stack to store the directory names\n        stack = []\n        \n        # loop through the list of strings\n        for i in range(len(path_list)):\n            # if the string is not empty and not '.'\n            if path_list[i] != '' and path_list[i] != '.':\n                # if the string is '..'\n                if path_list[i] == '..':\n                    # if the stack is not empty\n                    if stack:\n                        # pop the last element from the stack\n                        stack.pop()\n                # otherwise, add the string to the stack\n                else:\n                    stack.append(path_list[i])\n        \n        # initialize a string to store the simplified path\n        simplified_path = ''\n        \n        # loop through the stack\n        for i in range(len(stack)):\n            # if the stack is not empty\n            if stack:\n                # add the string to the simplified path\n                simplified_path += '/' + stack[i]\n        \n        # if the simplified path is empty, return '/'\n        if not simplified_path:\n            return '/'\n        \n        # otherwise, return the simplified path\n        return simplified_path"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['*'] = True\n        \n        # build adjacency list\n        adj_list = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_list:\n                    adj_list[board[i][j]] = []\n                adj_list[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] not in adj_matrix:\n                    adj_matrix[board[i][j]] = []\n                adj_matrix[board[i][j]].append((i,j))\n        \n        # build adjacency matrix\n        adj_matrix = {}\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # if len(s) != len(t):"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 sets for rows, cols, and squares\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        squares = [set() for _ in range(9)]\n        \n        # 2. iterate through board\n        for i in range(9):\n            for j in range(9):\n                # 3. if the value is not '.'\n                if board[i][j] != '.':\n                    # 4. add value to the set\n                    value = int(board[i][j])\n                    rows[i].add(value)\n                    cols[j].add(value)\n                    square_index = (i // 3) * 3 + j // 3\n                    squares[square_index].add(value)\n                    \n        # 5. check if any of the sets has more than 1 value\n        for row, col, square in zip(rows, cols, squares):\n            if len(row) > 1 or len(col) > 1 or len(square) > 1:\n                return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. Create a list of strings\n        # 2. Iterate through the list\n        # 3. If the number is divisible by 3 and 5, add \"FizzBuzz\" to the list\n        # 4. If the number is divisible by 3, add \"Fizz\" to the list\n        # 5. If the number is divisible by 5, add \"Buzz\" to the list\n        # 6. If the number is not divisible by 3 or 5, add the number to the list\n        \n        # 1. Create a list of strings\n        answer = []\n        \n        # 2. Iterate through the list\n        for i in range(1, n+1):\n            \n            # 3. If the number is divisible by 3 and 5, add \"FizzBuzz\" to the list\n            if i % 3 == 0 and i % 5 == 0:\n                answer.append(\"FizzBuzz\")\n                \n            # 4. If the number is divisible by 3, add \"Fizz\" to the list\n            elif i % 3 == 0:\n                answer.append(\"Fizz\")\n                \n            # 5. If the number is divisible by 5, add \"Buzz\" to the list\n            elif i % 5 == 0:\n                answer.append(\"Buzz\")\n                \n            # 6. If the number is not divisible by 3 or 5, add the number to the list\n            else:\n                answer.append(str(i))\n                \n        # 7. Return the list of strings\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 26^0 = 1\n        # 2. 26^1 = 26\n        # 3. 26^2 = 676\n        # 4. 26^3 = 25600\n        # 5. 26^4 = 1440000\n        # 6. 26^5 = 73720000\n        # 7. 26^6 = 3584000000\n        # 8. 26^7 = 184320000000\n        # 9. 26^8 = 1073741824000\n        # 10. 26^9 = 53687091200000\n        # 11. 26^10 = 2684354560000000\n        # 12. 26^11 = 142161004000000000\n        # 13. 26^12 = 7888609600000000000\n        # 14. 26^13 = 41424400000000000000\n        # 15. 26^14 = 209715200000000000000\n        # 16. 26^15 = 1048576000000000000000\n        # 17. 26^16 = 5242880000000000000000\n        # 18. 26^17 = 26214400000000000000000\n        # 19. 26^18 = 131072000000000000000000\n        # 20. 26^19 = 655360000000000000000000\n        # 21. 26^20 = 3276800000000000000000000\n        # 22. 26^21 = 16384000000000000000000000\n        # 23. 26^22 = 81920000000000000000000000\n        # 24. 26^23 = 409600000000000000000000000\n        # 25. 26^24 = 2048000000000000000000000000\n        # 26. 26^25 = 10240000000000000000000000000\n        # 27. 26^26 = 51200000000000000000000000000\n        # 28. 26^27 = 256000000000000000000000000000\n        # 29. 26^28 = 1280000000000000000000000000000\n        # 30. 26^29 = 6400000000000000000000000000000\n        # 31. 26^30 = 32000000000000000000000000000000\n        # 32. 26^3"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # 1. Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping of pattern to words\n        mapping = {}\n        \n        # create a set to store the set of words\n        word_set = set()\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern is not in the mapping, add it to the mapping\n            if pattern[i] not in mapping:\n                mapping[pattern[i]] = words[i]\n            # if the word is already in the mapping, check if it matches the pattern\n            else:\n                # if the word is not in the mapping, return False\n                if mapping[pattern[i]] != words[i]:\n                    return False\n        \n        # if the set of words is not empty, return False\n        if word_set:\n            return False\n        \n        # if the set of words is empty, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return [nums]\n        # if len(nums) == 2:\n        #     return [[nums[0], nums[1]], [nums[1], nums[0]]]\n        # if len(nums) == 3:\n        #     return [[nums[0], nums[1], nums[2]], [nums[0], nums[2], nums[1]], [nums[1], nums[0], nums[2]], [nums[1], nums[2], nums[0]], [nums[2], nums[0], nums[1]], [nums[2], nums[1], nums[0]]]\n        \n        # if len(nums) == 4:\n        #     return [[nums[0], nums[1], nums[2], nums[3]], [nums[0], nums[1], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3]], [nums[0], nums[2], nums[3], nums[1]], [nums[1], nums[0], nums[2], nums[3]], [nums[1], nums[0], nums[3], nums[2]], [nums[1], nums[2], nums[0], nums[3]], [nums[1], nums[2], nums[3], nums[0]], [nums[2], nums[0], nums[1], nums[3]], [nums[2], nums[0], nums[3], nums[1]], [nums[2], nums[1], nums[0], nums[3]], [nums[2], nums[1], nums[3], nums[0]], [nums[3], nums[0], nums[1], nums[2]], [nums[3], nums[0], nums[2], nums[1]], [nums[3], nums[1], nums[0], nums[2]], [nums[3], nums[1], nums[2], nums[0]], [nums[0], nums[1], nums[2], nums[3]], [nums[0], nums[1], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3]], [nums[0], nums[2], nums[3], nums[1]], [nums[1], nums[2], nums[3], nums[0]], [nums[1], nums[3], nums[0], nums[2]], [nums[1], nums[3], nums[2], nums[0]], [nums[2], nums[3], nums[0], nums[1]], [nums[2], nums[3], nums[1], nums[0]], [nums[3], nums[2], nums[0], nums[1]], [nums[3], nums[2], nums[1], nums[0]]]\n        \n        # if len(nums) == 5:\n        #     return [[nums[0], nums[1], nums[2], nums[3], nums[4]], [nums[0], nums[1], nums[3], nums[4], nums[2]], [nums[0], nums[1], nums[4], nums[2], nums[3]], [nums[0], nums[1], nums[4], nums[3], nums[2]], [nums[0], nums[2], nums[1], nums[3], nums[4]], [nums[0], nums[2], nums[1], nums[4], nums[3]], [nums[0], nums[2], nums[3], nums[1], nums[4]], [nums[0], nums[2], nums[3], nums[4], nums"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a new listnode\n        # 2. create a new listnode\n        # 3. create a new listnode\n        # 4. create a new listnode\n        # 5. create a new listnode\n        # 6. create a new listnode\n        # 7. create a new listnode\n        # 8. create a new listnode\n        # 9. create a new listnode\n        # 10. create a new listnode\n        # 11. create a new listnode\n        # 12. create a new listnode\n        # 13. create a new listnode\n        # 14. create a new listnode\n        # 15. create a new listnode\n        # 16. create a new listnode\n        # 17. create a new listnode\n        # 18. create a new listnode\n        # 19. create a new listnode\n        # 20. create a new listnode\n        # 21. create a new listnode\n        # 22. create a new listnode\n        # 23. create a new listnode\n        # 24. create a new listnode\n        # 25. create a new listnode\n        # 26. create a new listnode\n        # 27. create a new listnode\n        # 28. create a new listnode\n        # 29. create a new listnode\n        # 30. create a new listnode\n        # 31. create a new listnode\n        # 32. create a new listnode\n        # 33. create a new listnode\n        # 34. create a new listnode\n        # 35. create a new listnode\n        # 36. create a new listnode\n        # 37. create a new listnode\n        # 38. create a new listnode\n        # 39. create a new listnode\n        # 40. create a new listnode\n        # 41. create a new listnode\n        # 42. create a new listnode\n        # 43. create a new listnode\n        # 44. create a new listnode\n        # 45. create a new listnode\n        # 46. create a new listnode\n        # 47. create a new listnode\n        # 48. create a new listnode\n        # 49. create a new listnode\n        # 50. create a new listnode\n        # 51. create a new listnode\n        # 52. create a new listnode\n        # 53. create a new listnode\n        # 54. create a new listnode\n        # 55. create a new listnode\n        # 56. create a new listnode\n        # 57. create a new listnode\n        # 58. create a new listnode\n        # 59. create a new listnode\n        # 60. create a new listnode\n        # 61. create a new listnode\n        # 62. create a new listnode\n        # 63. create a new listnode\n        # 64. create a new listnode\n        # 65. create a new listnode\n        # 66. create a new listnode\n        # 67. create a new listnode\n        # 68. create a new listnode\n        # 69. create a new listnode\n        # 70. create a new listnode\n        # 71. create a new listnode\n        # 72. create a new listnode\n        # 73. create a new listnode\n        # 74. create a new listnode\n        # 75. create a new listnode\n        # 76. create a new listnode\n        # 77. create a new listnode\n        # 78. create a new listnode\n        # 79. create a new listnode\n        # 80. create a new listnode\n        # 81. create a new listnode\n        # 82. create a new listnode\n        # 83. create a new listnode\n        # 84. create a new listnode\n        # 85. create a new listnode\n        # 86. create a new listnode"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert num to binary\n        ## 2. reverse the binary\n        ## 3. convert binary to decimal\n        ## 4. return the complement\n        \n        ## 1. convert num to binary\n        binary = \"\"\n        while num > 0:\n            binary = str(num % 2) + binary\n            num = num // 2\n        \n        ## 2. reverse the binary\n        binary = binary[::-1]\n        \n        ## 3. convert binary to decimal\n        decimal = 0\n        for i in range(len(binary)):\n            decimal += int(binary[i]) * (2 ** i)\n        \n        ## 4. return the complement\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 2:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 2:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 2:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 2:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 2:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 2:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 2:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     if node.right:\n        #         stack.append(node.right)\n        # return res[::-1]\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n            res.append(node.val)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area ="}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(N * L)\n        # Space Complexity: O(N)\n        \n        # Create a set of words\n        word_set = set(words)\n        \n        # Create a dictionary to store the longest word in the set\n        longest_word = {}\n        \n        # Iterate through the set of words\n        for word in word_set:\n            # Get the length of the word\n            word_len = len(word)\n            \n            # If the word is in the dictionary, update the longest word\n            if word_len in longest_word:\n                longest_word[word_len] = word\n            else:\n                longest_word[word_len] = word\n        \n        # Create a list to store the concatenated words\n        concatenated_words = []\n        \n        # Iterate through the set of words\n        for word in word_set:\n            # Get the length of the word\n            word_len = len(word)\n            \n            # If the word is in the dictionary, update the longest word\n            if word_len in longest_word:\n                # Create a dictionary to store the longest word in the set\n                longest_word = {}\n                \n                # Iterate through the set of words\n                for word in word_set:\n                    # Get the length of the word\n                    word_len = len(word)\n                    \n                    # If the word is in the dictionary, update the longest word\n                    if word_len in longest_word:\n                        longest_word[word_len] = word\n                    else:\n                        longest_word[word_len] = word\n                \n                # Create a list to store the concatenated words\n                concatenated_words = []\n                \n                # Iterate through the set of words\n                for word in word_set:\n                    # Get the length of the word\n                    word_len = len(word)\n                    \n                    # If the word is in the dictionary, update the longest word\n                    if word_len in longest_word:\n                        # If the word is a concatenated word, add it to the list\n                        if self.is_concatenated_word(word, longest_word):\n                            concatenated_words.append(word)\n                    else:\n                        # If the word is not a concatenated word, add it to the list\n                        if self.is_concatenated_word(word, longest_word):\n                            concatenated_words.append(word)\n                \n                # If the concatenated words list is not empty, add the concatenated words to the list\n                if concatenated_words:\n                    concatenated_words.append(word)\n        \n        # Return the concatenated words list\n        return concatenated_words\n    \n    def is_concatenated_word(self, word, longest_word):\n        # Create a dictionary to store the longest word in the set\n        longest_word = {}\n        \n        # Iterate through the set of words\n        for word in word_set:\n            # Get the length of the word\n            word_len = len(word)\n            \n            # If the word is in the dictionary, update the longest word\n            if word_len in longest_word:\n                longest_word[word_len] = word\n            else:\n                longest_word[word_len] = word\n        \n        # Create a list to store the concatenated words\n        concatenated_words = []\n        \n        # Iterate through the set of words\n        for word in word_set:\n            # Get the length of the word\n            word_len = len(word)\n            \n            # If the word is in the dictionary, update the longest word\n            if word_len in longest_word:\n                # If the word is a concatenated word, add it to the list\n                if self.is_concatenated_word(word, longest_word):\n                    concatenated_words.append(word)\n            else:\n                # If the word is not a concatenated word, add it to the list\n                if self.is_concatenated_word(word, longest_word):\n                    concatenated_words.append(word)\n        \n        # Return the concatenated words list\n        return concatenated_words\n    \n    def is_concatenated_word(self, word, longest_word):\n        # Create a dictionary to store the longest word in the set\n        longest_word = {}\n        \n        # Iterate through the set of words\n        for word in"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 queen\n        # 2. 2 queens\n        # 3. 3 queens\n        # 4. 4 queens\n        # 5. 5 queens\n        # 6. 6 queens\n        # 7. 7 queens\n        # 8. 8 queens\n        # 9. 9 queens\n        # 10. 10 queens\n        # 11. 11 queens\n        # 12. 12 queens\n        # 13. 13 queens\n        # 14. 14 queens\n        # 15. 15 queens\n        # 16. 16 queens\n        # 17. 17 queens\n        # 18. 18 queens\n        # 19. 19 queens\n        # 20. 20 queens\n        # 21. 21 queens\n        # 22. 22 queens\n        # 23. 23 queens\n        # 24. 24 queens\n        # 25. 25 queens\n        # 26. 26 queens\n        # 27. 27 queens\n        # 28. 28 queens\n        # 29. 29 queens\n        # 30. 30 queens\n        # 31. 31 queens\n        # 32. 32 queens\n        # 33. 33 queens\n        # 34. 34 queens\n        # 35. 35 queens\n        # 36. 36 queens\n        # 37. 37 queens\n        # 38. 38 queens\n        # 39. 39 queens\n        # 40. 40 queens\n        # 41. 41 queens\n        # 42. 42 queens\n        # 43. 43 queens\n        # 44. 44 queens\n        # 45. 45 queens\n        # 46. 46 queens\n        # 47. 47 queens\n        # 48. 48 queens\n        # 49. 49 queens\n        # 50. 50 queens\n        # 51. 51 queens\n        # 52. 52 queens\n        # 53. 53 queens\n        # 54. 54 queens\n        # 55. 55 queens\n        # 56. 56 queens\n        # 57. 57 queens\n        # 58. 58 queens\n        # 59. 59 queens\n        # 60. 60 queens\n        # 61. 61 queens\n        # 62. 62 queens\n        # 63. 63 queens\n        # 64. 64 queens\n        # 65. 65 queens\n        # 66. 66 queens\n        # 67. 67 queens\n        # 68. 68 queens\n        # 69. 69 queens\n        # 70. 70 queens\n        # 71. 71 queens\n        # 72. 72 queens\n        # 73. 73 queens\n        # 74. 74 queens\n        # 75. 75 queens\n        # 76. 76 queens\n        # 77. 77 queens\n        # 78. 78 queens\n        # 79. 79 queens\n        # 80. 80 queens\n        # 81. 81 queens\n        # 82. 82 queens\n        # 83. 83 queens\n        # 84. 84 queens\n        # 85. 85 queens\n        # 86. 86 queens\n        # 87. 87 queens"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \u521d\u59cb\u5316\u68cb\u76d8\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        # 2. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col = [set() for _ in range(2*n-1)]\n        # 3. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        diagonal = [set() for _ in range(2*n-1)]\n        # 4. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        anti_diagonal = [set() for _ in range(2*n-1)]\n        # 5. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5217\u5750\u6807\n        col = [set() for _ in range(n)]\n        # 6. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5750\u6807\n        row = [set() for _ in range(n)]\n        # 7. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        diagonal = [set() for _ in range(2*n-1)]\n        # 8. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        anti_diagonal = [set() for _ in range(2*n-1)]\n        # 9. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5217\u5750\u6807\n        col = [set() for _ in range(n)]\n        # 10. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5750\u6807\n        row = [set() for _ in range(n)]\n        # 11. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        diagonal = [set() for _ in range(2*n-1)]\n        # 12. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        anti_diagonal = [set() for _ in range(2*n-1)]\n        # 13. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5217\u5750\u6807\n        col = [set() for _ in range(n)]\n        # 14. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5750\u6807\n        row = [set() for _ in range(n)]\n        # 15. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        diagonal = [set() for _ in range(2*n-1)]\n        # 16. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        anti_diagonal = [set() for _ in range(2*n-1)]\n        # 17. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5217\u5750\u6807\n        col = [set() for _ in range(n)]\n        # 18. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5750\u6807\n        row = [set() for _ in range(n)]\n        # 19. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        diagonal = [set() for _ in range(2*n-1)]\n        # 20. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        anti_diagonal = [set() for _ in range(2*n-1)]\n        # 21. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5217\u5750\u6807\n        col = [set() for _ in range(n)]\n        # 22. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5750\u6807\n        row = [set() for _ in range(n)]\n        # 23. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        diagonal = [set() for _ in range(2*n-1)]\n        # 24. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        anti_diagonal = [set() for _ in range(2*n-1)]\n        # 25. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5217\u5750\u6807\n        col = [set() for _ in range(n)]\n        # 26. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5750\u6807\n        row = [set() for _ in range(n)]\n        # 27. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        diagonal = [set() for _ in range(2*n-1)]\n        # 28. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        anti_diagonal = [set() for _ in range(2*n-1)]\n        # 29. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5217\u5750\u6807\n        col = [set() for _ in range(n)]\n        # 30. \u521d\u59cb\u5316\u68cb\u76d8"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # if word is empty, return False\n        if not word:\n            return False\n        \n        # if board is empty, return False\n        if not board:\n            return False\n        \n        # if word is longer than board, return False\n        if len(word) > len(board) * len(board[0]):\n            return False\n        \n        # if word is shorter than board, return False\n        if len(word) < len(board) * len(board[0]):\n            return False\n        \n        # if word is the same as board, return True\n        if word == board:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board, return True\n        if word == board[0][0]:\n            return True\n        \n        # if word is the same as board,"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. if the array has less than 3 elements, return the max element\n        # 3. if the array has 3 elements, return the third max element\n        # 4. if the array has more than 3 elements, return the third max element\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. if the array has less than 3 elements, return the max element\n        if len(nums) < 3:\n            return nums[-1]\n        \n        # 3. if the array has 3 elements, return the third max element\n        if len(nums) == 3:\n            return nums[1]\n        \n        # 4. if the array has more than 3 elements, return the third max element\n        return nums[2]"}]}