{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n - 1\n        top, bottom = 0, m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        ranges = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    ranges.append(str(start))\n                else:\n                    ranges.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            ranges.append(str(start))\n        else:\n            ranges.append(str(start) + \"->\" + str(end))\n        \n        return ranges"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers as 0\n        # 2. mark all numbers in the range [1, len(nums)] as 1\n        # 3. iterate through the array and mark the numbers as -1 if they are in the range [1, len(nums)]\n        # 4. iterate through the array again and return the first number that is not marked as -1\n        \n        for i in range(len(nums)):\n            if nums[i] <= 0:\n                nums[i] = float('inf')\n        \n        for i in range(len(nums)):\n            num = abs(nums[i])\n            if num <= len(nums):\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(1, len(nums) + 1):\n            if nums[i - 1] > 0:\n                return i\n        \n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate the list of numbers\n        nums = [i for i in range(1, n+1)]\n        \n        # 2. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 3. calculate the kth permutation\n        k -= 1\n        res = ''\n        for i in range(n-1, -1, -1):\n            # 3.1 calculate the index of the current digit\n            idx = k // fact\n            # 3.2 calculate the digit\n            res += str(nums[idx])\n            # 3.3 remove the digit from the list\n            nums.pop(idx)\n            # 3.4 update k\n            k %= fact\n            # 3.5 update the factorial\n            fact //= i\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the numbers and their indices\n        num_dict = {}\n        \n        # iterate through the numbers list\n        for i, num in enumerate(numbers):\n            # check if the complement of the target minus the current number is in the dictionary\n            if target - num in num_dict:\n                # return the indices of the complement and the current number\n                return [num_dict[target - num], i]\n            # add the current number to the dictionary with its index as the value\n            num_dict[num] = i"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr_num = int(num[i:j+1])\n                if op:\n                    backtrack(j+1, curr - prev, curr_num, res, op + '-' + str(curr_num))\n                    backtrack(j+1, curr + prev, -curr_num, res, op + '+' + str(curr_num))\n                    backtrack(j+1, curr - prev + prev, curr_num, res, op + '*' + str(curr_num))\n                else:\n                    backtrack(j+1, curr_num, curr_num, res, str(curr_num))\n                    backtrack(j+1, -curr_num, -curr_num, res, '-' + str(curr_num))\n                    backtrack(j+1, curr_num, -curr_num, res, '+' + str(curr_num))\n                    backtrack(j+1, curr_num * prev, curr_num, res, str(curr_num) + '*' + str(prev))\n        \n        res = []\n        backtrack(0, 0, 0, res, '')\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left_sum = dfs(root.left, curr_sum * 10 + root.val)\n            right_sum = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left_sum + right_sum\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        \n        res = []\n        for i in range(0, n, k):\n            res.append(s[i:i+k])\n        \n        return '-'.join(res)"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the total amount of gas in the tank\n        total_gas = sum(gas)\n        ## 2. Find the total amount of cost\n        total_cost = sum(cost)\n        \n        ## 3. If the total amount of gas is less than the total amount of cost, return -1\n        if total_gas < total_cost:\n            return -1\n        \n        ## 4. Initialize the tank with 0\n        tank = 0\n        ## 5. Initialize the starting index with 0\n        start = 0\n        \n        ## 6. Loop through the gas and cost lists\n        for i in range(len(gas)):\n            ## 7. Add the gas and cost at the current index\n            tank += gas[i] - cost[i]\n            ## 8. If the tank is less than 0, set the starting index to the current index + 1\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        ## 9. Return the starting index\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits.insert(0, 1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_greater_element(nums1, k):\n            out = []\n            for i, n in enimport enumerate(nums1):\n                while out and n > out[-1] and len(out) + len(nums1) - i > k:\n                    out.pop()\n                if len(out) < k:\n                    out.append(n)\n            return out\n        \n        def merge(nums1, nums2, k):\n            out = []\n            for n1, n2 in zip(nums1, nums2):\n                while out and n1 > out[-1] and len(out) + len(nums2) - i > k:\n                    out.pop()\n                if len(out) < k:\n                    out.append(n2)\n            return out\n        \n        def max_array(nums):\n            out = []\n            for n in nums:\n                while out and n > out[-1] and len(out) < len(nums):\n                    out.pop()\n                if len(out) < len(nums):\n                    out.append(n)\n            return out\n        \n        m, n = len(nums1), len(nums2)\n        if m + n == k:\n            return max_array(nums1 + nums2)\n        if m < k:\n            return max_array(nums2)\n        if n < k:\n            return max_array(nums1)\n        if k == 1:\n            return max_array(nums1 + nums2)\n        if k == 2:\n            return max_array(merge(nums1, nums2, k))\n        if k == 3:\n            return max_array(merge(nums1, nums2, k))\n        if k == 4:\n            return max_array(merge(nums1, nums2, k))\n        if k == 5:\n            return max_array(merge(nums1, nums2, k))\n        if k == 6:\n            return max_array(merge(nums1, nums2, k))\n        if k == 7:\n            return max_array(merge(nums1, nums2, k))\n        if k == 8:\n            return max_array(merge(nums1, nums2, k))\n        if k == 9:\n            return max_array(merge(nums1, nums2, k))\n        if k == 10:\n            return max_array(merge(nums1, nums2, k))\n        if k == 11:\n            return max_array(merge(nums1, nums2, k))\n        if k == 12:\n            return max_array(merge(nums1, nums2, k))\n        if k == 13:\n            return max_array(merge(nums1, nums2, k))\n        if k == 14:\n            return max_array(merge(nums1, nums2, k))\n        if k == 15:\n            return max_array(merge(nums1, nums2, k))\n        if k == 16:\n            return max_array(merge(nums1, nums2, k))\n        if k == 17:\n            return max_array(merge(nums1, nums2, k))\n        if k == 18:\n            return max_array(merge(nums1, nums2, k))\n        if k == 19:\n            return max_array(merge(nums1, nums2, k))\n        if k == 20:\n            return max_array(merge(nums1, nums2, k))\n        if k == 21:\n            return max_array(merge(nums1, nums2, k))\n        if k == 22:\n            return max_array(merge(nums1, nums2, k))\n        if k == 23:\n            return max_array(merge(nums1, nums2, k))\n        if k == 24:\n            return max_array(merge(nums1, nums2, k))\n        if k == 25:\n            return max_array(merge(nums1, nums2, k))\n        if k == 26:\n            return max_"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if i == m - 1 and j == n - 1:\n                    dp[i][j] = max(1, 1 - dungeon[i][j])\n                elif i == m - 1:\n                    dp[i][j] = max(1, dp[i][j + 1] - dungeon[i][j])\n                elif j == n - 1:\n                    dp[i][j] = max(1, dp[i + 1][j] - dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if sum(bisect_right(nums, mid) - i for i in range(len(nums))) >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = [i for i, letter in enumerate(s_list) if letter in vowels]\n        \n        for i in range(len(vowel_indices) // 2):\n            s_list[vowel_indices[i]], s_list[vowel_indices[-i - 1]] = s_list[vowel_indices[-i - 1]], s_list[vowel_indices[i]]\n        \n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_length = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                current_num = num\n                current_length = 1\n                \n                while current_num + 1 in nums_set:\n                    current_num += 1\n                    current_length += 1\n                    \n                max_length = max(max_length, current_length)\n                \n        return max_length"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.98% of Python online submissions for Missing Number.\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        queue = collections.deque([(beginWord, 1)])\n        visited = set([beginWord])\n        while queue:\n            word, depth = queue.popleft()\n            if word == endWord:\n                return depth\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word in wordList and next_word not in visited:\n                        visited.add(next_word)\n                        queue.append((next_word, depth+1))\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        carry = 0\n        result = []\n        for i in range(len(a)-1, -1, -1):\n            if a[i] == '1':\n                carry += 1\n            if i < len(b):\n                if b[i] == '1':\n                    carry += 1\n            result.append(str(carry % 2))\n            carry //= 2\n        \n        if carry:\n            result.append(str(carry))\n        \n        return ''.join(result[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_left_index):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (find_left_index and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        cur_reach = 0\n        \n        for i in range(n):\n            if i > cur_reach:\n                jumps += 1\n                cur_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices[::2], prices[1::2]))\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j] + prices[i] - prices[i - 1], dp[i - 1][j - 1] + prices[i] - prices[i - 1])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        if num < 0:\n            num = num + 2**32\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = ''\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # iterate through the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate through the string again and return the first character with a frequency of 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with a frequency of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n                \n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert the strings to integers\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add the integers\n        result = num1 + num2\n        \n        # convert the result to a string\n        result = str(result)\n        \n        return result"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res, num = 0, 0\n            while i < len(s):\n                if s[i].isdigit():\n                    num = num * 10 + int(s[i])\n                elif s[i] == '(':\n                    num, i = helper(s, i + 1, 1)\n                elif s[i] == ')':\n                    return res, i + 1\n                else:\n                    res += sign * num\n                    sign = 1 if s[i] == '+' else -1\n                    num = 0\n                i += 1\n            return res + sign * num\n        \n        return helper(s, 0, 1)[0]"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # heapify profits\n        heap = []\n        for c, p in sorted_capital:\n            if c <= w:\n                heapq.heappush(heap, -p)\n            else:\n                break\n        \n        # iterate over sorted capital\n        for c, p in sorted_capital:\n            if c > w:\n                break\n            if len(heap) > 0:\n                w += -heapq.heappop(heap)\n                k -= 1\n            if k == 0:\n                break\n        \n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '{':\n                stack.append('}')\n            elif i == '[':\n                stack.append(']')\n            elif len(stack) == 0 or i != stack.pop():\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # if we have reached the end, it means we are already in the highest permutation\n        if i == -1:\n            return nums.reverse()\n        \n        # find the next number that is larger than the number we found before\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the part of the array that is after the number we found before\n        nums[i + 1:] = nums[i + 1:][::-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a hashmap\n        hashmap = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            \n            # check if the number is already in the hashmap\n            if num in hashmap:\n                \n                # if it is, check if the difference between the index and the value is less than or equal to k\n                if i - hashmap[num] <= k:\n                    return True\n                \n            # add the number to the hashmap\n            hashmap[num] = i\n            \n        # if we haven't found a duplicate within the given window, return false\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        \n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(0, n, 2):\n            if couples[i][0] / 2 != couples[i][1] / 2:\n                j = row.index(couples[i][0] + 1)\n                row[i], row[j] = row[j], row[i]\n                swaps += 1\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        \n        ans = []\n        for word in words:\n            if set(word.lower()) <= row1:\n                ans.append(word)\n            elif set(word.lower()) <= row2:\n                ans.append(word)\n            elif set(word.lower()) <= row3:\n                ans.append(word)\n        \n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        for _ in range(left - 1):\n            prev = prev.next\n        \n        curr = prev.next\n        for _ in range(right - left):\n            nxt = curr.next\n            curr.next = nxt.next\n            nxt.next = prev.next\n            prev.next = nxt\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # for example, if the string is \"abcdcba\", the longest palindrome is \"abcdcba\"\n        # the length of the longest palindrome is 7\n        # the center of the longest palindrome is the character 'c'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 11\n        # the center of the shortest palindrome is the character 'd'\n        # the remaining part of the string is \"abcd\"\n        # the shortest palindrome is \"abcdcba\" + \"abcd\"\n        # the length of the shortest palindrome is 1"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        # create a hashmap for the characters in t\n        # and their counts\n        count_t = collections.Counter(t)\n        \n        # create a hashmap for the characters in s\n        # and their counts\n        count_s = collections.Counter()\n        \n        # create a hashmap for the characters in s\n        # and their counts\n        # and the number of characters in t\n        # that have been found in s\n        required = len(count_t)\n        \n        # create a hashmap for the characters in s\n        # and their counts\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and the number of characters in t\n        # that have been found in s\n        # and"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3] and distance[i - 2] == distance[i - 4]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        \n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character in the string\n        freq = {}\n        \n        # initialize the length of the longest palindrome to 0\n        longest_palindrome = 0\n        \n        # loop through the string and update the frequency of each character\n        for char in s:\n            if char in freq:\n                freq[char] += 1\n            else:\n                freq[char] = 1\n        \n        # loop through the dictionary and check for odd-length palindromes\n        for char, count in freq.items():\n            if count % 2 == 0:\n                longest_palindrome += count\n            else:\n                longest_palindrome += count - 1\n                odd_found = True\n        \n        # if there are any odd-length palindromes, add 1 to the length\n        if odd_found:\n            longest_palindrome += 1\n        \n        return longest_palindrome"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder)\n        root.left = self.buildTree(inorder[:idx], postorder)\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # get all the trees in the forest\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        \n        # sort the trees by height\n        trees.sort(key=lambda x: x[0])\n        \n        # start from the top left corner\n        steps = 0\n        curr_pos = (0, 0)\n        for tree in trees:\n            steps += self.bfs(forest, curr_pos, tree)\n            if steps == -1:\n                return -1\n            curr_pos = tree\n        \n        return steps\n    \n    def bfs(self, forest, start, end):\n        \"\"\"\n        Breadth-first search to find the shortest path from start to end\n        \"\"\"\n        visited = set()\n        queue = collections.deque([(start, 0)])\n        while queue:\n            curr_pos, steps = queue.popleft()\n            if curr_pos == end:\n                return steps\n            for dir in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                new_pos = (curr_pos[0] + dir[0], curr_pos[1] + dir[1])\n                if new_pos not in visited and 0 <= new_pos[0] < len(forest) and 0 <= new_pos[1] < len(forest[0]) and forest[new_pos[0]][new_pos[1]] > 0:\n                    visited.add(new_pos)\n                    queue.append((new_pos, steps + 1))\n        return -1"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. calculate the prefix sum\n        # 2. sort the prefix sum\n        # 3. use two pointers to find the range sum\n        # 4. use binary search to find the range sum\n        # 5. use two pointers to find the range sum\n        # 6. use two pointers to find the range sum\n        # 7. use two pointers to find the range sum\n        # 8. use two pointers to find the range sum\n        # 9. use two pointers to find the range sum\n        # 10. use two pointers to find the range sum\n        # 11. use two pointers to find the range sum\n        # 12. use two pointers to find the range sum\n        # 13. use two pointers to find the range sum\n        # 14. use two pointers to find the range sum\n        # 15. use two pointers to find the range sum\n        # 16. use two pointers to find the range sum\n        # 17. use two pointers to find the range sum\n        # 18. use two pointers to find the range sum\n        # 19. use two pointers to find the range sum\n        # 20. use two pointers to find the range sum\n        # 21. use two pointers to find the range sum\n        # 22. use two pointers to find the range sum\n        # 23. use two pointers to find the range sum\n        # 24. use two pointers to find the range sum\n        # 25. use two pointers to find the range sum\n        # 26. use two pointers to find the range sum\n        # 27. use two pointers to find the range sum\n        # 28. use two pointers to find the range sum\n        # 29. use two pointers to find the range sum\n        # 30. use two pointers to find the range sum\n        # 31. use two pointers to find the range sum\n        # 32. use two pointers to find the range sum\n        # 33. use two pointers to find the range sum\n        # 34. use two pointers to find the range sum\n        # 35. use two pointers to find the range sum\n        # 36. use two pointers to find the range sum\n        # 37. use two pointers to find the range sum\n        # 38. use two pointers to find the range sum\n        # 39. use two pointers to find the range sum\n        # 40. use two pointers to find the range sum\n        # 41. use two pointers to find the range sum\n        # 42. use two pointers to find the range sum\n        # 43. use two pointers to find the range sum\n        # 44. use two pointers to find the range sum\n        # 45. use two pointers to find the range sum\n        # 46. use two pointers to find the range sum\n        # 47. use two pointers to find the range sum\n        # 48. use two pointers to find the range sum\n        # 49. use two pointers to find the range sum\n        # 50. use two pointers to find the range sum\n        # 51. use two pointers to find the range sum\n        # 52. use two pointers to find the range sum\n        # 53. use two pointers to find the range sum\n        # 54. use two pointers to find the range sum\n        # 55. use two pointers to find the range sum\n        # 56. use two pointers to find the range sum\n        # 57. use two pointers to find the range sum\n        # 58. use two pointers to find the range sum\n        # 59. use two pointers to find the range sum\n        # 60. use two pointers to find the range sum\n        # 61. use two pointers to find the range sum\n        # 62. use two poin"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the first row\n        # 4. Find the number of coins in the second row\n        # 5. Find the number of coins in the third row\n        # 6. Find the number of coins in the fourth row\n        # 7. Find the number of coins in the fifth row\n        # 8. Find the number of coins in the sixth row\n        # 9. Find the number of coins in the seventh row\n        # 10. Find the number of coins in the eighth row\n        # 11. Find the number of coins in the ninth row\n        # 12. Find the number of coins in the tenth row\n        # 13. Find the number of coins in the eleventh row\n        # 14. Find the number of coins in the twelfth row\n        # 15. Find the number of coins in the thirteenth row\n        # 16. Find the number of coins in the fourteenth row\n        # 17. Find the number of coins in the fifteenth row\n        # 18. Find the number of coins in the sixteenth row\n        # 19. Find the number of coins in the seventeenth row\n        # 20. Find the number of coins in the eighteenth row\n        # 21. Find the number of coins in the nineteenth row\n        # 22. Find the number of coins in the twentieth row\n        # 23. Find the number of coins in the twenty-first row\n        # 24. Find the number of coins in the twenty-second row\n        # 25. Find the number of coins in the twenty-third row\n        # 26. Find the number of coins in the twenty-fourth row\n        # 27. Find the number of coins in the twenty-fifth row\n        # 28. Find the number of coins in the twenty-sixth row\n        # 29. Find the number of coins in the twenty-seventh row\n        # 30. Find the number of coins in the twenty-eighth row\n        # 31. Find the number of coins in the twenty-ninth row\n        # 32. Find the number of coins in the thirty-first row\n        # 33. Find the number of coins in the thirty-second row\n        # 34. Find the number of coins in the thirty-third row\n        # 35. Find the number of coins in the thirty-fourth row\n        # 36. Find the number of coins in the thirty-fifth row\n        # 37. Find the number of coins in the thirty-sixth row\n        # 38. Find the number of coins in the thirty-seventh row\n        # 39. Find the number of coins in the thirty-eighth row\n        # 40. Find the number of coins in the thirty-ninth row\n        # 41. Find the number of coins in the forty-first row\n        # 42. Find the number of coins in the forty-second row\n        # 43. Find the number of coins in the forty-third row\n        # 44. Find the number of coins in the forty-fourth row\n        # 45. Find the number of coins in the forty-fifth row\n        # 46. Find the number of coins in the forty-sixth row\n        # 47. Find the number of coins in the forty-seventh row\n        # 48. Find the number of coins in the forty-eighth row\n        # 49. Find the number of coins in the forty-ninth row\n        # 50. Find the number of coins in the fifty-first row\n        # 51. Find the number of coins in the fifty-second row\n        # 52. Find the number of coins in the fifty-third row\n        # 53. Find the number of coins in the fifty-fourth row\n        # 54. Find the number of coins in the fifty-fifth row\n        # 55. Find the number of coins in the fifty-sixth row\n        # 56. Find the number of coins"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        \n        for i in range(1, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if i > 1 and s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        \n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a, b = 1, 2\n        for i in range(3, n+1):\n            a, b = b, a+b\n        return b"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the dp array with False\n        dp = [False] * (len(s) + 1)\n        \n        # Set the first element to True\n        dp[0] = True\n        \n        # Iterate over the string\n        for i in range(len(s)):\n            # Iterate over the dictionary\n            for word in wordDict:\n                # Check if the substring is in the dictionary\n                if s[i:i+len(word)] == word:\n                    # If it is, set the corresponding element to True\n                    dp[i+len(word)] = dp[i]\n        \n        # Return the last element of the dp array\n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (left and node.val <= left.val) or (right and node.val >= right.val):\n                return False\n            \n            return valid(node.left, left, node) and valid(node.right, node, right)\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # add the new interval to the end of the list\n        intervals.append(newInterval)\n        \n        # sort the list by start value\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the merged list\n        merged = [intervals[0]]\n        \n        # loop through the list\n        for i in range(1, len(intervals)):\n            # get the current interval\n            curr = intervals[i]\n            \n            # get the last merged interval\n            last = merged[-1]\n            \n            # if the current interval overlaps with the last merged interval\n            if curr[0] <= last[1]:\n                # update the last merged interval\n                last[1] = max(curr[1], last[1])\n            else:\n                # add the current interval to the merged list\n                merged.append(curr)\n        \n        # return the merged list\n        return merged"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_palindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if is_palindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the min and max values\n        min_val = float('inf')\n        max_val = float('-inf')\n        \n        # Initialize the heap\n        heap = []\n        \n        # Initialize the min_val and max_val\n        for i in range(len(nums)):\n            min_val = min(min_val, nums[i][0])\n            max_val = max(max_val, nums[i][-1])\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        \n        # Initialize the range\n        range_ = max_val - min_val\n        res = [min_val, max_val]\n        \n        # Iterate over the heap\n        while heap:\n            # Pop the smallest element\n            val, i, j = heapq.heappop(heap)\n            \n            # Update the range\n            range_ = max(range_, max_val - val)\n            \n            # Update the result\n            if range_ < max_val - min_val:\n                res = [min_val, max_val]\n            \n            # If the last element has been added to the heap\n            if j + 1 == len(nums[i]):\n                break\n            \n            # Add the next element to the heap\n            heapq.heappush(heap, (nums[i][j + 1], i, j + 1))\n            \n            # Update the min_val and max_val\n            min_val = min(min_val, nums[i][j + 1])\n            max_val = max(max_val, nums[i][j + 1])\n        \n        return res"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set([(0, 0)])\n        res = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            res = max(res, t)\n            if i == j == n - 1:\n                return res\n            for ni, nj in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    seen.add((ni, nj))\n                    \n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize a 2D array with zeros\n        grid = [[0] * n for _ in range(m)]\n        \n        # Fill the first row with ones\n        for i in range(n):\n            grid[0][i] = 1\n        \n        # Fill the first column with ones\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # Fill the rest of the grid with the sum of the values above and to the left\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        \n        # Return the value in the bottom-right corner\n        return grid[m - 1][n - 1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1_len = len(num1)\n        num2_len = len(num2)\n        \n        result = [0] * (num1_len + num2_len)\n        \n        for i in range(num1_len - 1, -1, -1):\n            for j in range(num2_len - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1 = i + j\n                p2 = i + j + 1\n                \n                mul += result[p2]\n                result[p1] += mul // 10\n                result[p2] += mul % 10\n                \n        i = 0\n        while i < len(result) - 1 and result[i] == 0:\n            i += 1\n        \n        return \"\".join(map(str, result[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the max profit by buying and selling the stock\n        ## 2. Find the max profit by buying and selling the stock\n        ## 3. Find the max profit by buying and selling the stock\n        ## 4. Find the max profit by buying and selling the stock\n        ## 5. Find the max profit by buying and selling the stock\n        ## 6. Find the max profit by buying and selling the stock\n        ## 7. Find the max profit by buying and selling the stock\n        ## 8. Find the max profit by buying and selling the stock\n        ## 9. Find the max profit by buying and selling the stock\n        ## 10. Find the max profit by buying and selling the stock\n        ## 11. Find the max profit by buying and selling the stock\n        ## 12. Find the max profit by buying and selling the stock\n        ## 13. Find the max profit by buying and selling the stock\n        ## 14. Find the max profit by buying and selling the stock\n        ## 15. Find the max profit by buying and selling the stock\n        ## 16. Find the max profit by buying and selling the stock\n        ## 17. Find the max profit by buying and selling the stock\n        ## 18. Find the max profit by buying and selling the stock\n        ## 19. Find the max profit by buying and selling the stock\n        ## 20. Find the max profit by buying and selling the stock\n        ## 21. Find the max profit by buying and selling the stock\n        ## 22. Find the max profit by buying and selling the stock\n        ## 23. Find the max profit by buying and selling the stock\n        ## 24. Find the max profit by buying and selling the stock\n        ## 25. Find the max profit by buying and selling the stock\n        ## 26. Find the max profit by buying and selling the stock\n        ## 27. Find the max profit by buying and selling the stock\n        ## 28. Find the max profit by buying and selling the stock\n        ## 29. Find the max profit by buying and selling the stock\n        ## 30. Find the max profit by buying and selling the stock\n        ## 31. Find the max profit by buying and selling the stock\n        ## 32. Find the max profit by buying and selling the stock\n        ## 33. Find the max profit by buying and selling the stock\n        ## 34. Find the max profit by buying and selling the stock\n        ## 35. Find the max profit by buying and selling the stock\n        ## 36. Find the max profit by buying and selling the stock\n        ## 37. Find the max profit by buying and selling the stock\n        ## 38. Find the max profit by buying and selling the stock\n        ## 39. Find the max profit by buying and selling the stock\n        ## 40. Find the max profit by buying and selling the stock\n        ## 41. Find the max profit by buying and selling the stock\n        ## 42. Find the max profit by buying and selling the stock\n        ## 43. Find the max profit by buying and selling the stock\n        ## 44. Find the max profit by buying and selling the stock\n        ## 45. Find the max profit by buying and selling the stock\n        ## 46. Find the max profit by buying and selling the stock\n        ## 47. Find the max profit by buying and selling the stock\n        ## 48. Find the max profit by buying and selling the stock\n        ## 49. Find the max profit by buying and selling the stock\n        ## 50. Find the max profit by buying and selling the stock\n        ## 51. Find the max profit by buying and selling the stock\n        ## 52. Find the max profit by buying and selling the stock\n        ## 53. Find the max profit by buying and selling the stock\n        ## 54. Find the max profit by buying and selling the stock\n        ## 55. Find the max profit by buying and selling the stock\n        ## 56. Find the max profit by buying and selling the stock\n        ## 57. Find the max profit by buying and selling the stock\n        ## 58."}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper():\n            return False\n        else:\n            return True"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## TLE\n        ## max_profit = 0\n        ## for i in range(len(prices)):\n        ##     for j in range(i+1, len(prices)):\n        ##         profit = prices[j] - prices[i]\n        ##         max_profit = max(max_profit, profit)\n        ## return max_profit\n        \n        ## DP\n        ## Time: O(n)\n        ## Space: O(1)\n        ## DP\n        ## max_profit = 0\n        ## min_price = float('inf')\n        ## for price in prices:\n        ##     min_price = min(min_price, price)\n        ##     max_profit = max(max_profit, price - min_price)\n        ## return max_profit\n        \n        ## DP\n        ## Time: O(n)\n        ## Space: O(1)\n        ## DP\n        max_profit = 0\n        min_price = prices[0]\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            if not stack:\n                return result\n            node = stack.pop()\n            result.append(node.val)\n            root = node.right"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        queue = collections.deque([s])\n        seen = {s}\n        while queue:\n            s = queue.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    queue.append(t)\n                    seen.add(t)\n        \n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a heap\n        heap = []\n        # loop through the lists\n        for l in lists:\n            # if the list is not empty\n            if l:\n                # add the first element to the heap\n                heapq.heappush(heap, (l.val, l))\n        # loop through the heap\n        while heap:\n            # pop the first element from the heap\n            val, node = heapq.heappop(heap)\n            # add the node to the dummy node\n            curr.next = node\n            # move the dummy node to the next node\n            curr = curr.next\n            # if the next node exists\n            if curr.next:\n                # add the next node to the heap\n                heapq.heappush(heap, (curr.next.val, curr.next))\n        # return the dummy node\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return math.floor(math.log(x, 5) + 1)\n        \n        lo, hi = 0, 10**18\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if f(mid) < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a dict to store the index of each word\n        word_dict = {word: i for i, word in enumerate(words)}\n        \n        # create a list to store the result\n        result = []\n        \n        # iterate over each word\n        for i, word in enumerate(words):\n            # reverse the word\n            rev_word = word[::-1]\n            \n            # check if the reversed word is a palindrome\n            if rev_word in word_dict:\n                # if it is, add the pair to the result\n                result.append([i, word_dict[rev_word]])\n            \n            # check if the word is a palindrome\n            for j in range(len(word)):\n                # check if the substring is a palindrome\n                if word[:j] in word_dict and rev_word[j:] in word_dict:\n                    # if it is, add the pair to the result\n                    result.append([i, word_dict[rev_word[j:]]])\n        \n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        \n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                res += 1\n            return res\n        \n        return spread(isInfected) - spread(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n                    break\n        \n        # build the result list\n        res = []\n        if dp[-1]:\n            self.dfs(s, wordDict, dp, '', res)\n        \n        return res\n    \n    def dfs(self, s, wordDict, dp, path, res):\n        if not s:\n            res.append(path[:-1])\n            return\n        \n        for i in range(1, len(s) + 1):\n            if dp[i]:\n                self.dfs(s[i:], wordDict, dp, path + ' ' + s[:i], res)"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_result = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_result.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                level_result.reverse()\n            result.append(level_result)\n            level += 1\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def gen_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return '%d:%02d' % (h, m)\n        \n        def gen_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [gen_time(h, m), gen_time(h + 1, m - 1), gen_time(h + 2, m - 2), gen_time(h + 3, m - 3), gen_time(h + 4, m - 4), gen_time(h + 5, m - 5), gen_time(h + 6, m - 6), gen_time(h + 7, m - 7), gen_time(h + 8, m - 8), gen_time(h + 9, m - 9)]\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h) + bin(m)).count('1') == turnedOn:\n                    res.append(gen_time(h, m))\n                    res.extend(gen_times(h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1, 1]]\n        \n        res = [[1], [1, 1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(res[i - 1][j - 1] + res[i - 1][j])\n            row.append(1)\n            res.append(row)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            # Recursively compute the maximum gain if we include this\n            # node in a path.\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            # The price to sell the node is the node's value, plus the\n            # maximum gain from the left or right subtree.\n            new_price = node.val + left_gain + right_gain\n            \n            # For the max_gain, we only keep the maximum\n            self.max_sum = max(self.max_sum, new_price)\n            \n            # For the max_gain, we only keep the maximum\n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        for i in range(n):\n            heapq.heappush(heap, (heightMap[0][i], 0, i))\n            heapq.heappush(heap, (heightMap[m-1][i], m-1, i))\n        \n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            seen.add((i, j))\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                    ans += max(0, h - heightMap[ni][nj])\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # remove non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Calculate the median of the window\n        median = self.calculate_median(window)\n        \n        # Add the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements in the array\n        for i in range(k, len(nums)):\n            # Remove the leftmost element from the window\n            window.pop(0)\n            \n            # Add the new element to the window\n            window.append(nums[i])\n            \n            # Calculate the median of the window\n            median = self.calculate_median(window)\n            \n            # Add the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def calculate_median(self, window):\n        # Sort the window\n        window.sort()\n        \n        # Calculate the median\n        if len(window) % 2 == 0:\n            # If the window is even, return the mean of the two middle elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0\n        else:\n            # If the window is odd, return the middle element\n            return window[len(window) // 2]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for _ in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        while n % 3 == 0:\n            n = n // 3\n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the list of positions by left coordinate\n        positions.sort(key=lambda x: x[0])\n        \n        # 2. create a list of heights\n        heights = [0]\n        \n        # 3. iterate through the list of positions\n        for left, sideLength in positions:\n            # 4. add the height of the current square to the list of heights\n            heights.append(heights[-1] + sideLength)\n            \n            # 5. iterate through the list of heights\n            for i in range(len(heights) - 2, -1, -1):\n                # 6. if the current height is less than the previous height, update the previous height\n                if heights[i] < heights[i + 1]:\n                    heights[i] = heights[i + 1]\n        \n        # 7. return the list of heights\n        return heights"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        \n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                sums = [max(sums[i] - k, 0) for i in range(m)]\n                sums = [0] + sums\n                sums = [sums[i] + (sums[i + 1] if i + 1 < m else 0) for i in range(m + 1)]\n                heap = [(0, 0)]\n                for s in sums:\n                    while heap[0][1] < s:\n                        heapq.heappop(heap)\n                    res = max(res, s + heap[0][0])\n                    heapq.heappush(heap, (heap[0][0] + s, s))\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend > 0 and divisor > 0:\n            return self.divide_helper(dividend, divisor)\n        else:\n            return -self.divide_helper(abs(dividend), abs(divisor))\n        \n    def divide_helper(self, dividend, divisor):\n        if dividend < divisor:\n            return 0\n        \n        if dividend == divisor:\n            return 1\n        \n        if dividend < divisor * 2:\n            return 1 + self.divide_helper(dividend - divisor, divisor)\n        \n        return 1 + self.divide_helper(dividend - divisor * 2, divisor * 2)"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'\n            \n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n            \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O' and (i == 0 or i == m - 1 or j == 0 or j == n - 1):\n                    dfs(i, j)\n                    \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                    \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the indices of the numbers\n        num_dict = {}\n        \n        # iterate through the list of numbers\n        for i, num in enumerate(nums):\n            # calculate the difference between the target and the current number\n            diff = target - num\n            \n            # if the difference is in the dictionary, return the indices\n            if diff in num_dict:\n                return [num_dict[diff], i]\n            \n            # otherwise, add the current number to the dictionary with its index\n            num_dict[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 0.00001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c not in [a, b]]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c not in [a, b]]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c not in [a, b]]\n                            else:\n                                new_cards = [float(a) / b] + [c for c in cards if c not in [a, b]]\n                            if backtrack(new_cards, 24):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if s is empty\n        if not s:\n            return False\n        \n        # if p is not empty, check if s is not empty\n        if p[0] != '*':\n            return s[0] == p[0] and self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, check if s is not empty\n        while s and (s[0] == p[0] or p[0] == '?'):\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, check if s is not empty\n        for i in range(len(s)):\n            if self.isMatch(s[i:], p[1:]):\n                return True\n        \n        # if p is not empty, check if s is not empty\n        return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in sorted(tickets):\n            graph[from_city].append(to_city)\n            \n        # dfs\n        route = []\n        def dfs(from_city):\n            # if there is no connection, append to the route\n            if from_city not in graph:\n                return\n            # if there is no connection, append to the route\n            to_city = graph[from_city].pop()\n            dfs(to_city)\n            route.append(from_city)\n            \n        dfs(\"JFK\")\n        return route[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize result\n        result = [[0, 0]]\n        \n        # iterate over buildings\n        for building in buildings:\n            # get left and right edges\n            left, right, height = building\n            \n            # iterate over result\n            for i, (x, h) in enimport itertools\n            # if current building is on the left edge of the current result\n            if x == result[-1][0]:\n                # if current building is taller than the previous building\n                if h > result[-1][1]:\n                    # update result\n                    result[-1] = [x, h]\n            # if current building is on the right edge of the current result\n            elif x > result[-1][0]:\n                # add new building to result\n                result.append([x, h])\n            # if current building is taller than the previous building\n            elif h > result[-1][1]:\n                # update result\n                result[-1] = [x, h]\n        \n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the reversed string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        \n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num < 10:\n                return ones[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + (\" \" + helper(num % 10))\n            elif num < 1000:\n                return ones[num // 100] + \" Hundred\" + (\" \" + helper(num % 100))\n            elif num < 1000000:\n                return helper(num // 1000) + \" Thousand\" + (\" \" + helper(num % 1000))\n            elif num < 1000000000:\n                return helper(num // 1000000) + \" Million\" + (\" \" + helper(num % 1000000))\n            else:\n                return helper(num // 1000000000) + \" Billion\" + (\" \" + helper(num % 1000000000))\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i-1]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i-1] - dp[i-1][j-i-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i-1] + dp[i-1][j-i-2] - ... - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i-1] + dp[i-1][j-i-2] - ... - dp[i-1][j-i] + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i-1] + dp[i-1][j-i-2] - ... - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i-1] + dp[i-1][j-i-2] - ... - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i] + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i-1] + dp[i-1][j-i-2] - ... - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i-1] + dp[i-1][j-i-2] - ... - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i] + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i] - dp[i-1][j-i-1] + dp[i-1][j-i-2] - ... -"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        \n        # find a cycle\n        visited = set()\n        for u in range(1, len(graph) + 1):\n            if u not in visited:\n                if self.dfs(u, -1, graph, visited):\n                    return [u, self.parent]\n        \n        # find the node with two parents\n        for u, v in edges:\n            if v not in graph[u]:\n                return [u, v]\n\n    def dfs(self, u, parent, graph, visited):\n        visited.add(u)\n        for v in graph[u]:\n            if v not in visited:\n                if self.dfs(v, u, graph, visited):\n                    return True\n            elif v != parent:\n                return True\n        return False"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            for i in range(first, n):\n                if nums[i] not in used:\n                    used.add(nums[i])\n                    nums[first], nums[i] = nums[i], nums[first]\n                    backtrack(first + 1)\n                    nums[first], nums[i] = nums[i], nums[first]\n        n = len(nums)\n        res = []\n        used = set()\n        backtrack()\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR operation\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 1 = 0\n        ## 1 ^ 0 = 1\n        ## 2 ^ 2 = 0\n        ## 2 ^ 1 = 3\n        ## 3 ^ 1 = 2\n        ## 3 ^ 0 = 3\n        ## 4 ^ 4 = 0\n        ## 4 ^ 3 = 7\n        ## 7 ^ 3 = 4\n        ## 7 ^ 2 = 5\n        ## 5 ^ 2 = 7\n        ## 5 ^ 1 = 6\n        ## 6 ^ 1 = 5\n        ## 6 ^ 0 = 6\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 = 8\n        ## 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6 ^ 7 ^ 7 ^ 8 ^ 8 = 0\n        ## 0 ^ 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    res = grid[i][j1] + (j1 != j2) * grid[i][j2]\n                    for dj1, dj2 in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                        nj1, nj2 = j1 + dj1, j2 + dj2\n                        if 0 <= nj1 < n and 0 <= nj2 < n:\n                            res += dp[i - 1][nj1][nj2]\n                        dp[i][j1][j2] = max(dp[i][j1][j2], res)\n        return dp[n - 1][n - 1][n - 1]"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^9 + 7\n        # 2. 10^9 + 7\n        # 3. 10^9 + 7\n        # 4. 10^9 + 7\n        # 5. 10^9 + 7\n        # 6. 10^9 + 7\n        # 7. 10^9 + 7\n        # 8. 10^9 + 7\n        # 9. 10^9 + 7\n        # 10. 10^9 + 7\n        # 11. 10^9 + 7\n        # 12. 10^9 + 7\n        # 13. 10^9 + 7\n        # 14. 10^9 + 7\n        # 15. 10^9 + 7\n        # 16. 10^9 + 7\n        # 17. 10^9 + 7\n        # 18. 10^9 + 7\n        # 19. 10^9 + 7\n        # 20. 10^9 + 7\n        # 21. 10^9 + 7\n        # 22. 10^9 + 7\n        # 23. 10^9 + 7\n        # 24. 10^9 + 7\n        # 25. 10^9 + 7\n        # 26. 10^9 + 7\n        # 27. 10^9 + 7\n        # 28. 10^9 + 7\n        # 29. 10^9 + 7\n        # 30. 10^9 + 7\n        # 31. 10^9 + 7\n        # 32. 10^9 + 7\n        # 33. 10^9 + 7\n        # 34. 10^9 + 7\n        # 35. 10^9 + 7\n        # 36. 10^9 + 7\n        # 37. 10^9 + 7\n        # 38. 10^9 + 7\n        # 39. 10^9 + 7\n        # 40. 10^9 + 7\n        # 41. 10^9 + 7\n        # 42. 10^9 + 7\n        # 43. 10^9 + 7\n        # 44. 10^9 + 7\n        # 45. 10^9 + 7\n        # 46. 10^9 + 7\n        # 47. 10^9 + 7\n        # 48. 10^9 + 7\n        # 49. 10^9 + 7\n        # 50. 10^9 + 7\n        # 51. 10^9 + 7\n        # 52. 10^9 + 7\n        # 53. 10^9 + 7\n        # 54. 10^9 + 7\n        # 55. 10^9 + 7\n        # 56. 10^9 + 7\n        # 57. 10^9 + 7\n        # 58. 10^9 + 7\n        # 59. 10^9 + 7\n        # 60. 10^9 + 7\n        # 61. 10^9 + 7\n        # 62. 10^9 + 7\n        # 63. 10^9 + 7\n        # 64. 10^9 + 7\n        # 65. 10^9 + 7\n        # 66. 10^9 + 7\n        # 67. 10^9 + 7\n        # 68. 10^9 + 7\n        # 69. 10^9 + 7\n        # 70. 10^9 + 7\n        # 71. 10^9 + 7\n        # 72. 10^9 + 7\n        # 73. 10^9 + 7\n        # 74. 10^9"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Initialize the last position to be the length of the array - 1\n        last_pos = len(nums) - 1\n        \n        # Iterate through the array backwards\n        for i in range(last_pos, -1, -1):\n            # If the current position is greater than or equal to the last position, update the last position\n            if i + nums[i] >= last_pos:\n                last_pos = i\n        \n        # If the last position is 0, return True, otherwise return False\n        return last_pos == 0"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j-1]\n                elif j == 0:\n                    grid[i][j] += grid[i-1][j]\n                else:\n                    grid[i][j] += min(grid[i][j-1], grid[i-1][j])\n        \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        prev = self.countAndSay(n - 1)\n        res = ''\n        count = 1\n        for i in range(len(prev) - 1):\n            if prev[i] == prev[i + 1]:\n                count += 1\n            else:\n                res += str(count) + prev[i]\n                count = 1\n        res += str(count) + prev[-1]\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(target):\n            subarrays = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    subarrays += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return subarrays <= k\n        \n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search there\n        if nums[pivot] <= target <= nums[-1]:\n            return self.binary_search(nums, target, 0, pivot)\n        \n        # otherwise, search the second half\n        return self.binary_search(nums, target, pivot + 1, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left\n        \n    def binary_search(self, nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            # base case: no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters using the current digit\n                for letter in digit_to_letters[next_digits[0]]:\n                    # append the current letter to the combination\n                    # and proceed to the next digit\n                    backtrack(combination + letter, next_digits[1:])\n        \n        # start with an empty combination and one digit\n        output = []\n        backtrack(\"\", digits)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the candidates\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current combination\n        current_combination = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the current index\n        current_index = 0\n        \n        # loop through the candidates\n        while current_index < len(candidates):\n            # if the current sum plus the current candidate is less than the target\n            if current_sum + candidates[current_index] < target:\n                # add the current candidate to the current combination\n                current_combination.append(candidates[current_index])\n                # update the current sum\n                current_sum += candidates[current_index]\n                # recursively call the function with the current combination and target\n                self.find_combinations(candidates, target, current_sum, current_combination, result)\n                # remove the last element from the current combination\n                current_combination.pop()\n                # update the current sum\n                current_sum -= candidates[current_index]\n            # if the current sum plus the current candidate is equal to the target\n            elif current_sum + candidates[current_index] == target:\n                # add the current combination to the result\n                result.append(current_combination + [candidates[current_index]])\n            # if the current sum plus the current candidate is greater than the target\n            else:\n                # break the loop\n                break\n            # update the current index\n            current_index += 1\n        \n        # return the result\n        return result\n    \n    def find_combinations(self, candidates, target, current_sum, current_combination, result):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :type current_sum: int\n        :type current_combination: List[int]\n        :type result: List[List[int]]\n        :rtype: None\n        \"\"\"\n        \n        # loop through the candidates\n        for i in range(len(candidates)):\n            # if the current sum plus the current candidate is less than the target\n            if current_sum + candidates[i] < target:\n                # add the current candidate to the current combination\n                current_combination.append(candidates[i])\n                # recursively call the function with the current combination and target\n                self.find_combinations(candidates, target, current_sum + candidates[i], current_combination, result)\n                # remove the last element from the current combination\n                current_combination.pop()"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        # convert n to an integer\n        num = int(n)\n        \n        # convert n to a list of digits\n        digits = list(n)\n        \n        #"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        \n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        # transpose\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(n):\n            matrix[i].reverse()"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum product and the current product\n        max_product = nums[0]\n        curr_product = nums[0]\n        \n        # Iterate through the array\n        for i in range(1, len(nums)):\n            # If the current number is positive, update the current product\n            if nums[i] > 0:\n                curr_product *= nums[i]\n                # Update the maximum product if necessary\n                max_product = max(max_product, curr_product)\n            # If the current number is zero, reset the current product\n            elif nums[i] == 0:\n                curr_product = 1\n            # If the current number is negative, update the current product\n            else:\n                temp = curr_product\n                curr_product = max(nums[i], curr_product * nums[i])\n                max_product = max(max_product, curr_product)\n                curr_product = max(nums[i], temp * nums[i])\n        \n        return max_product"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. build a dict to store the stone position\n        stone_dict = {}\n        for i, stone in enumerate(stones):\n            stone_dict[stone] = i\n        \n        # 2. build a dict to store the jump distance\n        jump_dict = {}\n        \n        # 3. build a queue to store the current stone position\n        queue = collections.deque([0])\n        \n        # 4. build a set to store the current stone position\n        visited = set()\n        \n        # 5. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 6. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 7. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 8. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 9. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 10. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 11. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 12. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 13. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 14. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 15. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 16. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 17. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 18. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 19. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 20. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 21. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 22. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 23. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 24. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 25. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 26. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 27. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 28. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 29. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 30. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 31. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 32. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 33. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 34. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 35. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 36. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 37. build a set to store the current jump distance\n        visited_jump = set()\n        \n        # 38. build a set to store the current jump distance\n        visited"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array\n        sorted_score = sorted(score, reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, score in enumerate(sorted_score):\n            rank_dict[score] = i + 1\n        \n        # create a list to store the result\n        result = []\n        for score in score:\n            result.append(rank_dict[score])\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, score in enumerate(sorted_score):\n            rank_dict[score] = i + 1\n        \n        # create a list to store the result\n        result = []\n        for score in score:\n            result.append(rank_dict[score])\n        \n        return result"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the maximum length of the substring to 0\n        max_length = 0\n        \n        # Initialize the start and end indices of the substring\n        start = 0\n        end = 0\n        \n        # Initialize a dictionary to store the characters and their indices\n        char_indices = {}\n        \n        # Iterate over the characters in the string\n        for i, char in enumerate(s):\n            # If the character is already in the dictionary, update the start index\n            if char in char_indices:\n                start = max(start, char_indices[char] + 1)\n            # Update the maximum length of the substring\n            max_length = max(max_length, i - start + 1)\n            # Update the character index in the dictionary\n            char_indices[char] = i\n        \n        # Return the maximum length of the substring\n        return max_length"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            word_dict_copy = word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                    if not word_dict_copy:\n                        res.append(left)\n                else:\n                    left = j + 1\n                    word_dict_copy = word_dict.copy()\n                    if word in word_dict_copy:\n                        word_dict_copy[word] -= 1\n                        if word_dict_copy[word] == 0:\n                            del word_dict_copy[word]\n                        if not word_dict_copy:\n                            res.append(left)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        arr.sort()\n        \n        # count the number of chunks\n        chunks = 0\n        for i in range(len(arr)):\n            if arr[i] == i:\n                chunks += 1\n        \n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n            \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        \n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        paths = []\n        dfs(root, '')\n        return paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i = left\n            j = mid + 1\n            while i <= mid:\n                while j <= right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n                i += 1\n            nums[left:right + 1] = sorted(nums[left:right + 1])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if i < len(v2):\n                    if v1[i] < v2[i]:\n                        return -1\n                    elif v1[i] > v2[i]:\n                        return 1\n                else:\n                    return 1\n            else:\n                if i < len(v2):\n                    return -1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. Greedy\n        ## 4. Monotonic stack\n        ## 5. Two pointers\n        ## 6. Binary search\n        ## 7. Binary search\n        ## 8. Binary search\n        ## 9. Binary search\n        ## 10. Binary search\n        ## 11. Binary search\n        ## 12. Binary search\n        ## 13. Binary search\n        ## 14. Binary search\n        ## 15. Binary search\n        ## 16. Binary search\n        ## 17. Binary search\n        ## 18. Binary search\n        ## 19. Binary search\n        ## 20. Binary search\n        ## 21. Binary search\n        ## 22. Binary search\n        ## 23. Binary search\n        ## 24. Binary search\n        ## 25. Binary search\n        ## 26. Binary search\n        ## 27. Binary search\n        ## 28. Binary search\n        ## 29. Binary search\n        ## 30. Binary search\n        ## 31. Binary search\n        ## 32. Binary search\n        ## 33. Binary search\n        ## 34. Binary search\n        ## 35. Binary search\n        ## 36. Binary search\n        ## 37. Binary search\n        ## 38. Binary search\n        ## 39. Binary search\n        ## 40. Binary search\n        ## 41. Binary search\n        ## 42. Binary search\n        ## 43. Binary search\n        ## 44. Binary search\n        ## 45. Binary search\n        ## 46. Binary search\n        ## 47. Binary search\n        ## 48. Binary search\n        ## 49. Binary search\n        ## 50. Binary search\n        ## 51. Binary search\n        ## 52. Binary search\n        ## 53. Binary search\n        ## 54. Binary search\n        ## 55. Binary search\n        ## 56. Binary search\n        ## 57. Binary search\n        ## 58. Binary search\n        ## 59. Binary search\n        ## 60. Binary search\n        ## 61. Binary search\n        ## 62. Binary search\n        ## 63. Binary search\n        ## 64. Binary search\n        ## 65. Binary search\n        ## 66. Binary search\n        ## 67. Binary search\n        ## 68. Binary search\n        ## 69. Binary search\n        ## 70. Binary search\n        ## 71. Binary search\n        ## 72. Binary search\n        ## 73. Binary search\n        ## 74. Binary search\n        ## 75. Binary search\n        ## 76. Binary search\n        ## 77. Binary search\n        ## 78. Binary search\n        ## 79. Binary search\n        ## 80. Binary search\n        ## 81. Binary search\n        ## 82. Binary search\n        ## 83. Binary search\n        ## 84. Binary search\n        ## 85. Binary search\n        ## 86. Binary search\n        ## 87. Binary search\n        ## 88. Binary search\n        ## 89. Binary search\n        ## 90. Binary search\n        ## 91. Binary search\n        ## 92. Binary search\n        ## 93. Binary search\n        ## 94. Binary search"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for duration, end in courses:\n            # add course to priority queue\n            heapq.heappush(pq, (-duration, end))\n            \n            # update total time\n            total += duration\n            \n            # if total time exceeds end date, remove course with longest duration\n            if total > end:\n                total += heapq.heappop(pq)[0]\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while True:\n            kth = self.getKth(prev, k)\n            if not kth:\n                break\n            # reverse the nodes in the range\n            prev.next = self.reverse(prev.next, kth.next)\n            # move the anchor\n            prev = kth\n        \n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = tail\n        while head != tail:\n            next = head.next\n            head.next = prev\n            prev = head\n            head = next\n        return prev\n    \n    def getKth(self, head, k):\n        while head and k > 0:\n            head = head.next\n            k -= 1\n        return head"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % len(s[0]) != 0:\n        #     return False\n        \n        # for i in range(len(s) // len(s[0])):\n        #     if s[i * len(s[0]):] == s[:len(s[0])]:\n        #         return True\n        # return False\n        \n        return s in (s * 2)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3) + dp[i-5] * 2 * (2*i - 9) / (i-4)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3) + dp[i-5] * 2 * (2*i - 9) / (i-4) + dp[i-6] * 2 * (2*i - 11) / (i-5)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3) + dp[i-5] * 2 * (2*i - 9) / (i-4) + dp[i-6] * 2 * (2*i - 11) / (i-5) + dp[i-7] * 2 * (2*i - 13) / (i-6)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) / (i-1) + dp[i-3] * 2 * (2*i - 5) / (i-2) + dp[i-4] * 2 * (2*i - 7) / (i-3) + dp[i-5] * 2 * (2*i - 9) / (i-4) + dp[i-6] * 2 * (2*i - 11) / (i-5) + dp[i-7] * 2 * (2*i - 13) / (i-6) + dp[i-8] * 2 * (2*i - 15) / (i-7)\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 * (2*i - 3) /"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR all the numbers in the list\n        ## Then, XOR the result with the result of the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0\n        ## So, if we XOR all the numbers in the list, we will get the XOR of all the numbers\n        ## Then, we XOR the XOR of all the numbers with the first number in the list\n        ## The result will be the single number\n        ## This is because the XOR of a number with itself is 0"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the dp array with a large value\n        dp = [float('inf')] * (1 << len(target))\n        dp[0] = 0\n        \n        # 2. Iterate over the stickers\n        for sticker in stickers:\n            # 3. Initialize the mask\n            mask = 0\n            # 4. Iterate over the characters in the sticker\n            for c in sticker:\n                # 5. Get the index of the character in the mask\n                index = ord(c) - ord('a')\n                # 6. Set the bit in the mask\n                mask |= 1 << index\n            # 7. Iterate over the values in the dp array\n            for i in range(len(dp)):\n                # 8. If the bit is already set in the mask, skip it\n                if i & mask:\n                    continue\n                # 9. Get the number of missing characters in the mask\n                missing = mask ^ i\n                # 10. Get the number of characters in the target that are not in the mask\n                extra = sum(missing & (1 << ord(c) - ord('a')) for c in target if c not in missing)\n                # 11. Update the dp array with the minimum number of stickers needed\n                dp[i | mask] = min(dp[i | mask], dp[i] + extra)\n        \n        # 12. Return the number of stickers needed to spell out the target, or -1 if it is impossible\n        return dp[len(dp) - 1] if dp[len(dp) - 1] != float('inf') else -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1] + 1, dp[j][j])\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        result = 0\n        \n        for i in range(len(s)):\n            if i + 1 < len(s) and roman_dict[s[i]] < roman_dict[s[i + 1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        \n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        q = collections.deque()\n        output = []\n        \n        for i, n in en.umerate(nums):\n            while q and q[0] < i - k + 1:\n                q.popleft()\n            while q and nums[q[-1]] < n:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                output.append(nums[q[0]])\n        return output"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge nums1 and nums2 into a single sorted list\n        nums = nums1 + nums2\n        nums.sort()\n        \n        # find the median\n        if len(nums) % 2 == 1:\n            return nums[len(nums) // 2]\n        else:\n            return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2.0"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        # if the pivot point is not found, return the first element\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found,"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 <= area <= 10^9\n        # 2. area is a perfect square\n        # 3. area is a perfect square\n        # 4. area is a perfect square\n        # 5. area is a perfect square\n        # 6. area is a perfect square\n        # 7. area is a perfect square\n        # 8. area is a perfect square\n        # 9. area is a perfect square\n        # 10. area is a perfect square\n        # 11. area is a perfect square\n        # 12. area is a perfect square\n        # 13. area is a perfect square\n        # 14. area is a perfect square\n        # 15. area is a perfect square\n        # 16. area is a perfect square\n        # 17. area is a perfect square\n        # 18. area is a perfect square\n        # 19. area is a perfect square\n        # 20. area is a perfect square\n        # 21. area is a perfect square\n        # 22. area is a perfect square\n        # 23. area is a perfect square\n        # 24. area is a perfect square\n        # 25. area is a perfect square\n        # 26. area is a perfect square\n        # 27. area is a perfect square\n        # 28. area is a perfect square\n        # 29. area is a perfect square\n        # 30. area is a perfect square\n        # 31. area is a perfect square\n        # 32. area is a perfect square\n        # 33. area is a perfect square\n        # 34. area is a perfect square\n        # 35. area is a perfect square\n        # 36. area is a perfect square\n        # 37. area is a perfect square\n        # 38. area is a perfect square\n        # 39. area is a perfect square\n        # 40. area is a perfect square\n        # 41. area is a perfect square\n        # 42. area is a perfect square\n        # 43. area is a perfect square\n        # 44. area is a perfect square\n        # 45. area is a perfect square\n        # 46. area is a perfect square\n        # 47. area is a perfect square\n        # 48. area is a perfect square\n        # 49. area is a perfect square\n        # 50. area is a perfect square\n        # 51. area is a perfect square\n        # 52. area is a perfect square\n        # 53. area is a perfect square\n        # 54. area is a perfect square\n        # 55. area is a perfect square\n        # 56. area is a perfect square\n        # 57. area is a perfect square\n        # 58. area is a perfect square\n        # 59. area is a perfect square\n        # 60. area is a perfect square\n        # 61. area is a perfect square\n        # 62. area is a perfect square\n        # 63. area is a perfect square\n        # 64. area is a perfect square\n        # 65. area is a perfect square\n        # 66. area is a perfect square\n        # 67. area is a perfect square\n        # 68. area is a perfect square\n        # 69. area is a perfect square\n        # 70. area is a perfect square\n        # 71. area is a perfect square\n        # 72. area is a perfect square\n        # 73. area is a perfect square\n        # 74. area is a perfect square\n        # 75. area is a perfect square\n        # 76. area is a perfect square\n        # 77. area is a perfect square\n        # 78. area is a perfect square\n        # 79. area is a perfect square\n        # 80. area is a perfect square\n        # 81. area is a perfect square\n        # 82. area is a perfect square\n        # 83. area is a perfect square\n        # 84. area is a perfect square\n        # 85. area is a perfect square\n        # 86. area is a"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build queue and visited\n        queue = collections.deque([beginWord])\n        visited = {beginWord}\n        \n        # build result\n        result = []\n        found = False\n        \n        while queue:\n            # get current level\n            level = []\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    found = True\n                for i in range(len(word)):\n                    for j in range(26):\n                        neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                        for nbr in graph[neighbor]:\n                            if nbr not in visited:\n                                visited.add(nbr)\n                                queue.append(nbr)\n                                level.append(nbr)\n            if found:\n                break\n            result.append(level)\n        \n        # build result\n        result = []\n        if found:\n            for word in result[-1]:\n                result.append([beginWord, word])\n            for i in range(len(result)-1, 0, -1):\n                for nbr in graph[result[i][0]]:\n                    if nbr in result[i-1]:\n                        result.insert(0, [result[i-1][0], nbr])\n                        break\n        return result"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\uc0c9\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \ud0d0\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        \n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                val2 = stack.pop()\n                val1 = stack.pop()\n                if token == \"+\":\n                    stack.append(val1 + val2)\n                elif token == \"-\":\n                    stack.append(val1 - val2)\n                elif token == \"*\":\n                    stack.append(val1 * val2)\n                else:\n                    stack.append(int(float(val1) / val2))\n        \n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min = float('inf'), float('inf')\n        x_max, y_max = float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        seen = set()\n        \n        for x1, y1, x2, y2 in rectangles:\n            for x, y in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:\n                if (x, y) in seen:\n                    seen.remove((x, y))\n                else:\n                    seen.add((x, y))\n        \n        return len(seen) == 4"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        \n        # 1. convert to base 26\n        # 2"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = num\n            else:\n                curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_flat = [num for row in board for num in row]\n        \n        # convert board_flat to a string\n        board_str = ''.join(str(num) for num in board_flat)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list\n        board_list = list(board_tuple)\n        \n        # convert board_list to a string\n        board_str = ''.join(board_list)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a list"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in the first half\n        if nums[pivot] == target:\n            return True\n        \n        # if the target is in the second half of the array, search in the second half\n        if nums[len(nums) - 1] == target:\n            return True\n        \n        # if the target is not in the first half of the array, search in the second half\n        if nums[pivot] < target:\n            return self.search(nums[pivot:], target)\n        \n        # if the target is not in the second half of the array, search in the first half\n        return self.search(nums[:pivot], target)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[m - 1][n - 1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums) - 2):\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n                \n        prev = None\n        min_diff = float('inf')\n        for n in inorder(root):\n            if prev:\n                min_diff = min(min_diff, n - prev)\n            prev = n\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        return sorted(Counter(dfs(root)).most_common(1)[0][0] if Counter(dfs(root)).most_common(1)[0][1] > 1 else [Counter(dfs(root)).most_common(1)[0][0]]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        # 5. return the number of steps\n        \n        # 1. check if password is strong\n        if len(password) < 6:\n            return max(6 - len(password), 0)\n        if len(password) > 20:\n            return max(20 - len(password), 0)\n        \n        # 2. find the first three repeating characters\n        repeating_chars = []\n        for i in range(2, len(password)):\n            if password[i] == password[i - 1] == password[i - 2]:\n                repeating_chars.append(password[i])\n        \n        # 3. replace the first three repeating characters with a character\n        if repeating_chars:\n            for char in repeating_chars:\n                password = password.replace(char, char[0], 1)\n        \n        # 4. repeat the above steps until password is strong\n        steps = max(len(password) - 20, 0)\n        for i in range(len(password) - 20):\n            if password[i] == password[i + 1] == password[i + 2]:\n                password = password[:i + 1] + password[i + 3:]\n                steps += 1\n        \n        # 5. return the number of steps\n        return steps"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max height\n        max_height = max(height)\n        \n        # 2. find the index of max height\n        max_height_index = height.index(max_height)\n        \n        # 3. find the left and right max height\n        left_max_height = max(height[:max_height_index])\n        right_max_height = max(height[max_height_index:])\n        \n        # 4. find the water\n        water = 0\n        for i in range(max_height_index):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        for i in range(len(height) - 1, max_height_index, -1):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        return water"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. return the result\n        \n        # 1. sort the array\n        sorted_nums = sorted(enumerate(nums), key=lambda x: x[1])\n        \n        # 2. for each element, find the number of smaller elements to the right\n        # 3. return the result\n        result = [0] * len(nums)\n        for i in range(len(nums) - 1, -1, -1):\n            num = sorted_nums[i][1]\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if sorted_nums[mid][0] <= num:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            result[i] = left\n        \n        return result"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        \n        # initialize result\n        res = 0\n        \n        # initialize end with the first end\n        end = intervals[0][1]\n        \n        # iterate over intervals\n        for interval in intervals:\n            # if end is less than the start of the current interval\n            if end < interval[0]:\n                # increment result\n                res += 1\n                # set end to the end of the current interval\n                end = interval[1]\n            # if end is greater than the end of the current interval\n            elif end > interval[1]:\n                # set end to the end of the current interval\n                end = interval[1]\n            # if end is equal to the end of the current interval\n            else:\n                # increment result\n                res += 1\n                # set end to the end of the current interval\n                end = interval[1]\n        \n        # return result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return (left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left))\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. build a dict to store the count of each atom\n        # 2. build a stack to store the count of each atom\n        # 3. build a stack to store the name of each atom\n        # 4. build a stack to store the parentheses\n        # 5. build a stack to store the parentheses\n        # 6. build a stack to store the parentheses\n        # 7. build a stack to store the parentheses\n        # 8. build a stack to store the parentheses\n        # 9. build a stack to store the parentheses\n        # 10. build a stack to store the parentheses\n        # 11. build a stack to store the parentheses\n        # 12. build a stack to store the parentheses\n        # 13. build a stack to store the parentheses\n        # 14. build a stack to store the parentheses\n        # 15. build a stack to store the parentheses\n        # 16. build a stack to store the parentheses\n        # 17. build a stack to store the parentheses\n        # 18. build a stack to store the parentheses\n        # 19. build a stack to store the parentheses\n        # 20. build a stack to store the parentheses\n        # 21. build a stack to store the parentheses\n        # 22. build a stack to store the parentheses\n        # 23. build a stack to store the parentheses\n        # 24. build a stack to store the parentheses\n        # 25. build a stack to store the parentheses\n        # 26. build a stack to store the parentheses\n        # 27. build a stack to store the parentheses\n        # 28. build a stack to store the parentheses\n        # 29. build a stack to store the parentheses\n        # 30. build a stack to store the parentheses\n        # 31. build a stack to store the parentheses\n        # 32. build a stack to store the parentheses\n        # 33. build a stack to store the parentheses\n        # 34. build a stack to store the parentheses\n        # 35. build a stack to store the parentheses\n        # 36. build a stack to store the parentheses\n        # 37. build a stack to store the parentheses\n        # 38. build a stack to store the parentheses\n        # 39. build a stack to store the parentheses\n        # 40. build a stack to store the parentheses\n        # 41. build a stack to store the parentheses\n        # 42. build a stack to store the parentheses\n        # 43. build a stack to store the parentheses\n        # 44. build a stack to store the parentheses\n        # 45. build a stack to store the parentheses\n        # 46. build a stack to store the parentheses\n        # 47. build a stack to store the parentheses\n        # 48. build a stack to store the parentheses\n        # 49. build a stack to store the parentheses\n        # 50. build a stack to store the parentheses\n        # 51. build a stack to store the parentheses\n        # 52. build a stack to store the parentheses\n        # 53. build a stack to store the parentheses\n        # 54. build a stack to store the parentheses\n        # 55. build a stack to store the parentheses\n        # 56. build a stack to store the parentheses\n        # 57. build a stack to store the parentheses\n        # 58. build a stack to store the parentheses\n        # 59. build a stack to store the parentheses\n        # 60. build a stack to store the parentheses\n        # 61. build a stack to store the parentheses\n        # 62. build a stack to store the parentheses\n        # 63. build a stack to store the parentheses\n        # 64. build a stack to store the parentheses\n        # 65."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        \n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - i - 1):\n                    res.append('({}){}'.format(left, right))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the number of patches required and the current sum\n        patches = 0\n        curr_sum = 0\n        \n        # Iterate over the numbers in the array\n        for num in nums:\n            # If the current sum is less than the target, add it to the current sum\n            while curr_sum < n and num <= curr_sum + n:\n                curr_sum += num\n                # Add the current number to the sum\n                curr_sum += num\n                # Increment the number of patches\n                patches += 1\n            # If the current sum is greater than the target, add a patch\n            if curr_sum > n:\n                break\n            # If the current sum is less than the target, add the current number to the sum\n            curr_sum += num\n        \n        # Return the number of patches required\n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 0\uc744 \ubc18\ud658\n        \n        stack = []\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                    if not stack:\n                        max_len = max(max_len, i + 1)\n                    else:\n                        max_len = max(max_len, i - stack[-1])\n                else:\n                    stack.append(i)\n        \n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return '0'\n        \n        res = ''\n        if (numerator < 0) ^ (denominator < 0):\n            res += '-'\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        res += str(numerator // denominator)\n        \n        numerator %= denominator\n        if numerator == 0:\n            return res\n        \n        res += '.'\n        seen = {numerator: len(res)}\n        while numerator:\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n            if numerator in seen:\n                idx = seen[numerator]\n                res = res[:idx] + '(' + res[idx:] + ')'\n                break\n            seen[numerator] = len(res)\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Use dynamic programming to find the longest increasing subsequence\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O("}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n + 1):\n            fast = fast.next\n        \n        # move both the slow and fast pointers until fast reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the nth position\n        slow.next = slow.next.next\n        \n        # return the modified linked list\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        \n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        \n        avg = total // n\n        curr = 0\n        ans = 0\n        for m in machines:\n            curr += m - avg\n            ans = max(ans, abs(curr))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.next.val)\n        root.right = self.sortedListToBST(slow.next.next)\n        slow.next = None\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        stack = [-1]\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n                max_area = max(max_area, heights[stack.pop()] * (i - stack[-1] - 1))\n            stack.append(i)\n        \n        while stack[-1] != -1:\n            max_area = max(max_area, heights[stack.pop()] * (len(heights) - stack[-1] - 1))\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n                return\n            for i in range(first, n):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            subset = []\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 2. I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C\n        # 3. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 4. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 5. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 6. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 7. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 8. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 9. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 10. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 11. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 12. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 13. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 14. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 15. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 16. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 17. 1000, 900, 500, 400, 100, 90"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 1. XOR all the characters in s and t\n        ## 2. XOR the result with 0\n        ## 3. Return the result\n        \n        result = 0\n        for c in s:\n            result ^= ord(c)\n        for c in t:\n            result ^= ord(c)\n        return chr(result)"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board, l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board, row, num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board, col, num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board, box_start_row, box_start_col, num):\n            for row in range(3):\n                for col in range(3):\n                    if board[row+box_start_row][col+box_start_col] == num:\n                        return True\n            return False\n        \n        def is_valid(board, row, col, num):\n            return not used_in_row(board, row, num) and not used_in_col(board, col, num) and not used_in_box(board, row - row % 3, col - col % 3, num)\n        \n        def solve_sudoku(board):\n            l = [0, 0]\n            if not find_empty_location(board, l):\n                return True\n            \n            row = l[0]\n            col = l[1]\n            \n            for num in range(1, 10):\n                if is_valid(board, row, col, num):\n                    board[row][col] = str(num)\n                    \n                    if solve_sudoku(board):\n                        return True\n                    \n                    board[row][col] = '.'\n            \n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        first_node = None\n        second_node = None\n        prev_node = None\n        \n        def inorder(node):\n            nonlocal first_node, second_node, prev_node\n            \n            if node:\n                inorder(node.left)\n                \n                if prev_node and prev_node.val > node.val:\n                    if first_node is None:\n                        first_node = prev_node\n                    second_node = node\n                \n                prev_node = node\n                \n                inorder(node.right)\n        \n        inorder(root)\n        \n        # swap the values of the two nodes\n        first_node.val, second_node.val = second_node.val, first_node.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        first_node = None\n        second_node = None\n        prev_node = None\n        \n        def inorder(node):\n            nonlocal first_node, second_node, prev_node\n            \n            if node:\n                inorder(node.left)\n                \n                if prev_node and prev_node.val > node.val:\n                    if first_node is None:\n                        first_node = prev_node\n                    second_node = node\n                \n                prev_node = node\n                \n                inorder(node.right)\n        \n        inorder(root)\n        \n        # swap the values of the two nodes\n        first_node.val, second_node.val = second_node.val, first_node.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        first_node = None\n        second_node = None\n        prev_node = None\n        \n        def inorder(node):\n            nonlocal first_node, second_node, prev_node\n            \n            if node:\n                inorder(node.left)\n                \n                if prev_node and prev_node.val > node.val:\n                    if first_node is None:\n                        first_node = prev_node\n                    second_node = node\n                \n                prev_node = node\n                \n                inorder(node.right)\n        \n        inorder(root)\n        \n        # swap the values of the two nodes\n        first_node.val, second_node.val = second_node.val, first_node.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        first_node = None\n        second_node = None\n        prev_node = None\n        \n        def inorder(node):\n            nonlocal first_node, second_node, prev_node\n            \n            if node:\n                inorder(node.left)\n                \n                if prev_node and prev_node.val > node.val:\n                    if first_node is None:\n                        first_node = prev_node\n                    second_node = node\n                \n                prev_node = node\n                \n                in"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if head.val != prev.val:\n                return False\n            head = head.next\n            prev = prev.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Initialize left and right pointers\n        left, right = 0, num\n        \n        # 2. Iterate while left pointer is less than or equal to right pointer\n        while left <= right:\n            # 3. Calculate the middle pointer\n            mid = (left + right) // 2\n            \n            # 4. If the middle pointer is the square of the number, return True\n            if mid ** 2 == num:\n                return True\n            \n            # 5. If the middle pointer is less than the number, set the left pointer to the middle pointer + 1\n            elif mid ** 2 < num:\n                left = mid + 1\n            \n            # 6. If the middle pointer is greater than the number, set the right pointer to the middle pointer - 1\n            else:\n                right = mid - 1\n        \n        # 7. If the loop completes without finding the square, return False\n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i & (i - 1)] + 1\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node):\n            if not node:\n                return\n            if node.word in words:\n                res.append(node.word)\n                words.remove(node.word)\n            if i > 0 and board[i - 1][j] in node.children:\n                dfs(i - 1, j, node.children[board[i - 1][j]])\n            if i < len(board) - 1 and board[i + 1][j] in node.children:\n                dfs(i + 1, j, node.children[board[i + 1][j]])\n            if j > 0 and board[i][j - 1] in node.children:\n                dfs(i, j - 1, node.children[board[i][j - 1]])\n            if j < len(board[0]) - 1 and board[i][j + 1] in node.children:\n                dfs(i, j + 1, node.children[board[i][j + 1]])\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['word'] = word\n        \n        res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] in trie:\n                    dfs(i, j, trie[board[i][j]])\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 squares\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(square)) != len(square):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a single string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. iterate through the list\n        # 4. convert each character to a number\n        # 5. add the number to the total\n        # 6. return the total\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle)):\n            \n            # 4. convert each character to a number\n            columnTitle[i] = ord(columnTitle[i]) - 64\n            \n            # 5. add the number to the total\n            total += columnTitle[i] * (26 ** i)\n            \n        # 6. return the total\n        return total"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, first.next, second = second, first.next, second.next\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is not equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for letter, word in zip(pattern, words):\n            # check if the letter is already in the mapping\n            if letter in mapping:\n                # check if the word is already mapped to the letter\n                if mapping[letter] != word:\n                    return False\n            else:\n                # add the letter to the mapping\n                mapping[letter] = word\n        \n        # return True if the mapping is complete\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            n = nums[i]\n            rem_nums = nums[:i] + nums[i+1:]\n            for p in self.permute(rem_nums):\n                res.append([n] + p)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m * n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid // n][mid % n] == target:\n                return True\n            elif matrix[mid // n][mid % n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a new ListNode with value 0\n        dummy = ListNode(0)\n        # Initialize a pointer to the current node\n        curr = dummy\n        # Initialize a variable to store the carry\n        carry = 0\n        \n        # Loop until both lists are empty\n        while l1 or l2 or carry:\n            # Calculate the value of the current node\n            val = carry\n            # If the first list is not empty, add its value to the current node\n            if l1:\n                val += l1.val\n            # If the second list is not empty, add its value to the current node\n            if l2:\n                val += l2.val\n            # Update the carry\n            carry = val // 10\n            # Update the value of the current node\n            curr.next = ListNode(val % 10)\n            # Move to the next node\n            curr = curr.next\n            # Move to the next node in the first list\n            if l1:\n                l1 = l1.next\n            # Move to the next node in the second list\n            if l2:\n                l2 = l2.next\n        \n        # Return the head of the new list\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip bits\n        flipped = ''\n        for bit in binary:\n            if bit == '0':\n                flipped += '1'\n            else:\n                flipped += '0'\n        \n        # convert to decimal\n        return int(flipped, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n        \n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the current line\n        current_line = []\n        \n        # Initialize the current line length\n        current_line_length = 0\n        \n        # Iterate over the words\n        for word in words:\n            # If the current line length plus the length of the current word plus 1 is less than or equal to the max width\n            if current_line_length + len(word) + 1 <= maxWidth:\n                # Add the word to the current line\n                current_line.append(word)\n                \n                # Update the current line length\n                current_line_length += len(word) + 1\n            else:\n                # If the current line is not empty\n                if current_line:\n                    # If the current line has only one word\n                    if len(current_line) == 1:\n                        # Pad the current line with spaces to the max width\n                        current_line = current_line[0] + ' ' * (maxWidth - len(current_line[0]))\n                    else:\n                        # Calculate the number of spaces to add\n                        num_spaces = maxWidth - current_line_length\n                        \n                        # Calculate the number of spaces to distribute\n                        num_spaces_per_word = num_spaces // (len(current_line) - 1)\n                        \n                        # Calculate the number of extra spaces to distribute\n                        extra_spaces = num_spaces % (len(current_line) - 1)\n                        \n                        # Initialize the current line\n                        current_line = []\n                        \n                        # Add the word to the current line\n                        current_line.append(word)\n                        \n                        # Update the current line length\n                        current_line_length = len(word) + 1\n                        \n                        # Iterate over the words in the current line\n                        for i in range(len(current_line) - 1):\n                            # Pad the current line with spaces to the number of spaces to distribute\n                            current_line[i] += ' ' * num_spaces_per_word\n                            \n                            # If there are extra spaces to distribute\n                            if extra_spaces > 0:\n                                # Pad the current line with spaces to the extra spaces\n                                current_line[i] += ' '\n                                \n                                # Decrement the extra spaces\n                                extra_spaces -= 1\n                                \n                    # Append the current line to the result list\n                    result.append(' '.join(current_line))\n                    \n        # If the current line is not empty\n        if current_line:\n            # If the current line has only one word\n            if len(current_line) == 1:\n                # Pad the current line with spaces to the max width\n                current_line = current_line[0] + ' ' * (maxWidth - len(current_line[0]))\n            else:\n                # Calculate the number of spaces to add\n                num_spaces = maxWidth - current_line_length\n                \n                # Calculate the number of spaces to distribute\n                num_spaces_per_word = num_spaces // (len(current_line) - 1)\n                \n                # Calculate the number of extra spaces to distribute\n                extra_spaces = num_spaces % (len(current_line) - 1)\n                \n                # Initialize the current line\n                current_line = []\n                \n                # Add the word to the current line\n                current_line.append(word)\n                \n                # Update the current line length\n                current_line_length = len(word) + 1\n                \n                # Iterate over the words in the current line\n                for i in range(len(current_line) - 1):\n                    # Pad the current line with spaces to the number of spaces to distribute\n                    current_line[i] += ' ' * num_spaces_per_word\n                    \n                    # If there are extra spaces to distribute\n                    if extra_spaces > 0:\n                        # Pad the current line with spaces to the extra spaces\n                        current_line[i] += ' '\n                        \n                        # Decrement the extra spaces\n                        extra_spaces -= 1\n                        \n                # Append the current line to the result list\n                result.append(' '.join(current_line))\n                \n        # Return the result list\n        return result"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in word_dict and suffix in word_dict:\n                    return True\n                if prefix in word_dict and is_concatenated(suffix, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row - col not in diag1 and row + col not in diag2:\n                    count += backtrack(row + 1, cols | {col}, diag1 | {row - col}, diag2 | {row + col})\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = any([dfs(i + 1, j, k + 1) for i in range(len(board)) for j in range(len(board[0]))])\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # iterate through nums1 and nums2\n        # if nums1[i] > nums2[j]\n        #   swap nums1[i] and nums2[j]\n        #   i += 1\n        #   j += 1\n        #   if i == m\n        #     nums1[i] = nums2[j]\n        #     i += 1\n        #     j += 1\n        #   if j == n\n        #     nums1[i] = nums2[j]\n        #     i += 1\n        #     j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #   i += 1\n        # if nums1[i] > nums2[j]\n        #   j += 1\n        # if nums1[i] < nums2[j]\n        #"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        nums.sort()\n        \n        # 2. check if the list has 3 elements\n        if len(nums) < 3:\n            return nums[-1]\n        \n        # 3. check if the third element is the largest\n        if nums[-1] == nums[-2]:\n            return nums[-3]\n        \n        # 4. return the third element\n        return nums[-3]"}]}