{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        #edge case\n        if len(matrix) == 0:\n            return []\n        \n        #edge case\n        if len(matrix[0]) == 0:\n            return []\n        \n        #edge case\n        if len(matrix) == 1 and len(matrix[0]) == 1:\n            return matrix[0]\n        \n        #edge case\n        if len(matrix) == 2 and len(matrix[0]) == 2:\n            return matrix[0] + matrix[1]\n        \n        #edge case\n        if len(matrix) == 3 and len(matrix[0]) == 3:\n            return matrix[0] + matrix[1] + matrix[2]\n        \n        #edge case\n        if len(matrix) == 4 and len(matrix[0]) == 4:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3]\n        \n        #edge case\n        if len(matrix) == 5 and len(matrix[0]) == 5:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4]\n        \n        #edge case\n        if len(matrix) == 6 and len(matrix[0]) == 6:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5]\n        \n        #edge case\n        if len(matrix) == 7 and len(matrix[0]) == 7:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5] + matrix[6]\n        \n        #edge case\n        if len(matrix) == 8 and len(matrix[0]) == 8:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5] + matrix[6] + matrix[7]\n        \n        #edge case\n        if len(matrix) == 9 and len(matrix[0]) == 9:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5] + matrix[6] + matrix[7] + matrix[8]\n        \n        #edge case\n        if len(matrix) == 10 and len(matrix[0]) == 10:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5] + matrix[6] + matrix[7] + matrix[8] + matrix[9]\n        \n        #edge case\n        if len(matrix) == 11 and len(matrix[0]) == 11:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5] + matrix[6] + matrix[7] + matrix[8] + matrix[9] + matrix[10]\n        \n        #edge case\n        if len(matrix) == 12 and len(matrix[0]) == 12:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5] + matrix[6] + matrix[7] + matrix[8] + matrix[9] + matrix[10] + matrix[11]\n        \n        #edge case\n        if len(matrix) == 13 and len(matrix[0]) == 13:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5] + matrix[6] + matrix[7] + matrix[8] + matrix[9] + matrix[10] + matrix[11] + matrix[12]\n        \n        #edge case\n        if len(matrix) == 14 and len(matrix[0]) == 14:\n            return matrix[0] + matrix[1] + matrix[2] + matrix[3] + matrix[4] + matrix[5] + matrix[6] + matrix[7] + matrix[8] + matrix[9] + matrix[10] + matrix[11] + matrix[12] + matrix[13]\n        \n        #edge case\n        if len(matrix) == 15 and len(matrix[0]) == 15:\n            return matrix[0] + matrix[1] + matrix[2] +"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        # if len(nums) == 2:\n        #     if nums[0] == nums[1] - 1:\n        #         return [str(nums[0]) + \"->\" + str(nums[1])]\n        #     else:\n        #         return [str(nums[0])]\n        \n        # if len(nums) == 3:\n        #     if nums[0] == nums[1] - 1:\n        #         if nums[2] == nums[1] + 1:\n        #             return [str(nums[0]) + \"->\" + str(nums[2])]\n        #         else:\n        #             return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2])]\n        #     else:\n        #         if nums[2] == nums[1] + 1:\n        #             return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2])]\n        #         else:\n        #             return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2])]\n        \n        # if len(nums) == 4:\n        #     if nums[0] == nums[1] - 1:\n        #         if nums[2] == nums[3] - 1:\n        #             return [str(nums[0]) + \"->\" + str(nums[3])]\n        #         else:\n        #             return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2]) + \"->\" + str(nums[3])]\n        #     else:\n        #         if nums[2] == nums[3] - 1:\n        #             return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2]) + \"->\" + str(nums[3])]\n        #         else:\n        #             return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2]) + \"->\" + str(nums[3])]\n        \n        # if len(nums) == 5:\n        #     if nums[0] == nums[1] - 1:\n        #         if nums[2] == nums[3] - 1:\n        #             if nums[4] == nums[3] + 1:\n        #                 return [str(nums[0]) + \"->\" + str(nums[4]), str(nums[3]) + \"->\" + str(nums[4])]\n        #             else:\n        #                 return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2]) + \"->\" + str(nums[3]), str(nums[4])]\n        #         else:\n        #             if nums[4] == nums[3] + 1:\n        #                 return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2]) + \"->\" + str(nums[3]), str(nums[4])]\n        #             else:\n        #                 return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2]) + \"->\" + str(nums[3]), str(nums[4])]\n        #     else:\n        #         if nums[2] == nums[3] - 1:\n        #             if nums[4] == nums[3] + 1:\n        #                 return [str(nums[0]) + \"->\" + str(nums[1]), str(nums[2]) + \"->\" + str(nums[3]), str(nums[4])]\n        #             else:\n        #                 return [str("}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) < len(t):\n        #     return 0\n        # if len(s) == len(t):\n        #     return 1 if s == t else 0\n        # if len(s) == 1:\n        #     return 1 if s == t else 0\n        # if len(s) == 2:\n        #     return 1 if s[0] == t[0] and s[1] == t[1] else 0\n        \n        # dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        # dp[0][0] = 1\n        # for i in range(1, len(s) + 1):\n        #     dp[i][0] = 1\n        #     for j in range(1, len(t) + 1):\n        #         dp[i][j] = dp[i - 1][j]\n        #         if s[i - 1] == t[j - 1]:\n        #             dp[i][j] += dp[i - 1][j - 1]\n        # return dp[-1][-1]\n        \n        # dp = [0] * (len(t) + 1)\n        # dp[0] = 1\n        # for i in range(1, len(s) + 1):\n        #     dp[0] = 1\n        #     for j in range(1, len(t) + 1):\n        #         if s[i - 1] == t[j - 1]:\n        #             dp[j] += dp[j - 1]\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # dp = [0] * (len(t) + 1)\n        # dp[0] = 1\n        # for i in range(1, len(s) + 1):\n        #     dp[0] = 1\n        #     for j in range(1, len(t) + 1):\n        #         if s[i - 1] == t[j - 1]:\n        #             dp[j] += dp[j - 1]\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # dp = [0] * (len(t) + 1)\n        # dp[0] = 1\n        # for i in range(1, len(s) + 1):\n        #     dp[0] = 1\n        #     for j in range(1, len(t) + 1):\n        #         if s[i - 1] == t[j - 1]:\n        #             dp[j] += dp[j - 1]\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # dp = [0] * (len(t) + 1)\n        # dp[0] = 1\n        # for i in range(1, len(s) + 1):\n        #     dp[0] = 1\n        #     for j in range(1, len(t) + 1):\n        #         if s[i - 1] == t[j - 1]:\n        #             dp[j] += dp[j - 1]\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # dp = [0] * (len(t) + 1)\n        # dp[0] = 1\n        # for i in range(1, len(s) + 1):\n        #     dp[0] = 1\n        #     for j in range(1, len(t) + 1):\n        #         if s[i - 1] == t[j - 1]:\n        #             dp[j] += dp[j - 1]\n        #         dp[j] += dp[j - 1]\n        # return dp[-1]\n        \n        # dp = [0] * (len(t) + 1)\n        # dp[0] = 1\n        # for i in"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1,2,3,4,5,6,7,8,9\n        # 2. 1,2,3,4,5,6,7,8,9\n        # 3. 1,2,3,4,5,6,7,8,9\n        # 4. 1,2,3,4,5,6,7,8,9\n        # 5. 1,2,3,4,5,6,7,8,9\n        # 6. 1,2,3,4,5,6,7,8,9\n        # 7. 1,2,3,4,5,6,7,8,9\n        # 8. 1,2,3,4,5,6,7,8,9\n        # 9. 1,2,3,4,5,6,7,8,9\n        # 10. 1,2,3,4,5,6,7,8,9\n        # 11. 1,2,3,4,5,6,7,8,9\n        # 12. 1,2,3,4,5,6,7,8,9\n        # 13. 1,2,3,4,5,6,7,8,9\n        # 14. 1,2,3,4,5,6,7,8,9\n        # 15. 1,2,3,4,5,6,7,8,9\n        # 16. 1,2,3,4,5,6,7,8,9\n        # 17. 1,2,3,4,5,6,7,8,9\n        # 18. 1,2,3,4,5,6,7,8,9\n        # 19. 1,2,3,4,5,6,7,8,9\n        # 20. 1,2,3,4,5,6,7,8,9\n        # 21. 1,2,3,4,5,6,7,8,9\n        # 22. 1,2,3,4,5,6,7,8,9\n        # 23. 1,2,3,4,5,6,7,8,9\n        # 24. 1,2,3,4,5,6,7,8,9\n        # 25. 1,2,3,4,5,6,7,8,9\n        # 26. 1,2,3,4,5,6,7,8,9\n        # 27. 1,2,3,4,5,6,7,8,9\n        # 28. 1,2,3,4,5,6,7,8,9\n        # 29. 1,2,3,4,5,6,7,8,9\n        # 30. 1,2,3,4,5,6,7,8,9\n        # 31. 1,2,3,4,5,6,7,8,9\n        # 32. 1,2,3,4,5,6,7,8,9\n        # 33. 1,2,3,4,5,6,7,8,9\n        # 34. 1,2,3,4,5,6,7,8,9\n        # 35. 1,2,3,4,5,6,7,8,9\n        # 36. 1,2,3,4,5,6,7,8,9\n        # 37. 1,2,3,4,5,6,7,8,9\n        # 38. 1,2,3,4,5,6,7,8,9\n        # 39. 1,2,3,4,5,6,7,8,9\n        # 40. 1,2,3,4,5,6,7,8,9\n        # 41. 1,2,3,4,5,6,7,8,9\n        # 42. 1"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force solution\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ##\n        ## Two pointers solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        \n        ## Brute force solution\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ##\n        ## Two pointers solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ##\n        ## Binary search solution\n        ## Time complexity: O(nlogn)"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, op_val, op_str, res):\n            if not num:\n                if op_val == target:\n                    res.append(op_str)\n                return\n            \n            for i in range(1, len(num) + 1):\n                if i == 1 or (i > 1 and num[0] != '0'):\n                    curr = int(num[:i])\n                    if op_val == 0:\n                        backtrack(num[i:], target - curr, curr, curr, op_str + str(curr), res)\n                    else:\n                        backtrack(num[i:], target - op_val + op_val * curr, op_val * curr, op_val * curr + curr, op_str + '*' + str(curr), res)\n            \n        if not num:\n            return []\n        \n        res = []\n        backtrack(num, target, 0, 0, '', res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## Recursive solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 1. Recursive solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 2. Iterative solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 3. DFS solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 4. BFS solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 1. Recursive solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 2. Iterative solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 3. DFS solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 4. BFS solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 1. Recursive solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 2. Iterative solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 3. DFS solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 4. BFS solution\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS solution\n        ## 4. BFS solution\n        \n        ## 1"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        ## 1. convert all uppercase to lowercase\n        ## 2. count the number of dashes\n        ## 3. if the number of dashes is greater than k, then we need to add one more dash\n        ## 4. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 5. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 6. if the number of dashes is greater than k, then we need to add one more dash\n        ## 7. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 8. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 9. if the number of dashes is greater than k, then we need to add one more dash\n        ## 10. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 11. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 12. if the number of dashes is greater than k, then we need to add one more dash\n        ## 13. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 14. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 15. if the number of dashes is greater than k, then we need to add one more dash\n        ## 16. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 17. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 18. if the number of dashes is greater than k, then we need to add one more dash\n        ## 19. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 20. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 21. if the number of dashes is greater than k, then we need to add one more dash\n        ## 22. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 23. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 24. if the number of dashes is greater than k, then we need to add one more dash\n        ## 25. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 26. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 27. if the number of dashes is greater than k, then we need to add one more dash\n        ## 28. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 29. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 30. if the number of dashes is greater than k, then we need to add one more dash\n        ## 31. if the number of dashes is less than k, then we need to add the number of dashes to the number of characters\n        ## 32. if the number of dashes is equal to k, then we need to add the number of dashes to the number of characters\n        ## 33. if the number of dashes is greater than k, then we need to add one more dash\n        ## 34. if the number of dashes is less than k, then we need to add the number of d"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the total gas and cost\n        ## 2. If the total gas is less than the total cost, return -1\n        ## 3. If the total gas is greater than the total cost, return -1\n        ## 4. If the total gas is equal to the total cost, return -1\n        ## 5. If the total gas is greater than the total cost, return -1\n        ## 6. If the total gas is greater than the total cost, return -1\n        ## 7. If the total gas is greater than the total cost, return -1\n        ## 8. If the total gas is greater than the total cost, return -1\n        ## 9. If the total gas is greater than the total cost, return -1\n        ## 10. If the total gas is greater than the total cost, return -1\n        ## 11. If the total gas is greater than the total cost, return -1\n        ## 12. If the total gas is greater than the total cost, return -1\n        ## 13. If the total gas is greater than the total cost, return -1\n        ## 14. If the total gas is greater than the total cost, return -1\n        ## 15. If the total gas is greater than the total cost, return -1\n        ## 16. If the total gas is greater than the total cost, return -1\n        ## 17. If the total gas is greater than the total cost, return -1\n        ## 18. If the total gas is greater than the total cost, return -1\n        ## 19. If the total gas is greater than the total cost, return -1\n        ## 20. If the total gas is greater than the total cost, return -1\n        ## 21. If the total gas is greater than the total cost, return -1\n        ## 22. If the total gas is greater than the total cost, return -1\n        ## 23. If the total gas is greater than the total cost, return -1\n        ## 24. If the total gas is greater than the total cost, return -1\n        ## 25. If the total gas is greater than the total cost, return -1\n        ## 26. If the total gas is greater than the total cost, return -1\n        ## 27. If the total gas is greater than the total cost, return -1\n        ## 28. If the total gas is greater than the total cost, return -1\n        ## 29. If the total gas is greater than the total cost, return -1\n        ## 30. If the total gas is greater than the total cost, return -1\n        ## 31. If the total gas is greater than the total cost, return -1\n        ## 32. If the total gas is greater than the total cost, return -1\n        ## 33. If the total gas is greater than the total cost, return -1\n        ## 34. If the total gas is greater than the total cost, return -1\n        ## 35. If the total gas is greater than the total cost, return -1\n        ## 36. If the total gas is greater than the total cost, return -1\n        ## 37. If the total gas is greater than the total cost, return -1\n        ## 38. If the total gas is greater than the total cost, return -1\n        ## 39. If the total gas is greater than the total cost, return -1\n        ## 40. If the total gas is greater than the total cost, return -1\n        ## 41. If the total gas is greater than the total cost, return -1\n        ## 42. If the total gas is greater than the total cost, return -1\n        ## 43. If the total gas is greater than the total cost, return -1\n        ## 44. If the total gas is greater than the total cost, return -1\n        ## 45. If the total gas is greater than the total cost, return -1\n        ## 46. If the total gas is greater than the total cost, return -1\n        ## 47. If the total gas is greater than the total cost, return -1\n        ## 48."}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then it means that s is empty as well\n        if not p:\n            return not s\n        \n        # if p is not empty, then it means that s is not empty\n        if not s:\n            return False\n        \n        # if p is a single character, then it means that s is a single character\n        if len(p) == 1:\n            return False if p[0] != '.' else True\n        \n        # if p is a double character, then it means that s is a double character\n        if len(p) == 2:\n            return False if p[0] != '.' and p[1] != '.' else True\n        \n        # if p is a triple character, then it means that s is a triple character\n        if len(p) == 3:\n            return False if p[0] != '.' and p[1] != '.' and p[2] != '.' else True\n        \n        # if p is a quadruple character, then it means that s is a quadruple character\n        if len(p) == 4:\n            return False if p[0] != '.' and p[1] != '.' and p[2] != '.' and p[3] != '.' else True\n        \n        # if p is a quintuple character, then it means that s is a quintuple character\n        if len(p) == 5:\n            return False if p[0] != '.' and p[1] != '.' and p[2] != '.' and p[3] != '.' and p[4] != '.' else True\n        \n        # if p is a sextuple character, then it means that s is a sextuple character\n        if len(p) == 6:\n            return False if p[0] != '.' and p[1] != '.' and p[2] != '.' and p[3] != '.' and p[4] != '.' and p[5] != '.' else True\n        \n        # if p is a septuple character, then it means that s is a septuple character\n        if len(p) == 7:\n            return False if p[0] != '.' and p[1] != '.' and p[2] != '.' and p[3] != '.' and p[4] != '.' and p[5] != '.' and p[6] != '.' else True\n        \n        # if p is a octuple character, then it means that s is a octuple character\n        if len(p) == 8:\n            return False if p[0] != '.' and p[1] != '.' and p[2] != '.' and p[3] != '.' and p[4] != '.' and p[5] != '.' and p[6] != '.' and p[7] != '.' else True\n        \n        # if p is a non-empty string, then it means that s is a non-empty string\n        if len(p) > 0:\n            # if p[0] is not '*', then it means that s[0] is not '.'\n            if p[0] != '*':\n                # if s[0] is not '.' and s[0] is not '*', then it means that s[0] is not '.'\n                if s[0] != '.' and s[0] != '*':\n                    # if s[0] is not '.' and s[0] is not '*', then it means that s[0] is not '.'\n                    if s[0] != '*':\n                        # if s[0] is not '.' and s[0] is not '*', then it means that s[0] is not '.'\n                        if s[0] != '*':\n                            # if s[0] is not '.' and s[0] is not '*', then it means that s[0] is not '.'\n                            if s[0] != '*':\n                                # if s[0] is not '.' and s[0] is not '*', then it means that s[0] is not '.'\n                                if s[0] != '*':\n                                    # if s[0] is not '.' and s[0] is not"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        # 1 is not a perfect number\n        # 2 is a perfect number\n        # 3 is a perfect number\n        # 4 is not a perfect number\n        # 5 is a perfect number\n        # 6 is not a perfect number\n        # 7 is a perfect number\n        # 8 is not a perfect number\n        # 9 is not a perfect number\n        # 10 is not a perfect number\n        # 11 is not a perfect number\n        # 12 is not a perfect number\n        # 13 is not a perfect number\n        # 14 is not a perfect number\n        # 15 is not a perfect number\n        # 16 is not a perfect number\n        # 17 is not a perfect number\n        # 18 is not a perfect number\n        # 19 is not a perfect number\n        # 20 is not a perfect number\n        # 21 is not a perfect number\n        # 22 is not a perfect number\n        # 23 is not a perfect number\n        # 24 is not a perfect number\n        # 25 is not a perfect number\n        # 26 is not a perfect number\n        # 27 is not a perfect number\n        # 28 is not a perfect number\n        # 29 is not a perfect number\n        # 30 is not a perfect number\n        # 31 is not a perfect number\n        # 32 is not a perfect number\n        # 33 is not a perfect number\n        # 34 is not a perfect number\n        # 35 is not a perfect number\n        # 36 is not a perfect number\n        # 37 is not a perfect number\n        # 38 is not a perfect number\n        # 39 is not a perfect number\n        # 40 is not a perfect number\n        # 41 is not a perfect number\n        # 42 is not a perfect number\n        # 43 is not a perfect number\n        # 44 is not a perfect number\n        # 45 is not a perfect number\n        # 46 is not a perfect number\n        # 47 is not a perfect number\n        # 48 is not a perfect number\n        # 49 is not a perfect number\n        # 50 is not a perfect number\n        # 51 is not a perfect number\n        # 52 is not a perfect number\n        # 53 is not a perfect number\n        # 54 is not a perfect number\n        # 55 is not a perfect number\n        # 56 is not a perfect number\n        # 57 is not a perfect number\n        # 58 is not a perfect number\n        # 59 is not a perfect number\n        # 60 is not a perfect number\n        # 61 is not a perfect number\n        # 62 is not a perfect number\n        # 63 is not a perfect number\n        # 64 is not a perfect number\n        # 65 is not a perfect number\n        # 66 is not a perfect number\n        # 67 is not a perfect number\n        # 68 is not a perfect number\n        # 69 is not a perfect number\n        # 70 is not a perfect number\n        # 71 is not a perfect number\n        # 72 is not a perfect number\n        # 73 is not a perfect number\n        # 74 is not a perfect number\n        # 75 is not a perfect number\n        # 76 is not a perfect number\n        # 77 is not a perfect number\n        # 78 is not a perfect number\n        # 79 is not a perfect number\n        # 80 is not a perfect number\n        # 81 is not a perfect number\n        # 82 is not a perfect number\n        # 83 is not a perfect number\n        # 84 is not a perfect number\n        # 85 is not a perfect number\n        # 86 is not a perfect number\n        # 87 is not a perfect number\n        # 88 is not a perfect number\n        # 89 is not a perfect number\n        # 90 is not a perfect number\n        # 91 is not a perfect number\n        # 92 is not a perfect number\n        # 93 is not a perfect number"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return 1\n        # return self.fib(n-1) + self.fib(n-2)\n        \n        # if n == 0:\n        #     return 0\n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 1\n        # if n == 3:\n        #     return 2\n        # if n == 4:\n        #     return 3\n        # if n == 5:\n        #     return 5\n        # if n == 6:\n        #     return 8\n        # if n == 7:\n        #     return 13\n        # if n == 8:\n        #     return 21\n        # if n == 9:\n        #     return 34\n        # if n == 10:\n        #     return 55\n        # if n == 11:\n        #     return 89\n        # if n == 12:\n        #     return 144\n        # if n == 13:\n        #     return 233\n        # if n == 14:\n        #     return 377\n        # if n == 15:\n        #     return 610\n        # if n == 16:\n        #     return 987\n        # if n == 17:\n        #     return 1597\n        # if n == 18:\n        #     return 2584\n        # if n == 19:\n        #     return 4181\n        # if n == 20:\n        #     return 6765\n        # if n == 21:\n        #     return 10946\n        # if n == 22:\n        #     return 17711\n        # if n == 23:\n        #     return 28657\n        # if n == 24:\n        #     return 46368\n        # if n == 25:\n        #     return 75025\n        # if n == 26:\n        #     return 121393\n        # if n == 27:\n        #     return 196418\n        # if n == 28:\n        #     return 317811\n        # if n == 29:\n        #     return 514229\n        # if n == 30:\n        #     return 832040\n        # if n == 31:\n        #     return 1346269\n        # if n == 32:\n        #     return 2178309\n        # if n == 33:\n        #     return 3524578\n        # if n == 34:\n        #     return 5702887\n        # if n == 35:\n        #     return 9237416\n        # if n == 36:\n        #     return 14930352\n        # if n == 37:\n        #     return 24157817\n        # if n == 38:\n        #     return 39088169\n        # if n == 39:\n        #     return 63245986\n        # if n == 40:\n        #     return 102334155\n        # if n == 41:\n        #     return 165580141\n        # if n == 42:\n        #     return 267914296\n        # if n == 43:\n        #     return 433494437\n        # if n == 44:\n        #     return 701408733\n        # if n == 45:\n        #     return 1134903170\n        # if n == 46:\n        #     return 1836311703\n        # if n == 47:\n        #     return 2971215073\n        # if n == 48:\n        #     return"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][j], max(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], min(dp[i][j-1], dp[i-1][j]) - dungeon[i][j])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i-1][j])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp[i][j] = max(dp[i][j], dungeon[i][j] - dp[i][j-1])\n        # dp["}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the left and right pointers\n        left, right = 0, len(nums) - 1\n        \n        # initialize the distance\n        distance = float('inf')\n        \n        # loop until the left pointer is less than the right pointer\n        while left < right:\n            \n            # calculate the distance\n            mid = (left + right) // 2\n            \n            # calculate the number of pairs with distance <= mid\n            count = self.countPairs(nums, mid)\n            \n            # if the number of pairs is less than k, update the distance\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n                distance = min(distance, mid)\n        \n        return distance\n    \n    def countPairs(self, nums, distance):\n        \"\"\"\n        :type nums: List[int]\n        :type distance: int\n        :rtype: int\n        \"\"\"\n        \n        # initialize the count\n        count = 0\n        \n        # initialize the left pointer\n        left = 0\n        \n        # loop until the left pointer is less than the length of the array\n        for right in range(len(nums)):\n            \n            # if the difference between the left and right pointer is less than or equal to the distance\n            if nums[right] - nums[left] <= distance:\n                \n                # increment the count\n                count += right - left\n                \n            # otherwise, increment the left pointer\n            else:\n                \n                # increment the left pointer\n                left += 1\n                \n                # if the left pointer is greater than the right pointer\n                if left > right:\n                    \n                    # break the loop\n                    break\n                \n                # increment the count\n                count += 1\n                \n        return count"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s is empty, return 0\n        if not s:\n            return 0\n        \n        # if s is only whitespace, return 0\n        if s.isspace():\n            return 0\n        \n        # if s is only one character, return 1\n        if len(s) == 1:\n            return 1\n        \n        # if s is only two characters, return 1\n        if len(s) == 2:\n            return 1\n        \n        # if s is only three characters, return 1\n        if len(s) == 3:\n            return 1\n        \n        # if s is only four characters, return 1\n        if len(s) == 4:\n            return 1\n        \n        # if s is only five characters, return 1\n        if len(s) == 5:\n            return 1\n        \n        # if s is only six characters, return 1\n        if len(s) == 6:\n            return 1\n        \n        # if s is only seven characters, return 1\n        if len(s) == 7:\n            return 1\n        \n        # if s is only eight characters, return 1\n        if len(s) == 8:\n            return 1\n        \n        # if s is only nine characters, return 1\n        if len(s) == 9:\n            return 1\n        \n        # if s is only ten characters, return 1\n        if len(s) == 10:\n            return 1\n        \n        # if s is only eleven characters, return 1\n        if len(s) == 11:\n            return 1\n        \n        # if s is only twelve characters, return 1\n        if len(s) == 12:\n            return 1\n        \n        # if s is only thirteen characters, return 1\n        if len(s) == 13:\n            return 1\n        \n        # if s is only fourteen characters, return 1\n        if len(s) == 14:\n            return 1\n        \n        # if s is only fifteen characters, return 1\n        if len(s) == 15:\n            return 1\n        \n        # if s is only sixteen characters, return 1\n        if len(s) == 16:\n            return 1\n        \n        # if s is only seventeen characters, return 1\n        if len(s) == 17:\n            return 1\n        \n        # if s is only eighteen characters, return 1\n        if len(s) == 18:\n            return 1\n        \n        # if s is only nineteen characters, return 1\n        if len(s) == 19:\n            return 1\n        \n        # if s is only twenty characters, return 1\n        if len(s) == 20:\n            return 1\n        \n        # if s is only twenty one characters, return 1\n        if len(s) == 21:\n            return 1\n        \n        # if s is only twenty two characters, return 1\n        if len(s) == 22:\n            return 1\n        \n        # if s is only twenty three characters, return 1\n        if len(s) == 23:\n            return 1\n        \n        # if s is only twenty four characters, return 1\n        if len(s) == 24:\n            return 1\n        \n        # if s is only twenty five characters, return 1\n        if len(s) == 25:\n            return 1\n        \n        # if s is only twenty six characters, return 1\n        if len(s) == 26:\n            return 1\n        \n        # if s is only twenty seven characters, return 1\n        if len(s) == 27:\n            return 1\n        \n        # if s is only twenty eight characters, return 1\n        if len(s) == 28:\n            return 1\n        \n        # if s is only twenty nine characters, return 1\n        if len(s) == 29:\n            return 1\n        \n        # if s is only thirty characters, return 1\n        if len(s) == 30:\n            return 1\n        \n        # if s is only thirty one characters, return 1\n        if len(s) == 31:\n            return 1\n        \n        #"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        vowel_indices = []\n        for i in range(len(s)):\n            if s[i] in vowels:\n                vowel_indices.append(i)\n        \n        # print(vowel_indices)\n        \n        # reverse the vowel indices\n        vowel_indices.reverse()\n        # print(vowel_indices)\n        \n        # reverse the vowels\n        vowels_reversed = []\n        for i in range(len(vowel_indices)):\n            vowels_reversed.append(s[vowel_indices[i]])\n        \n        # print(vowels_reversed)\n        \n        # reverse the vowels\n        vowels_reversed.reverse()\n        # print(vowels_reversed)\n        \n        # replace the vowels\n        for i in range(len(vowel_indices)):\n            s = s[:vowel_indices[i]] + vowels_reversed[i] + s[vowel_indices[i] + 1:]\n        \n        return s"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Edge Case:\n        if len(nums) == 0:\n            return 0\n        \n        # Create a hashmap to store the number and its index\n        # If the number is already in the hashmap, then we don't need to do anything\n        # If the number is not in the hashmap, then we need to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence\n        # We will use the hashmap to find the longest consecutive sequence"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the sum of all the numbers in the array\n        ## 2. Find the sum of all the numbers in the range [0, n]\n        ## 3. Find the difference between the two sums\n        ## 4. Return the difference\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the sum of all the numbers in the array\n        ## 2. Find the sum of all the numbers in the range [0, n]\n        ## 3. Find the sum of all the numbers in the range [0, n]\n        ## 4. Find the difference between the two sums\n        ## 5. Return the difference\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the sum of all the numbers in the array\n        ## 2. Find the sum of all the numbers in the range [0, n]\n        ## 3. Find the sum of all the numbers in the range [0, n]\n        ## 4. Find the sum of all the numbers in the range [0, n]\n        ## 5. Find the difference between the two sums\n        ## 6. Return the difference\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the sum of all the numbers in the array\n        ## 2. Find the sum of all the numbers in the range [0, n]\n        ## 3. Find the sum of all the numbers in the range [0, n]\n        ## 4. Find the sum of all the numbers in the range [0, n]\n        ## 5. Find the sum of all the numbers in the range [0, n]\n        ## 6. Find the difference between the two sums\n        ## 7. Return the difference\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the sum of all the numbers in the array\n        ## 2. Find the sum of all the numbers in the range [0, n]\n        ## 3. Find the sum of all the numbers in the range [0, n]\n        ## 4. Find the sum of all the numbers in the range [0, n]\n        ## 5. Find the sum of all the numbers in the range [0, n]\n        ## 6. Find the sum of all the numbers in the range [0, n]\n        ## 7. Find the sum of all the numbers in the range [0, n]\n        ## 8. Find the difference between the two sums\n        ## 9. Return the difference\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Find the sum of all the numbers in the array\n        ## 2. Find the sum of all the numbers in the range [0, n]\n        ## 3. Find the sum of all the numbers in the range [0, n]\n        ## 4. Find the sum of all the numbers in the range [0, n]\n        ## 5. Find the sum of all the numbers in the range [0, n]\n        ## 6. Find the sum of all the numbers in the range [0, n]\n        ## 7. Find the sum of all the numbers in the range [0, n]\n        ## 8. Find the sum of all the numbers in the range [0, n]\n        ## 9. Find the sum of all the numbers in the range [0, n]\n        ## 10. Find the sum of all"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number of words in wordList, m is the length of the longest word in wordList\n        \n        ## BFS\n        ## Time: O(n*m)\n        ## Space: O(n*m)\n        ## where n is the number"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # if len(a) < len(b):\n        #     a, b = b, a\n        #     # print(a, b)\n        #     # print(len(a), len(b))\n        #     # print(a[::-1], b[::-1])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:len(b)])\n        #     # print(a[::-1][:len(b)], b[::-1][:"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # binary search\n        # find the leftmost index\n        # find the rightmost index\n        # return [leftmost, rightmost]\n        \n        # edge case\n        if len(nums) == 0:\n            return [-1, -1]\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        leftmost = -1\n        rightmost = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                leftmost = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                rightmost = mid\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return [leftmost, rightmost]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]\n        #         j += 1\n        # return i + 1\n        \n        # if len(nums) == 0:\n        #     return 0\n        # if len(nums) == 1:\n        #     return 1\n        \n        # i = 0\n        # j = 1\n        # while j < len(nums):\n        #     if nums[i] == nums[j]:\n        #         j += 1\n        #     else:\n        #         i += 1\n        #         nums[i] = nums[j]"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if k is greater than the length of the array, then we can buy and sell as many times as we want\n        if k >= len(prices):\n            return sum(prices[i] - prices[i-1] for i in range(1, len(prices)))\n        \n        # if k is 0, then we can't buy and sell at all\n        if k == 0:\n            return 0\n        \n        # initialize the array to hold the max profit for each day\n        # we will have k+1 because we will have a buy and sell day\n        # the first day will always be 0\n        # the last day will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the array will always be -1\n        # the first element will always be the first element of the array\n        # the last element will always be the last element of the array\n        # the rest of the"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {\n            10: \"a\",\n            11: \"b\",\n            12: \"c\",\n            13: \"d\",\n            14: \"e\",\n            15: \"f\"\n        }\n        \n        hex_list = []\n        while num > 0:\n            remainder = num % 16\n            if remainder >= 10:\n                hex_list.append(hex_dict[remainder])\n            else:\n                hex_list.append(str(remainder))\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = \"\"\n        for i in hex_list:\n            hex_str += i\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap with key as the character and value as the index of the character\n        ## 2. Iterate through the string and for each character, check if the character is already in the hashmap\n        ## 3. If the character is already in the hashmap, then update the value of the character to -1\n        ## 4. If the character is not in the hashmap, then add the character to the hashmap with value as the index of the character\n        ## 5. Iterate through the hashmap and find the first character with value as 1\n        ## 6. If the character is not found, then return -1\n        ## 7. If the character is found, then return the index of the character\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, then return -1\n        ## 2. If the string has only one character, then return 0\n        \n        ## Initialization:\n        ## 1. Create a hashmap with key as the character and value as the index of the character\n        ## 2. Create a list with the index of the character\n        ## 3. Create a variable to store the index of the first non-repeating character\n        ## 4. Create a variable to store the index of the last non-repeating character\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, then return -1\n        ## 2. If the string has only one character, then return 0\n        \n        ## Algorithm:\n        ## 1. Create a hashmap with key as the character and value as the index of the character\n        ## 2. Iterate through the string and for each character, check if the character is already in the hashmap\n        ## 3. If the character is already in the hashmap, then update the value of the character to -1\n        ## 4. If the character is not in the hashmap, then add the character to the hashmap with value as the index of the character\n        ## 5. Iterate through the hashmap and find the first character with value as 1\n        ## 6. If the character is not found, then return -1\n        ## 7. If the character is found, then return the index of the character\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, then return -1\n        ## 2. If the string has only one character, then return 0\n        \n        ## Initialization:\n        ## 1. Create a hashmap with key as the character and value as the index of the character\n        ## 2. Create a list with the index of the character\n        ## 3. Create a variable to store the index of the first non-repeating character\n        ## 4. Create a variable to store the index of the last non-repeating character\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, then return -1\n        ## 2. If the string has only one character, then return 0\n        \n        ## Algorithm:\n        ## 1. Create a hashmap with key as the character and value as the index of the character\n        ## 2. Iterate through the string and for each character, check if the character is already in the hashmap\n        ## 3. If the character is already in the hashmap, then update the value of the character to -1\n        ## 4. If the character is not in the hashmap, then add the character to the hashmap with value as the index of the character\n        ## 5. Iterate through the hashmap and find the first character with value as 1\n        ## 6. If the character is not found, then return -1\n        ## 7. If the character is found, then return the index of the character\n        \n        ## Edge Cases:\n        ## 1. If the string is empty, then return -1\n        ## 2. If the string has only one character, then return 0\n        \n        ## Initialization:\n        ## 1. Create a hashmap with key as the character and value as the index of the character\n        ##"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # if indexDiff < 0 or valueDiff < 0:\n        #     return False\n        \n        # if indexDiff >= len(nums) or valueDiff >= len(nums):\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff == 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff == 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff > 0:\n        #     return False\n        \n        # if indexDiff > 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff < 0 and valueDiff < 0:\n        #     return False\n        \n        # if indexDiff > 0"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,2\n        # 0,1,"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1st approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 2nd approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 3rd approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 4th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 5th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 6th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 7th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 8th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 9th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 10th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 11th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 12th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 13th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 14th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 15th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 16th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 17th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 18th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 19th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 20th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 21st approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 22nd approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 23rd approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 24th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 25th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 26th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 27th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 28th approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)\n        # if root.right is None:\n        #     return 1 + self.countNodes(root.left)\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # if root is None:\n        #     return 0\n        # if root.left is None and root.right is None:\n        #     return 1\n        # if root.left is None:\n        #     return 1 + self.countNodes(root.right)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort capital and profits\n        # 2. loop through capital and profits\n        # 3. if capital is less than or equal to w, add profit to w\n        # 4. if k is greater than 0, decrement k\n        # 5. if k is 0, return w\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # loop through capital and profits\n        i = 0\n        while k > 0 and i < len(sorted_capital):\n            # if capital is less than or equal to w, add profit to w\n            if sorted_capital[i][0] <= w:\n                w += sorted_capital[i][1]\n                i += 1\n            # if k is greater than 0, decrement k\n            elif k > 0:\n                k -= 1\n                w += sorted_capital[i][1]\n            # if k is 0, return w\n            else:\n                return w\n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets:\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        #     else:\n        #         stack.append(char)\n        \n        # return len(stack) == 0\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets:\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        #     else:\n        #         stack.append(char)\n        \n        # return len(stack) == 0\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets:\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        #     else:\n        #         stack.append(char)\n        \n        # return len(stack) == 0\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets:\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        #     else:\n        #         stack.append(char)\n        \n        # return len(stack) == 0\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets:\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        #     else:\n        #         stack.append(char)\n        \n        # return len(stack) == 0\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #     if char in brackets:\n        #         if stack and stack[-1] == brackets[char]:\n        #             stack.pop()\n        #         else:\n        #             return False\n        #     else:\n        #         stack.append(char)\n        \n        # return len(stack) == 0\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        \n        # stack = []\n        # brackets = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        \n        # for char in s:\n        #"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two numbers\n        # reverse the numbers after the number that is smaller than the next number\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the number that is smaller than the next number\n        # swap the two"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Sliding Window\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        \n        # Brute Force\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # if len(nums) <= 1:\n        #     return False\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in hashmap:\n        #         if i - hashmap[nums[i]] <= k:\n        #             return True\n        #     hashmap[nums[i]] = i\n        # return False\n        \n        # Sliding Window\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        if len(nums) <= 1:\n            return False\n        hashmap = {}\n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if i - hashmap[nums[i]] <= k:\n                    return True\n            hashmap[nums[i]] = i\n        return False\n        \n        # Hashmap\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # if len(nums) <= 1:\n        #     return False\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     if nums[i] in hashmap:\n        #         if i - hashmap[nums[i]] <= k:\n        #             return True\n        #     hashmap[nums[i]] = i\n        # return False\n        \n        # Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # if len(nums) <= 1:\n        #     return False\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] == nums[j] and abs(i-j) <= k:\n        #             return True\n        # return False\n        \n        # Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # if len(nums) <= 1:\n        #     return False\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] == nums[j] and abs(i-j) <= k:\n        #             return True\n        # return False\n        \n        # Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # if len(nums) <= 1:\n        #     return False\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] == nums[j] and abs(i-j) <= k:\n        #             return True\n        # return False\n        \n        # Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # if len(nums) <= 1:\n        #     return False\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] == nums[j] and abs(i-j) <= k:\n        #             return True\n        # return False\n        \n        # Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # if len(nums) <= 1:"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        # find min and max\n        min_num = float('inf')\n        max_num = float('-inf')\n        for num in nums:\n            min_num = min(min_num, num)\n            max_num = max(max_num, num)\n        \n        # if min_num == max_num, then the array is sorted\n        if min_num == max_num:\n            return 0\n        \n        # calculate the bucket size\n        bucket_size = max(1, (max_num - min_num) // (len(nums) - 1))\n        \n        # calculate the bucket count\n        bucket_count = (max_num - min_num) // bucket_size + 1\n        \n        # initialize the buckets\n        buckets = [None] * bucket_count\n        \n        # put the numbers into the buckets\n        for num in nums:\n            bucket_index = (num - min_num) // bucket_size\n            if buckets[bucket_index] is None:\n                buckets[bucket_index] = [num, num]\n            else:\n                buckets[bucket_index][0] = min(buckets[bucket_index][0], num)\n                buckets[bucket_index][1] = max(buckets[bucket_index][1], num)\n        \n        # find the max gap\n        max_gap = 0\n        prev_max = buckets[0][1]\n        for i in range(1, bucket_count):\n            if buckets[i] is None:\n                continue\n            max_gap = max(max_gap, buckets[i][0] - prev_max)\n            prev_max = buckets[i][1]\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        while q:\n            level = []\n            for i in range(len(q)):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1. 2n == row.length\n        # 2. 2 <= n <= 30\n        # 3. n is even.\n        # 4. 0 <= row[i] < 2n\n        # 5. All the elements of row are unique.\n        \n        # 1"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n        #     return True\n        \n        # if len(s1) == 0:\n        #     return s2 == s3\n        \n        # if len(s2) == 0:\n        #     return s1 == s3\n        \n        # if len(s1) == 0 or len(s2) == 0:\n        #     return False\n        \n        # if s1[0] == s3[0] and s2[0] == s3[0]:\n        #     return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\n        \n        # if s1[0] == s3[0]:\n        #     return self.isInterleave(s1[1:], s2, s3[1:])\n        \n        # if s2[0] == s3[0]:\n        #     return self.isInterleave(s1, s2[1:], s3[1:])\n        \n        # return False\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n        #     return True\n        \n        # if len(s1) == 0:\n        #     return s2 == s3\n        \n        # if len(s2) == 0:\n        #     return s1 == s3\n        \n        # if len(s1) == 0 or len(s2) == 0:\n        #     return False\n        \n        # if s1[0] == s3[0] and s2[0] == s3[0]:\n        #     return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\n        \n        # if s1[0] == s3[0]:\n        #     return self.isInterleave(s1[1:], s2, s3[1:])\n        \n        # if s2[0] == s3[0]:\n        #     return self.isInterleave(s1, s2[1:], s3[1:])\n        \n        # return False\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n        #     return True\n        \n        # if len(s1) == 0:\n        #     return s2 == s3\n        \n        # if len(s2) == 0:\n        #     return s1 == s3\n        \n        # if len(s1) == 0 or len(s2) == 0:\n        #     return False\n        \n        # if s1[0] == s3[0] and s2[0] == s3[0]:\n        #     return self.isInterleave(s1[1:], s2, s3[1:]) or self.isInterleave(s1, s2[1:], s3[1:])\n        \n        # if s1[0] == s3[0]:\n        #     return self.isInterleave(s1[1:], s2, s3[1:])\n        \n        # if s2[0] == s3[0]:\n        #     return self.isInterleave(s1, s2[1:], s3[1:])\n        \n        # return False\n        \n        # if len(s1) + len(s2) != len(s3):\n        #     return False\n        \n        # if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n        #     return True\n        \n        # if len(s1) == 0:\n        #     return s2 == s3"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the greed factors and the cookie sizes\n        g.sort()\n        s.sort()\n        \n        # initialize the number of children that can be satisfied\n        satisfied = 0\n        \n        # initialize the index of the greed factors and cookie sizes\n        g_index = 0\n        s_index = 0\n        \n        # loop through the greed factors\n        while g_index < len(g):\n            # loop through the cookie sizes\n            while s_index < len(s):\n                # if the cookie size is greater than the greed factor, break out of the loop\n                if s[s_index] >= g[g_index]:\n                    break\n                # increment the cookie size index\n                s_index += 1\n            # increment the number of children that can be satisfied\n            satisfied += 1\n            # increment the greed factor index\n            g_index += 1\n        \n        # return the number of children that can be satisfied\n        return satisfied"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. create a hashmap of the first row\n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 1. create a hashmap of the first row\n        firstRow = {'q','w','e','r','t','y','u','i','o','p'}\n        secondRow = {'a','s','d','f','g','h','j','k','l'}\n        thirdRow = {'z','x','c','v','b','n','m'}\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in the hashmap, remove it from the list\n        # 5. return the list\n        \n        # 2. iterate through the words\n        # 3. if the word is in the hashmap, add it to the list\n        # 4. if the word is not in"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the left node\n        # 2. Find the right node\n        # 3. Reverse the nodes\n        # 4. Connect the left node to the right node\n        # 5. Connect the right node to the next node\n        \n        # 1. Find the left node\n        left_node = None\n        left_node_prev = None\n        curr = head\n        while curr and left > 1:\n            left_node_prev = curr\n            curr = curr.next\n            left -= 1\n        \n        # 2. Find the right node\n        right_node = None\n        right_node_prev = None\n        curr = head\n        while curr and right > 0:\n            right_node_prev = curr\n            curr = curr.next\n            right -= 1\n        \n        # 3. Reverse the nodes\n        right_node_next = right_node.next\n        right_node.next = None\n        curr = left_node\n        prev = None\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # 4. Connect the left node to the right node\n        if left_node_prev:\n            left_node_prev.next = right_node\n        else:\n            head = right_node\n        \n        # 5. Connect the right node to the next node\n        right_node_prev.next = right_node_next\n        \n        return head\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the left node\n        # 2. Find the right node\n        # 3. Reverse the nodes\n        # 4. Connect the left node to the right node\n        # 5. Connect the right node to the next node\n        \n        # 1. Find the left node\n        left_node = None\n        left_node_prev = None\n        curr = head\n        while curr and left > 1:\n            left_node_prev = curr\n            curr = curr.next\n            left -= 1\n        \n        # 2. Find the right node\n        right_node = None\n        right_node_prev = None\n        curr = head\n        while curr and right > 0:\n            right_node_prev = curr\n            curr = curr.next\n            right -= 1\n        \n        # 3. Reverse the nodes\n        right_node_next = right_node.next\n        right_node.next = None\n        curr = left_node\n        prev = None\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # 4. Connect the left node to the right node\n        if left_node_prev:\n            left_node_prev.next = right_node\n        else:\n            head = right_node\n        \n        # 5. Connect the right node to the next node\n        right_node_prev.next = right_node_next\n        \n        return head\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the left node\n        # 2. Find the right"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the reversed string + the original string\n        \n        # 1. Find the longest palindrome substring\n        # 2. Reverse the string\n        # 3. Concatenate the reversed string with the original string\n        # 4. If the reversed string is a palindrome, return the reversed string\n        # 5. If the reversed string is not a palindrome, return the"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # if the length of s is smaller than the length of t, return \"\"\n        if len(s) < len(t):\n            return \"\"\n        \n        # create a dictionary to store the frequency of each character in t\n        # and a dictionary to store the frequency of each character in s\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s\n        # that is not in t\n        # and a dictionary to store the frequency of each character in s"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 1st case: \n        # 2. 2nd case: \n        # 3. 3rd case: \n        # 4. 4th case: \n        # 5. 5th case: \n        # 6. 6th case: \n        # 7. 7th case: \n        # 8. 8th case: \n        # 9. 9th case: \n        # 10. 10th case: \n        # 11. 11th case: \n        # 12. 12th case: \n        # 13. 13th case: \n        # 14. 14th case: \n        # 15. 15th case: \n        # 16. 16th case: \n        # 17. 17th case: \n        # 18. 18th case: \n        # 19. 19th case: \n        # 20. 20th case: \n        # 21. 21st case: \n        # 22. 22nd case: \n        # 23. 23rd case: \n        # 24. 24th case: \n        # 25. 25th case: \n        # 26. 26th case: \n        # 27. 27th case: \n        # 28. 28th case: \n        # 29. 29th case: \n        # 30. 30th case: \n        # 31. 31st case: \n        # 32. 32nd case: \n        # 33. 33rd case: \n        # 34. 34th case: \n        # 35. 35th case: \n        # 36. 36th case: \n        # 37. 37th case: \n        # 38. 38th case: \n        # 39. 39th case: \n        # 40. 40th case: \n        # 41. 41st case: \n        # 42. 42nd case: \n        # 43. 43rd case: \n        # 44. 44th case: \n        # 45. 45th case: \n        # 46. 46th case: \n        # 47. 47th case: \n        # 48. 48th case: \n        # 49. 49th case: \n        # 50. 50th case: \n        # 51. 51st case: \n        # 52. 52nd case: \n        # 53. 53rd case: \n        # 54. 54th case: \n        # 55. 55th case: \n        # 56. 56th case: \n        # 57. 57th case: \n        # 58. 58th case: \n        # 59. 59th case: \n        # 60. 60th case: \n        # 61. 61st case: \n        # 62. 62nd case: \n        # 63. 63rd case: \n        # 64. 64th case: \n        # 65. 65th case: \n        # 66. 66th case: \n        # 67. 67th case: \n        # 68. 68th case: \n        # 69. 69th case: \n        # 70. 70th case: \n        # 71. 71st case: \n        # 72. 72nd case: \n        # 73. 73rd case: \n        # 74. 74th case: \n        # 75."}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next and curr.next.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next and curr.next.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next and curr.next.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next and curr.next.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next and curr.next.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next and curr.next.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next and curr.next.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next and curr.next.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         curr.next = curr.next.next\n        #"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(postorder[-1])\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(postorder[-1])\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(postorder[-1])\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(postorder[-1])\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder[0])\n        \n        # root = TreeNode(postorder[-1])\n        # root_index = inorder.index(postorder[-1])\n        # left_inorder = inorder[:root_index]\n        # right_inorder = inorder[root_index+1:]\n        # left_postorder = postorder[:len(left_inorder)]\n        # right_postorder = postorder[len(left_inorder):-1]\n        # root.left = self.buildTree(left_inorder, left_postorder)\n        # root.right = self.buildTree(right_inorder, right_postorder)\n        # return root\n        \n        # if len(inorder) == 0:\n        #     return None\n        # if len(inorder) == 1:\n        #     return TreeNode(inorder"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the starting point\n        ## 2. find the shortest path from the starting point to all the trees\n        ## 3. find the shortest path from the starting point to the shortest tree\n        ## 4. find the shortest path from the shortest tree to the shortest tree\n        ## 5. find the shortest path from the shortest tree to the shortest tree\n        ## 6. find the shortest path from the shortest tree to the shortest tree\n        ## 7. find the shortest path from the shortest tree to the shortest tree\n        ## 8. find the shortest path from the shortest tree to the shortest tree\n        ## 9. find the shortest path from the shortest tree to the shortest tree\n        ## 10. find the shortest path from the shortest tree to the shortest tree\n        ## 11. find the shortest path from the shortest tree to the shortest tree\n        ## 12. find the shortest path from the shortest tree to the shortest tree\n        ## 13. find the shortest path from the shortest tree to the shortest tree\n        ## 14. find the shortest path from the shortest tree to the shortest tree\n        ## 15. find the shortest path from the shortest tree to the shortest tree\n        ## 16. find the shortest path from the shortest tree to the shortest tree\n        ## 17. find the shortest path from the shortest tree to the shortest tree\n        ## 18. find the shortest path from the shortest tree to the shortest tree\n        ## 19. find the shortest path from the shortest tree to the shortest tree\n        ## 20. find the shortest path from the shortest tree to the shortest tree\n        ## 21. find the shortest path from the shortest tree to the shortest tree\n        ## 22. find the shortest path from the shortest tree to the shortest tree\n        ## 23. find the shortest path from the shortest tree to the shortest tree\n        ## 24. find the shortest path from the shortest tree to the shortest tree\n        ## 25. find the shortest path from the shortest tree to the shortest tree\n        ## 26. find the shortest path from the shortest tree to the shortest tree\n        ## 27. find the shortest path from the shortest tree to the shortest tree\n        ## 28. find the shortest path from the shortest tree to the shortest tree\n        ## 29. find the shortest path from the shortest tree to the shortest tree\n        ## 30. find the shortest path from the shortest tree to the shortest tree\n        ## 31. find the shortest path from the shortest tree to the shortest tree\n        ## 32. find the shortest path from the shortest tree to the shortest tree\n        ## 33. find the shortest path from the shortest tree to the shortest tree\n        ## 34. find the shortest path from the shortest tree to the shortest tree\n        ## 35. find the shortest path from the shortest tree to the shortest tree\n        ## 36. find the shortest path from the shortest tree to the shortest tree\n        ## 37. find the shortest path from the shortest tree to the shortest tree\n        ## 38. find the shortest path from the shortest tree to the shortest tree\n        ## 39. find the shortest path from the shortest tree to the shortest tree\n        ## 40. find the shortest path from the shortest tree to the shortest tree\n        ## 41. find the shortest path from the shortest tree to the shortest tree\n        ## 42. find the shortest path from the shortest tree to the shortest tree\n        ## 43. find the shortest path from the shortest tree to the shortest tree\n        ## 44. find the shortest path from the shortest tree to the shortest tree\n        ## 45. find the shortest path from the shortest tree to the shortest tree\n        ## 46. find the shortest path"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return self.minDepth(root.right) + 1\n        \n        if root.right is None:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 2:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 3:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 4:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 5:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 6:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 7:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 8:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 9:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 10:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 11:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 12:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 13:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 14:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 15:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 16:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 17:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 18:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 19:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 20:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 21:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 22:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 23:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 24:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 25:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 26:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 27:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 28:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 29:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 30:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 31:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # Approach 32:"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        # if a and b are the same, then the longest uncommon subsequence is -1\n        if a == b:\n            return -1\n        \n        # if a is longer than b, then the longest uncommon subsequence is the length of a\n        if len(a) > len(b):\n            return len(a)\n        \n        # if b is longer than a, then the longest uncommon subsequence is the length of b\n        if len(b) > len(a):\n            return len(b)\n        \n        # if a is the same as b, then the longest uncommon subsequence is -1\n        if a == b:\n            return -1\n        \n        # if a is the same as b, then the longest uncommon subsequence is the length of a\n        if a == b:\n            return -1\n        \n        # if a is longer than b, then the longest uncommon subsequence is the length of a\n        if len(a) > len(b):\n            return len(a)\n        \n        # if b is longer than a, then the longest uncommon subsequence is the length of b\n        if len(b) > len(a):\n            return len(b)\n        \n        # if a is the same as b, then the longest uncommon subsequence is -1\n        if a == b:\n            return -1\n        \n        # if a is the same as b, then the longest uncommon subsequence is the length of a\n        if a == b:\n            return -1\n        \n        # if a is longer than b, then the longest uncommon subsequence is the length of a\n        if len(a) > len(b):\n            return len(a)\n        \n        # if b is longer than a, then the longest uncommon subsequence is the length of b\n        if len(b) > len(a):\n            return len(b)\n        \n        # if a is the same as b, then the longest uncommon subsequence is -1\n        if a == b:\n            return -1\n        \n        # if a is the same as b, then the longest uncommon subsequence is the length of a\n        if a == b:\n            return -1\n        \n        # if a is longer than b, then the longest uncommon subsequence is the length of a\n        if len(a) > len(b):\n            return len(a)\n        \n        # if b is longer than a, then the longest uncommon subsequence is the length of b\n        if len(b) > len(a):\n            return len(b)\n        \n        # if a is the same as b, then the longest uncommon subsequence is -1\n        if a == b:\n            return -1\n        \n        # if a is the same as b, then the longest uncommon subsequence is the length of a\n        if a == b:\n            return -1\n        \n        # if a is longer than b, then the longest uncommon subsequence is the length of a\n        if len(a) > len(b):\n            return len(a)\n        \n        # if b is longer than a, then the longest uncommon subsequence is the length of b\n        if len(b) > len(a):\n            return len(b)\n        \n        # if a is the same as b, then the longest uncommon subsequence is -1\n        if a == b:\n            return -1\n        \n        # if a is the same as b, then the longest uncommon subsequence is the length of a\n        if a == b:\n            return -1\n        \n        # if a is longer than b, then the longest uncommon subsequence is the length of a\n        if len(a) > len(b):\n            return len(a)\n        \n        # if b is longer than a, then the longest uncommon subsequence is the length of b\n        if len(b) > len(a):\n            return len(b)\n        \n        # if a is the same as b, then the longest uncommon subsequence is -1\n        if a == b:\n            return -1\n        \n        # if a is the same as b, then the longest uncommon subsequence is the length of a\n        if a == b:\n            return -1\n        \n        # if a is longer than b, then the longest uncommon subsequence is the length of a\n        if len(a) > len(b):\n            return len(a)"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.insert(0, level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.append(level)\n        # return result[::-1]\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.insert(0, level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.insert(0, level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.insert(0, level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.insert(0, level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result = []\n        # while queue:\n        #     level = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     result.insert(0, level)\n        # return result\n        \n        # if root is None:\n        #     return []\n        \n        # queue = [root]\n        # result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        # if x < 0:\n        #     return False\n        # if x < 10:\n        #     return True\n        # if x % 10 == 0:\n        #     return False\n        # if x < 100:\n        #     return True\n        # if x < 1000:\n        #     return True\n        # if x < 10000:\n        #     return True\n        # if x < 100000:\n        #     return True\n        # if x < 1000000:\n        #     return True\n        # if x < 10000000:\n        #     return True\n        # if x < 100000000:\n        #     return True\n        # if x < 1000000000:\n        #     return True\n        # if x < 10000000000:\n        #     return True\n        # if x < 100000000000:\n        #     return True\n        # if x < 1000000000000:\n        #     return True\n        # if x < 10000000000000:\n        #     return True\n        # if x < 100000000000000:\n        #     return True\n        # if x < 1000000000000000:\n        #     return True\n        # if x < 10000000000000000:\n        #     return True\n        # if x < 100000000000000000:\n        #     return True\n        # if x < 1000000000000000000:\n        #     return True\n        # if x < 10000000000000000000:\n        #     return True\n        # if x < 100000000000000000000:\n        #     return True\n        # if x < 1000000000000000000000:\n        #     return True\n        # if x < 10000000000000000000000:\n        #     return True\n        # if x < 100000000000000000000000:\n        #     return True\n        # if x < 1000000000000000000000000:\n        #     return True\n        # if x < 10000000000000000000000000:\n        #     return True\n        # if x < 100000000000000000000000000:\n        #     return True\n        # if x < 1000000000000000000000000000:\n        #     return True\n        # if x < 10000000000000000000000000000:\n        #     return True\n        # if x < 100000000000000000000000000000:\n        #     return True\n        # if x < 1000000000000000000000000000000:\n        #     return True\n        # if x < 10000000000000000000000000000000:\n        #     return True\n        # if x < 100000000000000000000000000000000:\n        #     return True\n        # if x < 10000000000"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s is empty, return 0\n        if not s:\n            return 0\n        \n        # if s is 0, return 0\n        if s[0] == '0':\n            return 0\n        \n        # if s is 1, return 1\n        if len(s) == 1:\n            return 1\n        \n        # if s is 2, return 2\n        if len(s) == 2:\n            if s[0] == '1' or s[0] == '2' and s[1] in ['0','1','2']:\n                return 2\n            else:\n                return 1\n        \n        # if s is 3, return 3\n        if len(s) == 3:\n            if s[0] == '1' or s[0] == '2' and s[1] in ['0','1','2']:\n                if s[2] in ['0','1','2']:\n                    return 3\n                else:\n                    return 2\n            else:\n                return 1\n        \n        # if s is 4, return 4\n        if len(s) == 4:\n            if s[0] == '1' or s[0] == '2' and s[1] in ['0','1','2']:\n                if s[2] in ['0','1','2']:\n                    if s[3] in ['0','1','2']:\n                        return 4\n                    else:\n                        return 2\n                else:\n                    return 1\n            else:\n                return 1\n        \n        # if s is 5, return 5\n        if len(s) == 5:\n            if s[0] == '1' or s[0] == '2' and s[1] in ['0','1','2']:\n                if s[2] in ['0','1','2']:\n                    if s[3] in ['0','1','2']:\n                        if s[4] in ['0','1','2']:\n                            return 5\n                        else:\n                            return 2\n                    else:\n                        return 2\n                else:\n                    return 1\n            else:\n                return 1\n        \n        # if s is 6, return 6\n        if len(s) == 6:\n            if s[0] == '1' or s[0] == '2' and s[1] in ['0','1','2']:\n                if s[2] in ['0','1','2']:\n                    if s[3] in ['0','1','2']:\n                        if s[4] in ['0','1','2']:\n                            if s[5] in ['0','1','2']:\n                                return 6\n                            else:\n                                return 2\n                        else:\n                            return 2\n                    else:\n                        return 2\n                else:\n                    return 1\n            else:\n                return 1\n        \n        # if s is 7, return 7\n        if len(s) == 7:\n            if s[0] == '1' or s[0] == '2' and s[1] in ['0','1','2']:\n                if s[2] in ['0','1','2']:\n                    if s[3] in ['0','1','2']:\n                        if s[4] in ['0','1','2']:\n                            if s[5] in ['0','1','2']:\n                                if s[6] in ['0','1','2']:\n                                    return 7\n                                else:\n                                    return 2\n                            else:\n                                return 2\n                        else:\n                            return 2\n                    else:\n                        return 2\n                else:\n                    return 1\n            else:\n                return 1\n        \n        # if s is 8, return 8\n        if len(s) == 8:\n            if s[0] == '1' or s[0] == '2' and s[1] in ['0','1','2']:\n                if s[2] in ['0','1','2']:\n                    if s[3] in ['0','1','2']:\n                        if s[4] in ['0','1','2']:\n                            if s[5] in ['0','1','2']:\n                                if s[6] in ['0','1','2']"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) > len(t):\n        #     return False\n        # if len(s) == len(t):\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) > len(t):\n        #     return False\n        # if len(s) == len(t):\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) > len(t):\n        #     return False\n        # if len(s) == len(t):\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) > len(t):\n        #     return False\n        # if len(s) == len(t):\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) > len(t):\n        #     return False\n        # if len(s) == len(t):\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) > len(t):\n        #     return False\n        # if len(s) == len(t):\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) > len(t):\n        #     return False\n        # if len(s) == len(t):\n        #     return s == t\n        \n        # if s[0] == t[0]:\n        #     return self.isSubsequence(s[1:], t[1:])\n        # else:\n        #     return self.isSubsequence(s, t[1:])\n        \n        # if len(s) == 0:\n        #     return True\n        # if len(t) == 0:\n        #     return False\n        # if len(s) > len(t):\n        #     return False\n        # if len(s) == len(t):\n        #     return s == t\n        \n        # if"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the max number that can be represented by n bits\n        # 2. 2^n - 1 is the max number that can be represented by n bits\n        # 3. 2^n - 1 is the max number that can be represented by n bits\n        # 4. 2^n - 1 is the max number that can be represented by n bits\n        # 5. 2^n - 1 is the max number that can be represented by n bits\n        # 6. 2^n - 1 is the max number that can be represented by n bits\n        # 7. 2^n - 1 is the max number that can be represented by n bits\n        # 8. 2^n - 1 is the max number that can be represented by n bits\n        # 9. 2^n - 1 is the max number that can be represented by n bits\n        # 10. 2^n - 1 is the max number that can be represented by n bits\n        # 11. 2^n - 1 is the max number that can be represented by n bits\n        # 12. 2^n - 1 is the max number that can be represented by n bits\n        # 13. 2^n - 1 is the max number that can be represented by n bits\n        # 14. 2^n - 1 is the max number that can be represented by n bits\n        # 15. 2^n - 1 is the max number that can be represented by n bits\n        # 16. 2^n - 1 is the max number that can be represented by n bits\n        # 17. 2^n - 1 is the max number that can be represented by n bits\n        # 18. 2^n - 1 is the max number that can be represented by n bits\n        # 19. 2^n - 1 is the max number that can be represented by n bits\n        # 20. 2^n - 1 is the max number that can be represented by n bits\n        # 21. 2^n - 1 is the max number that can be represented by n bits\n        # 22. 2^n - 1 is the max number that can be represented by n bits\n        # 23. 2^n - 1 is the max number that can be represented by n bits\n        # 24. 2^n - 1 is the max number that can be represented by n bits\n        # 25. 2^n - 1 is the max number that can be represented by n bits\n        # 26. 2^n - 1 is the max number that can be represented by n bits\n        # 27. 2^n - 1 is the max number that can be represented by n bits\n        # 28. 2^n - 1 is the max number that can be represented by n bits\n        # 29. 2^n - 1 is the max number that can be represented by n bits\n        # 30. 2^n - 1 is the max number that can be represented by n bits\n        # 31. 2^n - 1 is the max number that can be represented by n bits\n        # 32. 2^n - 1 is the max number that can be represented by n bits\n        # 33. 2^n - 1 is the max number that can be represented by n bits\n        # 34. 2^n - 1 is the max number that can be represented by n bits\n        # 35. 2^n - 1 is the max number that can be represented by n bits\n        # 36. 2^n - 1 is the max number that can be represented by n bits\n        # 37. 2^n - 1 is the max number that can be represented by n bits\n        # 38. 2^n - 1 is the max number that can be represented by n bits\n        # 39. 2^n - 1 is the max number that can be represented by n bits\n        # 40. 2^n - 1 is the max number that can be represented by n bits\n        # 41. 2^n - 1 is the max number that can be represented by n bits\n        # 42. 2"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if n == 1:\n        #     return 1\n        # if n == 2:\n        #     return 2\n        # if n == 3:\n        #     return 3\n        # if n == 4:\n        #     return 5\n        # if n == 5:\n        #     return 8\n        # if n == 6:\n        #     return 13\n        # if n == 7:\n        #     return 21\n        # if n == 8:\n        #     return 34\n        # if n == 9:\n        #     return 55\n        # if n == 10:\n        #     return 89\n        # if n == 11:\n        #     return 144\n        # if n == 12:\n        #     return 233\n        # if n == 13:\n        #     return 377\n        # if n == 14:\n        #     return 610\n        # if n == 15:\n        #     return 987\n        # if n == 16:\n        #     return 1597\n        # if n == 17:\n        #     return 2584\n        # if n == 18:\n        #     return 4181\n        # if n == 19:\n        #     return 6765\n        # if n == 20:\n        #     return 10946\n        # if n == 21:\n        #     return 17711\n        # if n == 22:\n        #     return 28657\n        # if n == 23:\n        #     return 46368\n        # if n == 24:\n        #     return 75025\n        # if n == 25:\n        #     return 121393\n        # if n == 26:\n        #     return 196418\n        # if n == 27:\n        #     return 317811\n        # if n == 28:\n        #     return 514229\n        # if n == 29:\n        #     return 832040\n        # if n == 30:\n        #     return 1346269\n        # if n == 31:\n        #     return 2178309\n        # if n == 32:\n        #     return 3524578\n        # if n == 33:\n        #     return 5702887\n        # if n == 34:\n        #     return 9237416\n        # if n == 35:\n        #     return 14930352\n        # if n == 36:\n        #     return 24157817\n        # if n == 37:\n        #     return 39088169\n        # if n == 38:\n        #     return 63245986\n        # if n == 39:\n        #     return 102334155\n        # if n == 40:\n        #     return 165580141\n        # if n == 41:\n        #     return 267914296\n        # if n == 42:\n        #     return 433494437\n        # if n == 43:\n        #     return 701408733\n        # if n == 44:\n        #     return 1134903170\n        # if n == 45:\n        #     return 1836311903\n        # if n == 46:\n        #     return 2971215073\n        # if n == 47:\n        #     return 4807526976\n        # if n == 48:\n        #     return 7778742049\n        # if n == 49:\n        #     return 12586269025\n        # if n == 50:\n        #     return 2036501107"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3. If not, return False\n        ## 4. If sorted, return True\n        \n        ## 1. Inorder traversal\n        ## 2. Check if the inorder traversal is sorted\n        ## 3"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # edge case\n        if len(intervals) == 0:\n            return [newInterval]\n        \n        # edge case\n        if len(intervals) == 1:\n            if newInterval[0] <= intervals[0][0]:\n                intervals[0][0] = newInterval[0]\n                return intervals\n            else:\n                intervals.insert(0, newInterval)\n                return intervals\n        \n        # edge case\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2 log(n^2))\n        # Space Complexity: O(n^2)\n        \n        # BFS\n        # 1. Initialize a queue with the first element of the grid\n        # 2. Initialize a set with the first element of the grid\n        # 3. Initialize a variable to keep track of the time\n        # 4. While the queue is not empty\n        # 5. Pop the first element of the queue\n        # 6. If the popped element is the last element of the grid, return the time\n        # 7. Otherwise, for each of the four adjacent elements of the popped element\n        # 8. If the element is not visited and the element is not the last element of the grid\n        # 9. Add the element to the queue and the set\n        # 10. Add the element to the set\n        # 11. Add the element to the queue\n        # 12. Add the element to the set\n        # 13. Add the element to the queue\n        # 14. Add the element to the set\n        # 15. Add the element to the queue\n        # 16. Add the element to the set\n        # 17. Add the element to the queue\n        # 18. Add the element to the set\n        # 19. Add the element to the queue\n        # 20. Add the element to the set\n        # 21. Add the element to the queue\n        # 22. Add the element to the set\n        # 23. Add the element to the queue\n        # 24. Add the element to the set\n        # 25. Add the element to the queue\n        # 26. Add the element to the set\n        # 27. Add the element to the queue\n        # 28. Add the element to the set\n        # 29. Add the element to the queue\n        # 30. Add the element to the set\n        # 31. Add the element to the queue\n        # 32. Add the element to the set\n        # 33. Add the element to the queue\n        # 34. Add the element to the set\n        # 35. Add the element to the queue\n        # 36. Add the element to the set\n        # 37. Add the element to the queue\n        # 38. Add the element to the set\n        # 39. Add the element to the queue\n        # 40. Add the element to the set\n        # 41. Add the element to the queue\n        # 42. Add the element to the set\n        # 43. Add the element to the queue\n        # 44. Add the element to the set\n        # 45. Add the element to the queue\n        # 46. Add the element to the set\n        # 47. Add the element to the queue\n        # 48. Add the element to the set\n        # 49. Add the element to the queue\n        # 50. Add the element to the set\n        # 51. Add the element to the queue\n        # 52. Add the element to the set\n        # 53. Add the element to the queue\n        # 54. Add the element to the set\n        # 55. Add the element to the queue\n        # 56. Add the element to the set\n        # 57. Add the element to the queue\n        # 58. Add the element to the set\n        # 59. Add the element to the queue\n        # 60. Add the element to the set\n        # 61. Add the element to the queue\n        # 62. Add the element to the set\n        # 63. Add the element to the queue\n        # 64. Add the element to the set\n        # 65. Add the element to the queue\n        # 66. Add the element to the set\n        # 67. Add the element to the queue\n        # 68. Add the element to the set\n        # 69. Add the element to the queue\n        # 70. Add the element to the set\n        # 71. Add the element to the queue\n        # 72. Add the element to the set\n        # 73. Add the element to"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math\n        ## 3. Combination\n        ## 4. DFS\n        ## 5. BFS\n        ## 6. Backtracking\n        \n        ## 1. DP\n        ## 2. Math"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # edge case\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        # edge case\n        if num1 == \"1\":\n            return num2\n        if num2 == \"1\":\n            return num1\n        \n        # edge case\n        if num1 == \"2\":\n            if num2 == \"2\":\n                return \"4\"\n            else:\n                return num2\n        if num2 == \"2\":\n            return num1 + num1\n        \n        # edge case\n        if num1 == \"3\":\n            if num2 == \"3\":\n                return \"9\"\n            else:\n                return num2 + num2\n        if num2 == \"3\":\n            return num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"4\":\n            if num2 == \"4\":\n                return \"16\"\n            else:\n                return num2 + num2 + num2\n        if num2 == \"4\":\n            return num1 + num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"5\":\n            if num2 == \"5\":\n                return \"25\"\n            else:\n                return num2 + num2 + num2 + num2\n        if num2 == \"5\":\n            return num1 + num1 + num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"6\":\n            if num2 == \"6\":\n                return \"36\"\n            else:\n                return num2 + num2 + num2 + num2 + num2\n        if num2 == \"6\":\n            return num1 + num1 + num1 + num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"7\":\n            if num2 == \"7\":\n                return \"49\"\n            else:\n                return num2 + num2 + num2 + num2 + num2 + num2\n        if num2 == \"7\":\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"8\":\n            if num2 == \"8\":\n                return \"64\"\n            else:\n                return num2 + num2 + num2 + num2 + num2 + num2 + num2\n        if num2 == \"8\":\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"9\":\n            if num2 == \"9\":\n                return \"81\"\n            else:\n                return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        if num2 == \"9\":\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"10\":\n            if num2 == \"10\":\n                return \"100\"\n            else:\n                return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        if num2 == \"10\":\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"11\":\n            if num2 == \"11\":\n                return \"111\"\n            else:\n                return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        if num2 == \"11\":\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        # edge case\n        if num1 == \"12\":\n            if num2 == \"12\":\n                return \"121\"\n            else:\n                return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        if num2 == \"12\":\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current combination\n        current = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the index\n        index = 0\n        \n        # initialize the visited array\n        visited = [False] * len(candidates)\n        \n        # initialize the current index\n        current_index = 0\n        \n        # loop through the candidates\n        while index < len(candidates):\n            \n            # if the current sum is less than the target\n            if current_sum < target:\n                \n                # if the current sum is equal to the target\n                if current_sum == target:\n                    \n                    # add the current combination to the result\n                    result.append(current.copy())\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination\n                    current.pop()\n                    \n                    # remove the last element from the current combination"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(word) == 1:\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0].islower() and word[1].isupper():\n        #     return True\n        \n        # if word[0].isupper() and word[1].isupper():\n        #     return True\n        \n        # if word[0].islower() and word[1].islower():\n        #     return True\n        \n        # if word[0].isupper() and word[1].islower():\n        #     return True\n        \n        # if word[0"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # 1. Initialize stack and result\n        # 2. While root is not None or stack is not empty\n        # 3. If root is not None, push root to stack and move to left child\n        # 4. If root is None and stack is not empty, pop stack and add to result\n        # 5. If root is None and stack is empty, return result\n        \n        # 1. Initialize stack and result\n        stack = []\n        result = []\n        \n        # 2. While root is not None or stack is not empty\n        while root or stack:\n            # 3. If root is not None, push root to stack and move to left child\n            if root:\n                stack.append(root)\n                root = root.left\n            # 4. If root is None and stack is not empty, pop stack and add to result\n            else:\n                root = stack.pop()\n                result.append(root.val)\n                root = root.right\n        # 5. If root is None and stack is empty, return result\n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder[0])\n        # root_index = inorder.index(preorder[0])\n        # left_preorder = preorder[1:root_index+1]\n        # left_inorder = inorder[:root_index]\n        # right_preorder = preorder[root_index+1:]\n        # right_inorder = inorder[root_index+1:]\n        # root.left = self.buildTree(left_preorder, left_inorder)\n        # root.right = self.buildTree(right_preorder, right_inorder)\n        # return root\n        \n        # if len(preorder) == 0:\n        #     return None\n        # if len(preorder) == 1:\n        #     return TreeNode(preorder[0])\n        \n        # root = TreeNode(preorder"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. find the left and right count of the parentheses\n        # 2. find the left and right count of the parentheses\n        # 3. find the left and right count of the parentheses\n        # 4. find the left and right count of the parentheses\n        # 5. find the left and right count of the parentheses\n        # 6. find the left and right count of the parentheses\n        # 7. find the left and right count of the parentheses\n        # 8. find the left and right count of the parentheses\n        # 9. find the left and right count of the parentheses\n        # 10. find the left and right count of the parentheses\n        # 11. find the left and right count of the parentheses\n        # 12. find the left and right count of the parentheses\n        # 13. find the left and right count of the parentheses\n        # 14. find the left and right count of the parentheses\n        # 15. find the left and right count of the parentheses\n        # 16. find the left and right count of the parentheses\n        # 17. find the left and right count of the parentheses\n        # 18. find the left and right count of the parentheses\n        # 19. find the left and right count of the parentheses\n        # 20. find the left and right count of the parentheses\n        # 21. find the left and right count of the parentheses\n        # 22. find the left and right count of the parentheses\n        # 23. find the left and right count of the parentheses\n        # 24. find the left and right count of the parentheses\n        # 25. find the left and right count of the parentheses\n        # 26. find the left and right count of the parentheses\n        # 27. find the left and right count of the parentheses\n        # 28. find the left and right count of the parentheses\n        # 29. find the left and right count of the parentheses\n        # 30. find the left and right count of the parentheses\n        # 31. find the left and right count of the parentheses\n        # 32. find the left and right count of the parentheses\n        # 33. find the left and right count of the parentheses\n        # 34. find the left and right count of the parentheses\n        # 35. find the left and right count of the parentheses\n        # 36. find the left and right count of the parentheses\n        # 37. find the left and right count of the parentheses\n        # 38. find the left and right count of the parentheses\n        # 39. find the left and right count of the parentheses\n        # 40. find the left and right count of the parentheses\n        # 41. find the left and right count of the parentheses\n        # 42. find the left and right count of the parentheses\n        # 43. find the left and right count of the parentheses\n        # 44. find the left and right count of the parentheses\n        # 45. find the left and right count of the parentheses\n        # 46. find the left and right count of the parentheses\n        # 47. find the left and right count of the parentheses\n        # 48. find the left and right count of the parentheses\n        # 49. find the left and right count of the parentheses\n        # 50. find the left and right count of the parentheses\n        # 51. find the left and right count of the parentheses\n        # 52. find the left and right count of the parentheses\n        # 53. find the left and right count of the parentheses\n        # 54. find the left and right count of the parentheses\n        # 55. find the left and right count of the parentheses\n        # 56. find the left and right count of the parentheses\n        # 57. find the left and right count of the parentheses\n        # 58. find"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # if lists is empty\n        if not lists:\n            return None\n        \n        # if there is only one list\n        if len(lists) == 1:\n            return lists[0]\n        \n        # if there are more than one list\n        if len(lists) > 1:\n            # find the length of the list\n            length = len(lists)\n            \n            # find the middle index\n            mid = length // 2\n            \n            # split the list into two halves\n            left = lists[:mid]\n            right = lists[mid:]\n            \n            # recursively merge the two halves\n            left_head = self.mergeKLists(left)\n            right_head = self.mergeKLists(right)\n            \n            # merge the two halves\n            return self.merge(left_head, right_head)\n        \n        # if there is only one list\n        if len(lists) == 1:\n            return lists[0]\n        \n        # if there are more than one list\n        if len(lists) > 1:\n            # find the length of the list\n            length = len(lists)\n            \n            # find the middle index\n            mid = length // 2\n            \n            # split the list into two halves\n            left = lists[:mid]\n            right = lists[mid:]\n            \n            # recursively merge the two halves\n            left_head = self.mergeKLists(left)\n            right_head = self.mergeKLists(right)\n            \n            # merge the two halves\n            return self.merge(left_head, right_head)\n        \n        # if there is only one list\n        if len(lists) == 1:\n            return lists[0]\n        \n        # if there are more than one list\n        if len(lists) > 1:\n            # find the length of the list\n            length = len(lists)\n            \n            # find the middle index\n            mid = length // 2\n            \n            # split the list into two halves\n            left = lists[:mid]\n            right = lists[mid:]\n            \n            # recursively merge the two halves\n            left_head = self.mergeKLists(left)\n            right_head = self.mergeKLists(right)\n            \n            # merge the two halves\n            return self.merge(left_head, right_head)\n        \n        # if there is only one list\n        if len(lists) == 1:\n            return lists[0]\n        \n        # if there are more than one list\n        if len(lists) > 1:\n            # find the length of the list\n            length = len(lists)\n            \n            # find the middle index\n            mid = length // 2\n            \n            # split the list into two halves\n            left = lists[:mid]\n            right = lists[mid:]\n            \n            # recursively merge the two halves\n            left_head = self.mergeKLists(left)\n            right_head = self.mergeKLists(right)\n            \n            # merge the two halves\n            return self.merge(left_head, right_head)\n        \n        # if there is only one list\n        if len(lists) == 1:\n            return lists[0]\n        \n        # if there are more than one list\n        if len(lists) > 1:\n            # find the length of the list\n            length = len(lists)\n            \n            # find the middle index\n            mid = length // 2\n            \n            # split the list into two halves\n            left = lists[:mid]\n            right = lists[mid:]\n            \n            # recursively merge the two halves\n            left_head = self.mergeKLists(left)\n            right_head = self.mergeKLists(right)\n            \n            # merge the two halves\n            return self.merge(left_head, right_head)\n        \n        # if there is only one list\n        if len(lists) == 1:\n            return lists[0]\n        \n        # if there are more than one list\n        if len(lists) > 1:\n            # find the length of the list\n            length = len(lists)\n            \n            # find the middle index\n            mid = length // 2\n            \n            # split the list into two halves\n            left = lists[:mid]\n            right = lists[mid:]"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^10 = 10^5 * 5\n        # 2. 10^10 = 10^5 * 5\n        # 3. 10^10 = 10^5 * 5\n        # 4. 10^10 = 10^5 * 5\n        # 5. 10^10 = 10^5 * 5\n        # 6. 10^10 = 10^5 * 5\n        # 7. 10^10 = 10^5 * 5\n        # 8. 10^10 = 10^5 * 5\n        # 9. 10^10 = 10^5 * 5\n        # 10. 10^10 = 10^5 * 5\n        # 11. 10^10 = 10^5 * 5\n        # 12. 10^10 = 10^5 * 5\n        # 13. 10^10 = 10^5 * 5\n        # 14. 10^10 = 10^5 * 5\n        # 15. 10^10 = 10^5 * 5\n        # 16. 10^10 = 10^5 * 5\n        # 17. 10^10 = 10^5 * 5\n        # 18. 10^10 = 10^5 * 5\n        # 19. 10^10 = 10^5 * 5\n        # 20. 10^10 = 10^5 * 5\n        # 21. 10^10 = 10^5 * 5\n        # 22. 10^10 = 10^5 * 5\n        # 23. 10^10 = 10^5 * 5\n        # 24. 10^10 = 10^5 * 5\n        # 25. 10^10 = 10^5 * 5\n        # 26. 10^10 = 10^5 * 5\n        # 27. 10^10 = 10^5 * 5\n        # 28. 10^10 = 10^5 * 5\n        # 29. 10^10 = 10^5 * 5\n        # 30. 10^10 = 10^5 * 5\n        # 31. 10^10 = 10^5 * 5\n        # 32. 10^10 = 10^5 * 5\n        # 33. 10^10 = 10^5 * 5\n        # 34. 10^10 = 10^5 * 5\n        # 35. 10^10 = 10^5 * 5\n        # 36. 10^10 = 10^5 * 5\n        # 37. 10^10 = 10^5 * 5\n        # 38. 10^10 = 10^5 * 5\n        # 39. 10^10 = 10^5 * 5\n        # 40. 10^10 = 10^5 * 5\n        # 41. 10^10 = 10^5 * 5\n        # 42. 10^10 = 10^5 * 5\n        # 43. 10^10 = 10^5 * 5\n        # 44. 10^10 = 10^5 * 5\n        # 45. 10^10 = 10^5 * 5\n        # 46. 10^10 = 10^5 * 5\n        # 47. 10^10 = 10^5 * 5\n        # 48. 10^10 = 10^5 * 5\n        # 49. 10^10 = 10^5 * 5\n        # 5"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. build a hashmap of words\n        ## 2. build a hashmap of words reverse\n        ## 3. build a hashmap of words reverse and its index\n        ## 4. build a hashmap of words reverse and its index\n        ## 5. build a hashmap of words reverse and its index\n        ## 6. build a hashmap of words reverse and its index\n        ## 7. build a hashmap of words reverse and its index\n        ## 8. build a hashmap of words reverse and its index\n        ## 9. build a hashmap of words reverse and its index\n        ## 10. build a hashmap of words reverse and its index\n        ## 11. build a hashmap of words reverse and its index\n        ## 12. build a hashmap of words reverse and its index\n        ## 13. build a hashmap of words reverse and its index\n        ## 14. build a hashmap of words reverse and its index\n        ## 15. build a hashmap of words reverse and its index\n        ## 16. build a hashmap of words reverse and its index\n        ## 17. build a hashmap of words reverse and its index\n        ## 18. build a hashmap of words reverse and its index\n        ## 19. build a hashmap of words reverse and its index\n        ## 20. build a hashmap of words reverse and its index\n        ## 21. build a hashmap of words reverse and its index\n        ## 22. build a hashmap of words reverse and its index\n        ## 23. build a hashmap of words reverse and its index\n        ## 24. build a hashmap of words reverse and its index\n        ## 25. build a hashmap of words reverse and its index\n        ## 26. build a hashmap of words reverse and its index\n        ## 27. build a hashmap of words reverse and its index\n        ## 28. build a hashmap of words reverse and its index\n        ## 29. build a hashmap of words reverse and its index\n        ## 30. build a hashmap of words reverse and its index\n        ## 31. build a hashmap of words reverse and its index\n        ## 32. build a hashmap of words reverse and its index\n        ## 33. build a hashmap of words reverse and its index\n        ## 34. build a hashmap of words reverse and its index\n        ## 35. build a hashmap of words reverse and its index\n        ## 36. build a hashmap of words reverse and its index\n        ## 37. build a hashmap of words reverse and its index\n        ## 38. build a hashmap of words reverse and its index\n        ## 39. build a hashmap of words reverse and its index\n        ## 40. build a hashmap of words reverse and its index\n        ## 41. build a hashmap of words reverse and its index\n        ## 42. build a hashmap of words reverse and its index\n        ## 43. build a hashmap of words reverse and its index\n        ## 44. build a hashmap of words reverse and its index\n        ## 45. build a hashmap of words reverse and its index\n        ## 46. build a hashmap of words reverse and its index\n        ## 47. build a hashmap of words reverse and its index\n        ## 48. build a hashmap of words reverse and its index\n        ## 49. build a hashmap of words reverse and its index\n        ## 50. build a hashmap of words reverse and its index\n        ## 51. build a hashmap of words reverse and its index\n        ## 52. build a hashmap of words reverse and its index\n        ## 53. build a hashmap of words reverse and its index\n        ## 54. build a hashmap of words reverse and its index\n        ## 55. build a hashmap of words reverse and its index\n        ## 56. build a hashmap of words reverse and its index\n        ## 57. build a hashmap of words reverse and its index\n        ## 58. build a hashmap of words reverse"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums[0])\n        \n        # mid = len(nums) // 2\n        # root = TreeNode(nums[mid])\n        # root.left = self.sortedArrayToBST(nums[:mid])\n        # root.right = self.sortedArrayToBST(nums[mid+1:])\n        # return root\n        \n        # if len(nums) == 0:\n        #     return None\n        # if len(nums) == 1:\n        #     return TreeNode(nums["}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region\n        # 3. Repeat until no more walls can be built\n        \n        # 1. Find the largest region\n        # 2. Build walls to infect the largest region"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # cache the longest increasing path for each cell\n        cache = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path = 0\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_2 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_3 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_4 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_5 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_6 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_7 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_8 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_9 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_10 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_11 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_12 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_13 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_14 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_15 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_16 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_17 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_18 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_19 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_20 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_21 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_22 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_23 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_24 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_25 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache_26 = [[0] * n for _ in range(m)]\n        \n        # cache the longest increasing path for each cell\n        longest_path_cache"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        ## DP solution\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## 1. Create a dictionary of words in wordDict\n        ## 2. Create a list of size n+1, where n is the length of s\n        ## 3. Iterate through the list of size n+1\n        ## 4. For each index, check if the substring of s[:i] is in the dictionary\n        ## 5. If it is, then add the substring of s[:i] to the list of words\n        ## 6. If the substring of s[:i] is not in the dictionary, then check if the substring of s[:i-1] is in the dictionary\n        ## 7. If it is, then add the substring of s[:i-1] to the list of words\n        ## 8. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 9. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 10. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 11. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 12. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 13. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 14. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 15. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 16. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 17. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 18. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 19. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 20. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 21. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 22. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 23. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 24. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 25. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 26. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 27. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 28. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 29. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to the list of words\n        ## 30. If the substring of s[:i-1] is not in the dictionary, then return []\n        ## 31. If the substring of s[:i-1] is in the dictionary, then add the substring of s[:i-1] to"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        # BFS\n        # queue = [root]\n        # level = 0\n        # res = []\n        # while queue:\n        #     level += 1\n        #     level_nodes = []\n        #     for _ in range(len(queue)):\n        #         node = queue.pop(0)\n        #         level_nodes.append(node.val)\n        #         if node.left:\n        #             queue.append(node.left)\n        #         if node.right:\n        #             queue.append(node.right)\n        #     if level % 2 == 0:\n        #         res.append(level_nodes[::-1])\n        #     else:\n        #         res.append(level_nodes)\n        # return res\n        \n        # DFS\n        # stack = [(root, 0)]\n        # res = []\n        # while stack:\n        #     node, level = stack.pop()\n        #     if node:\n        #         if level >= len(res):\n        #             res.append([node.val])\n        #         else:\n        #             res[level].append(node.val)\n        #         stack.append((node.left, level + 1))\n        #         stack.append((node.right, level + 1))\n        # return res\n        \n        # DFS\n        # stack = [(root, 0)]\n        # res = []\n        # while stack:\n        #     node, level = stack.pop()\n        #     if node:\n        #         if level >= len(res):\n        #             res.append([node.val])\n        #         else:\n        #             res[level].append(node.val)\n        #         stack.append((node.right, level + 1))\n        #         stack.append((node.left, level + 1))\n        # return res\n        \n        # DFS\n        # stack = [(root, 0)]\n        # res = []\n        # while stack:\n        #     node, level = stack.pop()\n        #     if node:\n        #         if level >= len(res):\n        #             res.append([node.val])\n        #         else:\n        #             res[level].append(node.val)\n        #         stack.append((node.left, level + 1))\n        #         stack.append((node.right, level + 1))\n        # return res\n        \n        # DFS\n        # stack = [(root, 0)]\n        # res = []\n        # while stack:\n        #     node, level = stack.pop()\n        #     if node:\n        #         if level >= len(res):\n        #             res.append([node.val])\n        #         else:\n        #             res[level].append(node.val)\n        #         stack.append((node.right, level + 1))\n        #         stack.append((node.left, level + 1))\n        # return res\n        \n        # DFS\n        # stack = [(root, 0)]\n        # res = []\n        # while stack:\n        #     node, level = stack.pop()\n        #     if node:\n        #         if level >= len(res):\n        #             res.append([node.val])\n        #         else:\n        #             res[level].append(node.val)\n        #         stack.append((node.left, level + 1))\n        #         stack.append((node.right, level + 1))\n        # return res\n        \n        # DFS\n        # stack = [(root, 0)]\n        # res = []\n        # while stack:\n        #     node, level = stack.pop()\n        #     if node:\n        #         if level >= len(res):\n        #             res.append([node.val])\n        #         else:\n        #             res[level].append(node.val)\n        #         stack.append((node.right, level + 1))\n        #         stack.append((node.left, level + 1))\n        # return res\n        \n        # DFS\n        # stack = [(root, 0)]\n        # res = []\n        # while stack:\n        #     node, level = stack.pop()\n        #     if node:\n        #"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        # initialize the list\n        res = [[1], [1,1]]\n        \n        # iterate from 3rd row to numRows\n        for i in range(2, numRows):\n            # initialize the list\n            temp = [1]\n            \n            # iterate from 1st to i-1th element\n            for j in range(1, i):\n                # add the sum of the two elements\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            \n            # add the last element\n            temp.append(1)\n            \n            # add the list to the result\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 3 == 0:\n        #     return self.isPowerOfThree(n/3)\n        # return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Recursive solution\n        ## 2. DFS\n        ## 3. BFS\n        ## 4. DFS + cache\n        ## 5. DFS + cache + memoization\n        ## 6. DFS + cache + memoization + pruning\n        ## 7. DFS + cache + memoization + pruning + postorder traversal\n        ## 8. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal\n        ## 9. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 10. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 11. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 12. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 13. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 14. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 15. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 16. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 17. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 18. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal\n        ## 19. DFS + cache + memoization + pruning + postorder traversal + postorder traversal + postorder traversal + postorder traversal + postorder traversal"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        #edge case\n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        #initialize variables\n        m = len(heightMap)\n        n = len(heightMap[0])\n        visited = [[False for _ in range(n)] for _ in range(m)]\n        heap = []\n        #initialize heap\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        #initialize directions\n        directions = [[1,0], [-1,0], [0,1], [0,-1]]\n        #initialize maxes\n        max_left = [float('inf') for _ in range(n)]\n        max_right = [float('inf') for _ in range(n)]\n        max_up = [float('inf') for _ in range(m)]\n        max_down = [float('inf') for _ in range(m)]\n        \n        #initialize maxes\n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    max_up[i] = heightMap[i][j]\n                if i == m-1:\n                    max_down[i] = heightMap[i][j]\n                if j == 0:\n                    max_left[j] = heightMap[i][j]\n                if j == n-1:\n                    max_right[j] = heightMap[i][j]\n        \n        #initialize water\n        water = 0\n        \n        #loop through heap\n        while heap:\n            #pop from heap\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            #loop through directions\n            for d in directions:\n                #get new i, j\n                new_i = curr_i + d[0]\n                new_j = curr_j + d[1]\n                #check if new i, j is valid\n                if new_i < 0 or new_i >= m or new_j < 0 or new_j >= n:\n                    continue\n                #check if visited\n                if visited[new_i][new_j]:\n                    continue\n                #check if new height is less than curr height\n                if heightMap[new_i][new_j] <= curr_height:\n                    continue\n                #update water\n                water += curr_height - heightMap[new_i][new_j]\n                #update maxes\n                max_left[new_j] = max(max_left[new_j], heightMap[new_i][new_j])\n                max_right[new_j] = max(max_right[new_j], heightMap[new_i][new_j])\n                max_up[new_i] = max(max_up[new_i], heightMap[new_i][new_j])\n                max_down[new_i] = max(max_down[new_i], heightMap[new_i][new_j])\n                #update visited\n                visited[new_i][new_j] = True\n                #push to heap\n                heapq.heappush(heap, (heightMap[new_i][new_j], new_i, new_j))\n        \n        #loop through maxes\n        for i in range(m):\n            for j in range(n):\n                #check if max is less than curr height\n                if max_left[j] <= heightMap[i][j] or max_right[j] <= heightMap[i][j] or max_up[i] <= heightMap[i][j] or max_down[i] <= heightMap[i][j]:\n                    continue\n                #update water\n                water += max_left[j] - heightMap[i][j]\n                water += max_right[j] - heightMap[i][j]\n                water += max_up[i] - heightMap[i][j]\n                water += max_down[i] - heightMap[i][j]\n        \n        return water"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters to lowercase letters\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # if k is odd, then the median is the middle value\n        # if k is even, then the median is the mean of the two middle values\n        # if k is 1, then the median is the first value\n        \n        # if k is 1, then the median is the first value\n        if k == 1:\n            return [min(nums)]\n        \n        # if k is 2, then the median is the mean of the two middle values\n        if k == 2:\n            return [(nums[0] + nums[1]) / 2.0]\n        \n        # if k is 3, then the median is the median of the three middle values\n        if k == 3:\n            return [(nums[0] + nums[1] + nums[2]) / 3.0]\n        \n        # if k is 4, then the median is the median of the four middle values\n        if k == 4:\n            return [(nums[0] + nums[1] + nums[2] + nums[3]) / 4.0]\n        \n        # if k is 5, then the median is the median of the five middle values\n        if k == 5:\n            return [(nums[0] + nums[1] + nums[2] + nums[3] + nums[4]) / 5.0]\n        \n        # if k is 6, then the median is the median of the six middle values\n        if k == 6:\n            return [(nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]) / 6.0]\n        \n        # if k is 7, then the median is the median of the seven middle values\n        if k == 7:\n            return [(nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6]) / 7.0]\n        \n        # if k is 8, then the median is the median of the eight middle values\n        if k == 8:\n            return [(nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7]) / 8.0]\n        \n        # if k is 9, then the median is the median of the nine middle values\n        if k == 9:\n            return [(nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8]) / 9.0]\n        \n        # if k is 10, then the median is the median of the ten middle values\n        if k == 10:\n            return [(nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8] + nums[9]) / 10.0]\n        \n        # if k is 11, then the median is the median of the eleven middle values\n        if k == 11:\n            return [(nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8] + nums[9] + nums[10]) / 11.0]\n        \n        # if k is 12, then the median is the median of the twelve middle values\n        if k == 12:\n            return [(nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8] + nums[9] + nums[10] + nums[11]) / 12.0]\n        \n        # if k is 13, then the median is the median of the thirteen middle values\n        if k == 13:\n            return [("}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is larger than the length of the list, we need to rotate it by k % length\n        if k >= length:\n            k = k % length\n        \n        # if k is 0, we don't need to rotate the list\n        if k == 0:\n            return head\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = new_head\n        while new_tail.next:\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = head\n        \n        # cut the old list off\n        new_head = new_head.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n == 1:\n            return True\n        \n        if n % 2 == 0:\n            return self.isUgly(n // 2)\n        \n        if n % 3 == 0:\n            return self.isUgly(n // 3)\n        \n        if n % 5 == 0:\n            return self.isUgly(n // 5)\n        \n        return False"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.left)\n        \n        return root.left.val + self.sumOfLeftLeaves(root.right) + self.sumOfLeftLeaves(root.left)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. 2D prefix sum\n        ## 2. 2D binary search\n        ## 3. 1D binary search\n        ## 4. 2D binary search\n        ## 5. 2D binary search\n        ## 6. 2D binary search\n        ## 7. 2D binary search\n        ## 8. 2D binary search\n        ## 9. 2D binary search\n        ## 10. 2D binary search\n        ## 11. 2D binary search\n        ## 12. 2D binary search\n        ## 13. 2D binary search\n        ## 14. 2D binary search\n        ## 15. 2D binary search\n        ## 16. 2D binary search\n        ## 17. 2D binary search\n        ## 18. 2D binary search\n        ## 19. 2D binary search\n        ## 20. 2D binary search\n        ## 21. 2D binary search\n        ## 22. 2D binary search\n        ## 23. 2D binary search\n        ## 24. 2D binary search\n        ## 25. 2D binary search\n        ## 26. 2D binary search\n        ## 27. 2D binary search\n        ## 28. 2D binary search\n        ## 29. 2D binary search\n        ## 30. 2D binary search\n        ## 31. 2D binary search\n        ## 32. 2D binary search\n        ## 33. 2D binary search\n        ## 34. 2D binary search\n        ## 35. 2D binary search\n        ## 36. 2D binary search\n        ## 37. 2D binary search\n        ## 38. 2D binary search\n        ## 39. 2D binary search\n        ## 40. 2D binary search\n        ## 41. 2D binary search\n        ## 42. 2D binary search\n        ## 43. 2D binary search\n        ## 44. 2D binary search\n        ## 45. 2D binary search\n        ## 46. 2D binary search\n        ## 47. 2D binary search\n        ## 48. 2D binary search\n        ## 49. 2D binary search\n        ## 50. 2D binary search\n        ## 51. 2D binary search\n        ## 52. 2D binary search\n        ## 53. 2D binary search\n        ## 54. 2D binary search\n        ## 55. 2D binary search\n        ## 56. 2D binary search\n        ## 57. 2D binary search\n        ## 58. 2D binary search\n        ## 59. 2D binary search\n        ## 60. 2D binary search\n        ## 61. 2D binary search\n        ## 62. 2D binary search\n        ## 63. 2D binary search\n        ## 64. 2D binary search\n        ## 65. 2D binary search\n        ## 66. 2D binary search\n        ## 67. 2D binary search\n        ## 68. 2D binary search\n        ## 69. 2D binary search\n        ## 70. 2D binary search\n        ## 71. 2D binary search\n        ## 72. 2D binary search\n        ## 73. 2D binary search\n        ## 74. 2D binary search\n        ## 75. 2D binary search\n        ## 76. 2D binary search\n        ## 77. 2D binary search\n        ## 78. 2D binary search\n        ## 79. 2D binary search\n        ## 80"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if dividend == 0:\n            return 0\n        \n        # edge case\n        if divisor == 1:\n            return dividend\n        \n        # edge case\n        if divisor == -1:\n            if dividend == -2147483648:\n                return 2147483647\n            else:\n                return -dividend\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == 1:\n                return -2147483648\n            elif divisor == -1:\n                return 2147483647\n            else:\n                return 0\n        \n        # edge case\n        if divisor == -2147483648:\n            if dividend == -2147483648:\n                return 1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == -1:\n                return 2147483647\n            else:\n                return -1\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == 1:\n                return 2147483647\n            elif divisor == -1:\n                return -2147483648\n            else:\n                return 0\n        \n        # edge case\n        if divisor == 2147483647:\n            if dividend == -2147483648:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == -1:\n                return -2147483648\n            else:\n                return 1\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == -2147483648:\n                return 1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == 2147483647:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == -2147483648:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == -2147483648:\n                return 1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == -2147483648:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == 2147483647:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == 2147483647:\n                return 1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == 2147483647:\n                return -1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == 2147483647:\n            if divisor == 2147483647:\n                return 1\n            else:\n                return 0\n        \n        # edge case\n        if dividend == -2147483648:\n            if divisor == -214748364"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        ## 1. Find all the O's on the border\n        ## 2. Mark all the O's on the border as visited\n        ## 3. For each O, if it is not visited, then it is a part of the island\n        ## 4. For each O, if it is not visited, then it is a part of the island\n        ## 5. For each O, if it is not visited, then it is a part of the island\n        ## 6. For each O, if it is not visited, then it is a part of the island\n        ## 7. For each O, if it is not visited, then it is a part of the island\n        ## 8. For each O, if it is not visited, then it is a part of the island\n        ## 9. For each O, if it is not visited, then it is a part of the island\n        ## 10. For each O, if it is not visited, then it is a part of the island\n        ## 11. For each O, if it is not visited, then it is a part of the island\n        ## 12. For each O, if it is not visited, then it is a part of the island\n        ## 13. For each O, if it is not visited, then it is a part of the island\n        ## 14. For each O, if it is not visited, then it is a part of the island\n        ## 15. For each O, if it is not visited, then it is a part of the island\n        ## 16. For each O, if it is not visited, then it is a part of the island\n        ## 17. For each O, if it is not visited, then it is a part of the island\n        ## 18. For each O, if it is not visited, then it is a part of the island\n        ## 19. For each O, if it is not visited, then it is a part of the island\n        ## 20. For each O, if it is not visited, then it is a part of the island\n        ## 21. For each O, if it is not visited, then it is a part of the island\n        ## 22. For each O, if it is not visited, then it is a part of the island\n        ## 23. For each O, if it is not visited, then it is a part of the island\n        ## 24. For each O, if it is not visited, then it is a part of the island\n        ## 25. For each O, if it is not visited, then it is a part of the island\n        ## 26. For each O, if it is not visited, then it is a part of the island\n        ## 27. For each O, if it is not visited, then it is a part of the island\n        ## 28. For each O, if it is not visited, then it is a part of the island\n        ## 29. For each O, if it is not visited, then it is a part of the island\n        ## 30. For each O, if it is not visited, then it is a part of the island\n        ## 31. For each O, if it is not visited, then it is a part of the island\n        ## 32. For each O, if it is not visited, then it is a part of the island\n        ## 33. For each O, if it is not visited, then it is a part of the island\n        ## 34. For each O, if it is not visited, then it is a part of the island\n        ## 35. For each O, if it is not visited, then it is a part of the island\n        ## 36. For each O, if it is not visited, then it is a part of the island\n        ## 37. For each O, if it is not visited, then it is a part of the island\n        ## 38. For each O, if it is not visited, then it is a part of the island\n        ## 39. For each O, if it is not visited, then it is a part of the island\n        ## 40. For each O, if it is not visited, then it is a part of the island\n        ## 41. For each"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## \n        ## for i in range(len(nums)):\n        ##     for j in range(i+1, len(nums)):\n        ##         if nums[i] + nums[j] == target:\n        ##             return [i,j]\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## \n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Two-pointer\n        ## Time complexity: O(nlogn)\n        ## Space complexity: O(1)\n        ## \n        ## nums.sort()\n        ## left = 0\n        ## right = len(nums) - 1\n        ## while left < right:\n        ##     if nums[left] + nums[right] == target:\n        ##         return [left, right]\n        ##     elif nums[left] + nums[right] < target:\n        ##         left += 1\n        ##     else:\n        ##         right -= 1\n        ## return [-1, -1]\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## \n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## \n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## \n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## \n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## \n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap:\n        ##         return [hashmap[complement], i]\n        ##     hashmap[nums[i]] = i\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## \n        ## hashmap = {}\n        ## for i in range(len(nums)):\n        ##     complement = target - nums[i]\n        ##     if complement in hashmap"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            if len(cards) == 2:\n                return abs(cards[0] * 4 - target) < 1e-6 or abs(cards[1] * 4 - target) < 1e-6\n            \n            if len(cards) == 3:\n                return abs(cards[0] * 3 - target) < 1e-6 or abs(cards[1] * 3 - target) < 1e-6 or abs(cards[2] * 3 - target) < 1e-6\n            \n            if len(cards) == 4:\n                return abs(cards[0] * 2 - target) < 1e-6 or abs(cards[1] * 2 - target) < 1e-6 or abs(cards[2] * 2 - target) < 1e-6 or abs(cards[3] * 2 - target) < 1e-6\n            \n            # 4 cards\n            # 1. 2 cards\n            # 2. 3 cards\n            # 3. 4 cards\n            # 4. 5 cards\n            # 5. 6 cards\n            # 6. 7 cards\n            # 7. 8 cards\n            # 8. 9 cards\n            # 9. 10 cards\n            # 10. 11 cards\n            # 11. 12 cards\n            # 12. 13 cards\n            # 13. 14 cards\n            # 14. 15 cards\n            # 15. 16 cards\n            # 16. 17 cards\n            # 17. 18 cards\n            # 18. 19 cards\n            # 19. 20 cards\n            # 20. 21 cards\n            # 21. 22 cards\n            # 22. 23 cards\n            # 23. 24 cards\n            # 24. 25 cards\n            # 25. 26 cards\n            # 26. 27 cards\n            # 27. 28 cards\n            # 28. 29 cards\n            # 29. 30 cards\n            # 30. 31 cards\n            # 31. 32 cards\n            # 32. 33 cards\n            # 33. 34 cards\n            # 34. 35 cards\n            # 35. 36 cards\n            # 36. 37 cards\n            # 37. 38 cards\n            # 38. 39 cards\n            # 39. 40 cards\n            # 40. 41 cards\n            # 41. 42 cards\n            # 42. 43 cards\n            # 43. 44 cards\n            # 44. 45 cards\n            # 45. 46 cards\n            # 46. 47 cards\n            # 47. 48 cards\n            # 48. 49 cards\n            # 49. 50 cards\n            # 50. 51 cards\n            # 51. 52 cards\n            # 52. 53 cards\n            # 53. 54 cards\n            # 54. 55 cards\n            # 55. 56 cards\n            # 56. 57 cards\n            # 57. 58 cards\n            # 58. 59 cards\n            # 59. 60 cards\n            # 60. 61 cards\n            # 61. 62 cards\n            # 62. 63 cards\n            # 63. 64 cards\n            # 64. 65 cards\n            # 65. 66 cards\n            # 66. 67 cards\n            # 67. 68 cards\n            # 68. 69 cards\n            # 69. 70 cards\n            # 70. 71 cards\n            # 71."}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if len(p) == 0:\n            return len(s) == 0\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'\n        \n        # if p is not empty, then s must not be empty\n        if len(s) == 0:\n            return len(p) == 1 and p[0] == '*'"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.youtube.com/watch?v=YX1zYsKj9_s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=NeetCode\n        # https://www.youtube.com/watch?v=_ZjYj-_Js2s&ab_channel=Ne"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        # build a hashmap\n        # build a stack\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set\n        # build a result stack\n        # build a hashmap\n        # build a queue\n        # build a visited set"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        # print(nums)\n        # print(target)\n        # print(len(nums))\n        # print(nums[0])\n        # print(nums[-1])\n        # print(nums[0] + nums[-1])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8] + nums[8] + nums[-9])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8] + nums[8] + nums[-9] + nums[9] + nums[-10])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8] + nums[8] + nums[-9] + nums[9] + nums[-10] + nums[10] + nums[-11])\n        # print(nums[0] + nums[-1] + nums[1] + nums[-2] + nums[2] + nums[-3] + nums[3] + nums[-4] + nums[4] + nums[-5] + nums[5] + nums[-6] + nums[6] + nums[-7] + nums[7] + nums[-8] + nums[8] + nums[-9] + nums[9] + nums[-10] + num"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize result\n        result = [[0,0]]\n        \n        # initialize max height\n        max_height = 0\n        \n        # initialize current building\n        curr_building = None\n        \n        # initialize current building index\n        curr_building_index = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building height\n        max_building_height = 0\n        \n        # initialize max building index\n        max_building_index = len(buildings) - 1\n        \n        # initialize max building"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. Two pointer approach\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 2. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 3. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 4. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 5. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 6. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 7. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 8. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 9. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 10. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 11. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 12. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 13. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 14. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 15. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 16. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 17. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 18. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 19. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 20. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 21. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 22. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 23. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 24. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 25. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 26. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 27. Reverse the string\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # 28. Reverse"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        # return prev\n        \n        # recursive\n        if not head:\n            return None\n        if not head.next:\n            return head\n        new_head = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.reverseList(head.next)\n        # head.next.next = head\n        # head.next = None\n        # return new_head\n        \n        # recursive\n        # if not head:\n        #     return None\n        # if not head.next:\n        #     return head\n        # new_head = self.re"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if len(triangle) == 1:\n        #     return triangle[0][0]\n        # if len(triangle) == 2:\n        #     return triangle[0][0] + triangle[1][0]\n        # if len(triangle) == 3:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0])\n        # if len(triangle) == 4:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0]) + min(triangle[2][1], triangle[3][0])\n        # if len(triangle) == 5:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0]) + min(triangle[2][1], triangle[3][0]) + min(triangle[3][2], triangle[4][0])\n        # if len(triangle) == 6:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0]) + min(triangle[2][1], triangle[3][0]) + min(triangle[3][2], triangle[4][0]) + min(triangle[4][3], triangle[5][0])\n        # if len(triangle) == 7:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0]) + min(triangle[2][1], triangle[3][0]) + min(triangle[3][2], triangle[4][0]) + min(triangle[4][3], triangle[5][0]) + min(triangle[5][4], triangle[6][0])\n        # if len(triangle) == 8:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0]) + min(triangle[2][1], triangle[3][0]) + min(triangle[3][2], triangle[4][0]) + min(triangle[4][3], triangle[5][0]) + min(triangle[5][4], triangle[6][0]) + min(triangle[6][5], triangle[7][0])\n        # if len(triangle) == 9:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0]) + min(triangle[2][1], triangle[3][0]) + min(triangle[3][2], triangle[4][0]) + min(triangle[4][3], triangle[5][0]) + min(triangle[5][4], triangle[6][0]) + min(triangle[6][5], triangle[7][0]) + min(triangle[7][6], triangle[8][0])\n        # if len(triangle) == 10:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0]) + min(triangle[2][1], triangle[3][0]) + min(triangle[3][2], triangle[4][0]) + min(triangle[4][3], triangle[5][0]) + min(triangle[5][4], triangle[6][0]) + min(triangle[6][5], triangle[7][0]) + min(triangle[7][6], triangle[8][0]) + min(triangle[8][7], triangle[9][0])\n        # if len(triangle) == 11:\n        #     return min(triangle[0][0], triangle[1][0]) + min(triangle[1][1], triangle[2][0]) + min(triangle[2][1], triangle[3][0]) + min(triangle[3][2], triangle[4][0]) + min(triangle[4][3], triangle[5][0]) + min(triangle[5][4], triangle[6][0]) + min(triangle[6][5], triangle[7][0]) + min(triangle[7][6], triangle[8][0]) + min(triangle[8][7], triangle[9][0]) + min(triangle[9][8], triangle[10][0])\n        # if len(triangle) == 12:\n        #     return min(triangle[0][0], triangle"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            # 1st node\n            node1 = prev.next\n            # 2nd node\n            node2 = node1.next\n            # 3rd node\n            node3 = node2.next\n            \n            # 3rd node is the 1st node\n            node2.next = node1\n            # 1st node is the 2nd node\n            node1.next = node3\n            # 2nd node is the 3rd node\n            prev.next = node2\n            \n            # 1st node is the 3rd node\n            prev = node1\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        # if root is None:\n        #     return False\n        # if root.left is None and root.right is None:\n        #     return root.val == targetSum\n        # if root.left is None:\n        #     return self.hasPathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.hasPathSum(root.left, targetSum - root.val)\n        # return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)\n        \n        #"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create two dummy nodes\n        # 2. create two pointers, one for the smaller list, one for the larger list\n        # 3. traverse the list, if the value is smaller than x, add it to the smaller list, otherwise add it to the larger list\n        # 4. connect the smaller list to the larger list\n        # 5. return the smaller list\n        \n        # 1. create two dummy nodes\n        smaller = ListNode(0)\n        larger = ListNode(0)\n        \n        # 2. create two pointers, one for the smaller list, one for the larger list\n        smaller_tail = smaller\n        larger_tail = larger\n        \n        # 3. traverse the list, if the value is smaller than x, add it to the smaller list, otherwise add it to the larger list\n        curr = head\n        while curr:\n            if curr.val < x:\n                smaller_tail.next = curr\n                smaller_tail = smaller_tail.next\n            else:\n                larger_tail.next = curr\n                larger_tail = larger_tail.next\n            curr = curr.next\n        \n        # 4. connect the smaller list to the larger list\n        smaller_tail.next = larger.next\n        larger_tail.next = None\n        \n        # 5. return the smaller list\n        return smaller.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # edge 1: (1,2)\n        # edge 2: (2,3)\n        # edge 3: (3,4)\n        # edge 4: (4,1)\n        # edge 5: (1,5)\n        \n        # edge 1: (1,2)\n        # edge 2: (2,3)\n        # edge 3: (3,4)\n        # edge 4: (4,1)\n        # edge 5: (1,5)\n        # edge 6: (5,6)\n        # edge 7: (6,7)\n        # edge 8: (7,8)\n        # edge 9: (8,9)\n        # edge 10: (9,10)\n        # edge 11: (10,11)\n        # edge 12: (11,12)\n        # edge 13: (12,13)\n        # edge 14: (13,14)\n        # edge 15: (14,15)\n        # edge 16: (15,16)\n        # edge 17: (16,17)\n        # edge 18: (17,18)\n        # edge 19: (18,19)\n        # edge 20: (19,20)\n        # edge 21: (20,21)\n        # edge 22: (21,22)\n        # edge 23: (22,23)\n        # edge 24: (23,24)\n        # edge 25: (24,25)\n        # edge 26: (25,26)\n        # edge 27: (26,27)\n        # edge 28: (27,28)\n        # edge 29: (28,29)\n        # edge 30: (29,30)\n        # edge 31: (30,31)\n        # edge 32: (31,32)\n        # edge 33: (32,33)\n        # edge 34: (33,34)\n        # edge 35: (34,35)\n        # edge 36: (35,36)\n        # edge 37: (36,37)\n        # edge 38: (37,38)\n        # edge 39: (38,39)\n        # edge 40: (39,40)\n        # edge 41: (40,41)\n        # edge 42: (41,42)\n        # edge 43: (42,43)\n        # edge 44: (43,44)\n        # edge 45: (44,45)\n        # edge 46: (45,46)\n        # edge 47: (46,47)\n        # edge 48: (47,48)\n        # edge 49: (48,49)\n        # edge 50: (49,50)\n        # edge 51: (50,51)\n        # edge 52: (51,52)\n        # edge 53: (52,53)\n        # edge 54: (53,54)\n        # edge 55: (54,55)\n        # edge 56: (55,56)\n        # edge 57: (56,57)\n        # edge 58: (57,58)\n        # edge 59: (58,59)\n        # edge 60: (59,60)\n        # edge 61: (60,61)\n        # edge 62: (61,62)\n        # edge 63: (62,63)\n        # edge 64: (63,64)\n        # edge 65: (64,65)\n        # edge 66: (65,66)"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. sort the list\n        ## 2. use a set to store the unique permutations\n        ## 3. use a set to store the unique permutations\n        ## 4. use a set to store the unique permutations\n        ## 5. use a set to store the unique permutations\n        ## 6. use a set to store the unique permutations\n        ## 7. use a set to store the unique permutations\n        ## 8. use a set to store the unique permutations\n        ## 9. use a set to store the unique permutations\n        ## 10. use a set to store the unique permutations\n        ## 11. use a set to store the unique permutations\n        ## 12. use a set to store the unique permutations\n        ## 13. use a set to store the unique permutations\n        ## 14. use a set to store the unique permutations\n        ## 15. use a set to store the unique permutations\n        ## 16. use a set to store the unique permutations\n        ## 17. use a set to store the unique permutations\n        ## 18. use a set to store the unique permutations\n        ## 19. use a set to store the unique permutations\n        ## 20. use a set to store the unique permutations\n        ## 21. use a set to store the unique permutations\n        ## 22. use a set to store the unique permutations\n        ## 23. use a set to store the unique permutations\n        ## 24. use a set to store the unique permutations\n        ## 25. use a set to store the unique permutations\n        ## 26. use a set to store the unique permutations\n        ## 27. use a set to store the unique permutations\n        ## 28. use a set to store the unique permutations\n        ## 29. use a set to store the unique permutations\n        ## 30. use a set to store the unique permutations\n        ## 31. use a set to store the unique permutations\n        ## 32. use a set to store the unique permutations\n        ## 33. use a set to store the unique permutations\n        ## 34. use a set to store the unique permutations\n        ## 35. use a set to store the unique permutations\n        ## 36. use a set to store the unique permutations\n        ## 37. use a set to store the unique permutations\n        ## 38. use a set to store the unique permutations\n        ## 39. use a set to store the unique permutations\n        ## 40. use a set to store the unique permutations\n        ## 41. use a set to store the unique permutations\n        ## 42. use a set to store the unique permutations\n        ## 43. use a set to store the unique permutations\n        ## 44. use a set to store the unique permutations\n        ## 45. use a set to store the unique permutations\n        ## 46. use a set to store the unique permutations\n        ## 47. use a set to store the unique permutations\n        ## 48. use a set to store the unique permutations\n        ## 49. use a set to store the unique permutations\n        ## 50. use a set to store the unique permutations\n        ## 51. use a set to store the unique permutations\n        ## 52. use a set to store the unique permutations\n        ## 53. use a set to store the unique permutations\n        ## 54. use a set to store the unique permutations\n        ## 55. use a set to store the unique permutations\n        ## 56. use a set to store the unique permutations\n        ## 57. use a set to store the unique permutations\n        ## 58. use a set to store the unique permutations\n        ## 59. use a set to store the unique permutations\n        ## 60. use a set to store the unique permutations\n        ## 61. use a set to store the unique permutations\n        #"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        # if num < 10:\n        #     return num\n        # else:\n        #     sum = 0\n        #     while num > 0:\n        #         sum += num % 10\n        #         num = num // 10\n        #     return self.addDigits(sum)\n        \n        #"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 12:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 13:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 14:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 15:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 16:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 17:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 18:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 19:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 20:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 21:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 22:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 23:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 24:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 25:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 26:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 27:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^9 + 7\n        # 2. 10^9 + 7\n        # 3. 10^9 + 7\n        # 4. 10^9 + 7\n        # 5. 10^9 + 7\n        # 6. 10^9 + 7\n        # 7. 10^9 + 7\n        # 8. 10^9 + 7\n        # 9. 10^9 + 7\n        # 10. 10^9 + 7\n        # 11. 10^9 + 7\n        # 12. 10^9 + 7\n        # 13. 10^9 + 7\n        # 14. 10^9 + 7\n        # 15. 10^9 + 7\n        # 16. 10^9 + 7\n        # 17. 10^9 + 7\n        # 18. 10^9 + 7\n        # 19. 10^9 + 7\n        # 20. 10^9 + 7\n        # 21. 10^9 + 7\n        # 22. 10^9 + 7\n        # 23. 10^9 + 7\n        # 24. 10^9 + 7\n        # 25. 10^9 + 7\n        # 26. 10^9 + 7\n        # 27. 10^9 + 7\n        # 28. 10^9 + 7\n        # 29. 10^9 + 7\n        # 30. 10^9 + 7\n        # 31. 10^9 + 7\n        # 32. 10^9 + 7\n        # 33. 10^9 + 7\n        # 34. 10^9 + 7\n        # 35. 10^9 + 7\n        # 36. 10^9 + 7\n        # 37. 10^9 + 7\n        # 38. 10^9 + 7\n        # 39. 10^9 + 7\n        # 40. 10^9 + 7\n        # 41. 10^9 + 7\n        # 42. 10^9 + 7\n        # 43. 10^9 + 7\n        # 44. 10^9 + 7\n        # 45. 10^9 + 7\n        # 46. 10^9 + 7\n        # 47. 10^9 + 7\n        # 48. 10^9 + 7\n        # 49. 10^9 + 7\n        # 50. 10^9 + 7\n        # 51. 10^9 + 7\n        # 52. 10^9 + 7\n        # 53. 10^9 + 7\n        # 54. 10^9 + 7\n        # 55. 10^9 + 7\n        # 56. 10^9 + 7\n        # 57. 10^9 + 7\n        # 58. 10^9 + 7\n        # 59. 10^9 + 7\n        # 60. 10^9 + 7\n        # 61. 10^9 + 7\n        # 62. 10^9 + 7\n        # 63. 10^9 + 7\n        # 64. 10^9 + 7\n        # 65. 10^9 + 7\n        # 66. 10^9 + 7\n        # 67. 10^9 + 7\n        # 68. 10^9 + 7\n        # 69. 10^9 + 7\n        # 70. 10^9 + 7\n        # 71. 10^9 + 7\n        # 72. 10^9 + 7\n        # 73. 10^9 + 7\n        # 74. 10^9"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1st pointer is slow, 2nd pointer is fast\n        # 3. slow pointer moves 1 step at a time\n        # 4. fast pointer moves 2 steps at a time\n        # 5. if fast pointer is 1, then it is a happy number\n        # 6. if fast pointer is not 1, then it is not a happy number\n        # 7. if fast pointer is not 1, then it is not a happy number\n        # 8. if fast pointer is not 1, then it is not a happy number\n        # 9. if fast pointer is not 1, then it is not a happy number\n        # 10. if fast pointer is not 1, then it is not a happy number\n        # 11. if fast pointer is not 1, then it is not a happy number\n        # 12. if fast pointer is not 1, then it is not a happy number\n        # 13. if fast pointer is not 1, then it is not a happy number\n        # 14. if fast pointer is not 1, then it is not a happy number\n        # 15. if fast pointer is not 1, then it is not a happy number\n        # 16. if fast pointer is not 1, then it is not a happy number\n        # 17. if fast pointer is not 1, then it is not a happy number\n        # 18. if fast pointer is not 1, then it is not a happy number\n        # 19. if fast pointer is not 1, then it is not a happy number\n        # 20. if fast pointer is not 1, then it is not a happy number\n        # 21. if fast pointer is not 1, then it is not a happy number\n        # 22. if fast pointer is not 1, then it is not a happy number\n        # 23. if fast pointer is not 1, then it is not a happy number\n        # 24. if fast pointer is not 1, then it is not a happy number\n        # 25. if fast pointer is not 1, then it is not a happy number\n        # 26. if fast pointer is not 1, then it is not a happy number\n        # 27. if fast pointer is not 1, then it is not a happy number\n        # 28. if fast pointer is not 1, then it is not a happy number\n        # 29. if fast pointer is not 1, then it is not a happy number\n        # 30. if fast pointer is not 1, then it is not a happy number\n        # 31. if fast pointer is not 1, then it is not a happy number\n        # 32. if fast pointer is not 1, then it is not a happy number\n        # 33. if fast pointer is not 1, then it is not a happy number\n        # 34. if fast pointer is not 1, then it is not a happy number\n        # 35. if fast pointer is not 1, then it is not a happy number\n        # 36. if fast pointer is not 1, then it is not a happy number\n        # 37. if fast pointer is not 1, then it is not a happy number\n        # 38. if fast pointer is not 1, then it is not a happy number\n        # 39. if fast pointer is not 1, then it is not a happy number\n        # 40. if fast pointer is not 1, then it is not a happy number\n        # 41. if fast pointer is not 1, then it is not a happy number\n        # 42. if fast pointer is not 1, then it is not a happy number\n        # 43. if fast pointer is not 1, then it is not a happy number\n        # 44. if fast pointer is not 1, then it is not a happy number\n        # 45. if fast pointer is not 1, then it is not a happy number\n        # 46. if fast pointer is not 1, then it is not a happy number\n        # 47. if fast pointer is not 1, then it is not a happy number\n        # 48. if fast pointer is not 1, then it is not a happy number\n        #"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order\n        \n        # if target is in the array, return the index\n        # if not, return the index where it would be if it were inserted in order"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(m*n)\n        # Space Complexity: O(m*n)\n        \n        # Approach: Dynamic Programming\n        # 1. Create a 2D array of size m*n\n        # 2. Initialize the first row and first column with the value of the first element of the grid\n        # 3. Iterate over the grid and update the value of the 2D array\n        # 4. Iterate over the 2D array and update the value of the 1D array\n        # 5. Return the last element of the 1D array\n        \n        # 1. Create a 2D array of size m*n\n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        \n        # 2. Initialize the first row and first column with the value of the first element of the grid\n        dp[0][0] = grid[0][0]\n        \n        # 3. Iterate over the grid and update the value of the 2D array\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n            \n        for j in range(1,n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n            \n        # 4. Iterate over the 2D array and update the value of the 1D array\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n                \n        # 5. Return the last element of the 1D array\n        return dp[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        # if n == 1:\n        #     return \"1\"\n        # if n == 2:\n        #     return \"11\"\n        # if n == 3:\n        #     return \"21\"\n        # if n == 4:\n        #     return \"1211\"\n        # if n == 5:\n        #     return \"111221\"\n        # if n == 6:\n        #     return \"312211\"\n        # if n == 7:\n        #     return \"13112221\"\n        # if n == 8:\n        #     return \"1113213211\"\n        # if n == 9:\n        #     return \"31131211131221\"\n        # if n == 10:\n        #     return \"13211311123113112211\"\n        # if n == 11:\n        #     return \"1113122113311213213211\"\n        # if n == 12:\n        #     return \"31131122212321321121312211\"\n        # if n == 13:\n        #     return \"132113111231131122112131121322211\"\n        # if n == 14:\n        #     return \"111312211331121321321121311322211\"\n        # if n == 15:\n        #     return \"311311222123213211213112132221121312211\"\n        # if n == 16:\n        #     return \"1321131112311311221121311213222112131221123211\"\n        # if n == 17:\n        #     return \"1113122113311213213211213113222112131221123211211312211\"\n        # if n == 18:\n        #     return \"3113112221232132112131121322211213122112321121131221123211\"\n        # if n == 19:\n        #     return \"132113111231131122112131121322211213122112321121131221123211213211\"\n        # if n == 20:\n        #     return \"11131221133112132132112131132221121312211232112113122112321121321123211\"\n        # if n == 21:\n        #     return \"311311222123213211213112132221121312211232112113122112321121321123211213211\"\n        # if n == 22:\n        #     return \"1321131112311311221121311213222112131221123211211312211232112132112321121321123211\"\n        #"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max value in nums\n        # find the min value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in nums\n        # binary search the max value in nums\n        # binary search the min value in num"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        ## 2 -> 3\n        ## 3 -> 4\n        ## 4 -> 5\n        ## 5 -> 6\n        ## 6 -> 7\n        ## 7 -> 8\n        ## 8 -> 9\n        ## 9 -> 9\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l\n        ## 6 -> m, n, o\n        ## 7 -> p, q, r, s\n        ## 8 -> t, u, v\n        ## 9 -> w, x, y, z\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l\n        ## 6 -> m, n, o\n        ## 7 -> p, q, r, s\n        ## 8 -> t, u, v\n        ## 9 -> w, x, y, z\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l\n        ## 6 -> m, n, o\n        ## 7 -> p, q, r, s\n        ## 8 -> t, u, v\n        ## 9 -> w, x, y, z\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l\n        ## 6 -> m, n, o\n        ## 7 -> p, q, r, s\n        ## 8 -> t, u, v\n        ## 9 -> w, x, y, z\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l\n        ## 6 -> m, n, o\n        ## 7 -> p, q, r, s\n        ## 8 -> t, u, v\n        ## 9 -> w, x, y, z\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l\n        ## 6 -> m, n, o\n        ## 7 -> p, q, r, s\n        ## 8 -> t, u, v\n        ## 9 -> w, x, y, z\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l\n        ## 6 -> m, n, o\n        ## 7 -> p, q, r, s\n        ## 8 -> t, u, v\n        ## 9 -> w, x, y, z\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l\n        ## 6 -> m, n, o\n        ## 7 -> p, q, r, s\n        ## 8 -> t, u, v\n        ## 9 -> w, x, y, z\n        \n        ## 2 -> a, b, c\n        ## 3 -> d, e, f\n        ## 4 -> g, h, i\n        ## 5 -> j, k, l"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the candidates\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current combination\n        curr_comb = []\n        \n        # initialize the current sum\n        curr_sum = 0\n        \n        # initialize the index\n        i = 0\n        \n        # initialize the length\n        length = len(candidates)\n        \n        # loop through the candidates\n        while i < length:\n            \n            # if the current sum is greater than the target, break\n            if curr_sum > target:\n                break\n            \n            # if the current sum is equal to the target, add the current combination to the result\n            if curr_sum == target:\n                result.append(curr_comb[:])\n                break\n            \n            # if the current sum is less than the target, add the current candidate to the current combination\n            curr_comb.append(candidates[i])\n            \n            # add the current candidate to the current sum\n            curr_sum += candidates[i]\n            \n            # recursively call the function with the next candidate\n            self.combinationSum(candidates, target, curr_comb, curr_sum, i, result)\n            \n            # remove the last element from the current combination\n            curr_comb.pop()\n            \n            # remove the last element from the current sum\n            curr_sum -= candidates[i]\n            \n            # increment the index\n            i += 1\n            \n        return result\n    \n    def combinationSum(self, candidates, target, curr_comb, curr_sum, i, result):\n        \n        # if the current sum is greater than the target, return\n        if curr_sum > target:\n            return\n        \n        # if the current sum is equal to the target, add the current combination to the result\n        if curr_sum == target:\n            result.append(curr_comb[:])\n            return\n        \n        # loop through the candidates\n        for j in range(i, len(candidates)):\n            \n            # if the current sum is greater than the target, break\n            if curr_sum > target:\n                break\n            \n            # if the current sum is equal to the target, add the current combination to the result\n            if curr_sum == target:\n                result.append(curr_comb[:])\n                return\n            \n            # add the current candidate to the current combination\n            curr_comb.append(candidates[j])\n            \n            # add the current candidate to the current sum\n            curr_sum += candidates[j]\n            \n            # recursively call the function with the next candidate\n            self.combinationSum(candidates, target, curr_comb, curr_sum, j, result)\n            \n            # remove the last element from the current combination\n            curr_comb.pop()\n            \n            # remove the last element from the current sum\n            curr_sum -= candidates[j]\n            \n            # increment the index\n            j += 1\n            \n        return"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the nearest palindrome\n        # 2. if the nearest palindrome is the same as n, return the smaller one\n        # 3. if the nearest palindrome is 0, return 10\n        # 4. if the nearest palindrome is 9, return 9\n        # 5. if the nearest palindrome is 10, return 11\n        # 6. if the nearest palindrome is 11, return 121\n        # 7. if the nearest palindrome is 121, return 131\n        # 8. if the nearest palindrome is 131, return 141\n        # 9. if the nearest palindrome is 141, return 151\n        # 10. if the nearest palindrome is 151, return 161\n        # 11. if the nearest palindrome is 161, return 171\n        # 12. if the nearest palindrome is 171, return 181\n        # 13. if the nearest palindrome is 181, return 191\n        # 14. if the nearest palindrome is 191, return 202\n        # 15. if the nearest palindrome is 202, return 212\n        # 16. if the nearest palindrome is 212, return 222\n        # 17. if the nearest palindrome is 222, return 232\n        # 18. if the nearest palindrome is 232, return 242\n        # 19. if the nearest palindrome is 242, return 252\n        # 20. if the nearest palindrome is 252, return 262\n        # 21. if the nearest palindrome is 262, return 272\n        # 22. if the nearest palindrome is 272, return 282\n        # 23. if the nearest palindrome is 282, return 292\n        # 24. if the nearest palindrome is 292, return 303\n        # 25. if the nearest palindrome is 303, return 313\n        # 26. if the nearest palindrome is 313, return 323\n        # 27. if the nearest palindrome is 323, return 333\n        # 28. if the nearest palindrome is 333, return 343\n        # 29. if the nearest palindrome is 343, return 353\n        # 30. if the nearest palindrome is 353, return 363\n        # 31. if the nearest palindrome is 363, return 373\n        # 32. if the nearest palindrome is 373, return 383\n        # 33. if the nearest palindrome is 383, return 393\n        # 34. if the nearest palindrome is 393, return 404\n        # 35. if the nearest palindrome is 404, return 414\n        # 36. if the nearest palindrome is 414, return 424\n        # 37. if the nearest palindrome is 424, return 434\n        # 38. if the nearest palindrome is 434, return 444\n        # 39. if the nearest palindrome is 444, return 454\n        # 40. if the nearest palindrome is 454, return 464\n        # 41. if the nearest palindrome is 464, return 474\n        # 42. if the nearest palindrome is 474, return 484\n        # 43. if the nearest palindrome is 484, return 494\n        # 44. if the nearest palindrome is 494, return 505"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. 2D array\n        # 4. 1D array\n        # 5. 2D array\n        # 6. 1D array\n        # 7. 2D array\n        # 8. 1D array\n        # 9. 2D array\n        # 10. 1D array\n        # 11. 2D array\n        # 12. 1D array\n        # 13. 2D array\n        # 14. 1D array\n        # 15. 2D array\n        # 16. 1D array\n        # 17. 2D array\n        # 18. 1D array\n        # 19. 2D array\n        # 20. 1D array\n        # 21. 2D array\n        # 22. 1D array\n        # 23. 2D array\n        # 24. 1D array\n        # 25. 2D array\n        # 26. 1D array\n        # 27. 2D array\n        # 28. 1D array\n        # 29. 2D array\n        # 30. 1D array\n        # 31. 2D array\n        # 32. 1D array\n        # 33. 2D array\n        # 34. 1D array\n        # 35. 2D array\n        # 36. 1D array\n        # 37. 2D array\n        # 38. 1D array\n        # 39. 2D array\n        # 40. 1D array\n        # 41. 2D array\n        # 42. 1D array\n        # 43. 2D array\n        # 44. 1D array\n        # 45. 2D array\n        # 46. 1D array\n        # 47. 2D array\n        # 48. 1D array\n        # 49. 2D array\n        # 50. 1D array\n        # 51. 2D array\n        # 52. 1D array\n        # 53. 2D array\n        # 54. 1D array\n        # 55. 2D array\n        # 56. 1D array\n        # 57. 2D array\n        # 58. 1D array\n        # 59. 2D array\n        # 60. 1D array\n        # 61. 2D array\n        # 62. 1D array\n        # 63. 2D array\n        # 64. 1D array\n        # 65. 2D array\n        # 66. 1D array\n        # 67. 2D array\n        # 68. 1D array\n        # 69. 2D array\n        # 70. 1D array\n        # 71. 2D array\n        # 72. 1D array\n        # 73. 2D array\n        # 74. 1D array\n        # 75. 2D array\n        # 76. 1D array\n        # 77. 2D array\n        # 78. 1D array\n        # 79. 2D array\n        # 80. 1D array\n        # 81. 2D array\n        # 82. 1D array\n        # 83. 2D array\n        # 84. 1D array\n        # 85. 2D array\n        # 86. 1D array\n        # 87. 2D array\n        # 88. 1D array\n        # 89. 2D array\n        # 90. 1D array\n        # 91. 2D array\n        # 92. 1D array\n        # 93. 2D array\n        # 94. 1D array"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #     if x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         x = str(x)\n        #         x = x[::-1]\n        #         x = int(x)\n        #         x = x * sign\n        #         return x\n        #     # return x\n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #     if x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         x = str(x)\n        #         x = x[::-1]\n        #         x = int(x)\n        #         x = x * sign\n        #         return x\n        #     # return x\n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #     if x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         x = str(x)\n        #         x = x[::-1]\n        #         x = int(x)\n        #         x = x * sign\n        #         return x\n        #     # return x\n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #     if x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         x = str(x)\n        #         x = x[::-1]\n        #         x = int(x)\n        #         x = x * sign\n        #         return x\n        #     # return x\n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #     if x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         x = str(x)\n        #         x = x[::-1]\n        #         x = int(x)\n        #         x = x * sign\n        #         return x\n        #     # return x\n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #     if x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         x = str(x)\n        #         x = x[::-1]\n        #         x = int(x)\n        #         x = x * sign\n        #         return x\n        #     # return x\n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #     if x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         x = str(x)\n        #         x = x[::-1]\n        #         x = int(x)\n        #         x = x * sign\n        #         return x\n        #     # return x\n        # if x < 0:\n        #     x = -x\n        #     sign = -1\n        # else:\n        #     sign = 1\n        #     x = abs(x)\n        #     if x > 2**31 - 1:\n        #         return 0\n        #     else:\n        #         x = str(x)\n        #         x = x[::-1]\n        #         x = int(x)\n        #         x = x * sign\n        #         return x\n        #     # return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column\n        \n        ## 1. 2D array to 1D array\n        ## 2. reverse each row\n        ## 3. reverse each column"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross the river\n        if stones[-1] == 0:\n            return False\n        \n        # if the last stone is not 0, then it is possible to cross the river\n        if stones[-1] != 0:\n            return True\n        \n        # if the last stone is 0, then it is impossible to cross"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score array\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the index of the score\n        # use a hashmap to store the"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        # Edge case\n        if len(words) == 0:\n            return []\n        \n        # Edge case\n        if len(s) == 0:\n            return []\n        \n        # Edge case\n        if len(words) * len(words[0]) > len(s):\n            return []\n        \n        # Edge case\n        if len(words) * len(words[0]) == len(s):\n            return [0]\n        \n        # Edge case\n        if len(words) == 1:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0]]\n        \n        # Edge case\n        if len(words) == 2:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1]]\n        \n        # Edge case\n        if len(words) == 3:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2]]\n        \n        # Edge case\n        if len(words) == 4:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2] and s[i+3*len(words[0]):i+4*len(words[0])] == words[3]]\n        \n        # Edge case\n        if len(words) == 5:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2] and s[i+3*len(words[0]):i+4*len(words[0])] == words[3] and s[i+4*len(words[0]):i+5*len(words[0])] == words[4]]\n        \n        # Edge case\n        if len(words) == 6:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2] and s[i+3*len(words[0]):i+4*len(words[0])] == words[3] and s[i+4*len(words[0]):i+5*len(words[0])] == words[4] and s[i+5*len(words[0]):i+6*len(words[0])] == words[5]]\n        \n        # Edge case\n        if len(words) == 7:\n            return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0] and s[i+len(words[0]):i+2*len(words[0])] == words[1] and s[i+2*len(words[0]):i+3*len(words[0])] == words[2] and s[i+3*len(words[0]):i+4*len(words[0])] == words[3] and s[i+4*len(words[0]):i+5*len(words[0])] == words[4] and s[i+5*len(words[0]):i"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:\n        #         curr = curr.next\n        #     else:\n        #         prev = dummy\n        #         while prev.next.val <= curr.next.val:\n        #             prev = prev.next\n        #         temp = curr.next\n        #         curr.next = temp.next\n        #         temp.next = prev.next\n        #         prev.next = temp\n        #         curr = dummy.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        # curr = head\n        # while curr.next:\n        #     if curr.val <= curr.next.val:"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         temp = curr.next\n        #         while temp.next and temp.next.val == curr.next.val:\n        #             temp = temp.next\n        #         curr.next = temp.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         temp = curr.next\n        #         while temp.next and temp.next.val == curr.next.val:\n        #             temp = temp.next\n        #         curr.next = temp.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         temp = curr.next\n        #         while temp.next and temp.next.val == curr.next.val:\n        #             temp = temp.next\n        #         curr.next = temp.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         temp = curr.next\n        #         while temp.next and temp.next.val == curr.next.val:\n        #             temp = temp.next\n        #         curr.next = temp.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         temp = curr.next\n        #         while temp.next and temp.next.val == curr.next.val:\n        #             temp = temp.next\n        #         curr.next = temp.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        # while curr.next:\n        #     if curr.next.val == curr.next.next.val:\n        #         temp = curr.next\n        #         while temp.next and temp.next.val == curr.next.val:\n        #             temp = temp.next\n        #         curr.next = temp.next\n        #     else:\n        #         curr = curr.next\n        # return dummy.next\n        \n        # if head is None or head.next is None:\n        #     return head\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        # print(nums)\n        # print(nums[0])\n        # print(nums[-1])\n        # print(nums[1])\n        # print(nums[-2])\n        # print(nums[2])\n        # print(nums[-3])\n        # print(nums[3])\n        # print(nums[-4])\n        # print(nums[4])\n        # print(nums[-5])\n        # print(nums[5])\n        # print(nums[-6])\n        # print(nums[6])\n        # print(nums[-7])\n        # print(nums[7])\n        # print(nums[-8])\n        # print(nums[8])\n        # print(nums[-9])\n        # print(nums[9])\n        # print(nums[-10])\n        # print(nums[10])\n        # print(nums[-11])\n        # print(nums[11])\n        # print(nums[-12])\n        # print(nums[12])\n        # print(nums[-13])\n        # print(nums[13])\n        # print(nums[-14])\n        # print(nums[14])\n        # print(nums[-15])\n        # print(nums[15])\n        # print(nums[-16])\n        # print(nums[16])\n        # print(nums[-17])\n        # print(nums[17])\n        # print(nums[-18])\n        # print(nums[18])\n        # print(nums[-19])\n        # print(nums[19])\n        # print(nums[-20])\n        # print(nums[20])\n        # print(nums[-21])\n        # print(nums[21])\n        # print(nums[-22])\n        # print(nums[22])\n        # print(nums[-23])\n        # print(nums[23])\n        # print(nums[-24])\n        # print(nums[24])\n        # print(nums[-25])\n        # print(nums[25])\n        # print(nums[-26])\n        # print(nums[26])\n        # print(nums[-27])\n        # print(nums[27])\n        # print(nums[-28])\n        # print(nums[28])\n        # print(nums[-29])\n        # print(nums[29])\n        # print(nums[-30])\n        # print(nums[30])\n        # print(nums[-31])\n        # print(nums[31])\n        # print(nums[-32])\n        # print(nums[32])\n        # print(nums[-33])\n        # print(nums[33])\n        # print(nums[-34])\n        # print(nums[34])\n        # print(nums[-35])\n        # print(nums[35])\n        # print(nums[-36])\n        # print(nums[36])\n        # print(nums[-37])\n        # print(nums[37])\n        # print(nums[-38])\n        # print(nums[38])\n        # print(nums[-39])\n        # print(nums[39])\n        # print(nums[-40])\n        # print(nums[40])\n        # print(nums[-41])\n        # print(nums[41])\n        # print(nums[-42])\n        # print(nums[42])\n        # print(nums[-43])\n        # print(nums[43])\n        # print(nums[-44])\n        # print(nums[44])\n        # print(nums[-45])\n        # print(nums[45])\n        # print(nums[-46])\n        # print(nums[46])"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of word2\n        # if both are not empty, then we need to find the minimum number of operations required to convert word1 to word2\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        # if word2 is empty, then we need to delete all the characters of word1\n        # if both are empty, then we need to insert all the characters of"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s in XOR\n        ## 4. return the count\n        \n        ## 1. XOR\n        ## 2. Count the number of 1s\n        ## 3. Count the number of 1s"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root.left is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.right)]\n        # if root.right is None:\n        #     return [str(root.val) + \"->\" + self.binaryTreePaths(root.left)]\n        # return [str(root.val) + \"->\" + x for x in self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)]\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     return [str(root.val)]\n        # if root"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > tx or sy > ty:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return (ty - sy) % sx == 0\n        # if sy == ty and sx < tx:\n        #     return (tx - sx) % sy == 0\n        # if sx < tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty) or self.reachingPoints(sx, sy, tx, ty % sx)\n        # if sx < tx and sy > ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty) or self.reachingPoints(sx, sy, tx, ty % sx)\n        # if sx > tx and sy < ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty) or self.reachingPoints(sx, sy, tx, ty % sx)\n        # if sx > tx and sy > ty:\n        #     return self.reachingPoints(sx, sy, tx % ty, ty) or self.reachingPoints(sx, sy, tx, ty % sx)\n        \n        # if tx < sx or ty < sy:\n        #     return False\n        # if tx == sx and ty < sy:\n        #     return (sy - ty) % sx == 0\n        # if ty == sy and tx < sx:\n        #     return (sx - tx) % sy == 0\n        # if tx < sx and ty < sy:\n        #     return self.reachingPoints(sx, sy, tx % sy, ty % sx) or self.reachingPoints(sx, sy, tx % sx, ty % sy)\n        # if tx < sx and ty > sy:\n        #     return self.reachingPoints(sx, sy, tx % sy, ty % sx) or self.reachingPoints(sx, sy, tx % sx, ty % sy)\n        # if tx > sx and ty < sy:\n        #     return self.reachingPoints(sx, sy, tx % sy, ty % sx) or self.reachingPoints(sx, sy, tx % sx, ty % sy)\n        # if tx > sx and ty > sy:\n        #     return self.reachingPoints(sx, sy, tx % sy, ty % sx) or self.reachingPoints(sx, sy, tx % sx, ty % sy)\n        \n        # if tx == sx and ty == sy:\n        #     return True\n        # if tx == sx and ty > sy:\n        #     return (sy - ty) % sx == 0\n        # if ty == sy and tx > sx:\n        #     return (sx - tx) % sy == 0\n        # if tx > sx and ty == sy:\n        #     return (sy - ty) % sx == 0\n        # if ty > sy and tx == sx:\n        #     return (sx - tx) % sy == 0\n        # if tx > sx and ty > sy:\n        #     return self.reachingPoints(sx, sy, tx % sy, ty % sx) or self.reachingPoints(sx, sy, tx % sx, ty % sy)\n        # if tx < sx and ty < sy:\n        #     return self.reachingPoints(sx, sy, tx % sy, ty % sx) or self.reachingPoints(sx, sy, tx % sx, ty % sy)\n        # if tx < sx and ty > sy:\n        #     return self.reachingPoints(sx, sy, tx % sy, ty % sx) or self.reachingPoints(sx, sy, tx % sx, ty % sy)\n        # if tx > sx and ty < sy:\n        #     return self.reachingPoints(sx, sy, tx % sy, ty % sx) or self.reachingPoints(sx, sy, tx % sx, ty % sy)\n        # if tx > sx and ty > sy:\n        #     return self.reachingPoints(sx, sy, tx % sy,"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        # split the version numbers into a list of integers\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        \n        # compare the integers\n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if i < len(v2):\n                    if v1[i] < v2[i]:\n                        return -1\n                    elif v1[i] > v2[i]:\n                        return 1\n                else:\n                    return -1\n            else:\n                if i < len(v2):\n                    return 1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap\n        # max heap"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. If the length is less than k, return the original list\n        if length < k:\n            return head\n        \n        # 3. Initialize the dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 4. Initialize the previous node and the current node\n        prev = dummy\n        curr = head\n        \n        # 5. Iterate through the linked list\n        while curr:\n            # 5.1. If the length is less than k, return the original list\n            if length < k:\n                return head\n            \n            # 5.2. If the length is greater than k, reverse the nodes\n            # 5.2.1. Initialize the next node\n            next_node = curr.next\n            \n            # 5.2.2. Reverse the nodes\n            curr.next = None\n            prev.next = self.reverse(curr)\n            \n            # 5.2.3. Update the previous node\n            prev = curr\n            \n            # 5.2.4. Update the current node\n            curr = next_node\n            \n            # 5.2.5. Update the length\n            length -= k\n            \n        # 6. Return the dummy node\n        return dummy.next\n    \n    def reverse(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Initialize the previous node and the current node\n        prev = None\n        curr = head\n        \n        # 2. Iterate through the linked list\n        while curr:\n            # 2.1. Initialize the next node\n            next_node = curr.next\n            \n            # 2.2. Reverse the nodes\n            curr.next = prev\n            \n            # 2.3. Update the previous node\n            prev = curr\n            \n            # 2.4. Update the current node\n            curr = next_node\n            \n        # 3. Return the previous node\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## TLE\n        ## if len(s) % len(s[:len(s)//2]) != 0:\n        ##     return False\n        ## for i in range(len(s)//2):\n        ##     if s[:len(s)//2] * (len(s)//2) == s:\n        ##         return True\n        ## return False\n        \n        ## KMP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/105554/Python-KMP-solution-with-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/1"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1,2,3,4,5,6,7,8,9,10\n        # 2. 1,2,3,4,5,6,7,8,9,10\n        # 3. 1,2,3,4,5,6,7,8,9,10\n        # 4. 1,2,3,4,5,6,7,8,9,10\n        # 5. 1,2,3,4,5,6,7,8,9,10\n        # 6. 1,2,3,4,5,6,7,8,9,10\n        # 7. 1,2,3,4,5,6,7,8,9,10\n        # 8. 1,2,3,4,5,6,7,8,9,10\n        # 9. 1,2,3,4,5,6,7,8,9,10\n        # 10. 1,2,3,4,5,6,7,8,9,10\n        # 11. 1,2,3,4,5,6,7,8,9,10\n        # 12. 1,2,3,4,5,6,7,8,9,10\n        # 13. 1,2,3,4,5,6,7,8,9,10\n        # 14. 1,2,3,4,5,6,7,8,9,10\n        # 15. 1,2,3,4,5,6,7,8,9,10\n        # 16. 1,2,3,4,5,6,7,8,9,10\n        # 17. 1,2,3,4,5,6,7,8,9,10\n        # 18. 1,2,3,4,5,6,7,8,9,10\n        # 19. 1,2,3,4,5,6,7,8,9,10\n        # 20. 1,2,3,4,5,6,7,8,9,10\n        # 21. 1,2,3,4,5,6,7,8,9,10\n        # 22. 1,2,3,4,5,6,7,8,9,10\n        # 23. 1,2,3,4,5,6,7,8,9,10\n        # 24. 1,2,3,4,5,6,7,8,9,10\n        # 25. 1,2,3,4,5,6,7,8,9,10\n        # 26. 1,2,3,4,5,6,7,8,9,10\n        # 27. 1,2,3,4,5,6,7,8,9,10\n        # 28. 1,2,3,4,5,6,7,8,9,10\n        # 29. 1,2,3,4,5,6,7,8,9,10\n        # 30. 1,2,3,4,5,6,7,8,9,10\n        # 31. 1,2,3,4,5,6,7,8,9,10\n        # 32. 1,2,3,4,5,6,7,8,9,10\n        # 33. 1,2,3,4,5,6,7,8,9,10\n        # 34. 1,2,3,4,5,6,7,8,9,10\n        # 35. 1,2,3,4,5,6,7,8,9,10\n        # 36. 1,2,3,4,5,6,7,8,9,10\n        # 37. 1,2,3,4,5,6,7,8,9,"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict of all the letters in the target\n        # 2. build a dict of all the letters in the stickers\n        # 3. build a dict of all the letters in the stickers\n        # 4. build a dict of all the letters in the stickers\n        # 5. build a dict of all the letters in the stickers\n        # 6. build a dict of all the letters in the stickers\n        # 7. build a dict of all the letters in the stickers\n        # 8. build a dict of all the letters in the stickers\n        # 9. build a dict of all the letters in the stickers\n        # 10. build a dict of all the letters in the stickers\n        # 11. build a dict of all the letters in the stickers\n        # 12. build a dict of all the letters in the stickers\n        # 13. build a dict of all the letters in the stickers\n        # 14. build a dict of all the letters in the stickers\n        # 15. build a dict of all the letters in the stickers\n        # 16. build a dict of all the letters in the stickers\n        # 17. build a dict of all the letters in the stickers\n        # 18. build a dict of all the letters in the stickers\n        # 19. build a dict of all the letters in the stickers\n        # 20. build a dict of all the letters in the stickers\n        # 21. build a dict of all the letters in the stickers\n        # 22. build a dict of all the letters in the stickers\n        # 23. build a dict of all the letters in the stickers\n        # 24. build a dict of all the letters in the stickers\n        # 25. build a dict of all the letters in the stickers\n        # 26. build a dict of all the letters in the stickers\n        # 27. build a dict of all the letters in the stickers\n        # 28. build a dict of all the letters in the stickers\n        # 29. build a dict of all the letters in the stickers\n        # 30. build a dict of all the letters in the stickers\n        # 31. build a dict of all the letters in the stickers\n        # 32. build a dict of all the letters in the stickers\n        # 33. build a dict of all the letters in the stickers\n        # 34. build a dict of all the letters in the stickers\n        # 35. build a dict of all the letters in the stickers\n        # 36. build a dict of all the letters in the stickers\n        # 37. build a dict of all the letters in the stickers\n        # 38. build a dict of all the letters in the stickers\n        # 39. build a dict of all the letters in the stickers\n        # 40. build a dict of all the letters in the stickers\n        # 41. build a dict of all the letters in the stickers\n        # 42. build a dict of all the letters in the stickers\n        # 43. build a dict of all the letters in the stickers\n        # 44. build a dict of all the letters in the stickers\n        # 45. build a dict of all the letters in the stickers\n        # 46. build a dict of all the letters in the stickers\n        # 47. build a dict of all the letters in the stickers\n        # 48. build a dict of all the letters in the stickers\n        # 49. build a dict of all the letters in the stickers\n        # 50. build a dict of all the letters in the stickers\n        # 51. build a dict of all the letters in the stickers\n        # 52. build a dict of all the letters in the stickers\n        # 53. build a dict of all the letters in the stickers\n        # 54. build a dict of all the letters in the stickers\n        # 55. build a dict of all the letters in the stickers\n        # 56. build a dict of all the letters in the stickers\n        # 57. build a dict of all the letters in the stickers\n        # 58. build a"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + 1)\n        # dp[i][j] ="}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the square root of x\n        # 2. if x is 0, return 0\n        # 3. if x is 1, return 1\n        # 4. if x is 2, return 1\n        # 5. if x is 3, return 1\n        # 6. if x is 4, return 2\n        # 7. if x is 5, return 2\n        # 8. if x is 6, return 2\n        # 9. if x is 7, return 2\n        # 10. if x is 8, return 3\n        # 11. if x is 9, return 3\n        # 12. if x is 10, return 3\n        # 13. if x is 11, return 3\n        # 14. if x is 12, return 3\n        # 15. if x is 13, return 3\n        # 16. if x is 14, return 3\n        # 17. if x is 15, return 3\n        # 18. if x is 16, return 4\n        # 19. if x is 17, return 4\n        # 20. if x is 18, return 4\n        # 21. if x is 19, return 4\n        # 22. if x is 20, return 4\n        # 23. if x is 21, return 4\n        # 24. if x is 22, return 4\n        # 25. if x is 23, return 4\n        # 26. if x is 24, return 4\n        # 27. if x is 25, return 4\n        # 28. if x is 26, return 4\n        # 29. if x is 27, return 4\n        # 30. if x is 28, return 4\n        # 31. if x is 29, return 4\n        # 32. if x is 30, return 4\n        # 33. if x is 31, return 4\n        # 34. if x is 32, return 4\n        # 35. if x is 33, return 4\n        # 36. if x is 34, return 4\n        # 37. if x is 35, return 4\n        # 38. if x is 36, return 4\n        # 39. if x is 37, return 4\n        # 40. if x is 38, return 4\n        # 41. if x is 39, return 4\n        # 42. if x is 40, return 4\n        # 43. if x is 41, return 4\n        # 44. if x is 42, return 4\n        # 45. if x is 43, return 4\n        # 46. if x is 44, return 4\n        # 47. if x is 45, return 4\n        # 48. if x is 46, return 4\n        # 49. if x is 47, return 4\n        # 50. if x is 48, return 4\n        # 51. if x is 49, return 4\n        # 52. if x is 50, return 4\n        # 53. if x is 51, return 4\n        # 54. if x is 52, return 4\n        # 55. if x is 53, return 4\n        # 56. if x is 54, return 4\n        # 57. if x is 55, return 4\n        # 58. if x is 56, return 4\n        # 59. if x is 57, return 4\n        # 60. if x is 58, return 4\n        # 61. if x is 59, return 4\n        # 62"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## O(n) time and O(n) space\n        ## hashmap\n        ## if the number is already in the hashmap, return True\n        ## else add the number to the hashmap\n        ## if the number is not in the hashmap, add it to the hashmap\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        ## O(n) time and O(1) space\n        ## sort the array\n        ## iterate through the array\n        ## if the number is the same as the previous number, return True\n        ## else, continue\n        ## return False\n        \n        #"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # if len(nums) == 2:\n        #     return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        # if len(nums) == 3:\n        #     return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2])]\n        \n        # if len(nums) == 4:\n        #     return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3])]\n        \n        # if len(nums) == 5:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4])]\n        \n        # if len(nums) == 6:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        # if len(nums) == 7:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        # if len(nums) == 8:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[2], nums[3"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1, nums2 = nums2, nums1\n        #     # nums1,"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # if rowIndex == 2:\n        #     return [1,2,1]\n        # if rowIndex == 3:\n        #     return [1,3,3,1]\n        # if rowIndex == 4:\n        #     return [1,4,6,4,1]\n        # if rowIndex == 5:\n        #     return [1,5,10,10,5,1]\n        # if rowIndex == 6:\n        #     return [1,6,15,20,15,6,1]\n        # if rowIndex == 7:\n        #     return [1,7,21,35,35,21,7,1]\n        # if rowIndex == 8:\n        #     return [1,8,28,56,70,56,28,8,1]\n        # if rowIndex == 9:\n        #     return [1,9,36,84,126,126,84,36,9,1]\n        # if rowIndex == 10:\n        #     return [1,10,45,120,210,252,210,120,45,10,1]\n        # if rowIndex == 11:\n        #     return [1,11,55,165,320,435,435,320,165,55,11,1]\n        # if rowIndex == 12:\n        #     return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        # if rowIndex == 13:\n        #     return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        # if rowIndex == 14:\n        #     return [1,14,88,343,864,1650,2431,2800,2431,1650,864,343,88,14,1]\n        # if rowIndex == 15:\n        #     return [1,15,99,414,1001,2002,3003,3432,3003,2002,1001,414,99,15,1]\n        # if rowIndex == 16:\n        #     return [1,16,100,455,1200,2640,4320,5600,5600,4320,2640,1200,455,100,16,1]\n        # if rowIndex == 17:\n        #     return [1,17,111,514,1560,3520,6006,7607,7607,6006,3520,1560,514,111,17,1]\n        # if rowIndex == 18:\n        #     return [1,18,122,569,1820,4032,7024,9249,9249,7024,4032,1820,569,122,18,1]\n        # if rowIndex == 19:\n        #     return [1,19,133,656,2220,5005,8640,12640,14241,12640,8640,5005,2220,656,133,19,1]\n        # if rowIndex == 20:\n        #     return [1,20,14"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        \n        ## 1. Recursive solution\n        ## 2. Iterative solution\n        ## 3. DFS\n        ## 4. BFS"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n            graph[beginWord].append(beginWord)\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if root is None:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n == 0:\n        #     return False\n        # while n % 2 == 0:\n        #     n = n / 2\n        # if n == 1:\n        #     return True\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #     return False\n        # if n == 1:\n        #     return True\n        # if n % 2 == 0:\n        #     return self.isPowerOfTwo(n/2)\n        # else:\n        #     return False\n        \n        # if n == 0:\n        #"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the result array\n        result = [[]]\n        \n        # initialize the current subset\n        curr_subset = []\n        \n        # initialize the current index\n        curr_index = 0\n        \n        # initialize the current number\n        curr_num = nums[0]\n        \n        # initialize the current count\n        curr_count = 0\n        \n        # initialize the current subset count\n        curr_subset_count = 0\n        \n        # initialize the current subset count\n        curr_subset_count = 0\n        \n        # loop through the array\n        for i in range(len(nums)):\n            \n            # if the current number is the same as the previous number\n            if nums[i] == curr_num:\n                \n                # increment the current count\n                curr_count += 1\n                \n                # if the current count is equal to the current subset count\n                if curr_count == curr_subset_count:\n                    \n                    # add the current number to the current subset\n                    curr_subset.append(curr_num)\n                    \n                    # add the current subset to the result array\n                    result.append(curr_subset)\n                    \n                    # increment the current subset count\n                    curr_subset_count += 1\n                    \n                    # reset the current count\n                    curr_count = 0\n                    \n                    # reset the current subset\n                    curr_subset = []\n                    \n                    # reset the current number\n                    curr_num = nums[i]\n                    \n                # if the current count is not equal to the current subset count\n                else:\n                    \n                    # add the current number to the current subset\n                    curr_subset.append(curr_num)\n                    \n                    # add the current subset to the result array\n                    result.append(curr_subset)\n                    \n                    # reset the current count\n                    curr_count = 0\n                    \n                    # reset the current subset\n                    curr_subset = []\n                    \n                    # reset the current number\n                    curr_num = nums[i]\n                    \n            # if the current number is not the same as the previous number\n            else:\n                \n                # add the current number to the current subset\n                curr_subset.append(curr_num)\n                \n                # add the current subset to the result array\n                result.append(curr_subset)\n                \n                # reset the current count\n                curr_count = 0\n                \n                # reset the current subset\n                curr_subset = []\n                \n                # reset the current number\n                curr_num = nums[i]\n                \n        # return the result array\n        return result"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif token == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif token == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif token == \"/\":\n                num = stack.pop()\n                if num < 0:\n                    num = -num\n                    num = -num // stack.pop()\n                    num = -num\n                else:\n                    num = num // stack.pop()\n                stack.append(num)\n            else:\n                stack.append(int(token))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. Find the min and max x and y coordinates\n        ## 2. Find the area of the rectangle\n        ## 3. Find the area of the rectangle that is not covered\n        ## 4. If the area of the rectangle is not covered, return False\n        ## 5. If the area of the rectangle is covered, return True\n        \n        ## 1. Find the min and max x and y coordinates\n        min_x = float('inf')\n        max_x = float('-inf')\n        min_y = float('inf')\n        max_y = float('-inf')\n        \n        for rect in rectangles:\n            min_x = min(min_x, rect[0])\n            max_x = max(max_x, rect[2])\n            min_y = min(min_y, rect[1])\n            max_y = max(max_y, rect[3])\n            \n        ## 2. Find the area of the rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        ## 3. Find the area of the rectangle that is not covered\n        ## 3.1 Find the area of the rectangle that is not covered\n        ## 3.2 Find the area of the rectangle that is not covered\n        ## 3.3 Find the area of the rectangle that is not covered\n        ## 3.4 Find the area of the rectangle that is not covered\n        ## 3.5 Find the area of the rectangle that is not covered\n        ## 3.6 Find the area of the rectangle that is not covered\n        ## 3.7 Find the area of the rectangle that is not covered\n        ## 3.8 Find the area of the rectangle that is not covered\n        ## 3.9 Find the area of the rectangle that is not covered\n        ## 3.10 Find the area of the rectangle that is not covered\n        ## 3.11 Find the area of the rectangle that is not covered\n        ## 3.12 Find the area of the rectangle that is not covered\n        ## 3.13 Find the area of the rectangle that is not covered\n        ## 3.14 Find the area of the rectangle that is not covered\n        ## 3.15 Find the area of the rectangle that is not covered\n        ## 3.16 Find the area of the rectangle that is not covered\n        ## 3.17 Find the area of the rectangle that is not covered\n        ## 3.18 Find the area of the rectangle that is not covered\n        ## 3.19 Find the area of the rectangle that is not covered\n        ## 3.20 Find the area of the rectangle that is not covered\n        ## 3.21 Find the area of the rectangle that is not covered\n        ## 3.22 Find the area of the rectangle that is not covered\n        ## 3.23 Find the area of the rectangle that is not covered\n        ## 3.24 Find the area of the rectangle that is not covered\n        ## 3.25 Find the area of the rectangle that is not covered\n        ## 3.26 Find the area of the rectangle that is not covered\n        ## 3.27 Find the area of the rectangle that is not covered\n        ## 3.28 Find the area of the rectangle that is not covered\n        ## 3.29 Find the area of the rectangle that is not covered\n        ## 3.30 Find the area of the rectangle that is not covered\n        ## 3.31 Find the area of the rectangle that is not covered\n        ## 3.32 Find the area of the rectangle that is not covered\n        ## 3.33 Find the area of the rectangle that is not covered\n        ## 3.34 Find the area of the rectangle that is not covered\n        ## 3.35 Find the area of the rectangle that is not covered\n        ## 3.36 Find the area of the rectangle that is not covered\n        ## 3.37 Find the area of the rectangle that is not covered\n        ## 3.38 Find the area of the rectangle that is not covered\n        ## 3.39 Find the area of the rectangle that is not covered\n        ## 3.40 Find the area of the rectangle that is not covered"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## TLE\n        ## if nums[i] < 0:\n        ##     if nums[i] > max_sum:\n        ##         max_sum = nums[i]\n        ##     else:\n        ##         max_sum += nums[i]\n        ## else:\n        ##     max_sum = nums[i]\n        ##     for j in range(i+1, len(nums)):\n        ##         max_sum += nums[j]\n        ##         if max_sum > max_sum_so_far:\n        ##             max_sum_so_far = max_sum\n        ## return max_sum_so_far\n        \n        ## 2. DP\n        ## Time: O(n)\n        ## Space: O(1)\n        ## TLE\n        ## max_sum = nums[0]\n        ## max_sum_so_far = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if nums[i] < 0:\n        ##         if nums[i] > max_sum:\n        ##             max_sum = nums[i]\n        ##         else:\n        ##             max_sum += nums[i]\n        ##     else:\n        ##         max_sum = nums[i]\n        ##         if max_sum > max_sum_so_far:\n        ##             max_sum_so_far = max_sum\n        ##     max_sum_so_far = max(max_sum_so_far, max_sum)\n        ## return max_sum_so_far\n        \n        ## 3. DP\n        ## Time: O(n)\n        ## Space: O(1)\n        ## AC\n        max_sum = nums[0]\n        max_sum_so_far = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                if nums[i] > max_sum:\n                    max_sum = nums[i]\n                else:\n                    max_sum += nums[i]\n            else:\n                max_sum = nums[i]\n                if max_sum > max_sum_so_far:\n                    max_sum_so_far = max_sum\n            max_sum_so_far = max(max_sum_so_far, max_sum)\n        return max_sum_so_far"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the empty space\n        # 2. Find the 2s and 5s\n        # 3. Find the 4s and 6s\n        # 4. Find the 7s and 8s\n        # 5. Find the 3s and 9s\n        # 6. Find the 1s and 10s\n        # 7. Find the 11s and 12s\n        # 8. Find the 13s and 14s\n        # 9. Find the 15s and 16s\n        # 10. Find the 17s and 18s\n        # 11. Find the 19s and 20s\n        # 12. Find the 21s and 22s\n        # 13. Find the 23s and 24s\n        # 14. Find the 25s and 26s\n        # 15. Find the 27s and 28s\n        # 16. Find the 29s and 30s\n        # 17. Find the 31s and 32s\n        # 18. Find the 33s and 34s\n        # 19. Find the 35s and 36s\n        # 20. Find the 37s and 38s\n        # 21. Find the 39s and 40s\n        # 22. Find the 41s and 42s\n        # 23. Find the 43s and 44s\n        # 24. Find the 45s and 46s\n        # 25. Find the 47s and 48s\n        # 26. Find the 49s and 50s\n        # 27. Find the 51s and 52s\n        # 28. Find the 53s and 54s\n        # 29. Find the 55s and 56s\n        # 30. Find the 57s and 58s\n        # 31. Find the 59s and 60s\n        # 32. Find the 61s and 62s\n        # 33. Find the 63s and 64s\n        # 34. Find the 65s and 66s\n        # 35. Find the 67s and 68s\n        # 36. Find the 69s and 70s\n        # 37. Find the 71s and 72s\n        # 38. Find the 73s and 74s\n        # 39. Find the 75s and 76s\n        # 40. Find the 77s and 78s\n        # 41. Find the 79s and 80s\n        # 42. Find the 81s and 82s\n        # 43. Find the 83s and 84s\n        # 44. Find the 85s and 86s\n        # 45. Find the 87s and 88s\n        # 46. Find the 89s and 90s\n        # 47. Find the 91s and 92s\n        # 48. Find the 93s and 94s\n        # 49. Find the 95s and 96s\n        # 50. Find the 97s and 98s\n        # 51. Find the 99s and 100s\n        # 52. Find the 101s and 102s\n        # 53. Find the 103s and 104s\n        # 54. Find the 105s and 106s\n        # 55. Find the 107s and 108s\n        # 56. Find the 109s and 110s\n        # 57. Find the 111s and 112s\n        # 58. Find the 1"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]\n        #     if t[i] in t_map:\n        #         if t_map[t[i]] != s[i]:\n        #             return False\n        #     else:\n        #         t_map[t[i]] = s[i]\n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_map = {}\n        # t_map = {}\n        # for i in range(len(s)):\n        #     if s[i] in s_map:\n        #         if s_map[s[i]] != t[i]:\n        #             return False\n        #     else:\n        #         s_map[s[i]] = t[i]"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums is not empty, return False\n        \n        # if target is in nums, return True\n        # if target is not in nums, return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:\n        #     return 0\n        # if obstacleGrid[0][0] == 0:\n        #     obstacleGrid[0][0] = 1\n        # else:\n        #     obstacleGrid[0][0] = 0\n        #     obstacleGrid[0][1] = 1\n        # if obstacleGrid[0][0] == 1:"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s[0] == '0':\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 3:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 4:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 5:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 6:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 7:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 8:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 9:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 10:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 11:\n        #     if s[1] == '0':\n        #         if s[0] == '1':\n        #             return 1\n        #         else:\n        #             return 0\n        #     else:\n        #         if s[0] == '1':\n        #             return 2\n        #         else:\n        #             return 1\n        # if len(s) == 12:\n        #     if s[1] == '0':"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # initialize the closest sum\n        closest_sum = nums[0] + nums[1] + nums[2]\n        \n        # initialize the closest difference\n        closest_diff = abs(closest_sum - target)\n        \n        # initialize the length of the array\n        n = len(nums)\n        \n        # iterate through the array\n        for i in range(n):\n            \n            # initialize the left and right pointers\n            left = i + 1\n            right = n - 1\n            \n            # iterate through the array\n            while left < right:\n                \n                # calculate the sum\n                sum = nums[i] + nums[left] + nums[right]\n                \n                # calculate the difference\n                diff = abs(sum - target)\n                \n                # if the difference is less than the closest difference\n                if diff < closest_diff:\n                    \n                    # update the closest sum\n                    closest_sum = sum\n                    \n                    # update the closest difference\n                    closest_diff = diff\n                    \n                # if the sum is less than the target\n                if sum < target:\n                    \n                    # increment the left pointer\n                    left += 1\n                    \n                # if the sum is greater than the target\n                else:\n                    \n                    # decrement the right pointer\n                    right -= 1\n                    \n        # return the closest sum\n        return closest_sum"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n        \n        # if root is None:\n        #     return 0\n        \n        # if root.left is None and root.right is None:\n        #     return 1\n        \n        # if root.left is None:\n        #     return 1 + self.maxDepth(root.right)\n        \n        # if root.right is None:\n        #     return 1 + self.maxDepth(root.left)\n        \n        # return 1 + max"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(n) space\n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hashmap to store the frequency of each element in nums1\n        ## 2. Iterate through nums2 and if the element is in the hashmap, add it to the result list and decrement the frequency by 1\n        ## 3. Return the result list\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Create a hash"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## Approach 1: Inorder Traversal\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach 2: Inorder Traversal + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 1: Inorder Traversal\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach 2: Inorder Traversal + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach 1: Inorder Traversal\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Approach 2: Inorder Traversal + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 3: Inorder Traversal + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 4: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 5: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 6: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 7: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 8: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 9: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 10: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 11: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 12: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach 13: Inorder Traversal + Minimum Difference + Minimum Difference + Minimum Difference + Minimum Difference + Minimum"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with the max frequency\n        ## 3. Return the nodes\n        \n        ## 1. Find the max frequency of the tree\n        ## 2. Find the nodes with"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is same as haystack, return 0\n        if needle == haystack:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle) > len(haystack):\n            return -1\n        \n        # if needle is empty, return 0\n        if len(needle) == 0:\n            return 0\n        \n        # if needle is longer than haystack, return -1\n        if len(needle"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \ucd5c\uc18c 3\uac1c \ubc18\ubcf5\ub418\ub294 \ubb38\uc790\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \ucd5c\uc18c 3\uac1c \ubc18\ubcf5\ub418\ub294 \ubb38\uc790\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \ucd5c\uc18c 3\uac1c \ubc18\ubcf5\ub418\ub294 \ubb38\uc790\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \ucd5c\uc18c 3\uac1c \ubc18\ubcf5\ub418\ub294 \ubb38\uc790\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \ucd5c\uc18c 3\uac1c \ubc18\ubcf5\ub418\ub294 \ubb38\uc790\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \ucd5c\uc18c 3\uac1c \ubc18\ubcf5\ub418\ub294 \ubb38\uc790\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \ucd5c\uc18c 3\uac1c \ubc18\ubcf5\ub418\ub294 \ubb38\uc790\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\ufffd"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10 = 2 * 5\n        # 2. 100 = 2 * 50\n        # 3. 1000 = 2 * 500\n        # 4. 10000 = 2 * 5000\n        # 5. 100000 = 2 * 50000\n        # 6. 1000000 = 2 * 500000\n        # 7. 10000000 = 2 * 5000000\n        # 8. 100000000 = 2 * 50000000\n        # 9. 1000000000 = 2 * 500000000\n        # 10. 10000000000 = 2 * 5000000000\n        # 11. 100000000000 = 2 * 50000000000\n        # 12. 1000000000000 = 2 * 500000000000\n        # 13. 10000000000000 = 2 * 5000000000000\n        # 14. 100000000000000 = 2 * 50000000000000\n        # 15. 1000000000000000 = 2 * 500000000000000\n        # 16. 10000000000000000 = 2 * 5000000000000000\n        # 17. 100000000000000000 = 2 * 50000000000000000\n        # 18. 1000000000000000000 = 2 * 500000000000000000\n        # 19. 10000000000000000000 = 2 * 5000000000000000000\n        # 20. 100000000000000000000 = 2 * 50000000000000000000\n        # 21. 1000000000000000000000 = 2 * 500000000000000000000\n        # 22. 10000000000000000000000 = 2 * 5000000000000000000000\n        # 23. 100000000000000000000000 = 2 * 50000000000000000000000\n        # 24. 1000000000000000000000000 = 2 * 500000000000000000000000\n        # 25. 10000000000000000000000000 = 2 * 5000000000000000000000000\n        # 26. 100000000000000000000000000 = 2 * 50000000000000000000"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        # if numRows is 2, then the string is already in zigzag format\n        if numRows == 2:\n            return s\n        \n        # if numRows is greater than 2, then we need to find the zigzag pattern\n        # for each row, we need to find the number of characters in the row\n        # and the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the number of characters in the next row\n        # we need to find the"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. 2 pointers\n        ## 2. 2 pointers\n        ## 3. 2 pointers\n        ## 4. 2 pointers\n        ## 5. 2 pointers\n        ## 6. 2 pointers\n        ## 7. 2 pointers\n        ## 8. 2 pointers\n        ## 9. 2 pointers\n        ## 10. 2 pointers\n        ## 11. 2 pointers\n        ## 12. 2 pointers\n        ## 13. 2 pointers\n        ## 14. 2 pointers\n        ## 15. 2 pointers\n        ## 16. 2 pointers\n        ## 17. 2 pointers\n        ## 18. 2 pointers\n        ## 19. 2 pointers\n        ## 20. 2 pointers\n        ## 21. 2 pointers\n        ## 22. 2 pointers\n        ## 23. 2 pointers\n        ## 24. 2 pointers\n        ## 25. 2 pointers\n        ## 26. 2 pointers\n        ## 27. 2 pointers\n        ## 28. 2 pointers\n        ## 29. 2 pointers\n        ## 30. 2 pointers\n        ## 31. 2 pointers\n        ## 32. 2 pointers\n        ## 33. 2 pointers\n        ## 34. 2 pointers\n        ## 35. 2 pointers\n        ## 36. 2 pointers\n        ## 37. 2 pointers\n        ## 38. 2 pointers\n        ## 39. 2 pointers\n        ## 40. 2 pointers\n        ## 41. 2 pointers\n        ## 42. 2 pointers\n        ## 43. 2 pointers\n        ## 44. 2 pointers\n        ## 45. 2 pointers\n        ## 46. 2 pointers\n        ## 47. 2 pointers\n        ## 48. 2 pointers\n        ## 49. 2 pointers\n        ## 50. 2 pointers\n        ## 51. 2 pointers\n        ## 52. 2 pointers\n        ## 53. 2 pointers\n        ## 54. 2 pointers\n        ## 55. 2 pointers\n        ## 56. 2 pointers\n        ## 57. 2 pointers\n        ## 58. 2 pointers\n        ## 59. 2 pointers\n        ## 60. 2 pointers\n        ## 61. 2 pointers\n        ## 62. 2 pointers\n        ## 63. 2 pointers\n        ## 64. 2 pointers\n        ## 65. 2 pointers\n        ## 66. 2 pointers\n        ## 67. 2 pointers\n        ## 68. 2 pointers\n        ## 69. 2 pointers\n        ## 70. 2 pointers\n        ## 71. 2 pointers\n        ## 72. 2 pointers\n        ## 73. 2 pointers\n        ## 74. 2 pointers\n        ## 75. 2 pointers\n        ## 76. 2 pointers\n        ## 77. 2 pointers\n        ## 78. 2 pointers\n        ## 79. 2 pointers\n        ## 80"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start and end\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        # initialize the result and the last two numbers\n        result = 0\n        last_two = [intervals[0][1], intervals[1][1]]\n        \n        # iterate through the intervals\n        for i in range(2, len(intervals)):\n            # if the last two numbers are not overlapping\n            if last_two[0] > intervals[i][0]:\n                # update the result\n                result += 1\n                # update the last two numbers\n                last_two[0] = intervals[i][1]\n                last_two[1] = intervals[i][1]\n            # if the last two numbers are overlapping\n            else:\n                # update the last two numbers\n                last_two[1] = min(last_two[1], intervals[i][1])\n                last_two[0] = min(last_two[0], intervals[i][1])\n                # update the result\n                result += 1\n        \n        # if the last two numbers are not overlapping\n        if last_two[0] > intervals[len(intervals)-1][0]:\n            # update the result\n            result += 1\n            # update the last two numbers\n            last_two[0] = intervals[len(intervals)-1][1]\n            last_two[1] = intervals[len(intervals)-1][1]\n        # if the last two numbers are overlapping\n        else:\n            # update the last two numbers\n            last_two[1] = min(last_two[1], intervals[len(intervals)-1][1])\n            last_two[0] = min(last_two[0], intervals[len(intervals)-1][1])\n            # update the result\n            result += 1\n        \n        # return the result\n        return result"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # Recursive solution\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        # if root is None:\n        #     return True\n        # return self.isMirror(root.left, root.right)\n        \n        # Iterative solution\n        # Time complexity: O(n)\n        # Space complexity: O(n)\n        if root is None:\n            return True\n        \n        queue = [root.left, root.right]\n        while queue:\n            left = queue.pop(0)\n            right = queue.pop(0)\n            if left is None and right is None:\n                continue\n            if left is None or right is None:\n                return False\n            if left.val != right.val:\n                return False\n            queue.append(left.left)\n            queue.append(right.right)\n            queue.append(left.right)\n            queue.append(right.left)\n        return True\n        \n    def isMirror(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        # return res\n        \n        # Iterative solution\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     res.append(node.val)\n        #     if node.right:\n        #         stack.append("}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 4^0 = 1\n        # 2. 4^1 = 4\n        # 3. 4^2 = 16\n        # 4. 4^3 = 64\n        # 5. 4^4 = 256\n        # 6. 4^5 = 1024\n        # 7. 4^6 = 4096\n        # 8. 4^7 = 16384\n        # 9. 4^8 = 65536\n        # 10. 4^9 = 262144\n        # 11. 4^10 = 1048576\n        # 12. 4^11 = 4194304\n        # 13. 4^12 = 16777216\n        # 14. 4^13 = 67108864\n        # 15. 4^14 = 268435456\n        # 16. 4^15 = 1073741824\n        # 17. 4^16 = 4294967296\n        # 18. 4^17 = 17179869184\n        # 19. 4^18 = 7205759403792\n        # 20. 4^19 = 288230376151712\n        # 21. 4^20 = 1099511627776000\n        # 22. 4^21 = 4491518113824000\n        # 23. 4^22 = 1943745246960000\n        # 24. 4^23 = 7778911841440000\n        # 25. 4^24 = 3221225474200000\n        # 26. 4^25 = 13835651658400000\n        # 27. 4^26 = 54975581388000000\n        # 28. 4^27 = 214748364700000000\n        # 29. 4^28 = 858993459200000000\n        # 30. 4^29 = 3435973836000000000\n        # 31. 4^30 = 13743895340000000000\n        # 32. 4^31 = 53687091200000000000\n        # 33. 4^32 = 218452456000000000000\n        # 34. 4^33 = 855361220000000000000\n        # 35. 4^34 = 3486736600000000000000\n        # 36. 4^35 = 13722362000000000000000\n        # 37. 4^36 = 53687091200000000000000\n        # 38. 4^37 = 218452456000000000000000\n        # 39. 4^38 = 855361220000000000000000\n        # 40. 4^39 = 3486736600000000000000000"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root == None:\n            return None\n        \n        # swap left and right\n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        # recursively invert left and right\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # if n is 0, return []\n        if n == 0:\n            return []\n        \n        # if n is 1, return ['()']\n        if n == 1:\n            return ['()']\n        \n        # if n is 2, return ['()()', '(())']\n        if n == 2:\n            return ['()()', '(())']\n        \n        # if n is 3, return ['()()()', '(())()', '()(())', '(()())', '()()()']\n        if n == 3:\n            return ['()()()', '(())()', '()(())', '(()())', '()()()']\n        \n        # if n is 4, return ['()()()()', '(())()()', '()(())()', '(()())()', '()()(())', '(())()()', '()(())()', '(()())()', '()()()()']\n        if n == 4:\n            return ['()()()()', '(())()()', '()(())()', '(()())()', '()()(())', '(())()()', '()(())()', '(()())()', '()()()()']\n        \n        # if n is 5, return ['()()()()()', '(())()()()', '()(())()()', '(()())()()', '()()(())()', '(())()()()', '()(())()()', '(()())()()', '()()()()()', '(())(())', '()(())()', '(()())()', '()()(())', '(())()()', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '(())(())', '()(())()', '(()())()', '()()()()', '"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[0] == 1:\n            return 1\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n - 1:\n            return 2\n        \n        # edge case\n        if nums[-1] == n - 2:\n            return 3\n        \n        # edge case\n        if nums[-1] == n - 3:\n            return 4\n        \n        # edge case\n        if nums[-1] == n - 4:\n            return 5\n        \n        # edge case\n        if nums[-1] == n - 5:\n            return 6\n        \n        # edge case\n        if nums[-1] == n - 6:\n            return 7\n        \n        # edge case\n        if nums[-1] == n - 7:\n            return 8\n        \n        # edge case\n        if nums[-1] == n - 8:\n            return 9\n        \n        # edge case\n        if nums[-1] == n - 9:\n            return 10\n        \n        # edge case\n        if nums[-1] == n - 10:\n            return 11\n        \n        # edge case\n        if nums[-1] == n - 11:\n            return 12\n        \n        # edge case\n        if nums[-1] == n - 12:\n            return 13\n        \n        # edge case\n        if nums[-1] == n - 13:\n            return 14\n        \n        # edge case\n        if nums[-1] == n - 14:\n            return 15\n        \n        # edge case\n        if nums[-1] == n - 15:\n            return 16\n        \n        # edge case\n        if nums[-1] == n - 16:\n            return 17\n        \n        # edge case\n        if nums[-1] == n - 17:\n            return 18\n        \n        # edge case\n        if nums[-1] == n - 18:\n            return 19\n        \n        # edge case\n        if nums[-1] == n - 19:\n            return 20\n        \n        # edge case\n        if nums[-1] == n - 20:\n            return 21\n        \n        # edge case\n        if nums[-1] == n - 21:\n            return 22\n        \n        # edge case\n        if nums[-1] == n - 22:\n            return 23\n        \n        # edge case\n        if nums[-1] == n - 23:\n            return 24\n        \n        # edge case\n        if nums[-1] == n - 24:\n            return 25\n        \n        # edge case\n        if nums[-1] == n - 25:\n            return 26\n        \n        # edge case\n        if nums[-1] == n - 26:\n            return 27\n        \n        # edge case\n        if nums[-1] == n - 27:\n            return 28\n        \n        # edge case\n        if nums[-1] == n - 28:\n            return 29\n        \n        # edge case\n        if nums[-1] == n - 29:\n            return 30\n        \n        # edge case\n        if nums[-1] == n - 30:\n            return 31\n        \n        # edge case\n        if nums[-1] == n - 31:\n            return 32\n        \n        # edge case\n        if nums[-1] == n - 32:\n            return 33\n        \n        # edge case\n        if nums[-1] == n - 33:\n            return 34\n        \n        #"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1. 2 pointers\n        # 2. 1 stack\n        # 3. 2 pointers + stack\n        # 4. 2 pointers + stack + hashmap\n        \n        # 1"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        # if denominator is 0, return error\n        if denominator == 0:\n            return \"Error\"\n        \n        # if numerator is 0, return 0\n        if numerator == 0:\n            return \"0\"\n        \n        # if numerator is negative, add -1 to numerator and multiply by -1\n        if numerator < 0:\n            numerator = -numerator\n            numerator_str = \"-\"\n        else:\n            numerator_str = \"\"\n        \n        # if denominator is negative, add -1 to denominator and multiply by -1\n        if denominator < 0:\n            denominator = -denominator\n            denominator_str = \"-\"\n        else:\n            denominator_str = \"\"\n        \n        # if numerator is 1, return 1\n        if numerator == 1:\n            return numerator_str + denominator_str + \"1\"\n        \n        # if numerator is 2, return 1/2\n        if numerator == 2:\n            return numerator_str + denominator_str + \"1/2\"\n        \n        # if numerator is 3, return 1/3\n        if numerator == 3:\n            return numerator_str + denominator_str + \"1/3\"\n        \n        # if numerator is 4, return 1/4\n        if numerator == 4:\n            return numerator_str + denominator_str + \"1/4\"\n        \n        # if numerator is 5, return 1/5\n        if numerator == 5:\n            return numerator_str + denominator_str + \"1/5\"\n        \n        # if numerator is 6, return 1/6\n        if numerator == 6:\n            return numerator_str + denominator_str + \"1/6\"\n        \n        # if numerator is 7, return 1/7\n        if numerator == 7:\n            return numerator_str + denominator_str + \"1/7\"\n        \n        # if numerator is 8, return 1/8\n        if numerator == 8:\n            return numerator_str + denominator_str + \"1/8\"\n        \n        # if numerator is 9, return 1/9\n        if numerator == 9:\n            return numerator_str + denominator_str + \"1/9\"\n        \n        # if numerator is 10, return 1/10\n        if numerator == 10:\n            return numerator_str + denominator_str + \"1/10\"\n        \n        # if numerator is 11, return 1/11\n        if numerator == 11:\n            return numerator_str + denominator_str + \"1/11\"\n        \n        # if numerator is 12, return 1/12\n        if numerator == 12:\n            return numerator_str + denominator_str + \"1/12\"\n        \n        # if numerator is 13, return 1/13\n        if numerator == 13:\n            return numerator_str + denominator_str + \"1/13\"\n        \n        # if numerator is 14, return 1/14\n        if numerator == 14:\n            return numerator_str + denominator_str + \"1/14\"\n        \n        # if numerator is 15, return 1/15\n        if numerator == 15:\n            return numerator_str + denominator_str + \"1/15\"\n        \n        # if numerator is 16, return 1/16\n        if numerator == 16:\n            return numerator_str + denominator_str + \"1/16\"\n        \n        # if numerator is 17, return 1/17\n        if numerator == 17:\n            return numerator_str + denominator_str + \"1/17\"\n        \n        # if numerator is 18, return 1/18\n        if numerator == 18:\n            return numerator_str + denominator_str + \"1/18\"\n        \n        # if numerator is 19, return 1/19\n        if numerator == 19:\n            return numerator_str + denominator_str + \"1"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the linked list\n        # 2. Create a dummy node\n        # 3. Create a pointer to the dummy node\n        # 4. Create a pointer to the head of the linked list\n        # 5. Create a pointer to the tail of the linked list\n        # 6. Create a pointer to the middle of the linked list\n        # 7. Split the linked list into two halves\n        # 8. Recursively sort the left half of the linked list\n        # 9. Recursively sort the right half of the linked list\n        # 10. Merge the sorted halves of the linked list\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 3. Create a pointer to the dummy node\n        curr = dummy\n        \n        # 4. Create a pointer to the head of the linked list\n        head = dummy.next\n        \n        # 5. Create a pointer to the tail of the linked list\n        tail = None\n        \n        # 6. Create a pointer to the middle of the linked list\n        middle = None\n        \n        # 7. Split the linked list into two halves\n        if length == 0:\n            return None\n        elif length == 1:\n            return head\n        elif length == 2:\n            if head.val > head.next.val:\n                head.next, head = head, head.next\n            return head\n        else:\n            # 8. Recursively sort the left half of the linked list\n            # 9. Recursively sort the right half of the linked list\n            # 10. Merge the sorted halves of the linked list\n            # 11. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 12. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 13. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 14. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 15. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 16. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 17. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 18. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 19. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 20. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 21. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 22. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 23. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 24. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 25. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 26. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 27. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 28. Set the tail of the right half of the linked list to the tail of the left half of the linked list\n            # 29. Set the tail of the left half of the linked list to the tail of the right half of the linked list\n            # 30. Set the tail of the right half of the linked list to"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # find the longest increasing subsequence\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] < envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] > envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] <= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] <= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] > envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] < envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] >= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] >= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] < envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] > envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] <= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] <= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] > envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] < envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] >= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] >= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] < envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] > envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] <= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] <= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] > envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] < envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] >= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] >= envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] < envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] > envelopes[j][1]\n        # dp[i] = max(dp[j] + 1) for all j < i and envelopes[j][1] <= envelopes[i][1]\n        # dp[i] = 1 if envelopes[i][1] <= envelopes[j][1]\n        # dp[i] = max(dp["}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## 1. Find the length of"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. sort the arrays\n        nums1.sort()\n        nums2.sort()\n        \n        ## 2. set the two pointers\n        i = 0\n        j = 0\n        \n        ## 3. set the result array\n        result = []\n        \n        ## 4. loop through the arrays\n        while i < len(nums1) and j < len(nums2):\n            \n            ## 5. if the two numbers are the same, add it to the result array\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n                \n            ## 6. if the first number is smaller, move the pointer to the next number\n            elif nums1[i] < nums2[j]:\n                i += 1\n                \n            ## 7. if the second number is smaller, move the pointer to the next number\n            else:\n                j += 1\n                \n        ## 8. return the result array\n        return result"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # left_max = 0\n        # right_min = avg\n        # max_diff = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n            \n        #     max_diff = max(max_diff, abs(left_sum - right_sum))\n            \n        #     left_max = max(left_max, left_sum)\n        #     right_min = min(right_min, right_sum)\n            \n        #     if left_max == right_min:\n        #         return max_diff\n            \n        # return max_diff\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # left_max = 0\n        # right_min = avg\n        # max_diff = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n            \n        #     max_diff = max(max_diff, abs(left_sum - right_sum))\n            \n        #     left_max = max(left_max, left_sum)\n        #     right_min = min(right_min, right_sum)\n            \n        #     if left_max == right_min:\n        #         return max_diff\n            \n        # return max_diff\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # left_max = 0\n        # right_min = avg\n        # max_diff = 0\n        \n        # for i in range(n):\n        #     left_sum += machines[i]\n        #     right_sum -= machines[i]\n            \n        #     max_diff = max(max_diff, abs(left_sum - right_sum))\n            \n        #     left_max = max(left_max, left_sum)\n        #     right_min = min(right_min, right_sum)\n            \n        #     if left_max == right_min:\n        #         return max_diff\n            \n        # return max_diff\n        \n        # if sum(machines) % n != 0:\n        #     return -1\n        \n        # n = len(machines)\n        # if n == 1:\n        #     return 0\n        \n        # sum_machines = sum(machines)\n        # avg = sum_machines // n\n        \n        # if avg * n != sum_machines:\n        #     return -1\n        \n        # left_sum = 0\n        # right_sum = sum_machines\n        # left_max = 0\n        # right_min = avg\n        # max_diff = 0\n        \n        # for i in"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            cnt = 0\n            for i in range(1, m + 1):\n                cnt += min(x // i, n)\n            return cnt\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        # find the middle of the linked list\n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the linked list into left and right\n        # left is the left half of the linked list\n        # right is the right half of the linked list\n        left = head\n        right = slow.next\n        slow.next = None\n        \n        # recursively build the tree\n        # base case: if the left is None, return None\n        if not left:\n            return None\n        \n        # recursively build the left subtree\n        left = self.sortedListToBST(left)\n        \n        # recursively build the right subtree\n        right = self.sortedListToBST(right)\n        \n        # return the root node of the tree\n        return TreeNode(slow.val, left, right)"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list2 = list2.next\n        \n        # curr = head\n        \n        # while list1 and list2:\n        #     if list1.val < list2.val:\n        #         curr.next = list1\n        #         list1 = list1.next\n        #     else:\n        #         curr.next = list2\n        #         list2 = list2.next\n        #     curr = curr.next\n        \n        # if list1:\n        #     curr.next = list1\n        # if list2:\n        #     curr.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list2 = list2.next\n        \n        # curr = head\n        \n        # while list1 and list2:\n        #     if list1.val < list2.val:\n        #         curr.next = list1\n        #         list1 = list1.next\n        #     else:\n        #         curr.next = list2\n        #         list2 = list2.next\n        #     curr = curr.next\n        \n        # if list1:\n        #     curr.next = list1\n        # if list2:\n        #     curr.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list2 = list2.next\n        \n        # curr = head\n        \n        # while list1 and list2:\n        #     if list1.val < list2.val:\n        #         curr.next = list1\n        #         list1 = list1.next\n        #     else:\n        #         curr.next = list2\n        #         list2 = list2.next\n        #     curr = curr.next\n        \n        # if list1:\n        #     curr.next = list1\n        # if list2:\n        #     curr.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list2 = list2.next\n        \n        # curr = head\n        \n        # while list1 and list2:\n        #     if list1.val < list2.val:\n        #         curr.next = list1\n        #         list1 = list1.next\n        #     else:\n        #         curr.next = list2\n        #         list2 = list2.next\n        #     curr = curr.next\n        \n        # if list1:\n        #     curr.next = list1\n        # if list2:\n        #     curr.next = list2\n        \n        # return head\n        \n        # if list1 is None:\n        #     return list2\n        # if list2 is None:\n        #     return list1\n        \n        # if list1.val < list2.val:\n        #     head = list1\n        #     list1 = list1.next\n        # else:\n        #     head = list2\n        #     list"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 57. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        #"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. 2^n\n        # 2. 2^n - 1\n        # 3. 2^n - 2\n        # 4. 2^n - 3\n        # 5. 2^n - 4\n        # 6. 2^n - 5\n        # 7. 2^n - 6\n        # 8. 2^n - 7\n        # 9. 2^n - 8\n        # 10. 2^n - 9\n        # 11. 2^n - 10\n        # 12. 2^n - 11\n        # 13. 2^n - 12\n        # 14. 2^n - 13\n        # 15. 2^n - 14\n        # 16. 2^n - 15\n        # 17. 2^n - 16\n        # 18. 2^n - 17\n        # 19. 2^n - 18\n        # 20. 2^n - 19\n        # 21. 2^n - 20\n        # 22. 2^n - 21\n        # 23. 2^n - 22\n        # 24. 2^n - 23\n        # 25. 2^n - 24\n        # 26. 2^n - 25\n        # 27. 2^n - 26\n        # 28. 2^n - 27\n        # 29. 2^n - 28\n        # 30. 2^n - 29\n        # 31. 2^n - 30\n        # 32. 2^n - 31\n        # 33. 2^n - 32\n        # 34. 2^n - 33\n        # 35. 2^n - 34\n        # 36. 2^n - 35\n        # 37. 2^n - 36\n        # 38. 2^n - 37\n        # 39. 2^n - 38\n        # 40. 2^n - 39\n        # 41. 2^n - 40\n        # 42. 2^n - 41\n        # 43. 2^n - 42\n        # 44. 2^n - 43\n        # 45. 2^n - 44\n        # 46. 2^n - 45\n        # 47. 2^n - 46\n        # 48. 2^n - 47\n        # 49. 2^n - 48\n        # 50. 2^n - 49\n        # 51. 2^n - 50\n        # 52. 2^n - 51\n        # 53. 2^n - 52\n        # 54. 2^n - 53\n        # 55. 2^n - 54\n        # 56. 2^n - 55\n        # 57. 2^n - 56\n        # 58. 2^n - 57\n        # 59. 2^n - 58\n        # 60. 2^n - 59\n        # 61. 2^n - 60\n        # 62. 2^n - 61\n        # 63. 2^n - 62\n        # 64. 2^n - 63\n        # 65. 2^n - 64\n        # 66. 2^n - 65\n        # 67. 2^n - 66\n        # 68. 2^n - 67\n        # 69. 2^n - 68\n        # 70. 2^n -"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1000 - M\n        # 500 - D\n        # 100 - C\n        # 50 - L\n        # 10 - X\n        # 5 - V\n        # 1 - I\n        \n        # 1"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. Create a hashmap to store the frequency of each letter in s\n        ## 2. Iterate through t and decrement the frequency of each letter in the hashmap\n        ## 3. Return the letter that has a frequency of 1\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Create a hashmap to store the frequency of each letter in s\n        hashmap = {}\n        \n        ## Iterate through s and increment the frequency of each letter in the hashmap\n        for letter in s:\n            if letter not in hashmap:\n                hashmap[letter] = 1\n            else:\n                hashmap[letter] += 1\n        \n        ## Iterate through t and decrement the frequency of each letter in the hashmap\n        for letter in t:\n            if letter not in hashmap:\n                return letter\n            else:\n                hashmap[letter] -= 1\n        \n        ## Return the letter that has a frequency of 1\n        for letter in hashmap:\n            if hashmap[letter] == 1:\n                return letter\n        \n        ## Return the letter that has a frequency of 1\n        return None"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. 1st pass:\n        # 1.1. find the empty cells\n        # 1.2. mark the empty cells with '.'\n        # 1.3. mark the empty cells with '0'\n        # 1.4. mark the empty cells with '1'\n        # 1.5. mark the empty cells with '2'\n        # 1.6. mark the empty cells with '3'\n        # 1.7. mark the empty cells with '4'\n        # 1.8. mark the empty cells with '5'\n        # 1.9. mark the empty cells with '6'\n        # 1.10. mark the empty cells with '7'\n        # 1.11. mark the empty cells with '8'\n        # 1.12. mark the empty cells with '9'\n        # 1.13. mark the empty cells with '10'\n        # 1.14. mark the empty cells with '11'\n        # 1.15. mark the empty cells with '12'\n        # 1.16. mark the empty cells with '13'\n        # 1.17. mark the empty cells with '14'\n        # 1.18. mark the empty cells with '15'\n        # 1.19. mark the empty cells with '16'\n        # 1.20. mark the empty cells with '17'\n        # 1.21. mark the empty cells with '18'\n        # 1.22. mark the empty cells with '19'\n        # 1.23. mark the empty cells with '20'\n        # 1.24. mark the empty cells with '21'\n        # 1.25. mark the empty cells with '22'\n        # 1.26. mark the empty cells with '23'\n        # 1.27. mark the empty cells with '24'\n        # 1.28. mark the empty cells with '25'\n        # 1.29. mark the empty cells with '26'\n        # 1.30. mark the empty cells with '27'\n        # 1.31. mark the empty cells with '28'\n        # 1.32. mark the empty cells with '29'\n        # 1.33. mark the empty cells with '30'\n        # 1.34. mark the empty cells with '31'\n        # 1.35. mark the empty cells with '32'\n        # 1.36. mark the empty cells with '33'\n        # 1.37. mark the empty cells with '34'\n        # 1.38. mark the empty cells with '35'\n        # 1.39. mark the empty cells with '36'\n        # 1.40. mark the empty cells with '37'\n        # 1.41. mark the empty cells with '38'\n        # 1.42. mark the empty cells with '39'\n        # 1.43. mark the empty cells with '40'\n        # 1.44. mark the empty cells with '41'\n        # 1.45. mark the empty cells with '42'\n        # 1.46. mark the empty cells with '43'\n        # 1.47. mark the empty cells with '44'\n        # 1.48. mark the empty cells with '45'\n        # 1.49. mark the empty cells with '46'\n        # 1.50. mark the empty cells with '47'\n        # 1.51. mark the empty cells with '48'\n        # 1.52. mark the empty cells with '49'\n        # 1.53. mark the empty cells with '50'\n        # 1.54. mark the empty cells with '51'\n        # 1.55. mark the empty cells with '52'\n        # 1.56. mark the empty cells with '53'\n        # 1.57. mark the empty cells with '54'\n        # 1.58. mark the empty cells with"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ## 3. Find the inorder predecessor of the second node\n        ## 4. Swap the values of the two nodes\n        ## 5. Recursively call the inorder successor of the first node\n        ##    and the inorder predecessor of the second node\n        \n        ## 1. Find the two nodes that are swapped\n        ## 2. Find the inorder successor of the first node\n        ##"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half with the second half\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # 3. Compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the square root is an integer, return True\n        # 3. else, return False\n        \n        # 1. find the square root of num\n        # 2. if the"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        \n        # return dummy.next\n        \n        # if head is None:\n        #     return None\n        \n        # dummy = ListNode(0)\n        # dummy.next = head\n        \n        # curr = dummy\n        \n        # while curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s1) != len(s2):\n        #     return False\n        \n        # if s1 == s2:\n        #     return True\n        \n        # if sorted(s1) != sorted(s2):\n        #     return False\n        \n        # if len(s1) == 1:\n        #     return True\n        \n        # if len(s1) == 2:\n        #     return s1[0] == s2[1] and s1[1] == s2[0]\n        \n        # if len(s1) == 3:\n        #     return s1[0] == s2[2] and s1[2] == s2[1] and s1[1] == s2[0]\n        \n        # if len(s1) == 4:\n        #     return s1[0] == s2[3] and s1[3] == s2[2] and s1[1] == s2[0] and s1[2] == s2[1]\n        \n        # if len(s1) == 5:\n        #     return s1[0] == s2[4] and s1[4] == s2[3] and s1[1] == s2[0] and s1[2] == s2[1] and s1[3] == s2[2]\n        \n        # if len(s1) == 6:\n        #     return s1[0] == s2[5] and s1[5] == s2[4] and s1[1] == s2[0] and s1[2] == s2[1] and s1[3] == s2[2] and s1[4] == s2[3]\n        \n        # if len(s1) == 7:\n        #     return s1[0] == s2[6] and s1[6] == s2[5] and s1[1] == s2[0] and s1[2] == s2[1] and s1[3] == s2[2] and s1[4] == s2[3] and s1[5] == s2[4]\n        \n        # if len(s1) == 8:\n        #     return s1[0] == s2[7] and s1[7] == s2[6] and s1[1] == s2[0] and s1[2] == s2[1] and s1[3] == s2[2] and s1[4] == s2[3] and s1[5] == s2[4] and s1[6] == s2[5]\n        \n        # if len(s1) == 9:\n        #     return s1[0] == s2[8] and s1[8] == s2[7] and s1[1] == s2[0] and s1[2] == s2[1] and s1[3] == s2[2] and s1[4] == s2[3] and s1[5] == s2[4] and s1[6] == s2[5] and s1[7] == s2[6]\n        \n        # if len(s1) == 10:\n        #     return s1[0] == s2[9] and s1[9] == s2[8] and s1[1] == s2[0] and s1[2] == s2[1] and s1[3] == s2[2] and s1[4] == s2[3] and s1[5] == s2[4] and s1[6] == s2[5] and s1[7] == s2[6] and s1[8] == s2[7]\n        \n        # if len(s1) == 11:\n        #     return s1[0] == s2[10] and s1[10] == s2[9] and s1[1] == s2[0] and s1[2] == s2[1] and s1[3] == s2[2] and s1[4] == s2[3] and s1[5] == s2[4] and s1[6] == s2[5] and s1[7] == s2[6] and"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of strings\n        path_list = path.split('/')\n        \n        # initialize a stack\n        stack = []\n        \n        # iterate through the list of strings\n        for i in range(len(path_list)):\n            \n            # if the string is empty, do nothing\n            if path_list[i] == '':\n                continue\n            \n            # if the string is a '.' or '..', do nothing\n            elif path_list[i] == '.' or path_list[i] == '..':\n                continue\n            \n            # if the string is not a '.' or '..', add it to the stack\n            else:\n                stack.append(path_list[i])\n        \n        # initialize a string to store the simplified path\n        simplified_path = ''\n        \n        # iterate through the stack\n        for i in range(len(stack)):\n            \n            # if the stack is empty, add a '/' to the simplified path\n            if len(stack) == 0:\n                simplified_path += '/'\n            \n            # if the stack is not empty, add the string to the simplified path\n            else:\n                simplified_path += stack[i]\n                simplified_path += '/'\n        \n        # return the simplified path\n        return simplified_path[:-1]"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a trie from the words\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['*'] = True\n        \n        # Build a set of words that can be found on the board\n        found = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                self.dfs(board, i, j, trie, found)\n        \n        return list(found)\n    \n    def dfs(self, board, i, j, node, found):\n        letter = board[i][j]\n        if letter not in node:\n            return\n        \n        if '*' in node:\n            found.add(letter)\n        \n        # Mark the letter as visited\n        board[i][j] = '#'\n        \n        # Recursively search the neighbors\n        if i > 0:\n            self.dfs(board, i-1, j, node[letter], found)\n        if i < len(board)-1:\n            self.dfs(board, i+1, j, node[letter], found)\n        if j > 0:\n            self.dfs(board, i, j-1, node[letter], found)\n        if j < len(board[0])-1:\n            self.dfs(board, i, j+1, node[letter], found)\n        \n        # Unmark the letter\n        board[i][j] = letter"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        \n        # for i in range(len(t)):\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict or t[i] not in t_dict:\n        #         return False\n        #     elif s_dict[s[i]] != t_dict[s[i]]:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        \n        # for i in range(len(t)):\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        \n        # if len(s_dict) != len(t_dict):\n        #     return False\n        \n        # for i in s_dict:\n        #     if i not in t_dict:\n        #         return False\n        #     elif s_dict[i] != t_dict[i]:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        \n        # for i in range(len(t)):\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        \n        # if len(s_dict) != len(t_dict):\n        #     return False\n        \n        # for i in s_dict:\n        #     if i not in t_dict:\n        #         return False\n        #     elif s_dict[i] != t_dict[i]:\n        #         return False\n        \n        # return True\n        \n        # if len(s) != len(t):\n        #     return False\n        \n        # s_dict = {}\n        # t_dict = {}\n        \n        # for i in range(len(s)):\n        #     if s[i] not in s_dict:\n        #         s_dict[s[i]] = 1\n        #     else:\n        #         s_dict[s[i]] += 1\n        \n        # for i in range(len(t)):\n        #     if t[i] not in t_dict:\n        #         t_dict[t[i]] = 1\n        #     else:\n        #         t_dict[t[i]] += 1\n        \n        # if len(s_dict) != len(t_dict):\n        #     return False\n        \n        # for i in s_dict:\n        #     if i not in t_dict:\n        #         return False\n        #     elif s_dict[i] != t_dict[i]:\n        #         return False\n        \n        # return True\n        \n        # if len("}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 2. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 3. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 4. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 5. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 6. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 7. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 8. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 9. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 10. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 11. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 12. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 13. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 14. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 15. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 16. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 17. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 18. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 19. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 20. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 21. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 22. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 23. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 24. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 25. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 26. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 27. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 28. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 29. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 30. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 31. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 32. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 33. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 34. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 35. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 36. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 37. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 38. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 39. 3 sets of 9 rows, 9 columns, and 9 sub-boxes\n        # 40. 3 sets of 9 rows, 9 columns, and"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        ## split the string into words\n        ## reverse the words\n        ## join the words\n        ## remove the leading and trailing spaces\n        \n        ## split the string into words\n        words = s.split()\n        \n        ## reverse the words\n        words.reverse()\n        \n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces\n        ## join the words\n        ## remove the leading and trailing spaces"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # if both are None\n        if p is None and q is None:\n            return True\n        \n        # if one is None and other is not\n        if p is None or q is None:\n            return False\n        \n        # if both are not None\n        if p.val != q.val:\n            return False\n        \n        # if both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        # and both are not None\n        #"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        curr = slow\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        # merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the number of words is not equal to the number of letters in the pattern, return False\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping of letters to words\n        # create a set to store the set of words\n        # create a set to store the set of letters\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create a dictionary to store the mapping of words to letters\n        # create a dictionary to store the mapping of letters to words\n        # create"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        ## 1. Create a new list node with value 0\n        ## 2. Create a pointer to the new list node\n        ## 3. Create a pointer to the head of the new list\n        ## 4. Create a pointer to the tail of the new list\n        ## 5. Create a pointer to the head of the first list\n        ## 6. Create a pointer to the tail of the first list\n        ## 7. Create a pointer to the head of the second list\n        ## 8. Create a pointer to the tail of the second list\n        ## 9. Create a pointer to the head of the result list\n        ## 10. Create a pointer to the tail of the result list\n        ## 11. Create a pointer to the head of the result list\n        ## 12. Create a pointer to the tail of the result list\n        ## 13. Create a pointer to the head of the result list\n        ## 14. Create a pointer to the tail of the result list\n        ## 15. Create a pointer to the head of the result list\n        ## 16. Create a pointer to the tail of the result list\n        ## 17. Create a pointer to the head of the result list\n        ## 18. Create a pointer to the tail of the result list\n        ## 19. Create a pointer to the head of the result list\n        ## 20. Create a pointer to the tail of the result list\n        ## 21. Create a pointer to the head of the result list\n        ## 22. Create a pointer to the tail of the result list\n        ## 23. Create a pointer to the head of the result list\n        ## 24. Create a pointer to the tail of the result list\n        ## 25. Create a pointer to the head of the result list\n        ## 26. Create a pointer to the tail of the result list\n        ## 27. Create a pointer to the head of the result list\n        ## 28. Create a pointer to the tail of the result list\n        ## 29. Create a pointer to the head of the result list\n        ## 30. Create a pointer to the tail of the result list\n        ## 31. Create a pointer to the head of the result list\n        ## 32. Create a pointer to the tail of the result list\n        ## 33. Create a pointer to the head of the result list\n        ## 34. Create a pointer to the tail of the result list\n        ## 35. Create a pointer to the head of the result list\n        ## 36. Create a pointer to the tail of the result list\n        ## 37. Create a pointer to the head of the result list\n        ## 38. Create a pointer to the tail of the result list\n        ## 39. Create a pointer to the head of the result list\n        ## 40. Create a pointer to the tail of the result list\n        ## 41. Create a pointer to the head of the result list\n        ## 42. Create a pointer to the tail of the result list\n        ## 43. Create a pointer to the head of the result list\n        ## 44. Create a pointer to the tail of the result list\n        ## 45. Create a pointer to the head of the result list\n        ## 46. Create a pointer to the tail of the result list\n        ## 47. Create a pointer to the head of the result list\n        ## 48. Create a pointer to the tail of the result list\n        ## 49. Create a pointer to the head of the result list\n        ## 50. Create a pointer to the tail of the result list\n        ## 51. Create a pointer to the head of the result list\n        ## 52. Create a pointer to the tail of the result list\n        ## 53. Create a pointer to the head of the result list\n        ## 54. Create a pointer to the tail of the result list\n        ## 55. Create a pointer to the head of the result list\n        ## 56. Create a pointer to the tail of the result list\n        ## 57. Create a pointer to the head of the result list\n        ## 58. Create a pointer"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 1:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 1:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 1:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 1:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 1:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 1:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i = 0\n        # while i < len(nums) - 1:\n        #     j = i + 1\n        #     while j < len(nums) - 1:\n        #         if nums[j] - nums[i] == nums[j + 1] - nums[j]:\n        #             count += 1\n        #             j += 1\n        #         else:\n        #             break\n        #     i += 1\n        # return count\n        \n        # if len(nums) < 3:\n        #     return 0\n        \n        # count = 0\n        # i"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # if root is None:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # if root is None:\n        #     return []\n        # stack = [root]\n        # result = []\n        # while stack:\n        #     node = stack.pop()\n        #     if node.left:\n        #         stack.append(node.left)\n        #     if node.right:\n        #         stack.append(node.right)\n        #     result.append(node.val)\n        # return result[::-1]\n        \n        # Iterative solution\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        if root is None:\n            return []\n        stack = [root]\n        result = []\n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n            result.append(node.val)\n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(N * L)\n        # Space Complexity: O(N * L)\n        \n        # 1. Build a dictionary with all the words\n        # 2. Build a set with all the words that are concatenated\n        # 3. Iterate through the words and check if the word is in the set\n        # 4. If the word is in the set, then we can check if the word is concatenated\n        # 5. If the word is not in the set, then we can check if the word is concatenated\n        # 6. If the word is not in the set, then we can check if the word is concatenated\n        # 7. If the word is not in the set, then we can check if the word is concatenated\n        # 8. If the word is not in the set, then we can check if the word is concatenated\n        # 9. If the word is not in the set, then we can check if the word is concatenated\n        # 10. If the word is not in the set, then we can check if the word is concatenated\n        # 11. If the word is not in the set, then we can check if the word is concatenated\n        # 12. If the word is not in the set, then we can check if the word is concatenated\n        # 13. If the word is not in the set, then we can check if the word is concatenated\n        # 14. If the word is not in the set, then we can check if the word is concatenated\n        # 15. If the word is not in the set, then we can check if the word is concatenated\n        # 16. If the word is not in the set, then we can check if the word is concatenated\n        # 17. If the word is not in the set, then we can check if the word is concatenated\n        # 18. If the word is not in the set, then we can check if the word is concatenated\n        # 19. If the word is not in the set, then we can check if the word is concatenated\n        # 20. If the word is not in the set, then we can check if the word is concatenated\n        # 21. If the word is not in the set, then we can check if the word is concatenated\n        # 22. If the word is not in the set, then we can check if the word is concatenated\n        # 23. If the word is not in the set, then we can check if the word is concatenated\n        # 24. If the word is not in the set, then we can check if the word is concatenated\n        # 25. If the word is not in the set, then we can check if the word is concatenated\n        # 26. If the word is not in the set, then we can check if the word is concatenated\n        # 27. If the word is not in the set, then we can check if the word is concatenated\n        # 28. If the word is not in the set, then we can check if the word is concatenated\n        # 29. If the word is not in the set, then we can check if the word is concatenated\n        # 30. If the word is not in the set, then we can check if the word is concatenated\n        # 31. If the word is not in the set, then we can check if the word is concatenated\n        # 32. If the word is not in the set, then we can check if the word is concatenated\n        # 33. If the word is not in the set, then we can check if the word is concatenated\n        # 34. If the word is not in the set, then we can check if the word is concatenated\n        # 35. If the word is not in the set, then we can check if the word is concatenated\n        # 36. If the word is not in the set, then we can check if the word is concatenated\n        # 37. If the word is not in the set, then we can check if the word is concatenated\n        # 38. If the word is not in the set, then we can check if the word is concatenated\n        # 39. If the word is not in the set, then we can check if the word is concatenated\n        # 40. If the word is not in the set,"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = -num\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win\n        # if n is a multiple of 4, then the last move will be a loss\n        # if n is not a multiple of 4, then the last move will be a win"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 queen\n        # 2. 2 queens\n        # 3. 3 queens\n        # 4. 4 queens\n        # 5. 5 queens\n        # 6. 6 queens\n        # 7. 7 queens\n        # 8. 8 queens\n        # 9. 9 queens\n        # 10. 10 queens\n        # 11. 11 queens\n        # 12. 12 queens\n        # 13. 13 queens\n        # 14. 14 queens\n        # 15. 15 queens\n        # 16. 16 queens\n        # 17. 17 queens\n        # 18. 18 queens\n        # 19. 19 queens\n        # 20. 20 queens\n        # 21. 21 queens\n        # 22. 22 queens\n        # 23. 23 queens\n        # 24. 24 queens\n        # 25. 25 queens\n        # 26. 26 queens\n        # 27. 27 queens\n        # 28. 28 queens\n        # 29. 29 queens\n        # 30. 30 queens\n        # 31. 31 queens\n        # 32. 32 queens\n        # 33. 33 queens\n        # 34. 34 queens\n        # 35. 35 queens\n        # 36. 36 queens\n        # 37. 37 queens\n        # 38. 38 queens\n        # 39. 39 queens\n        # 40. 40 queens\n        # 41. 41 queens\n        # 42. 42 queens\n        # 43. 43 queens\n        # 44. 44 queens\n        # 45. 45 queens\n        # 46. 46 queens\n        # 47. 47 queens\n        # 48. 48 queens\n        # 49. 49 queens\n        # 50. 50 queens\n        # 51. 51 queens\n        # 52. 52 queens\n        # 53. 53 queens\n        # 54. 54 queens\n        # 55. 55 queens\n        # 56. 56 queens\n        # 57. 57 queens\n        # 58. 58 queens\n        # 59. 59 queens\n        # 60. 60 queens\n        # 61. 61 queens\n        # 62. 62 queens\n        # 63. 63 queens\n        # 64. 64 queens\n        # 65. 65 queens\n        # 66. 66 queens\n        # 67. 67 queens\n        # 68. 68 queens\n        # 69. 69 queens\n        # 70. 70 queens\n        # 71. 71 queens\n        # 72. 72 queens\n        # 73. 73 queens\n        # 74. 74 queens\n        # 75. 75 queens\n        # 76. 76 queens\n        # 77. 77 queens\n        # 78. 78 queens\n        # 79. 79 queens\n        # 80. 80 queens\n        # 81. 81 queens\n        # 82. 82 queens\n        # 83. 83 queens\n        # 84. 84 queens\n        # 85. 85 queens\n        # 86. 86 queens\n        # 87. 87 queens"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \u521d\u59cb\u5316\u68cb\u76d8\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        # 2. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        row_col_map = {i: [] for i in range(n)}\n        # 3. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        diag_map = {i: [] for i in range(2*n-1)}\n        # 4. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        anti_diag_map = {i: [] for i in range(2*n-1)}\n        \n        # 5. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        for i in range(n):\n            row_col_map[i].append(i)\n        # 6. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            diag_map[i].append(i)\n        # 7. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            anti_diag_map[n-1-i].append(i)\n        \n        # 8. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        for i in range(n):\n            row_col_map[i].append(i)\n        # 9. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            diag_map[i].append(i)\n        # 10. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            anti_diag_map[n-1-i].append(i)\n        \n        # 11. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        for i in range(n):\n            row_col_map[i].append(i)\n        # 12. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            diag_map[i].append(i)\n        # 13. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            anti_diag_map[n-1-i].append(i)\n        \n        # 14. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        for i in range(n):\n            row_col_map[i].append(i)\n        # 15. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            diag_map[i].append(i)\n        # 16. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            anti_diag_map[n-1-i].append(i)\n        \n        # 17. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        for i in range(n):\n            row_col_map[i].append(i)\n        # 18. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            diag_map[i].append(i)\n        # 19. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            anti_diag_map[n-1-i].append(i)\n        \n        # 20. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        for i in range(n):\n            row_col_map[i].append(i)\n        # 21. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            diag_map[i].append(i)\n        # 22. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u53cd\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            anti_diag_map[n-1-i].append(i)\n        \n        # 23. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u884c\u5217\u5750\u6807\n        for i in range(n):\n            row_col_map[i].append(i)\n        # 24. \u521d\u59cb\u5316\u68cb\u76d8\u7684\u5bf9\u89d2\u7ebf\u5750\u6807\n        for i in range(n):\n            diag_map[i].append(i)\n        # 25. \u521d\u59cb"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. Check if the word is empty\n        if not word:\n            return False\n        \n        ## 2. Check if the board is empty\n        if not board:\n            return False\n        \n        ## 3. Check if the word is longer than the board\n        if len(word) > len(board) * len(board[0]):\n            return False\n        \n        ## 4. Check if the word is shorter than the board\n        if len(word) < len(board) * len(board[0]):\n            return False\n        \n        ## 5. Check if the word is the same as the board\n        if word == board[0][0]:\n            return True\n        \n        ## 6. Check if the word is the same as the board\n        if word == board[-1][-1]:\n            return True\n        \n        ## 7. Check if the word is the same as the board\n        if word == board[0][-1]:\n            return True\n        \n        ## 8. Check if the word is the same as the board\n        if word == board[-1][0]:\n            return True\n        \n        ## 9. Check if the word is the same as the board\n        if word == board[0][0] + word[1:]:\n            return True\n        \n        ## 10. Check if the word is the same as the board\n        if word == board[-1][0] + word[1:]:\n            return True\n        \n        ## 11. Check if the word is the same as the board\n        if word == board[0][-1] + word[1:]:\n            return True\n        \n        ## 12. Check if the word is the same as the board\n        if word == board[-1][-1] + word[1:]:\n            return True\n        \n        ## 13. Check if the word is the same as the board\n        if word == board[0][0] + word[1:] + word[0]:\n            return True\n        \n        ## 14. Check if the word is the same as the board\n        if word == board[-1][0] + word[1:] + word[0]:\n            return True\n        \n        ## 15. Check if the word is the same as the board\n        if word == board[0][-1] + word[1:] + word[0]:\n            return True\n        \n        ## 16. Check if the word is the same as the board\n        if word == board[-1][-1] + word[1:] + word[0]:\n            return True\n        \n        ## 17. Check if the word is the same as the board\n        if word == board[0][0] + word[1:] + word[0] + word[1:]:\n            return True\n        \n        ## 18. Check if the word is the same as the board\n        if word == board[-1][0] + word[1:] + word[0] + word[1:]:\n            return True\n        \n        ## 19. Check if the word is the same as the board\n        if word == board[0][-1] + word[1:] + word[0] + word[1:]:\n            return True\n        \n        ## 20. Check if the word is the same as the board\n        if word == board[-1][-1] + word[1:] + word[0] + word[1:]:\n            return True\n        \n        ## 21. Check if the word is the same as the board\n        if word == board[0][0] + word[1:] + word[0] + word[1:] + word[2:]:\n            return True\n        \n        ## 22. Check if the word is the same as the board\n        if word == board[-1][0] + word[1:] + word[0] + word[1:] + word[2:]:\n            return True\n        \n        ## 23. Check if the word is the same as the board\n        if word == board[0][-1] + word[1:] + word[0] + word[1:] + word[2:]:\n            return True\n        \n        ## 24. Check if the word is the same as the board\n        if word == board[-1][-1] +"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        # if len(nums) == 2:\n        #     return max(nums[0], nums[1])\n        # if len(nums) == 3:\n        #     return max(nums[0], nums[1], nums[2])\n        \n        # max1 = max2 = max3 = float('-inf')\n        # max1_count = max2_count = max3_count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] > max1:\n        #         max1 = nums[i]\n        #         max1_count = 1\n        #     elif nums[i] == max1:\n        #         max1_count += 1\n        #     elif nums[i] > max2:\n        #         max2 = nums[i]\n        #         max2_count = 1\n        #     elif nums[i] == max2:\n        #         max2_count += 1\n        #     elif nums[i] > max3:\n        #         max3 = nums[i]\n        #         max3_count = 1\n        #     elif nums[i] == max3:\n        #         max3_count += 1\n        # if max1_count == 1 and max2_count == 1 and max3_count == 1:\n        #     return max1\n        # if max1_count == 1 and max2_count == 1 and max3_count == 2:\n        #     return max2\n        # if max1_count == 1 and max2_count == 2 and max3_count == 1:\n        #     return max2\n        # if max1_count == 1 and max2_count == 2 and max3_count == 2:\n        #     return max3\n        # if max1_count == 2 and max2_count == 1 and max3_count == 1:\n        #     return max2\n        # if max1_count == 2 and max2_count == 1 and max3_count == 2:\n        #     return max3\n        # if max1_count == 2 and max2_count == 2 and max3_count == 1:\n        #     return max3\n        # if max1_count == 2 and max2_count == 2 and max3_count == 2:\n        #     return max1\n        \n        # max1 = max2 = max3 = float('-inf')\n        # max1_count = max2_count = max3_count = 0\n        # for i in range(len(nums)):\n        #     if nums[i] > max1:\n        #         max1 = nums[i]\n        #         max1_count = 1\n        #     elif nums[i] == max1:\n        #         max1_count += 1\n        #     elif nums[i] > max2:\n        #         max2 = nums[i]\n        #         max2_count = 1\n        #     elif nums[i] == max2:\n        #         max2_count += 1\n        #     elif nums[i] > max3:\n        #         max3 = nums[i]\n        #         max3_count = 1\n        #     elif nums[i] == max3:\n        #         max3_count += 1\n        # if max1_count == 1 and max2_count == 1 and max3_count == 1:\n        #     return max1\n        # if max1_count == 1 and max2_count == 1 and max3_count == 2:\n        #     return max2\n        # if max1_count == 1 and max2_count == 2 and max3_count == 1:\n        #     return max2\n        # if max1_count == 1 and max2_count == 2 and max3_count == 2:\n        #     return max3\n        # if max1_count == 2 and max2_count == 1 and max3_count == 1:\n        #     return max2\n        # if max1_count == 2 and max2_count == 1 and max3_count == 2:\n        #     return max3\n        # if max1_count == 2 and max2_count == 2 and max3_count == 1:\n        #"}]}