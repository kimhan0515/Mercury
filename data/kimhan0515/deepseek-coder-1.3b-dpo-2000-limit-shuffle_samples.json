{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right, top, bottom = 0, m-1, 0, n-1\n        while left <= right and top <= bottom:\n            # left to right\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            # top to bottom\n            if top > bottom:\n                break\n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            # right to left\n            if right < left:\n                break\n            for i in range(right, left-1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n            # bottom to top\n            if bottom < top:\n                break\n            for i in range(bottom, top-1, -1):\n                res.append(matrix[i][left])\n            left += 1\n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        if nums[0] < nums[1]:\n            res = [str(nums[0])]\n        else:\n            res = [str(nums[0])]\n        \n        i = 0\n        j = 1\n        while j < len(nums):\n            if nums[j] - nums[j-1] == 1:\n                j += 1\n            else:\n                if j - i == 1:\n                    res.append(str(nums[i]))\n                else:\n                    res.append(str(nums[i]) + \"->\" + str(nums[j-1]))\n                i = j\n                j += 1\n        \n        if j - i == 1:\n            res.append(str(nums[i]))\n        else:\n            res.append(str(nums[i]) + \"->\" + str(nums[j-1]))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] means the number of distinct subsequences of s[:i]\n        # dp[i] = dp[i-1] + dp[i-1]*num_t_in_s[i-1]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len] + ...\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len] + ... - dp[i-t_len]*num_t_in_s[i-1]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len] + ... - dp[i-t_len]*num_t_in_s[i-1] + dp[i-t_len]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len] + ... - dp[i-t_len]*num_t_in_s[i-1] + dp[i-t_len]*num_t_in_s[i-1]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len] + ... - dp[i-t_len]*num_t_in_s[i-1] + dp[i-t_len]*num_t_in_s[i-1] + dp[i-t_len]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len] + ... - dp[i-t_len]*num_t_in_s[i-1] + dp[i-t_len]*num_t_in_s[i-1] + dp[i-t_len]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len] + ... - dp[i-t_len]*num_t_in_s[i-1] + dp[i-t_len]*num_t_in_s[i-1] + dp[i-t_len]\n        # dp[i] = dp[i] + dp[i-1] - dp[i-t_len] + dp[i-1]*num_t_in_s[i-1] - dp[i-2t_len] + ... - dp[i-t_len]*num_t_in_s[i-"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers as 0\n        # 2. mark all numbers in range [1, n] as 1\n        # 3. iterate through the array and mark the corresponding index as -1\n        # 4. iterate through the array again and return the first index with value not equal to -1\n        # 5. if all numbers are present, return n + 1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            j = abs(nums[i]) - 1\n            if j < n:\n                nums[j] -= n\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n            # 2. calculate the kth permutation\n            k = (k - 1) // fact\n        # 3. calculate the permutation\n        res = []\n        # 4. calculate the permutation\n        nums = list(range(1, n + 1))\n        # 5. calculate the permutation\n        for i in range(n - 1, -1, -1):\n            # 6. calculate the permutation\n            res.append(nums[k // fact])\n            # 7. calculate the permutation\n            nums.remove(nums[k // fact])\n            # 8. calculate the permutation\n            k = k % fact\n            # 9. calculate the permutation\n            fact = fact // i\n        # 10. calculate the permutation\n        return ''.join(map(str, res))"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Two pointers\n        # 2. If the sum of two numbers is greater than target, move the right pointer to the left\n        # 3. If the sum of two numbers is less than target, move the left pointer to the right\n        # 4. If the sum of two numbers equals target, return the indices\n        # 5. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 6. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 7. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 8. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 9. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 10. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 11. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 12. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 13. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 14. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 15. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 16. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 17. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 18. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 19. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 20. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 21. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 22. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 23. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 24. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 25. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 26. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 27. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 28. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 29. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 30. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 31. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 32. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 33. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 34. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 35. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 36. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 37. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 38. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 39. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 40. If the sum of two numbers does not equal target, move the left pointer to the right\n        # 41. If the sum of two numbers does not equal target, move the right pointer to the right\n        # 42. If the sum of two numbers does not equal target, move the left pointer to the right\n        #"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if not num: return []\n        if num[0] == '0' and num[1] != '+' and num[1] != '-': return []\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        ## 1. recursive solution\n        ## 2. iterative solution\n        ## 3. DFS\n        ## 4. BFS\n        ## 5. preorder traversal\n        ## 6. inorder traversal\n        ## 7. postorder traversal\n        ## 8. level order traversal\n        ## 9. BFS\n        ## 10. DFS\n        ## 11. BFS\n        ## 12. DFS\n        ## 13. BFS\n        ## 14. DFS\n        ## 15. BFS\n        ## 16. DFS\n        ## 17. BFS\n        ## 18. DFS\n        ## 19. BFS\n        ## 20. DFS\n        ## 21. BFS\n        ## 22. DFS\n        ## 23. BFS\n        ## 24. DFS\n        ## 25. BFS\n        ## 26. DFS\n        ## 27. BFS\n        ## 28. DFS\n        ## 29. BFS\n        ## 30. DFS\n        ## 31. BFS\n        ## 32. DFS\n        ## 33. BFS\n        ## 34. DFS\n        ## 35. BFS\n        ## 36. DFS\n        ## 37. BFS\n        ## 38. DFS\n        ## 39. BFS\n        ## 40. DFS\n        ## 41. BFS\n        ## 42. DFS\n        ## 43. BFS\n        ## 44. DFS\n        ## 45. BFS\n        ## 46. DFS\n        ## 47. BFS\n        ## 48. DFS\n        ## 49. BFS\n        ## 50. DFS\n        ## 51. BFS\n        ## 52. DFS\n        ## 53. BFS\n        ## 54. DFS\n        ## 55. BFS\n        ## 56. DFS\n        ## 57. BFS\n        ## 58. DFS\n        ## 59. BFS\n        ## 60. DFS\n        ## 61. BFS\n        ## 62. DFS\n        ## 63. BFS\n        ## 64. DFS\n        ## 65. BFS\n        ## 66. DFS\n        ## 67. BFS\n        ## 68. DFS\n        ## 69. BFS\n        ## 70. DFS\n        ## 71. BFS\n        ## 72. DFS\n        ## 73. BFS\n        ## 74. DFS\n        ## 75. BFS\n        ## 76. DFS\n        ## 77. BFS\n        ## 78. DFS\n        ## 79. BFS\n        ## 80. DFS\n        ## 81. BFS\n        ## 82. DFS\n        ## 83. BFS\n        ## 84. DFS\n        ## 85. BFS\n        ## 86. DFS\n        ## 87. BFS\n        ## 88. DFS\n        ## 89. BFS\n        ## 90. DFS\n        ## 91. BFS\n        ## 92. DFS\n        ## 93. BFS\n        ## 94. DFS\n        ## 95. BFS\n        ## 96. DFS\n        ## 97. BFS\n        ## 98. DFS\n        ## 99. BFS\n        ## 100. DFS\n        ## 1"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        ## first reverse the string\n        s = s[::-1]\n        ## find the number of groups\n        groups = s.count('-')\n        ## if the number of groups is 0, return the original string\n        if groups == 0:\n            return s\n        ## if the number of groups is larger than the length of the string, return the original string\n        if groups > len(s):\n            return s\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups\n        groups = groups + groups // k\n        ## find the number of groups"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        start = 0\n        total_gas = 0\n        total_cost = 0\n        \n        for i in range(len(gas)):\n            total_gas += gas[i]\n            total_cost += cost[i]\n            if gas[i] < cost[i]:\n                start = i\n                \n        if total_gas < total_cost:\n            return start\n        \n        remain_gas = 0\n        for i in range(start):\n            remain_gas += gas[i] - cost[i]\n            \n        if remain_gas < 0:\n            return start\n        \n        # find the starting station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the ending station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas >= 0:\n        #     return -1\n        \n        # find the middle station\n        # if remain_gas < 0:\n        #     return -1\n        \n        # find the middle station\n        # if"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i-1]\n        # 2. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1]\n        # 3. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2]\n        # 4. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3]\n        # 5. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4]\n        # 6. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5]\n        # 7. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5] + nums[i+6]\n        # 8. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5] + nums[i+6] + nums[i+7]\n        # 9. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5] + nums[i+6] + nums[i+7] + nums[i+8]\n        # 10. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5] + nums[i+6] + nums[i+7] + nums[i+8] + nums[i+9]\n        # 11. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5] + nums[i+6] + nums[i+7] + nums[i+8] + nums[i+9] + nums[i+10]\n        # 12. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5] + nums[i+6] + nums[i+7] + nums[i+8] + nums[i+9] + nums[i+10] + nums[i+11]\n        # 13. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5] + nums[i+6] + nums[i+7] + nums[i+8] + nums[i+9] + nums[i+10] + nums[i+11] + nums[i+12]\n        # 14. \u5c06nums[i] \u53d8\u4e3a nums[i] + nums[i+1] + nums[i+2] + nums[i+3] + nums[i+4] + nums[i+5] + nums[i+6] + nums[i+7] + nums[i+8] + nums[i+9] + nums[i+10] + nums[i+1"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # reverse the digits list\n        digits = digits[::-1]\n        \n        # add 1 to the first digit\n        digits[0] += 1\n        \n        # carry over the ones place\n        for i in range(1, len(digits)):\n            if digits[i] >= 10:\n                digits[i] -= 10\n                if i == len(digits) - 1:\n                    digits.append(1)\n                else:\n                    digits[i + 1] += 1\n        \n        # reverse the digits list again\n        return digits[::-1]"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then it means it can match any string\n        if not p:\n            return False\n        \n        # if p is not empty, then it means it can match any string\n        if not p[0] == '*':\n            return False\n        \n        # if p is '*', then it means it can match any string\n        if not p[1:]:\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '*':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '.':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '+':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '?':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '{':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '}':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '[':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == ']':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '(':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == ')':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '<':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '>':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '|':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '^':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '&':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '$':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '~':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '`':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '\\\\':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '^':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '|':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '^':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '|':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '^':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '|':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '^':\n            return True\n        \n        # if p is '*', then it means it can match any string\n        if p[1] == '|':\n            return True\n        \n        # if p is '*', then it means it"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the length of the subarray in nums1 that is not compared to nums2\n        if len(nums1) < k:\n            return nums2[:k]\n        if len(nums2) < k:\n            return nums1[:k]\n        \n        # find the length of the subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is less than k, then we can't find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is equal to k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we can find a subarray in nums2 that is not compared to nums1\n        # if the length of nums2 is greater than k, then we"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        if num % 3 == 0:\n            return False\n        if num % 5 == 0:\n            return False\n        if num % 7 == 0:\n            return False\n        if num % 11 == 0:\n            return False\n        if num % 13 == 0:\n            return False\n        if num % 17 == 0:\n            return False\n        if num % 19 == 0:\n            return False\n        if num % 23 == 0:\n            return False\n        if num % 29 == 0:\n            return False\n        if num % 31 == 0:\n            return False\n        if num % 37 == 0:\n            return False\n        if num % 41 == 0:\n            return False\n        if num % 43 == 0:\n            return False\n        if num % 47 == 0:\n            return False\n        if num % 53 == 0:\n            return False\n        if num % 59 == 0:\n            return False\n        if num % 61 == 0:\n            return False\n        if num % 67 == 0:\n            return False\n        if num % 71 == 0:\n            return False\n        if num % 73 == 0:\n            return False\n        if num % 79 == 0:\n            return False\n        if num % 83 == 0:\n            return False\n        if num % 89 == 0:\n            return False\n        if num % 97 == 0:\n            return False\n        if num % 101 == 0:\n            return False\n        if num % 103 == 0:\n            return False\n        if num % 107 == 0:\n            return False\n        if num % 109 == 0:\n            return False\n        if num % 113 == 0:\n            return False\n        if num % 127 == 0:\n            return False\n        if num % 131 == 0:\n            return False\n        if num % 137 == 0:\n            return False\n        if num % 139 == 0:\n            return False\n        if num % 149 == 0:\n            return False\n        if num % 151 == 0:\n            return False\n        if num % 157 == 0:\n            return False\n        if num % 163 == 0:\n            return False\n        if num % 167 == 0:\n            return False\n        if num % 173 == 0:\n            return False\n        if num % 179 == 0:\n            return False\n        if num % 181 == 0:\n            return False\n        if num % 191 == 0:\n            return False\n        if num % 193 == 0:\n            return False\n        if num % 197 == 0:\n            return False\n        if num % 199 == 0:\n            return False\n        if num % 223 == 0:\n            return False\n        if num % 227 == 0:\n            return False\n        if num % 229 == 0:\n            return False\n        if num % 233 == 0:\n            return False\n        if num % 239 == 0:\n            return False\n        if num % 241 == 0:\n            return False\n        if num % 251 == 0:\n            return False\n        if num % 257 == 0:\n            return False\n        if num % 263 == 0:\n            return False\n        if num % 269 == 0:\n            return False\n        if num % 271 == 0:\n            return False\n        if num % 277 == 0:\n            return False\n        if num % 281 == 0:\n            return False\n        if num % 283 == 0:\n            return False\n        if num % 293 == 0:\n            return False\n        if num % 307 == 0:\n            return False\n        if num % 311 == 0:\n            return False\n        if num % 313 == 0:\n            return False\n        if num % 31"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n > 1:\n            a, b = 0, 1\n            for i in range(2, n+1):\n                a, b = b, a+b\n            return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # \u4ece\u540e\u5f80\u524d\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e0\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u52a0\u4e0a\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\n        # \u5982\u679c\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u5c0f\u4e8e\u4e0b\u4e00\u4e2a\u623f\u95f4\u7684\u8840\u91cf\uff0c\u8bf4\u660e\u5f53\u524d\u623f\u95f4\u7684\u8840\u91cf\u4e00\u5b9a\u662f0\uff0c\u5426\u5219\u8840\u91cf\u4e3a"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        nums.sort()\n        \n        # binary search the number of pairs with distance k\n        # if the number of pairs with distance k is less than k,\n        # then the answer is the number of pairs with distance k+1\n        # if the number of pairs with distance k is greater than k,\n        # then the answer is the number of pairs with distance k-1\n        # if the number of pairs with distance k is equal to k,\n        # then the answer is the number of pairs with distance k\n        # if the number of pairs with distance k is equal to k+1,\n        # then the answer is the number of pairs with distance k-1\n        # if the number of pairs with distance k is equal to k-1,\n        # then the answer is the number of pairs with distance k\n        # if the number of pairs with distance k is equal to k-2,\n        # then the answer is the number of pairs with distance k-2\n        # ...\n        # if the number of pairs with distance k is equal to 1,\n        # then the answer is the number of pairs with distance 0\n        # if the number of pairs with distance k is equal to 0,\n        # then the answer is the number of pairs with distance -1\n        # if the number of pairs with distance k is equal to -1,\n        # then the answer is the number of pairs with distance -2\n        # ...\n        # if the number of pairs with distance k is equal to -k,\n        # then the answer is the number of pairs with distance -k+1\n        # if the number of pairs with distance k is equal to -k-1,\n        # then the answer is the number of pairs with distance -k+2\n        # ...\n        # if the number of pairs with distance k is equal to -k-k,\n        # then the answer is the number of pairs with distance -k-k+1\n        # if the number of pairs with distance k is equal to -k-k-1,\n        # then the answer is the number of pairs with distance -k-k-2\n        # ...\n        # if the number of pairs with distance k is equal to -k-k-k,\n        # then the answer is the number of pairs with distance -k-k-k+1\n        # if the number of pairs with distance k is equal to -k-k-k-1,\n        # then the answer is the number of pairs with distance -k-k-k-2\n        # ...\n        # if the number of pairs with distance k is equal to -k-k-k-k,\n        # then the answer is the number of pairs with distance -k-k-k-k+1\n        # if the number of pairs with distance k is equal to -k-k-k-k-1,\n        # then the answer is the number of pairs with distance -k-k-k-k-2\n        # ...\n        # if the number of pairs with distance k is equal to -k-k-k-k-k,\n        # then the answer is the number of pairs with distance -k-k-k-k-k+1\n        # if the number of pairs with distance k is equal to -k-k-k-k-k-1,\n        # then the answer is the number of pairs with distance -k-k-k-k-k-2\n        # ...\n        # if the number of pairs with distance k is equal to -k-k-k-k-k-k,\n        # then the answer is the number of pairs with distance -k-k-k-k-k-k+1\n        # if the number of pairs with distance k is equal to -k-k-k-k-k-k-1,\n        # then the answer is the number of pairs with distance -k-k-k-k-k-k-2\n        # ...\n        # if the number of pairs with distance k is equal to -k-k-k-k-k-k-k,\n        # then the answer is the number of pairs with distance -k-k-k-k-k-k-k+1\n        # if the number of pairs with distance k is equal to -k-k-k-k-k-k-k-1,\n        # then the answer is the number of pairs with distance -k-k-k-k-k-k-k-2\n        # ...\n        # if the number of pairs with distance k is equal to"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s is empty, return 0\n        if not s:\n            return 0\n        \n        # if s only contains spaces, return 0\n        if s.isspace():\n            return 0\n        \n        # if s only contains digits, return 1\n        if s.isdigit():\n            return 1\n        \n        # if s only contains letters, return 1\n        if s.isalpha():\n            return 1\n        \n        # if s contains letters and digits, return 2\n        if s.isalnum():\n            return 2\n        \n        # if s contains letters, digits, and special characters, return 3\n        if s.isalnum() or s.isalpha() or s.isdigit():\n            return 3\n        \n        # if s contains letters, digits, and special characters, return 4\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace():\n            return 4\n        \n        # if s contains letters, digits, special characters, and spaces, return 5\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum():\n            return 5\n        \n        # if s contains letters, digits, special characters, spaces, and special characters, return 6\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha():\n            return 6\n        \n        # if s contains letters, digits, special characters, spaces, and special characters, return 7\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit():\n            return 7\n        \n        # if s contains letters, digits, special characters, spaces, and special characters, return 8\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit() or s.isspace():\n            return 8\n        \n        # if s contains letters, digits, special characters, spaces, and special characters, return 9\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum():\n            return 9\n        \n        # if s contains letters, digits, special characters, spaces, and special characters, return 10\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha():\n            return 10\n        \n        # if s contains letters, digits, special characters, spaces, and special characters, return 11\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum():\n            return 11\n        \n        # if s contains letters, digits, special characters, spaces, and special characters, return 12\n        if s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum() or s.isalpha() or s.isdigit() or s.isspace() or s.isalnum():\n            return 12\n        \n        # if s contains letters, digits, special characters, spaces, and special characters, return 13\n        if s.isalnum() or s.isalpha()"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the vowels\n        # 2. reverse the vowels\n        # 3. join the vowels\n        vowels = [i for i in s if i in 'aeiouAEIOU']\n        j = len(vowels) - 1\n        ans = list(s)\n        for i in range(len(s)):\n            if s[i] in 'aeiouAEIOU':\n                ans[i] = vowels[j]\n                j -= 1\n        return ''.join(ans)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums is empty, return 0\n        if not nums:\n            return 0\n        \n        # create a hashmap to store the number and its index\n        # if the number is already in the hashmap, we don't need to do anything\n        # if the number is not in the hashmap, we will add it to the hashmap\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        # if the number is in the hashmap, we will update the index of the number\n        #"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## XOR all the numbers from 0 to n\n        ## XOR all the numbers from 0 to n+1\n        ## XOR all the numbers from 0 to 2n+1\n        ## XOR all the numbers from 0 to 2n+2\n        ## XOR all the numbers from 0 to 2n+3\n        ## XOR all the numbers from 0 to 2n+4\n        ## XOR all the numbers from 0 to 2n+5\n        ## XOR all the numbers from 0 to 2n+6\n        ## XOR all the numbers from 0 to 2n+7\n        ## XOR all the numbers from 0 to 2n+8\n        ## XOR all the numbers from 0 to 2n+9\n        ## XOR all the numbers from 0 to 2n+10\n        ## XOR all the numbers from 0 to 2n+11\n        ## XOR all the numbers from 0 to 2n+12\n        ## XOR all the numbers from 0 to 2n+13\n        ## XOR all the numbers from 0 to 2n+14\n        ## XOR all the numbers from 0 to 2n+15\n        ## XOR all the numbers from 0 to 2n+16\n        ## XOR all the numbers from 0 to 2n+17\n        ## XOR all the numbers from 0 to 2n+18\n        ## XOR all the numbers from 0 to 2n+19\n        ## XOR all the numbers from 0 to 2n+20\n        ## XOR all the numbers from 0 to 2n+21\n        ## XOR all the numbers from 0 to 2n+22\n        ## XOR all the numbers from 0 to 2n+23\n        ## XOR all the numbers from 0 to 2n+24\n        ## XOR all the numbers from 0 to 2n+25\n        ## XOR all the numbers from 0 to 2n+26\n        ## XOR all the numbers from 0 to 2n+27\n        ## XOR all the numbers from 0 to 2n+28\n        ## XOR all the numbers from 0 to 2n+29\n        ## XOR all the numbers from 0 to 2n+30\n        ## XOR all the numbers from 0 to 2n+31\n        ## XOR all the numbers from 0 to 2n+32\n        ## XOR all the numbers from 0 to 2n+33\n        ## XOR all the numbers from 0 to 2n+34\n        ## XOR all the numbers from 0 to 2n+35\n        ## XOR all the numbers from 0 to 2n+36\n        ## XOR all the numbers from 0 to 2n+37\n        ## XOR all the numbers from 0 to 2n+38\n        ## XOR all the numbers from 0 to 2n+39\n        ## XOR all the numbers from 0 to 2n+40\n        ## XOR all the numbers from 0 to 2n+41\n        ## XOR all the numbers from 0 to 2n+42\n        ## XOR all the numbers from 0 to 2n+43\n        ## XOR all the numbers from 0 to 2n+44\n        ## XOR all the numbers from 0 to 2n+45\n        ## XOR all the numbers from 0 to 2n+46\n        ## XOR all the numbers from 0 to 2n+47\n        ## XOR all the numbers from 0 to 2n+48\n        ## XOR all the numbers from 0 to 2n+49\n        ## XOR all the numbers from 0 to 2n+50\n        ## XOR all the numbers from 0 to 2n+51\n        ## XOR all the numbers from 0 to 2n+52\n        ## XOR all the numbers from 0 to 2n"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        if endWord not in wordList:\n            return 0\n        \n        # build a hashmap of the wordList\n        word_map = {}\n        for word in wordList:\n            if word not in word_map:\n                word_map[word] = []\n            word_map[word].append(word)\n        \n        # build a queue and a set to track visited words\n        queue = [beginWord]\n        visited = set()\n        \n        # build a hashmap to track the number of steps\n        step = 1\n        # build a hashmap to track the number of steps\n        step_map = {beginWord: 1}\n        \n        # iterate until the queue is empty\n        while queue:\n            # iterate through the current level\n            next_level = []\n            for word in queue:\n                # if the word is the endWord, return the step\n                if word == endWord:\n                    return step_map[word]\n                # otherwise, add the words in the word_map[word] to the next_level\n                else:\n                    next_level.extend(word_map[word] if word in word_map else [])\n            # increment the step\n            step += 1\n            # add the next_level to the queue\n            queue.extend(next_level)\n            # add the visited words to the visited set\n            visited.update(queue)\n            # add the step_map[word] to the step_map\n            step_map[word] = step\n        \n        # return 0 if the endWord is not in the word_map\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # if len(a) < len(b):\n        #     a, b = b, a\n        #\n        # carry = 0\n        # res = ''\n        #\n        # for i in range(len(a)-1, -1, -1):\n        #     if a[i] == '1':\n        #         carry += 1\n        #     if i < len(b):\n        #         if b[i] == '1':\n        #             carry += 1\n        #     res = str(carry%2) + res\n        #     carry //= 2\n        #\n        # if carry:\n        #     res = '1' + res\n        #\n        # return res\n\n        # if len(a) < len(b):\n        #     a, b = b, a\n        #\n        # carry = 0\n        # res = ''\n        #\n        # for i in range(len(a)-1, -1, -1):\n        #     if a[i] == '1':\n        #         carry += 1\n        #     if i < len(b):\n        #         if b[i] == '1':\n        #             carry += 1\n        #     res = str(carry%2) + res\n        #     carry //= 2\n        #\n        # if carry:\n        #     res = '1' + res\n        #\n        # return res\n\n        # if len(a) < len(b):\n        #     a, b = b, a\n        #\n        # carry = 0\n        # res = ''\n        #\n        # for i in range(len(a)-1, -1, -1):\n        #     if a[i] == '1':\n        #         carry += 1\n        #     if i < len(b):\n        #         if b[i] == '1':\n        #             carry += 1\n        #     res = str(carry%2) + res\n        #     carry //= 2\n        #\n        # if carry:\n        #     res = '1' + res\n        #\n        # return res\n\n        # if len(a) < len(b):\n        #     a, b = b, a\n        #\n        # carry = 0\n        # res = ''\n        #\n        # for i in range(len(a)-1, -1, -1):\n        #     if a[i] == '1':\n        #         carry += 1\n        #     if i < len(b):\n        #         if b[i] == '1':\n        #             carry += 1\n        #     res = str(carry%2) + res\n        #     carry //= 2\n        #\n        # if carry:\n        #     res = '1' + res\n        #\n        # return res\n\n        # if len(a) < len(b):\n        #     a, b = b, a\n        #\n        # carry = 0\n        # res = ''\n        #\n        # for i in range(len(a)-1, -1, -1):\n        #     if a[i] == '1':\n        #         carry += 1\n        #     if i < len(b):\n        #         if b[i] == '1':\n        #             carry += 1\n        #     res = str(carry%2) + res\n        #     carry //= 2\n        #\n        # if carry:\n        #     res = '1' + res\n        #\n        # return res\n\n        # if len(a) < len(b):\n        #     a, b = b, a\n        #\n        # carry = 0\n        # res = ''\n        #\n        # for i in range(len(a)-1, -1, -1):\n        #     if a[i] == '1':\n        #         carry += 1\n        #     if i < len(b):\n        #         if b[i] == '1':\n        #             carry += 1\n        #     res = str(carry%2) + res\n        #     carry //= 2\n        #\n        # if carry:\n        #     res = '1' + res\n        #\n        # return res\n\n        # if len(a) < len(b):\n        #     a, b = b, a\n        #\n        # carry = 0"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the index of the target\n        # if not found, return [-1, -1]\n        # if found, find the leftmost and rightmost index\n        # return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1]\n        # if found, return [leftmost_index, rightmost_index]\n        # if not found, return [-1, -1"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        # slow and fast pointers\n        slow = 0\n        fast = 1\n        \n        # iterate through the list\n        while fast < len(nums):\n            # if the current element is different from the previous element\n            if nums[slow] != nums[fast]:\n                # move the slow pointer to the next position\n                slow += 1\n                # move the element at the slow pointer to the current fast pointer\n                nums[slow] = nums[fast]\n            # move the fast pointer to the next position\n            fast += 1\n        # return the length of the list minus the slow pointer\n        return slow + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return 0\n        # if nums[0] >= len(nums) - 1:\n        #     return 1\n        # if nums[0] == 0:\n        #     return 0\n        # if nums[0] == 1:\n        #     return 1\n        # if nums[0] == 2:\n        #     return 2\n        # if nums[0] == 3:\n        #     return 3\n        # if nums[0] == 4:\n        #     return 4\n        # if nums[0] == 5:\n        #     return 5\n        # if nums[0] == 6:\n        #     return 6\n        # if nums[0] == 7:\n        #     return 7\n        # if nums[0] == 8:\n        #     return 8\n        # if nums[0] == 9:\n        #     return 9\n        # if nums[0] == 10:\n        #     return 10\n        # if nums[0] == 11:\n        #     return 11\n        # if nums[0] == 12:\n        #     return 12\n        # if nums[0] == 13:\n        #     return 13\n        # if nums[0] == 14:\n        #     return 14\n        # if nums[0] == 15:\n        #     return 15\n        # if nums[0] == 16:\n        #     return 16\n        # if nums[0] == 17:\n        #     return 17\n        # if nums[0] == 18:\n        #     return 18\n        # if nums[0] == 19:\n        #     return 19\n        # if nums[0] == 20:\n        #     return 20\n        # if nums[0] == 21:\n        #     return 21\n        # if nums[0] == 22:\n        #     return 22\n        # if nums[0] == 23:\n        #     return 23\n        # if nums[0] == 24:\n        #     return 24\n        # if nums[0] == 25:\n        #     return 25\n        # if nums[0] == 26:\n        #     return 26\n        # if nums[0] == 27:\n        #     return 27\n        # if nums[0] == 28:\n        #     return 28\n        # if nums[0] == 29:\n        #     return 29\n        # if nums[0] == 30:\n        #     return 30\n        # if nums[0] == 31:\n        #     return 31\n        # if nums[0] == 32:\n        #     return 32\n        # if nums[0] == 33:\n        #     return 33\n        # if nums[0] == 34:\n        #     return 34\n        # if nums[0] == 35:\n        #     return 35\n        # if nums[0] == 36:\n        #     return 36\n        # if nums[0] == 37:\n        #     return 37\n        # if nums[0] == 38:\n        #     return 38\n        # if nums[0] == 39:\n        #     return 39\n        # if nums[0] == 40:\n        #     return 40\n        # if nums[0] == 41:\n        #     return 41\n        # if nums[0] == 42:\n        #     return 42\n        # if nums[0] == 43:\n        #     return 43\n        # if nums[0] == 44:\n        #     return 44\n        # if nums[0] == 45:\n        #     return 45\n        # if nums[0] == 46:\n        #     return 46\n        # if nums[0] == 47:"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(prices[i] - prices[i - 1] for i in range(1, len(prices)) if prices[i] > prices[i - 1])\n        if k == 0:\n            return 0\n        # dp[i] means the max profit when k transactions are done with i] days left\n        dp = [0] * (k + 1)\n        # min_price[i] means the lowest price of the ith day\n        min_price = [float('inf')] * (k + 1)\n        for price in prices:\n            for t in reversed(range(1, k + 1)):\n                # if t is odd, buy\n                if t & 1:\n                    dp[t] = max(dp[t] - price, min_price[t - 1] - price)\n                # if t is even, sell\n                else:\n                    dp[t] = max(dp[t] + price, dp[t - 1] + price)\n                    min_price[t] = min(min_price[t], price)\n        return dp[k]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = 0xffffffff + num + 1\n        \n        # 16\u8fdb\u5236\u8f6c\u6362\u4e3a2\u8fdb\u5236\n        # 0x000000000000000000000000000000000000000000000000000000000000000010100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap with all the characters in the string\n        # and their respective indices\n        # if the character is seen more than once,\n        # set the value to -1\n        # if the character is seen once,\n        # set the value to the index\n        # if the character is seen once,\n        # return the value\n        # if the character is not seen,\n        # return -1\n        # if the string is empty,\n        # return -1\n        # if the string is not empty,\n        # return the first index of the first character that is not seen more than once\n        \n        # create a hashmap with all the characters in the string\n        # and their respective indices\n        # if the character is seen more than once,\n        # set the value to -1\n        # if the character is seen once,\n        # set the value to the index\n        # if the character is seen once,\n        # return the value\n        # if the character is not seen,\n        # return -1\n        # if the string is empty,\n        # return -1\n        # if the string is not empty,\n        # return the first index of the first character that is not seen more than once\n        \n        # create a hashmap with all the characters in the string\n        # and their respective indices\n        # if the character is seen more than once,\n        # set the value to -1\n        # if the character is seen once,\n        # set the value to the index\n        # if the character is seen once,\n        # return the value\n        # if the character is not seen,\n        # return -1\n        # if the string is empty,\n        # return -1\n        # if the string is not empty,\n        # return the first index of the first character that is not seen more than once\n        hm = {}\n        for i in range(len(s)):\n            if s[i] in hm:\n                hm[s[i]] = -1\n            else:\n                hm[s[i]] = i\n        # if the character is seen more than once,\n        # set the value to -1\n        # if the character is seen once,\n        # set the value to the index\n        # if the character is seen once,\n        # return the value\n        # if the character is not seen,\n        # return -1\n        # if the string is empty,\n        # return -1\n        # if the string is not empty,\n        # return the first index of the first character that is not seen more than once\n        for i in range(len(s)):\n            if hm[s[i]] != -1:\n                return hm[s[i]]\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if the length of the list is less than 2, return False\n        if len(nums) < 2:\n            return False\n        \n        # if the difference between the index and the value is larger than the difference, return False\n        if indexDiff < valueDiff:\n            return False\n        \n        # if the difference between the index and the value is 0, return True\n        if indexDiff == 0:\n            return True\n        \n        # initialize the hashmap\n        hashmap = {}\n        \n        # iterate through the list\n        for i in range(len(nums)):\n            \n            # if the number is in the hashmap, return True\n            if nums[i] in hashmap:\n                return True\n            \n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find the closest number in the hashmap\n            # if the number is equal to the hashmap, find the closest number in the hashmap\n            # if the number is larger than the hashmap, find the closest number in the hashmap\n            # if the number is smaller than the hashmap, find"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the first 0\n        ## 2. find the last 0\n        ## 3. return last_0 - first_0 + 1\n        ## 4. if first_0 is 0, return 0\n        ## 5. if last_0 is 0, return 0\n        ## 6. if first_0 is not 0, return last_0 - first_0 + 1\n        \n        first_0 = nums.find(0)\n        if first_0 == -1:\n            return 0\n        last_0 = nums[::-1].find(0)\n        if last_0 == -1:\n            return 0\n        if first_0 == 0:\n            return 0\n        if last_0 == 0:\n            return 0\n        return last_0 - first_0 + 1"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        # find the height of the left subtree\n        left_height = 0\n        left_node = root\n        while left_node.left:\n            left_height += 1\n            left_node = left_node.left\n        \n        # find the height of the right subtree\n        right_height = 0\n        right_node = root\n        while right_node.right:\n            right_height += 1\n            right_node = right_node.right\n        \n        # if left and right heights are equal, then the tree is perfect binary tree\n        if left_height == right_height:\n            return (2**(left_height+1) - 1)\n        \n        # otherwise, recursively find the number of nodes in the left and right subtrees\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num2[0] == '0':\n        #     return num1\n        # if num1[0] == '0':\n        #     return num2\n        # if num"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5c06s\u5206\u5272\u6210\u6570\u5b57\u548c\u7b26\u53f7\u4e24\u90e8\u5206\n        # 2. \u5c06\u7b26\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 3. \u5c06\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 4. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 5. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 6. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 7. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 8. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 9. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 10. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 11. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 12. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 13. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 14. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 15. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 16. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 17. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 18. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 19. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 20. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 21. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 22. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 23. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 24. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 25. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 26. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 27. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 28. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 29. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 30. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 31. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 32. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 33. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 34. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 35. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 36. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 37. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 38. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 39. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 40. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 41. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 42. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 43. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 44. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 45. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 46. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 47. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 48. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 49. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 50. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 51. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7\n        # 52. \u5c06\u6b63\u8d1f\u53f7\u548c\u6570\u5b57\u5206\u5f00\uff0c\u6b63\u8d1f\u53f7"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort by capital\n        # if capital[i] > w, then we can't do anything\n        # if capital[i] <= w, then we can do i+1 projects\n        # if i+1 projects are done, then we can do i+2 projects\n        # if i+2 projects are done, then we can do i+3 projects\n        # if i+3 projects are done, then we can do i+4 projects\n        # if i+4 projects are done, then we can do i+5 projects\n        # if i+5 projects are done, then we can do i+6 projects\n        # if i+6 projects are done, then we can do i+7 projects\n        # if i+7 projects are done, then we can do i+8 projects\n        # if i+8 projects are done, then we can do i+9 projects\n        # if i+9 projects are done, then we can do i+10 projects\n        # if i+10 projects are done, then we can do i+11 projects\n        # if i+11 projects are done, then we can do i+12 projects\n        # if i+12 projects are done, then we can do i+13 projects\n        # if i+13 projects are done, then we can do i+14 projects\n        # if i+14 projects are done, then we can do i+15 projects\n        # if i+15 projects are done, then we can do i+16 projects\n        # if i+16 projects are done, then we can do i+17 projects\n        # if i+17 projects are done, then we can do i+18 projects\n        # if i+18 projects are done, then we can do i+19 projects\n        # if i+19 projects are done, then we can do i+20 projects\n        # if i+20 projects are done, then we can do i+21 projects\n        # if i+21 projects are done, then we can do i+22 projects\n        # if i+22 projects are done, then we can do i+23 projects\n        # if i+23 projects are done, then we can do i+24 projects\n        # if i+24 projects are done, then we can do i+25 projects\n        # if i+25 projects are done, then we can do i+26 projects\n        # if i+26 projects are done, then we can do i+27 projects\n        # if i+27 projects are done, then we can do i+28 projects\n        # if i+28 projects are done, then we can do i+29 projects\n        # if i+29 projects are done, then we can do i+30 projects\n        # if i+30 projects are done, then we can do i+31 projects\n        # if i+31 projects are done, then we can do i+32 projects\n        # if i+32 projects are done, then we can do i+33 projects\n        # if i+33 projects are done, then we can do i+34 projects\n        # if i+34 projects are done, then we can do i+35 projects\n        # if i+35 projects are done, then we can do i+36 projects\n        # if i+36 projects are done, then we can do i+37 projects\n        # if i+37 projects are done, then we can do i+38 projects\n        # if i+38 projects are done, then we can do i+39 projects\n        # if i+39 projects are done, then we can do i+40 projects\n        # if i+40 projects are done, then we can do i+41 projects\n        # if i+41 projects are done, then we can do i+42 projects\n        # if i+42 projects are done, then we can do i+43 projects\n        # if i+43 projects are done, then we can do i+44 projects\n        # if i+44 projects are done, then we can do i+45 projects\n        # if i+45 projects are done, then we can do i+46 projects\n        # if i+46 projects are done, then we can do i+47 projects\n        # if i+47 projects are done, then we can do i+48 projects\n        # if i+48 projects are done,"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        # \n        # stack = []\n        # \n        # for c in s:\n        #     if c == '(':\n        #         stack.append(')')\n        #     elif c == '[':\n        #         stack.append(']')\n        #     elif c == '{':\n        #         stack.append('}')\n        #     elif stack and stack[-1] == c:\n        #         stack.pop()\n        #     else:\n        #         return False\n        # \n        # return stack == []\n        \n        # \n        # if len(s) % 2 != 0:\n        #     return False\n        # \n        # stack = []\n        # \n        # d = {\n        #     ')': '(',\n        #     ']': '[',\n        #     '}': '{',\n        # }\n        # \n        # for c in s:\n        #     if c not in d:\n        #         stack.append(c)\n        #     elif not stack or stack[-1] != d[c]:\n        #         return False\n        #         # if not stack or stack[-1] != d[c]:\n        #         #     return False\n        #         #     # if not stack or stack[-1] != d[c]:\n        #         #     #     return False\n        #         #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     # if not stack or stack[-1] != d[c]:\n        #         #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #     #"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than its next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i < 0:\n            nums.reverse()\n            return\n        \n        # find the first number that is larger than nums[i]\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[j]:\n            j -= 1\n        j += 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse nums[j:]\n        nums[j:] = nums[j:][::-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # if k is larger than the length of nums, return False\n        if k >= len(nums):\n            return False\n        \n        # create a hashmap to store the number and its index\n        hashmap = {}\n        \n        # iterate through the nums list\n        for i in range(len(nums)):\n            # if the number is already in the hashmap, return True\n            if nums[i] in hashmap:\n                return True\n            # otherwise, add the number to the hashmap\n            hashmap[nums[i]] = i\n        \n        # if the length of the hashmap is smaller than k, return False\n        if len(hashmap) <= k:\n            return False\n        \n        # iterate through the hashmap\n        for num in hashmap:\n            # if the difference between the index of the number and the index of the number in the hashmap is smaller than k, return True\n            if i - hashmap[num] < k:\n                return True\n        \n        # if the loop completes without returning True, return False\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        # find the min and max\n        min_num = min(nums)\n        max_num = max(nums)\n        \n        # if min_num == max_num, return 0\n        if min_num == max_num:\n            return 0\n        \n        # if the length of nums is 1, return 0\n        if len(nums) == 1:\n            return 0\n        \n        # find the range of nums\n        range_num = max_num - min_num\n        \n        # find the bucket size\n        bucket_size = (range_num + 1) // (len(nums) - 1) or 1\n        \n        # find the bucket_nums\n        bucket_nums = [0] * (len(nums) - 1)\n        \n        # find the bucket_nums\n        for num in nums:\n            if num == min_num:\n                continue\n            bucket_nums[(num - min_num) // bucket_size] += 1\n        \n        # find the max_gap\n        max_gap = 0\n        # find the pre_num\n        pre_num = bucket_nums[0]\n        # find the pre_index\n        pre_index = 0\n        # find the next_index\n        next_index = 0\n        # find the next_num\n        next_num = 0\n        # find the next_index\n        for index, num in enumerate(bucket_nums):\n            if num == 0:\n                continue\n            if index == 0:\n                pre_num = num\n                pre_index = index\n                continue\n            if index == 1:\n                next_num = num\n                next_index = index\n                break\n            if next_num == 0:\n                next_num = num\n                next_index = index\n                break\n            if next_num - pre_num > max_gap:\n                max_gap = next_num - pre_num\n            pre_num = next_num\n            pre_index = next_index\n            next_num = 0\n            next_index = 0\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        while queue:\n            level = []\n            next_queue = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    next_queue.append(node.left)\n                if node.right:\n                    next_queue.append(node.right)\n            res.append(level)\n            queue = next_queue\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n        # 2. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\n        # 3. 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n        # 4. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\n        # 5. 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n        # 6. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\n        # 7. 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n        # 8. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\n        # 9. 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n        # 10. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\n        # 11. 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n        # 12. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\n        # 13. 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n        # 14. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31\n        # 15. 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30\n        # 16. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27,"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) > len(s2):\n            return self.isInterleave(s2, s1, s3)\n        \n        if not s1:\n            return s2 == s3\n        \n        if not s2:\n            return s1 == s3\n        \n        dp = [False] * (len(s2) + 1)\n        for i in range(len(s1)):\n            if s1[i] == s3[i]:\n                dp[i] = True\n            else:\n                break\n        else:\n            return False\n        \n        for i in range(1, len(s1)):\n            if s1[i] == s3[i]:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = False\n        \n        for i in range(len(s1), len(s2)):\n            if s2[i] == s3[i]:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = False\n        \n        for i in range(len(s2), len(s3)):\n            if s1[i] == s3[i]:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = dp[i - 1]\n        \n        for i in range(len(s1), len(s2)):\n            if dp[i]:\n                continue\n            if s2[i] == s3[i]:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = False\n        \n        for i in range(len(s2), len(s3)):\n            if dp[i]:\n                continue\n            if s1[i] == s3[i]:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = False\n        \n        return dp[len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if g[i] < s[j]:\n                i += 1\n            else:\n                j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1st row\n        first_row = set('qwertyuiopQWERTYUIOP')\n        # 2nd row\n        second_row = set('asdfghjklASDFGHJKL')\n        # 3rd row\n        third_row = set('zxcvbnmZXCVBNM')\n        \n        # result\n        result = []\n        \n        # iterate through each word\n        for word in words:\n            # if the first letter is in the first row,\n            # then it must be in the second row\n            if word[0] in first_row:\n                # if the rest of the word is in the second row,\n                # then it must be in the third row\n                if word[1:] in second_row:\n                    result.append(word)\n                # otherwise, it must be in the third row\n                elif word[1:] in third_row:\n                    result.append(word)\n            # otherwise, it must be in the first row\n            elif word[0] in second_row:\n                # if the rest of the word is in the second row,\n                # then it must be in the third row\n                if word[1:] in second_row:\n                    result.append(word)\n                # otherwise, it must be in the third row\n                elif word[1:] in third_row:\n                    result.append(word)\n            # otherwise, it must be in the first row\n            elif word[0] in third_row:\n                # if the rest of the word is in the second row,\n                # then it must be in the third row\n                if word[1:] in second_row:\n                    result.append(word)\n                # otherwise, it must be in the third row\n                elif word[1:] in third_row:\n                    result.append(word)\n        \n        return result"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        # 3. Connect the (left-1)th node to the sublist\n        # 4. Return the head.head\n        \n        # 1. Find the (left-1)th node\n        # 2. Reverse the nodes from left to right\n        #"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome suffix\n        suffix = s[::-1]\n        # find the shortest palindrome prefix\n        # if s is palindrome, then prefix = suffix\n        # if s is not palindrome, then prefix = s[:-1] + s\n        prefix = s[:-suffix[::-1].rfind(suffix) + 1\n        # return the shortest palindrome\n        return suffix[:prefix] + s"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. build hashmap of t\n        # 2. iterate through s, if t[c] -= 1, if hashmap[c] > 0, count += 1\n        # 3. if count == len(t), add left and right\n        # 4. if hashmap[s[left]] > 0, count -= 1\n        # 5. if count == len(t), add left and right\n        # 6. repeat 3 and 5 until s is empty\n        # 7. return min_window\n        \n        if not t:\n            return \"\"\n        \n        hashmap = {}\n        for c in t:\n            if c not in hashmap:\n                hashmap[c] = 1\n            else:\n                hashmap[c] += 1\n        \n        left = 0\n        count = 0\n        min_window = s + \"$\"\n        for right, c in enumerate(s):\n            if c not in hashmap:\n                continue\n            elif hashmap[c] > 0:\n                count += 1\n            hashmap[c] -= 1\n            if count == len(hashmap):\n                while left < right and hashmap[s[left]] > 0:\n                    hashmap[s[left]] -= 1\n                    left += 1\n                if right - left + 1 < len(min_window):\n                    min_window = s[left:right + 1]\n        return min_window if min_window != s + \"$\" else \"\""}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if distance[2] >= distance[0] and distance[3] >= distance[1]:\n            return True\n        if distance[3] >= distance[1] and distance[2] + distance[4] >= distance[0]:\n            return True\n        if distance[4] >= distance[2] and distance[3] + distance[5] >= distance[1]:\n            return True\n        if distance[5] >= distance[3] and distance[4] + distance[6] >= distance[2]:\n            return True\n        if distance[6] >= distance[5] and distance[7] >= distance[4]:\n            return True\n        if distance[7] >= distance[6] and distance[8] >= distance[7]:\n            return True\n        if distance[8] >= distance[7] and distance[9] >= distance[8]:\n            return True\n        if distance[9] >= distance[8] and distance[10] >= distance[9]:\n            return True\n        if distance[10] >= distance[9] and distance[11] >= distance[10]:\n            return True\n        if distance[11] >= distance[10] and distance[12] >= distance[11]:\n            return True\n        if distance[12] >= distance[11] and distance[13] >= distance[12]:\n            return True\n        if distance[13] >= distance[12] and distance[14] >= distance[13]:\n            return True\n        if distance[14] >= distance[13] and distance[15] >= distance[14]:\n            return True\n        if distance[15] >= distance[14] and distance[16] >= distance[15]:\n            return True\n        if distance[16] >= distance[15] and distance[17] >= distance[16]:\n            return True\n        if distance[17] >= distance[16] and distance[18] >= distance[17]:\n            return True\n        if distance[18] >= distance[17] and distance[19] >= distance[18]:\n            return True\n        if distance[19] >= distance[18] and distance[20] >= distance[19]:\n            return True\n        if distance[20] >= distance[19] and distance[21] >= distance[20]:\n            return True\n        if distance[21] >= distance[20] and distance[22] >= distance[21]:\n            return True\n        if distance[22] >= distance[21] and distance[23] >= distance[22]:\n            return True\n        if distance[23] >= distance[22] and distance[24] >= distance[23]:\n            return True\n        if distance[24] >= distance[23] and distance[25] >= distance[24]:\n            return True\n        if distance[25] >= distance[24] and distance[26] >= distance[25]:\n            return True\n        if distance[26] >= distance[25] and distance[27] >= distance[26]:\n            return True\n        if distance[27] >= distance[26] and distance[28] >= distance[27]:\n            return True\n        if distance[28] >= distance[27] and distance[29] >= distance[28]:\n            return True\n        if distance[29] >= distance[28] and distance[30] >= distance[29]:\n            return True\n        if distance[30] >= distance[29] and distance[31] >= distance[30]:\n            return True\n        if distance[31] >= distance[30] and distance[32] >= distance[31]:\n            return True\n        if distance[32] >= distance[31] and distance[33] >= distance[32]:\n            return True\n        if distance[33] >= distance[32] and distance[34] >= distance[33]:\n            return True\n        if distance[34] >= distance[33] and distance[35] >= distance[34]:\n            return True\n        if distance[35] >= distance[34] and distance[36] >= distance[35]:\n            return True\n        if distance[36] >= distance[35] and distance[37] >= distance"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        # dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # iterate through the list\n        curr = head\n        prev = dummy\n        while curr:\n            # if the next node is a duplicate, move the prev pointer to the next node\n            if curr.next and curr.val == curr.next.val:\n                prev.next = curr.next\n            # otherwise, move the prev pointer to the next node\n            else:\n                prev = curr\n            curr = curr.next\n        \n        # return the head of the list\n        return dummy.next"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 26\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 3. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 4. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 5. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 6. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 7. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 8. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 9. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 10. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 11. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 12. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 13. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 14. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 15. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 16. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 17. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 18. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 19. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 20. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 21. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 22. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 23. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 24. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 25. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 26. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 27. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 28. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 29. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 30. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 31. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 32. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 33. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 34. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 35. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 36. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 37. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 38. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 39. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 40. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 41. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 42. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 43. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 44. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 45. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 46. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 47. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 48. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 49. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 50. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 51. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 52. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 53. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 54. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 55. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 56. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 57. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 58. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 59. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 60. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 61. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 62. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 63. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 64. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 65. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 66. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 67. \u51fa\u73b0\u5076\u6570\u6b21\u7684\u5b57\u6bcd\n        # 68. \u51fa\u73b0\u5947\u6570\u6b21\u7684\u5b57\u6bcd\n        # 69. \u51fa\u73b0\u5076\u6570\u6b21"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        # find the root value\n        root_val = postorder[-1]\n        # find the root index\n        root_idx = inorder_idx_map[root_val]\n        # left subtree\n        left_subtree = self.buildTree(inorder[:root_idx], postorder[:root_idx])\n        # right subtree\n        right_subtree = self.buildTree(inorder[root_idx+1:], postorder[root_idx:root_idx_len-1])\n        # root node\n        root = TreeNode(root_val)\n        root.left = left_subtree\n        root.right = right_subtree\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that is at least height 2\n        # 2. use BFS to find the shortest path to that tree\n        # 3. repeat step 2 until all trees are visited\n        # 4. repeat step 1 until all trees are visited\n        # 5. return the number of steps\n        \n        # 1. find the first tree that"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        if not root.left:\n            return self.minDepth(root.right) + 1\n        if not root.right:\n            return self.minDepth(root.left) + 1\n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. use hashmap to store the sum of the array\n        # 3. use hashmap to store the number of the sum\n        # 4. use hashmap to store the number of the sum\n        # 5. use hashmap to store the number of the sum\n        # 6. use hashmap to store the number of the sum\n        # 7. use hashmap to store the number of the sum\n        # 8. use hashmap to store the number of the sum\n        # 9. use hashmap to store the number of the sum\n        # 10. use hashmap to store the number of the sum\n        # 11. use hashmap to store the number of the sum\n        # 12. use hashmap to store the number of the sum\n        # 13. use hashmap to store the number of the sum\n        # 14. use hashmap to store the number of the sum\n        # 15. use hashmap to store the number of the sum\n        # 16. use hashmap to store the number of the sum\n        # 17. use hashmap to store the number of the sum\n        # 18. use hashmap to store the number of the sum\n        # 19. use hashmap to store the number of the sum\n        # 20. use hashmap to store the number of the sum\n        # 21. use hashmap to store the number of the sum\n        # 22. use hashmap to store the number of the sum\n        # 23. use hashmap to store the number of the sum\n        # 24. use hashmap to store the number of the sum\n        # 25. use hashmap to store the number of the sum\n        # 26. use hashmap to store the number of the sum\n        # 27. use hashmap to store the number of the sum\n        # 28. use hashmap to store the number of the sum\n        # 29. use hashmap to store the number of the sum\n        # 30. use hashmap to store the number of the sum\n        # 31. use hashmap to store the number of the sum\n        # 32. use hashmap to store the number of the sum\n        # 33. use hashmap to store the number of the sum\n        # 34. use hashmap to store the number of the sum\n        # 35. use hashmap to store the number of the sum\n        # 36. use hashmap to store the number of the sum\n        # 37. use hashmap to store the number of the sum\n        # 38. use hashmap to store the number of the sum\n        # 39. use hashmap to store the number of the sum\n        # 40. use hashmap to store the number of the sum\n        # 41. use hashmap to store the number of the sum\n        # 42. use hashmap to store the number of the sum\n        # 43. use hashmap to store the number of the sum\n        # 44. use hashmap to store the number of the sum\n        # 45. use hashmap to store the number of the sum\n        # 46. use hashmap to store the number of the sum\n        # 47. use hashmap to store the number of the sum\n        # 48. use hashmap to store the number of the sum\n        # 49. use hashmap to store the number of the sum\n        # 50. use hashmap to store the number of the sum\n        # 51. use hashmap to store the number of the sum\n        # 52. use hashmap to store the number of the sum\n        # 53. use hashmap to store the number of the sum\n        # 54. use hashmap to store the number of the sum\n        # 55. use hashmap to store the number of the sum\n        # 56. use hashmap to store the number of the sum\n        # 57. use hashmap to store the number of the sum\n        # 58. use hashmap to store the number of the sum\n        # 59. use hashmap to store the number of the sum\n        # 60. use hashmap to store the number of the sum\n        # 61. use hashmap to store the number of the sum\n        #"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # return (int)((-1 + sqrt(1 + 8*n))/2)\n        return int((sqrt(1 + 8*n) - 1)/2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            if len(a) > len(b):\n                return len(a)\n            else:\n                return len(b)"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        # level order traversal\n        queue = [root]\n        res = []\n        while queue:\n            level = []\n            next_queue = []\n            for node in queue:\n                level.append(node.val)\n                if node.left:\n                    next_queue.append(node.left)\n                if node.right:\n                    next_queue.append(node.right)\n            res.append(level)\n            queue = next_queue\n        \n        # reverse the result\n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        if x < 10:\n            return True\n        if x % 10 == 0:\n            return False\n        if x < 100:\n            return True\n        if x < 1000:\n            return False\n        if x < 10000:\n            return False\n        if x < 100000:\n            return False\n        if x < 1000000:\n            return False\n        if x < 10000000:\n            return False\n        if x < 100000000:\n            return False\n        if x < 1000000000:\n            return False\n        if x < 10000000000:\n            return False\n        if x < 100000000000:\n            return False\n        if x < 1000000000000:\n            return False\n        if x < 10000000000000:\n            return False\n        if x < 100000000000000:\n            return False\n        if x < 1000000000000000:\n            return False\n        if x < 10000000000000000:\n            return False\n        if x < 100000000000000000:\n            return False\n        if x < 1000000000000000000:\n            return False\n        if x < 10000000000000000000:\n            return False\n        if x < 100000000000000000000:\n            return False\n        if x < 1000000000000000000000:\n            return False\n        if x < 10000000000000000000000:\n            return False\n        if x < 100000000000000000000000:\n            return False\n        if x < 1000000000000000000000000:\n            return False\n        if x < 10000000000000000000000000:\n            return False\n        if x < 100000000000000000000000000:\n            return False\n        if x < 1000000000000000000000000000:\n            return False\n        if x < 10000000000000000000000000000:\n            return False\n        if x < 100000000000000000000000000000:\n            return False\n        if x < 1000000000000000000000000000000:\n            return False\n        if x < 10000000000000000000000000000000:\n            return False\n        if x < 100000000000000000000000000000000:\n            return False\n        if x < 1000000000000000000000000000000000:\n            return False\n        if x < 10000000000000000000000000000000000:\n            return False\n        if x < 1000000000000000000000000"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        one_digit = one_digit_ways = 1\n        two_digits = two_digits_ways = 0\n        \n        for c in s[1:]:\n            if c == '0':\n                if two_digits == 0:\n                    return 0\n                one_digit, two_digits = two_digits, one_digit\n            else:\n                one_digit, two_digits = two_digits * 10 + one_digit, one_digit\n                \n            one_digit_ways, two_digits_ways = two_digits_ways + one_digit_ways, one_digit_ways\n            \n        return one_digit_ways + two_digits_ways"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        for c in s:\n            if t[i] == c:\n                i += 1\n            else:\n                i += 1\n            if i >= len(t):\n                return False\n        return True"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 2:\n            return n\n        a, b = 1, 2\n        for i in range(2, n):\n            a, b = b, a+b\n        return b"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 2. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 3. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 4. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 5. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 6. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 7. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 8. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 9. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 10. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 11. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 12. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 13. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 14. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 15. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 16. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 17. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 18. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 19. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 20. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 21. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 22. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 23. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 24. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 25. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 26. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 27. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 28. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 29. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(s)\u7684\u6570\u7ec4dp\u8bb0\u5f55s\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 30. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen(wordDict)\u7684\u6570\u7ec4dp\u8bb0\u5f55wordDict\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\u662f\u5426\u53ef\u4ee5\u88ab\u62c6\u5206\n        # 31. \u7528\u4e00\u4e2a\u957f\u5ea6\u4e3alen"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # inorder traversal of BST is sorted\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if inorder traversal is sorted, then BST is valid\n        # if inorder traversal is not sorted, then BST is not valid\n        # if"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # find the index of the first interval that is larger than newInterval\n        # if not found, the new interval is the first interval\n        # if found, the index is the index of the first interval that is larger than newInterval\n        # if the index is 0, the new interval is the first interval\n        # if the index is len(intervals), the new interval is the last interval\n        # if the index is len(intervals) - 1, the new interval is the last interval\n        # if the index is len(intervals) - 2, the new interval is the second last interval\n        # ...\n        # if the index is len(intervals) - k, the new interval is the kth last interval\n        # if the index is len(intervals) - k - 1, the new interval is the (k + 1)th last interval\n        # ...\n        # if the index is len(intervals) - k * 2, the new interval is the (k * 2)th last interval\n        # if the index is len(intervals) - k * 2 - 1, the new interval is the (k * 2 + 1)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 1, the new interval is the (k * 2 - 1)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 2, the new interval is the (k * 2 - 2)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 3, the new interval is the (k * 2 - 3)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 4, the new interval is the (k * 2 - 4)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 5, the new interval is the (k * 2 - 5)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 6, the new interval is the (k * 2 - 6)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 7, the new interval is the (k * 2 - 7)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 8, the new interval is the (k * 2 - 8)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 9, the new interval is the (k * 2 - 9)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 10, the new interval is the (k * 2 - 10)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 11, the new interval is the (k * 2 - 11)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 12, the new interval is the (k * 2 - 12)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 13, the new interval is the (k * 2 - 13)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 14, the new interval is the (k * 2 - 14)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 15, the new interval is the (k * 2 - 15)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 16, the new interval is the (k * 2 - 16)th last interval\n        # ...\n        # if the index is len(intervals) - (k * 2) - 17, the new interval is the (k * 2 - 1"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 2. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 3. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 4. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 5. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 6. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 7. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 8. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 9. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 10. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 11. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 12. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 13. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 14. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 15. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 16. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 17. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 18. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 19. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 20. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 21. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 22. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 23. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 24. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 25. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 26. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 27. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 28. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 29. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 30. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 31. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 32. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 33. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 34. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 35. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 36. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 37. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 38. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 39. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 40. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 41. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 42. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 43. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 44. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 45. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 46. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 47. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 48. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 49. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 50. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 51. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 52. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 53. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 54. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 55. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 56. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 57. \u7528\u56de\u6587\u4e32\u7684\u957f\u5ea6\u6765\u5206\u5272\n        # 58."}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the min and max of each list\n        min_val = nums[0][0]\n        max_val = nums[0][0]\n        for l in nums:\n            if l[0] < min_val:\n                min_val = l[0]\n            if l[-1] > max_val:\n                max_val = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k\n        max_list = [max_val] * k\n        for l in nums:\n            if l[0] < min_list[0]:\n                min_list[0] = l[0]\n            if l[-1] > max_list[-1]:\n                max_list[-1] = l[-1]\n        \n        # find the min and max of the lists\n        min_list = [min_val] * k"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # find the maximum time\n        maximum = max(grid[0][0], grid[n-1][n-1])\n        # binary search\n        left, right = 0, maximum\n        while left < right:\n            # find the time when the water level is t\n            t = (left + right) // 2\n            # if the water level is t, check if we can reach the bottom right\n            if self.canReach(grid, t):\n                # if we can, then we can try to find the minimum time\n                right = t\n            else:\n                # if we can't, then we can try to find the maximum time\n                left = t + 1\n        # return the maximum time\n        return left\n    \n    def canReach(self, grid, t):\n        # initialize the queue\n        queue = [(0, 0)]\n        # initialize the visited set\n        visited = set()\n        # loop through the queue\n        while queue:\n            # get the current position\n            i, j = queue.pop()\n            # if the current position is the target, return True\n            if i == j:\n                return True\n            # if the current position is not visited, add it to the visited set\n            if i not in visited:\n                visited.add(i)\n            # if the current position is less than the target, add its neighbors to the queue\n            if i < j:\n                j = j or j_next\n            # if the current position is greater than the target, add its neighbors to the queue\n            if j > j_next:\n                j = j_next\n                j_next = j_next + 1\n                if j not in visited:\n                    visited.add(j)\n                    queue.append(j)\n        # return False if we never visited the target\n        return False"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if m > n:\n        #     m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n, m\n        #     # m, n = n"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1[0] == '0' or num2[0] == '0':\n            return '0'\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in reversed(range(len(num1))):\n            for j in reversed(range(len(num2))):\n                res[j] += res[j + 1] * 10\n                res[j + 1] += (num1[i] - '0')\n                \n        for i in range(len(res) - 1):\n            if res[i] == 0:\n                res[i] = res[i + 1]\n            else:\n                res[i + 1] = res[i] // 10\n                \n        return str(res[0])"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) < 2:\n        #     return 0\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # for i in range(1, len(prices)):\n        #     if prices[i] < buy1_price:\n        #         buy1_idx, buy1_price = i, prices[i]\n        #     elif prices[i] < buy2_price:\n        #         buy2_idx, buy2_price = i, prices[i]\n        #     elif prices[i] > sell_price:\n        #         sell_idx, sell_price = i, prices[i]\n        \n        # if buy1_idx == -1 or buy2_idx == -1:\n        #     return 0\n        \n        # if buy1_idx > buy2_idx:\n        #     buy1_idx, buy2_idx = buy2_idx, buy1_idx\n        \n        # if sell_idx > buy1_idx:\n        #     buy1_idx, sell_idx = sell_idx, buy1_idx\n        \n        # if sell_idx > buy2_idx:\n        #     buy2_idx, sell_idx = sell_idx, buy2_idx\n        \n        # return prices[sell_idx] - prices[buy1_idx]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]\n        \n        # buy1_idx, buy1_price = -1, prices[0]\n        # buy2_idx, buy2_price = -1, prices[0]\n        # sell_idx, sell_price = -1, prices[0]"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not candidates:\n            return []\n        candidates.sort()\n        res, index, length = [], 0, len(candidates)\n        while index < length and candidates[index] < target:\n            if candidates[index] < target - candidates[index]:\n                index += 1\n            else:\n                res.append([candidates[index] * (index + 1))\n                index += 1\n                length -= 1\n        if not res:\n            return []\n        res_index = 0\n        res_length = len(res)\n        res_res_index = 0\n        res_res_length = res_index\n        while index < length:\n            if candidates[index] < target - candidates[index]:\n                index += 1\n            else:\n                if index == res_res_index:\n                    res_res_index += 1\n                    res_res_length += 1\n                    if res_res_index == res_length:\n                        break\n                res[res_res_index] = [candidates[index]] * (index + 1)\n                res_res_index += 1\n                res_res_length += 1\n                index += 1\n                length -= 1\n        return res[:res_res_length]"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.istitle():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n                \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # if root is None:\n        #     return []\n        # stack = [root]\n        # res = []\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # if root is None:\n        #     return []\n        # res = []\n        # stack = [root]\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # if root is None:\n        #     return []\n        # res = []\n        # stack = [root]\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # if root is None:\n        #     return []\n        # res = []\n        # stack = [root]\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # if root is None:\n        #     return []\n        # res = []\n        # stack = [root]\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # if root is None:\n        #     return []\n        # res = []\n        # stack = [root]\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # if root is None:\n        #     return []\n        # res = []\n        # stack = [root]\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # if root is None:\n        #     return []\n        # res = []\n        # stack = [root]\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node.left)\n        #     res.append(node.val)\n        # return res\n        \n        # if root is None:\n        #     return []\n        # res = []\n        # stack = [root]\n        # while stack:\n        #     node = stack.pop()\n        #     if node.right:\n        #         stack.append(node.right)\n        #     if node.left:\n        #         stack.append(node"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root_val = preorder[0]\n        root_idx = inorder.index(root_val)\n        root = TreeNode(root_val)\n        root.left = self.buildTree(preorder[1:root_idx], inorder[:root_idx])\n        root.right = self.buildTree(preorder[root_idx+1:], inorder[root_idx+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # find the first and last ')'\n        first_r = s.rfind(')')\n        if first_r == -1:\n            return [s]\n        # find the first '('\n        first_l = s.find('(')\n        if first_l == -1:\n            return [s]\n        # find the length of the longest valid substring\n        length = first_r - first_l\n        # find the length of the shortest valid substring\n        length_shortest = 0\n        # find the length of the longest valid substring\n        length_longest = 0\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find the length of the shortest valid substring\n        length_shortest_r = first_r\n        # find the length of the longest valid substring\n        length_longest_r = first_r\n        # find the length of the shortest valid substring\n        length_shortest_l = first_l\n        # find the length of the longest valid substring\n        length_longest_l = first_l\n        # find"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the list\n        length = len(lists)\n        # 2. if the length is 0, return None\n        if length == 0:\n            return None\n        # 3. if the length is 1, return the first element\n        if length == 1:\n            return lists[0]\n        # 4. if the length is 2, return the first two elements\n        if length == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        # 5. if the length is 3, return the first three elements\n        if length == 3:\n            return self.mergeThreeLists(lists[0], lists[1], lists[2])\n        # 6. if the length is 4, return the first four elements\n        if length == 4:\n            return self.mergeFourLists(lists[0], lists[1], lists[2], lists[3])\n        # 7. if the length is 5, return the first five elements\n        if length == 5:\n            return self.mergeFiveLists(lists[0], lists[1], lists[2], lists[3], lists[4])\n        # 8. if the length is 6, return the first six elements\n        if length == 6:\n            return self.mergeSixLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5])\n        # 9. if the length is 7, return the first seven elements\n        if length == 7:\n            return self.mergeSevenLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5], lists[6])\n        # 10. if the length is 8, return the first eight elements\n        if length == 8:\n            return self.mergeEightLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5], lists[6], lists[7])\n        # 11. if the length is 9, return the first nine elements\n        if length == 9:\n            return self.mergeNineLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5], lists[6], lists[7], lists[8])\n        # 12. if the length is 10, return the first ten elements\n        if length == 10:\n            return self.mergeTenLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5], lists[6], lists[7], lists[8], lists[9])\n        # 13. if the length is 11, return the first eleven elements\n        if length == 11:\n            return self.mergeElevenLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5], lists[6], lists[7], lists[8], lists[9], lists[10])\n        # 14. if the length is 12, return the first twelve elements\n        if length == 12:\n            return self.mergeTwelveLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5], lists[6], lists[7], lists[8], lists[9], lists[10], lists[11])\n        # 15. if the length is 13, return the first thirteen elements\n        if length == 13:\n            return self.mergeThirteenLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5], lists[6], lists[7], lists[8], lists[9], lists[10], lists[11], lists[12])\n        # 16. if the length is 14, return the first fourteen elements\n        if length == 14:\n            return self.mergeFourteenLists(lists[0], lists[1], lists[2], lists[3], lists[4], lists[5], lists[6], lists[7], lists[8], lists[9], lists[10], lists[11], lists[12], lists[13])\n        # 17. if the length is 15, return the first fifteen elements\n        if length == 15:\n            return self.mergeFif"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5224\u65ad\u662f\u5426\u4e3a\u56de\u6587\n        # 2. \u5982\u679c\u56de\u6587\uff0c\u5219\u957f\u5ea6\u4e3a1\n        # 3. \u5982\u679c\u4e0d\u662f\u56de\u6587\uff0c\u5219\u957f\u5ea6\u4e3a2\n        # 4. \u5982\u679c\u957f\u5ea6\u4e3a2\uff0c\u5219\u957f\u5ea6\u4e3a1\n        # 5. \u5982\u679c\u957f\u5ea6\u4e3a3\uff0c\u5219\u957f\u5ea6\u4e3a2\n        # 6. \u5982\u679c\u957f\u5ea6\u4e3a4\uff0c\u5219\u957f\u5ea6\u4e3a3\n        # 7. \u5982\u679c\u957f\u5ea6\u4e3a5\uff0c\u5219\u957f\u5ea6\u4e3a4\n        # 8. \u5982\u679c\u957f\u5ea6\u4e3a6\uff0c\u5219\u957f\u5ea6\u4e3a5\n        # 9. \u5982\u679c\u957f\u5ea6\u4e3a7\uff0c\u5219\u957f\u5ea6\u4e3a6\n        # 10. \u5982\u679c\u957f\u5ea6\u4e3a8\uff0c\u5219\u957f\u5ea6\u4e3a7\n        # 11. \u5982\u679c\u957f\u5ea6\u4e3a9\uff0c\u5219\u957f\u5ea6\u4e3a8\n        # 12. \u5982\u679c\u957f\u5ea6\u4e3a10\uff0c\u5219\u957f\u5ea6\u4e3a9\n        # 13. \u5982\u679c\u957f\u5ea6\u4e3a11\uff0c\u5219\u957f\u5ea6\u4e3a10\n        # 14. \u5982\u679c\u957f\u5ea6\u4e3a12\uff0c\u5219\u957f\u5ea6\u4e3a11\n        # 15. \u5982\u679c\u957f\u5ea6\u4e3a13\uff0c\u5219\u957f\u5ea6\u4e3a12\n        # 16. \u5982\u679c\u957f\u5ea6\u4e3a14\uff0c\u5219\u957f\u5ea6\u4e3a13\n        # 17. \u5982\u679c\u957f\u5ea6\u4e3a15\uff0c\u5219\u957f\u5ea6\u4e3a14\n        # 18. \u5982\u679c\u957f\u5ea6\u4e3a16\uff0c\u5219\u957f\u5ea6\u4e3a15\n        # 19. \u5982\u679c\u957f\u5ea6\u4e3a17\uff0c\u5219\u957f\u5ea6\u4e3a16\n        # 20. \u5982\u679c\u957f\u5ea6\u4e3a18\uff0c\u5219\u957f\u5ea6\u4e3a17\n        # 21. \u5982\u679c\u957f\u5ea6\u4e3a19\uff0c\u5219\u957f\u5ea6\u4e3a18\n        # 22. \u5982\u679c\u957f\u5ea6\u4e3a20\uff0c\u5219\u957f\u5ea6\u4e3a19\n        # 23. \u5982\u679c\u957f\u5ea6\u4e3a21\uff0c\u5219\u957f\u5ea6\u4e3a20\n        # 24. \u5982\u679c\u957f\u5ea6\u4e3a22\uff0c\u5219\u957f\u5ea6\u4e3a21\n        # 25. \u5982\u679c\u957f\u5ea6\u4e3a23\uff0c\u5219\u957f\u5ea6\u4e3a22\n        # 26. \u5982\u679c\u957f\u5ea6\u4e3a24\uff0c\u5219\u957f\u5ea6\u4e3a23\n        # 27. \u5982\u679c\u957f\u5ea6\u4e3a25\uff0c\u5219\u957f\u5ea6\u4e3a24\n        # 28. \u5982\u679c\u957f\u5ea6\u4e3a26\uff0c\u5219\u957f\u5ea6\u4e3a25\n        # 29. \u5982\u679c\u957f\u5ea6\u4e3a27\uff0c\u5219\u957f\u5ea6\u4e3a26\n        # 30. \u5982\u679c\u957f\u5ea6\u4e3a28\uff0c\u5219\u957f\u5ea6\u4e3a27\n        # 31. \u5982\u679c\u957f\u5ea6\u4e3a29\uff0c\u5219\u957f\u5ea6\u4e3a28\n        # 32. \u5982\u679c\u957f\u5ea6\u4e3a30\uff0c\u5219\u957f\u5ea6\u4e3a29\n        # 33. \u5982\u679c\u957f\u5ea6\u4e3a31\uff0c\u5219\u957f\u5ea6\u4e3a30\n        # 34. \u5982\u679c\u957f\u5ea6\u4e3a32\uff0c\u5219\u957f\u5ea6\u4e3a31\n        # 35. \u5982\u679c\u957f\u5ea6\u4e3a33\uff0c\u5219\u957f\u5ea6\u4e3a32\n        # 36. \u5982\u679c\u957f\u5ea6\u4e3a34\uff0c\u5219\u957f\u5ea6\u4e3a33\n        # 37. \u5982\u679c\u957f\u5ea6\u4e3a35\uff0c\u5219\u957f\u5ea6\u4e3a34\n        # 38. \u5982\u679c\u957f\u5ea6\u4e3a36\uff0c\u5219\u957f\u5ea6\u4e3a35\n        # 39. \u5982\u679c\u957f\u5ea6\u4e3a37\uff0c\u5219\u957f\u5ea6\u4e3a36\n        # 40. \u5982\u679c\u957f\u5ea6\u4e3a38\uff0c\u5219\u957f\u5ea6\u4e3a37\n        # 41. \u5982\u679c\u957f\u5ea6\u4e3a39\uff0c\u5219\u957f\u5ea6\u4e3a38\n        # 42. \u5982\u679c\u957f\u5ea6\u4e3a40\uff0c\u5219\u957f\u5ea6\u4e3a39\n        # 43. \u5982\u679c\u957f\u5ea6\u4e3a41\uff0c\u5219\u957f\u5ea6\u4e3a40\n        # 44. \u5982\u679c\u957f\u5ea6\u4e3a42\uff0c\u5219\u957f\u5ea6\u4e3a41\n        # 45. \u5982\u679c\u957f\u5ea6\u4e3a43\uff0c\u5219\u957f\u5ea6\u4e3a42\n        # 46. \u5982\u679c\u957f\u5ea6\u4e3a44\uff0c\u5219\u957f\u5ea6\u4e3a43\n        # 47. \u5982\u679c\u957f\u5ea6\u4e3a45\uff0c\u5219\u957f\u5ea6\u4e3a44\n        # 48. \u5982\u679c\u957f\u5ea6\u4e3a46\uff0c\u5219\u957f\u5ea6\u4e3a45\n        # 49. \u5982\u679c\u957f\u5ea6\u4e3a47\uff0c\u5219\u957f\u5ea6\u4e3a46\n        # 50. \u5982\u679c\u957f\u5ea6\u4e3a48\uff0c\u5219\u957f\u5ea6\u4e3a47\n        # 51. \u5982\u679c\u957f\u5ea6\u4e3a49\uff0c\u5219"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 10^n - 10^(n-1) = k\n        # 10^n - 10^(n-1) = k\n        # 10^n - 10^(n-1) = k * 10^(n-1)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4) * 10^(n-5)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4) * 10^(n-5) * 10^(n-6)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4) * 10^(n-5) * 10^(n-6) * 10^(n-7)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4) * 10^(n-5) * 10^(n-6) * 10^(n-7) * 10^(n-8)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4) * 10^(n-5) * 10^(n-6) * 10^(n-7) * 10^(n-8) * 10^(n-9)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4) * 10^(n-5) * 10^(n-6) * 10^(n-7) * 10^(n-8) * 10^(n-9) * 10^(n-10)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4) * 10^(n-5) * 10^(n-6) * 10^(n-7) * 10^(n-8) * 10^(n-9) * 10^(n-10) * 10^(n-11)\n        # 10^n - 10^(n-1) = k * 10^(n-1) * 10^(n-2) * 10^(n-3) * 10^(n-4) * 10^(n-5) * 10^(n-6) * 10^(n-7) * 10^(n-8) *"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a hashmap for the reversed words\n        # the key is the reversed word and the value is the index\n        # we will use this hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an empty list\n        # we will use the hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an empty list\n        # we will use the hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an empty list\n        # we will use the hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an empty list\n        # we will use the hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an empty list\n        # we will use the hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an empty list\n        # we will use the hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an empty list\n        # we will use the hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an empty list\n        # we will use the hashmap to check if the reversed word is in the hashmap\n        # if the reversed word is in the hashmap, we will check if the original word is in the hashmap\n        # if the original word is in the hashmap, we will get the index of the reversed word\n        # if the original word is not in the hashmap, we will get an empty list\n        # if the reversed word is not in the hashmap, we will get an"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contiguous regions\n        # 4. Return the number of walls\n        \n        # 1. Find the largest contiguous region\n        # 2. Put walls in that region\n        # 3. Repeat until no more contigu"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        res, seen = 0, {}\n        directions = ((1, 0), (-1, 0), (0, 1), (0, -1))\n        \n        def dfs(i, j):\n            if (j, j) not in seen:\n                seen[j] = j\n                res = 1\n            else:\n                res = seen[j]\n            for di, dj in directions:\n                if 0 <= i*di + j < m*n:\n                    if res < seen[i*di + j]:\n                        res = seen[i*di + j]\n                    else:\n                        res = dfs(i*di + j)\n            seen[j] = res + 1\n            return res\n        \n        for i in range(m):\n            for j in range(n):\n                if not seen[j]:\n                    res = max(res, dfs(i, j))\n        \n        return res"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build a hashmap for each word in wordDict\n        # 2. iterate through s, if s[:i] in hashmap, then s[i:] is a valid word\n        # 3. if s[:i] in hashmap, then s[i:] is a valid word\n        # 4. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 5. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 6. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 7. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 8. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 9. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 10. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 11. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 12. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 13. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 14. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 15. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 16. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 17. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 18. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 19. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 20. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 21. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 22. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 23. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 24. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 25. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 26. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 27. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 28. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 29. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 30. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 31. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 32. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 33. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 34. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 35. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 36. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 37. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 38. if s[:i] not in hashmap, then s[i:] is not a valid word\n        # 39. if s[:i] not in hashmap"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            if level % 2 == 0:\n                res.append([node.val for node in queue[::-1] )\n            else:\n                res.append([node.val for node in queue])\n            queue = [child for node in queue for child in (node.left, node.right) if child]\n            level += 1\n        \n        return res"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if turnedOn == 0:\n            return [ \"0:00\" ]\n        \n        if turnedOn > 8:\n            return []\n        \n        # 10 bits for hours, 5 bits for minutes\n        # 10000 - 10111 = 9 bits\n        # 01111 = 9 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 11111 = 15 bits\n        # 00000 = 0 bits\n        # 111"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        if numRows > 2:\n            res = [[1],[1,1]]\n            for i in range(2,numRows):\n                res.append([1] + [res[-1][j] + [res[-1][j+1] for j in range(len(res[-1])-1)]\n            return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        if n == 1:\n            return True\n        if n % 3 == 0:\n            return self.isPowerOfThree(n/3)\n        else:\n            return False"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        ## 1. If root is None, return 0\n        ## 2. If root.left is None and root.right is None, return root.val\n        ## 3. If root.left is None, return max(root.val + maxPathSum(root.right))\n        ## 4. If root.right is None, return max(root.val + maxPathSum(root.left))\n        ## 5. Return max(root.val + max(maxPathSum(root.left), maxPathSum(root.right)))\n        ## 6. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right))\n        ## 7. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 8. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 9. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 10. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 11. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 12. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 13. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 14. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 15. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 16. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 17. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 18. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 19. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 20. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 21. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 22. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 23. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 24. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 25. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 26. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 27. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 28. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 29. Return max(root.val + maxPathSum(root.left) + maxPathSum(root.right) + root.val)\n        ## 30. Return max(root.val + maxPath"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap or not heightMap[0]:\n            return 0\n        \n        # find the max and min height of the map\n        m, n = len(heightMap), len(heightMap[0])\n        # use a min heap to store the min height of each column\n        pq = [(heightMap[0][j], j) for j in range(n)]\n        visited = set((0,)*n)\n        # use a max heap to store the max height of each row\n        pqr = [(heightMap[i][0], i) for i in range(1, m)]\n        \n        # use a variable to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row\n        # and another variable to store the max height of the next row\n        # we use two variables to store the max height of the current row"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert to lowercase\n        # 3. reverse the string\n        # 4. compare the two strings\n        \n        # 1. remove all non-alphanumeric characters\n        s = ''.join(filter(lambda c: c.isalnum(), s)).lower()\n        \n        # 2. reverse the string\n        s = s[::-1]\n        \n        # 3. compare the two strings\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median\n        # 3. if k is odd, return the median\n        # 4. if k is even, return the average of the two medians\n        \n        # 1. sort the list\n        # 2. find the median"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the length of the list\n        length = 0\n        p = head\n        while p:\n            length += 1\n            p = p.next\n        \n        # find the new head and the new tail\n        new_head = head\n        new_tail = head\n        k = k % length\n        if k == 0:\n            return head\n        for i in range(k):\n            new_tail = new_tail.next\n        \n        # find the new tail\n        p = head\n        while new_tail.next:\n            p = p.next\n            new_tail = new_tail.next\n        new_tail.next = head\n        new_head = p.next\n        p.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        if n == 1:\n            return True\n        if n % 2 == 0:\n            return self.isUgly(n // 2)\n        if n % 3 == 0:\n            return self.isUgly(n // 3)\n        if n % 5 == 0:\n            return self.isUgly(n // 5)\n        return False"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        # 2. use a dict to store the max height of each left\n        # 3. use a list to store the max height of each left\n        # 4. use a dict to store the max height of each left\n        # 5. use a list to store the max height of each left\n        # 6. use a dict to store the max height of each left\n        # 7. use a list to store the max height of each left\n        # 8. use a dict to store the max height of each left\n        # 9. use a list to store the max height of each left\n        # 10. use a dict to store the max height of each left\n        # 11. use a list to store the max height of each left\n        # 12. use a dict to store the max height of each left\n        # 13. use a list to store the max height of each left\n        # 14. use a dict to store the max height of each left\n        # 15. use a list to store the max height of each left\n        # 16. use a dict to store the max height of each left\n        # 17. use a list to store the max height of each left\n        # 18. use a dict to store the max height of each left\n        # 19. use a list to store the max height of each left\n        # 20. use a dict to store the max height of each left\n        # 21. use a list to store the max height of each left\n        # 22. use a dict to store the max height of each left\n        # 23. use a list to store the max height of each left\n        # 24. use a dict to store the max height of each left\n        # 25. use a list to store the max height of each left\n        # 26. use a dict to store the max height of each left\n        # 27. use a list to store the max height of each left\n        # 28. use a dict to store the max height of each left\n        # 29. use a list to store the max height of each left\n        # 30. use a dict to store the max height of each left\n        # 31. use a list to store the max height of each left\n        # 32. use a dict to store the max height of each left\n        # 33. use a list to store the max height of each left\n        # 34. use a dict to store the max height of each left\n        # 35. use a list to store the max height of each left\n        # 36. use a dict to store the max height of each left\n        # 37. use a list to store the max height of each left\n        # 38. use a dict to store the max height of each left\n        # 39. use a list to store the max height of each left\n        # 40. use a dict to store the max height of each left\n        # 41. use a list to store the max height of each left\n        # 42. use a dict to store the max height of each left\n        # 43. use a list to store the max height of each left\n        # 44. use a dict to store the max height of each left\n        # 45. use a list to store the max height of each left\n        # 46. use a dict to store the max height of each left\n        # 47. use a list to store the max height of each left\n        # 48. use a dict to store the max height of each left\n        # 49. use a list to store the max height of each left\n        # 50. use a dict to store the max height of each left\n        # 51. use a list to store the max height of each left\n        # 52. use a dict to store the max height of each left\n        # 53. use a list to store the max height of each left\n        # 54. use a dict to store the max height of each left\n        # 55. use a list to store the max height of each left\n        # 56. use a dict to store the max height of each left\n        # 57. use a list to store the max height of each left\n        # 58. use a dict to store the max"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        else:\n            return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max in the first row\n        # 2. find the min in the first row\n        # 3. find the max in the first column\n        # 4. find the min in the first column\n        # 5. find the max in the rest of the matrix\n        # 6. find the min in the rest of the matrix\n        # 7. find the max in the rest of the matrix\n        # 8. find the min in the rest of the matrix\n        # 9. find the max in the rest of the matrix\n        # 10. find the min in the rest of the matrix\n        # 11. find the max in the rest of the matrix\n        # 12. find the min in the rest of the matrix\n        # 13. find the max in the rest of the matrix\n        # 14. find the min in the rest of the matrix\n        # 15. find the max in the rest of the matrix\n        # 16. find the min in the rest of the matrix\n        # 17. find the max in the rest of the matrix\n        # 18. find the min in the rest of the matrix\n        # 19. find the max in the rest of the matrix\n        # 20. find the min in the rest of the matrix\n        # 21. find the max in the rest of the matrix\n        # 22. find the min in the rest of the matrix\n        # 23. find the max in the rest of the matrix\n        # 24. find the min in the rest of the matrix\n        # 25. find the max in the rest of the matrix\n        # 26. find the min in the rest of the matrix\n        # 27. find the max in the rest of the matrix\n        # 28. find the min in the rest of the matrix\n        # 29. find the max in the rest of the matrix\n        # 30. find the min in the rest of the matrix\n        # 31. find the max in the rest of the matrix\n        # 32. find the min in the rest of the matrix\n        # 33. find the max in the rest of the matrix\n        # 34. find the min in the rest of the matrix\n        # 35. find the max in the rest of the matrix\n        # 36. find the min in the rest of the matrix\n        # 37. find the max in the rest of the matrix\n        # 38. find the min in the rest of the matrix\n        # 39. find the max in the rest of the matrix\n        # 40. find the min in the rest of the matrix\n        # 41. find the max in the rest of the matrix\n        # 42. find the min in the rest of the matrix\n        # 43. find the max in the rest of the matrix\n        # 44. find the min in the rest of the matrix\n        # 45. find the max in the rest of the matrix\n        # 46. find the min in the rest of the matrix\n        # 47. find the max in the rest of the matrix\n        # 48. find the min in the rest of the matrix\n        # 49. find the max in the rest of the matrix\n        # 50. find the min in the rest of the matrix\n        # 51. find the max in the rest of the matrix\n        # 52. find the min in the rest of the matrix\n        # 53. find the max in the rest of the matrix\n        # 54. find the min in the rest of the matrix\n        # 55. find the max in the rest of the matrix\n        # 56. find the min in the rest of the matrix\n        # 57. find the max in the rest of the matrix\n        # 58. find the min in the rest of the matrix\n        # 59. find the max in the rest of the matrix\n        # 60. find the min in the rest of the matrix\n        # 61. find the max in the rest of the matrix\n        # 62. find the min in the rest of the matrix\n        # 63. find the max in the rest of the matrix\n        # 64. find the min in the rest of the matrix\n        # 65. find the max in the rest of the matrix"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # if dividend is negative, make it positive\n        if dividend < 0:\n            dividend = -dividend\n        if divisor < 0:\n            divisor = -divisor\n        \n        # if divisor is 0, return max int\n        if divisor == 0:\n            return 2147483647\n        \n        # if dividend is 0, return 0\n        if dividend == 0:\n            return 0\n        \n        # if divisor is 1, return dividend\n        if divisor == 1:\n            return dividend\n        \n        # if divisor is -1, return -dividend\n        if divisor == -1:\n            if dividend > -2147483648:\n                return -dividend\n            else:\n                return 2147483647\n        \n        # if dividend is -2147483648, return -2147483648\n        if dividend == -2147483648:\n            return -2147483648\n        \n        # if dividend is 2147483647, return 2147483647\n        if dividend == 2147483647:\n            return 2147483647\n        \n        # if dividend is 2147483648, return 2147483648\n        if dividend == 2147483648:\n            return 2147483648\n        \n        # if dividend is -2147483649, return -2147483648\n        if dividend == -2147483649:\n            return -2147483648\n        \n        # if dividend is -2147483649, return -2147483648\n        if dividend == -2147483649:\n            return -2147483648\n        \n        # if dividend is -2147483650, return -2147483648\n        if dividend == -2147483650:\n            return -2147483648\n        \n        # if dividend is -2147483651, return -2147483648\n        if dividend == -2147483651:\n            return -2147483648\n        \n        # if dividend is -2147483652, return -2147483648\n        if dividend == -2147483652:\n            return -2147483648\n        \n        # if dividend is -2147483653, return -2147483648\n        if dividend == -2147483653:\n            return -2147483648\n        \n        # if dividend is -2147483654, return -2147483648\n        if dividend == -2147483654:\n            return -2147483648\n        \n        # if dividend is -2147483655, return -2147483648\n        if dividend == -2147483655:\n            return -2147483648\n        \n        # if dividend is -2147483656, return -2147483648\n        if dividend == -2147483656:\n            return -2147483648\n        \n        # if dividend is -2147483657, return -2147483648\n        if dividend == -"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        # mark all the O's that are on the border as -1\n        # and all the O's that are not on the border as 0\n        # mark all the O's that are not on the border as -1\n        # if the number is 0, it means that it is not on the border\n        # if the number is -1, it means that it is on the border\n        # if the number is 1, it means that it is not on the border\n        # if the number is 2, it means that it is on the border\n        # if the number is 3, it means that it is not on the border\n        # if the number is 4, it means that it is on the border\n        # if the number is 5, it means that it is not on the border\n        # if the number is 6, it means that it is on the border\n        # if the number is 7, it means that it is not on the border\n        # if the number is 8, it means that it is on the border\n        # if the number is 9, it means that it is not on the border\n        # if the number is 10, it means that it is on the border\n        # if the number is 11, it means that it is not on the border\n        # if the number is 12, it means that it is on the border\n        # if the number is 13, it means that it is not on the border\n        # if the number is 14, it means that it is on the border\n        # if the number is 15, it means that it is not on the border\n        # if the number is 16, it means that it is on the border\n        # if the number is 17, it means that it is not on the border\n        # if the number is 18, it means that it is on the border\n        # if the number is 19, it means that it is not on the border\n        # if the number is 20, it means that it is on the border\n        # if the number is 21, it means that it is not on the border\n        # if the number is 22, it means that it is on the border\n        # if the number is 23, it means that it is not on the border\n        # if the number is 24, it means that it is on the border\n        # if the number is 25, it means that it is not on the border\n        # if the number is 26, it means that it is on the border\n        # if the number is 27, it means that it is not on the border\n        # if the number is 28, it means that it is on the border\n        # if the number is 29, it means that it is not on the border\n        # if the number is 30, it means that it is on the border\n        # if the number is 31, it means that it is not on the border\n        # if the number is 32, it means that it is on the border\n        # if the number is 33, it means that it is not on the border\n        # if the number is 34, it means that it is on the border\n        # if the number is 35, it means that it is not on the border\n        # if the number is 36, it means that it is on the border\n        # if the number is 37, it means that it is not on the border\n        # if the number is 38, it means that it is on the border\n        # if the number is 39, it means that it is not on the border\n        # if the number is 40, it means that it is on the border\n        # if the number is 41, it means that it is not on the border\n        # if the number is 42, it means that it is on the border\n        # if the number is 43, it means that it is not on the border\n        # if the number is 44, it means that it is on the border\n        # if the number is 45, it means that it is not on the border\n        # if the number is 46, it means that it is on the border\n        # if the number is 47, it means that it is not on the border\n        # if the number is 48, it means that it is"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a hashmap to store the complement of each number\n        complement_map = {}\n        \n        # iterate through the list of numbers\n        for i, num in enumerate(nums):\n            \n            # if the complement of the target minus the current number is already in the map, return the indices\n            if complement_map.get(target - num) is not None:\n                return [complement_map[target - num], i]\n            \n            # otherwise, add the number to the map\n            complement_map[num] = i]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(cards) == 1:\n            if abs(cards[0] - 4) * 3 == 1:\n                return True\n            else:\n                return False\n        if len(cards) == 2:\n            if abs(cards[0] - cards[1]) * 3 == 1:\n                return True\n            else:\n                return False\n        if len(cards) == 3:\n            if abs(cards[0] - cards[1] - cards[2]) * 3 == 1:\n                return True\n            else:\n                return False\n        if len(cards) == 4:\n            if abs(cards[0] - cards[1] - cards[2] - cards[3]) * 3 == 1:\n                return True\n            else:\n                return False\n        \n        # 1. 4 1 8 7\n        # 2. 1 2 1 2\n        # 3. 1 1 1 1\n        # 4. 1 1 1 1\n        # 5. 1 1 1 1\n        # 6. 1 1 1 1\n        # 7. 1 1 1 1\n        # 8. 1 1 1 1\n        # 9. 1 1 1 1\n        # 10. 1 1 1 1\n        # 11. 1 1 1 1\n        # 12. 1 1 1 1\n        # 13. 1 1 1 1\n        # 14. 1 1 1 1\n        # 15. 1 1 1 1\n        # 16. 1 1 1 1\n        # 17. 1 1 1 1\n        # 18. 1 1 1 1\n        # 19. 1 1 1 1\n        # 20. 1 1 1 1\n        # 21. 1 1 1 1\n        # 22. 1 1 1 1\n        # 23. 1 1 1 1\n        # 24. 1 1 1 1\n        # 25. 1 1 1 1\n        # 26. 1 1 1 1\n        # 27. 1 1 1 1\n        # 28. 1 1 1 1\n        # 29. 1 1 1 1\n        # 30. 1 1 1 1\n        # 31. 1 1 1 1\n        # 32. 1 1 1 1\n        # 33. 1 1 1 1\n        # 34. 1 1 1 1\n        # 35. 1 1 1 1\n        # 36. 1 1 1 1\n        # 37. 1 1 1 1\n        # 38. 1 1 1 1\n        # 39. 1 1 1 1\n        # 40. 1 1 1 1\n        # 41. 1 1 1 1\n        # 42. 1 1 1 1\n        # 43. 1 1 1 1\n        # 44. 1 1 1 1\n        # 45. 1 1 1 1\n        # 46. 1 1 1 1\n        # 47. 1 1 1 1\n        # 48. 1 1 1 1\n        # 49. 1 1 1 1\n        # 50. 1 1 1 1\n        # 51. 1 1 1 1\n        # 52. 1 1 1 1\n        # 53. 1 1 1 1\n        # 54. 1 1 1 1\n        # 55. 1 1 1 1\n        # 56. 1 1 1 1"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then s must be empty as well\n        if not p:\n            return not s\n        \n        # if p is not empty, then s must not be empty\n        if not s:\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p)\n        \n        # if p is not empty, then s must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[1] == '*':\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[1] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[1] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[1] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[1] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[1] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[1] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[1] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[1] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[1] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[0] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[1] == '*':\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, then s must not be empty\n        if p[1] != '*':\n            return False\n        \n        # if p is not empty, then s must not be empty\n        if p[0] == '*':"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival airports, add it to the result\n        # else, add the next departure airport to the result\n        # return the result\n        \n        # build a hashmap of departure airport to list of arrival airports\n        # sort the departure airports by alphabetical order\n        # iterate over the departure airports in reverse order\n        # if the departure airport has no arrival air"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) < 4:\n            return []\n        \n        nums.sort()\n        res = []\n        if nums[0] + nums[1] + nums[2] + nums[3] < target:\n            return res\n        \n        if nums[0] + nums[1] + nums[2] + nums[3] > target:\n            return res\n        \n        if nums[0] + nums[1] + nums[2] + nums[3] == target:\n            return [[nums[0], nums[1], nums[2], nums[3]]\n        \n        d = {}\n        for i in range(len(nums) - 1):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 3):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 2):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 4):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 5):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 6):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 7):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 8):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 9):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 10):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 11):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 12):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 13):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d[nums[i]]\n        \n        for i in range(len(nums) - 14):\n            if nums[i] not in d:\n                d[nums[i]] = i\n            else:\n                d[nums[i]] = d["}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. sort the buildings by left\n        # 2. use a priority queue to store the right\n        # 3. if the right is larger than the top of the queue, pop the top\n        # 4. if the right is smaller than the top of the queue, add the right to the queue\n        # 5. if the right is equal to the top of the queue, pop the top\n        # 6. if the queue is empty, add the right to the queue\n        # 7. if the queue is not empty, add the right to the result\n        # 8. return the result\n        \n        # 1. sort the buildings by left\n        # 2. use a priority queue to store the right\n        # 3. if the right is larger than the top of the queue, pop the top\n        # 4. if the right is smaller than the top of the queue, add the right to the queue\n        # 5. if the right is equal to the top of the queue, pop the top\n        # 6. if the queue is empty, add the right to the queue\n        # 7. if the queue is not empty, add the right to the result\n        # 8. return the result\n        \n        # 1. sort the buildings by left\n        # 2. use a priority queue to store the right\n        # 3. if the right is larger than the top of the queue, pop the top\n        # 4. if the right is smaller than the top of the queue, add the right to the queue\n        # 5. if the right is equal to the top of the queue, pop the top\n        # 6. if the queue is empty, add the right to the queue\n        # 7. if the queue is not empty, add the right to the result\n        # 8. return the result\n        \n        # 1. sort the buildings by left\n        # 2. use a priority queue to store the right\n        # 3. if the right is larger than the top of the queue, pop the top\n        # 4. if the right is smaller than the top of the queue, add the right to the queue\n        # 5. if the right is equal to the top of the queue, pop the top\n        # 6. if the queue is empty, add the right to the queue\n        # 7. if the queue is not empty, add the right to the result\n        # 8. return the result\n        \n        # 1. sort the buildings by left\n        # 2. use a priority queue to store the right\n        # 3. if the right is larger than the top of the queue, pop the top\n        # 4. if the right is smaller than the top of the queue, add the right to the queue\n        # 5. if the right is equal to the top of the queue, pop the top\n        # 6. if the queue is empty, add the right to the queue\n        # 7. if the queue is not empty, add the right to the result\n        # 8. return the result\n        \n        # 1. sort the buildings by left\n        # 2. use a priority queue to store the right\n        # 3. if the right is larger than the top of the queue, pop the top\n        # 4. if the right is smaller than the top of the queue, add the right to the queue\n        # 5. if the right is equal to the top of the queue, pop the top\n        # 6. if the queue is empty, add the right to the queue\n        # 7. if the queue is not empty, add the right to the result\n        # 8. return the result\n        \n        # 1. sort the buildings by left\n        # 2. use a priority queue to store the right\n        # 3. if the right is larger than the top of the queue, pop the top\n        # 4. if the right is smaller than the top of the queue, add the right to the queue\n        # 5. if the right is equal to the top of the queue, pop the top\n        # 6. if the queue is empty, add the right to the queue\n        # 7. if the queue is not empty, add the right to the result\n        # 8. return the result\n        \n        # 1. sort the buildings by left\n        # 2. use a priority queue to store the right\n        # 3. if the right is larger than the top of the queue, pop the top\n        # 4."}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the list\n        s.reverse()\n        \n        # swap the first half with the second half\n        for i in range(0, len(s) // 2):\n            s[i], s[len(s) - i - 1] = s[len(s) - i - 1], s[i]"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     next = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = next\n        # return prev\n        \n        # recursive\n        if not head or not head.next:\n            return head\n        new_head = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return new_head"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if len(triangle) == 1:\n        #     return triangle[0][0]\n        # if len(triangle) == 2:\n        #     return min(triangle[0][0], triangle[1][0])\n        # if len(triangle) == 3:\n        #     return min(triangle[0][0], min(triangle[1][0], triangle[2][0]))\n        # if len(triangle) == 4:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], triangle[3][0]))\n        # if len(triangle) == 5:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], triangle[4][0]))\n        # if len(triangle) == 6:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], triangle[5][0]))\n        # if len(triangle) == 7:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], min(triangle[5][0], triangle[6][0]))\n        # if len(triangle) == 8:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], min(triangle[5][0], min(triangle[6][0], triangle[7][0]))\n        # if len(triangle) == 9:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], min(triangle[5][0], min(triangle[6][0], min(triangle[7][0], triangle[8][0]))\n        # if len(triangle) == 10:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], min(triangle[5][0], min(triangle[6][0], min(triangle[7][0], min(triangle[8][0], triangle[9][0]))\n        # if len(triangle) == 11:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], min(triangle[5][0], min(triangle[6][0], min(triangle[7][0], min(triangle[8][0], min(triangle[9][0], triangle[10][0]))\n        # if len(triangle) == 12:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], min(triangle[5][0], min(triangle[6][0], min(triangle[7][0], min(triangle[8][0], min(triangle[9][0], min(triangle[10][0], triangle[11][0]))\n        # if len(triangle) == 13:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], min(triangle[5][0], min(triangle[6][0], min(triangle[7][0], min(triangle[8][0], min(triangle[9][0], min(triangle[10][0], min(triangle[11][0], triangle[12][0]))\n        # if len(triangle) == 14:\n        #     return min(triangle[0][0], min(triangle[1][0], min(triangle[2][0], min(triangle[3][0], min(triangle[4][0], min(triangle[5][0], min(triangle[6][0], min(triangle[7][0], min(triangle[8][0], min(triangle[9][0], min(triangle[10][0"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return 'Zero'\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 2 3 4 5 6 7 8 9 10\n        # 1 1 2 3 4 5 6 7 8 9\n        # 1 1 1 2 3 4 5 6 7 8\n        # 1 1 1 1 2 3 4 5 6 7\n        # 1 1 1 1 1 2 3 4 5 6\n        # 1 1 1 1 1 1 2 3 4 5\n        # 1 1 1 1 1 1 1 2 3 4\n        # 1 1 1 1 1 1 1 1 2 3\n        # 1 1 1 1 1 1 1 1 1 2\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1 1 1 1 1 1 1\n        # 1 1 1 1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        # p1, p2\n        p1 = dummy\n        p2 = p1.next\n        # p3\n        p3 = p2.next\n        \n        # loop until p3 is None\n        while p3:\n            # p1 -> p2 -> p3\n            p1.next = p3\n            # p2 -> p3 -> p4\n            p2.next = p3.next\n            # p3 -> p4 -> p1\n            p3.next = p2\n            # p1 -> p3 -> p2\n            p1 = p2\n            # p2 -> p1 -> p3\n            p2 = p1.next\n            # p3 -> p2 -> p1\n            p3 = p2.next\n        \n        # return dummy.next\n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return root.val == targetSum\n        \n        if root.left:\n            if self.hasPathSum(root.left, targetSum - root.val):\n                return True\n        if root.right:\n            if self.hasPathSum(root.right, targetSum - root.val):\n                return True\n        return False"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create two dummy nodes\n        # 2. create two pointers, one for smaller, one for larger\n        # 3. traverse the list, if the current node is smaller than x,\n        #    append it to the smaller list, otherwise append it to the larger list\n        # 4. join the smaller list to the larger list\n        # 5. return the smaller list\n        \n        smaller_head = ListNode(0)\n        larger_head = ListNode(0)\n        smaller_tail = smaller_head\n        larger_tail = larger_head\n        \n        curr = head\n        while curr:\n            if curr.val < x:\n                smaller_tail.next = curr\n                smaller_tail = smaller_tail.next\n            else:\n                larger_tail.next = curr\n                larger_tail = larger_tail.next\n            curr = curr.next\n        \n        smaller_tail.next = larger_head.next\n        larger_tail.next = None\n        \n        return smaller_head.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with indegree 1\n        indegree = [0] * (n + 1)\n        parent = None\n        for edge in edges:\n            if indegree[edge[1]] == 0:\n                parent = edge[1]\n            else:\n                indegree[edge[1]] -= 1\n        # 2. find the node with indegree 2\n        for edge in edges:\n            if indegree[edge[1]] == 1:\n                return edge[0], edge[1]\n        # 3. find the node with indegree 0\n        # 4. find the node with indegree 1\n        # 5. find the node with indegree 0\n        # 6. find the node with indegree 1\n        # 7. find the node with indegree 0\n        # 8. find the node with indegree 1\n        # 9. find the node with indegree 0\n        # 10. find the node with indegree 1\n        # 11. find the node with indegree 0\n        # 12. find the node with indegree 1\n        # 13. find the node with indegree 0\n        # 14. find the node with indegree 1\n        # 15. find the node with indegree 0\n        # 16. find the node with indegree 1\n        # 17. find the node with indegree 0\n        # 18. find the node with indegree 1\n        # 19. find the node with indegree 0\n        # 20. find the node with indegree 1\n        # 21. find the node with indegree 0\n        # 22. find the node with indegree 1\n        # 23. find the node with indegree 0\n        # 24. find the node with indegree 1\n        # 25. find the node with indegree 0\n        # 26. find the node with indegree 1\n        # 27. find the node with indegree 0\n        # 28. find the node with indegree 1\n        # 29. find the node with indegree 0\n        # 30. find the node with indegree 1\n        # 31. find the node with indegree 0\n        # 32. find the node with indegree 1\n        # 33. find the node with indegree 0\n        # 34. find the node with indegree 1\n        # 35. find the node with indegree 0\n        # 36. find the node with indegree 1\n        # 37. find the node with indegree 0\n        # 38. find the node with indegree 1\n        # 39. find the node with indegree 0\n        # 40. find the node with indegree 1\n        # 41. find the node with indegree 0\n        # 42. find the node with indegree 1\n        # 43. find the node with indegree 0\n        # 44. find the node with indegree 1\n        # 45. find the node with indegree 0\n        # 46. find the node with indegree 1\n        # 47. find the node with indegree 0\n        # 48. find the node with indegree 1\n        # 49. find the node with indegree 0\n        # 50. find the node with indegree 1\n        # 51. find the node with indegree 0\n        # 52. find the node with indegree 1\n        # 53. find the node with indegree 0\n        # 54. find the node with indegree 1\n        # 55. find the node with indegree 0\n        # 56. find the node with indegree 1\n        # 57. find the node with indegree 0\n        # 58. find the node with indegree 1\n        # 59. find"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the list\n        nums.sort()\n        # initialize the result list\n        res = [nums[:]]\n        # iterate through the list\n        for i in range(len(nums)-2, -1, -1):\n            # if the current number is the same as the next number,\n            # we have a duplicate, so we skip it\n            if nums[i] == nums[i+1]:\n                continue\n            # otherwise, we need to find the number of numbers\n            # that are larger than the current number\n            j = i+1\n            # find the index of the last number that is larger than the current number\n            while j+1 < n and nums[j] < nums[j+1]:\n                j += 1\n            # if the index is 0, we have no larger numbers\n            if j == 0:\n                continue\n            # otherwise, we need to find the index of the last number that is smaller than the current number\n            k = j-1\n            # find the index of the last number that is smaller than the current number\n            while k+1 < j and nums[k] > nums[k+1]:\n                k += 1\n            # if the index is 0, we have no smaller numbers\n            if k == 0:\n                continue\n            # otherwise, we need to find the index of the first number that is larger than the current number\n            l = k+1\n            # find the index of the first number that is larger than the current number\n            while l+1 < j and nums[l] > nums[l+1]:\n                l += 1\n            # if the index is 0, we have no larger numbers\n            if l == 0:\n                continue\n            # otherwise, we need to find the index of the first number that is smaller than the current number\n            m = l-1\n            # find the index of the first number that is smaller than the current number\n            while m+1 < l and nums[m] < nums[m+1]:\n                m += 1\n            # if the index is 0, we have no smaller numbers\n            if m == 0:\n                continue\n            # otherwise, we need to find the index of the last number that is larger than the current number\n            n = m-1\n            # find the index of the last number that is larger than the current number\n            while n+1 < m and nums[n] < nums[n+1]:\n                n += 1\n            # if the index is 0, we have no larger numbers\n            if n == 0:\n                continue\n            # otherwise, we need to find the index of the last number that is smaller than the current number\n            p = n-1\n            # find the index of the last number that is smaller than the current number\n            while p+1 < n and nums[p] > nums[p+1]:\n                p += 1\n            # if the index is 0, we have no smaller numbers\n            if p == 0:\n                continue\n            # otherwise, we need to find the index of the first number that is larger than the current number\n            q = p-1\n            # find the index of the first number that is larger than the current number\n            while q+1 < p and nums[q] > nums[q+1]:\n                q += 1\n            # if the index is 0, we have no larger numbers\n            if q == 0:\n                continue\n            # otherwise, we need to find the index of the first number that is smaller than the current number\n            r = q-1\n            # find the index of the first number that is smaller than the current number\n            while r+1 < q and nums[r] < nums[r+1]:\n                r += 1\n            # if the index is 0, we have no smaller numbers\n            if r == 0:\n                continue\n            # otherwise, we need to find the index of the last number that is larger than the current number\n            s = r-1\n            # find the index of the last number that is larger than the current number\n            while s+1 < r and nums[s] < nums[s+1]:\n                s += 1\n            # if the index is 0, we have no larger numbers\n            if s == 0:\n                continue\n            # otherwise, we need to find the index of the last number that is smaller than the current number\n            t = s-1\n            # find the index of the last number"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR all the numbers\n        # 1 ^ 1 = 0\n        # 1 ^ 0 = 1\n        # 0 ^ 0 = 0\n        # 0 ^ 1 = 1\n        # 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. remove trailing spaces\n        s = s.rstrip()\n        \n        ## 2. find the last index of the word\n        last_index = len(s) - 1\n        while last_index >= 0 and s[last_index] == ' ':\n            last_index -= 1\n        \n        ## 3. find the length of the last word\n        length = 0\n        while last_index >= 0 and s[last_index] != ' ':\n            last_index -= 1\n            length += 1\n        \n        return length"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the first row of cherries\n        # 2. find the last row of cherries\n        # 3. find the first column of cherries\n        # 4. find the last column of cherries\n        # 5. find the first row of empty spaces\n        # 6. find the last row of empty spaces\n        # 7. find the first column of empty spaces\n        # 8. find the last column of empty spaces\n        # 9. find the first row of cherries\n        # 10. find the last row of cherries\n        # 11. find the first column of cherries\n        # 12. find the last column of cherries\n        # 13. find the first row of empty spaces\n        # 14. find the last row of empty spaces\n        # 15. find the first column of empty spaces\n        # 16. find the last column of empty spaces\n        # 17. find the first row of cherries\n        # 18. find the last row of cherries\n        # 19. find the first column of cherries\n        # 20. find the last column of cherries\n        # 21. find the first row of empty spaces\n        # 22. find the last row of empty spaces\n        # 23. find the first column of empty spaces\n        # 24. find the last column of empty spaces\n        # 25. find the first row of cherries\n        # 26. find the last row of cherries\n        # 27. find the first column of cherries\n        # 28. find the last column of cherries\n        # 29. find the first row of empty spaces\n        # 30. find the last row of empty spaces\n        # 31. find the first column of empty spaces\n        # 32. find the last column of empty spaces\n        # 33. find the first row of cherries\n        # 34. find the last row of cherries\n        # 35. find the first column of cherries\n        # 36. find the last column of cherries\n        # 37. find the first row of empty spaces\n        # 38. find the last row of empty spaces\n        # 39. find the first column of empty spaces\n        # 40. find the last column of empty spaces\n        # 41. find the first row of cherries\n        # 42. find the last row of cherries\n        # 43. find the first column of cherries\n        # 44. find the last column of cherries\n        # 45. find the first row of empty spaces\n        # 46. find the last row of empty spaces\n        # 47. find the first column of empty spaces\n        # 48. find the last column of empty spaces\n        # 49. find the first row of cherries\n        # 50. find the last row of cherries\n        # 51. find the first column of cherries\n        # 52. find the last column of cherries\n        # 53. find the first row of empty spaces\n        # 54. find the last row of empty spaces\n        # 55. find the first column of empty spaces\n        # 56. find the last column of empty spaces\n        # 57. find the first row of cherries\n        # 58. find the last row of cherries\n        # 59. find the first column of cherries\n        # 60. find the last column of cherries\n        # 61. find the first row of empty spaces\n        # 62. find the last row of empty spaces\n        # 63. find the first column of empty spaces\n        # 64. find the last column of empty spaces\n        # 65. find the first row of cherries\n        # 66. find the last row of cherries\n        # 67. find the first column of cherries\n        # 68. find the last column of cherries\n        # 69. find the first row of empty spaces\n        # 70. find the last row of empty spaces\n        # 71. find the first column of empty spaces\n        # 72. find the last column of empty spaces\n        # 73. find the first row of cherries\n        # 74. find the last row of"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 10^9 + 7\n        MOD = 10**9 + 7\n        \n        # 2^n modulo MOD\n        two_n = pow(2, n, MOD)\n        \n        # 2^(n-1) modulo MOD\n        two_n_minus_1 = pow(2, n-1, MOD)\n        \n        # 2^n modulo MOD - 1\n        two_n_minus_1_mod_1 = (two_n - 1) % MOD\n        \n        # 2^n modulo MOD - 2\n        two_n_minus_2 = (two_n - 2) % MOD\n        \n        # 2^n modulo MOD - 3\n        two_n_minus_3 = (two_n - 3) % MOD\n        \n        # 2^n modulo MOD - 4\n        two_n_minus_4 = (two_n - 4) % MOD\n        \n        # 2^n modulo MOD - 5\n        two_n_minus_5 = (two_n - 5) % MOD\n        \n        # 2^n modulo MOD - 6\n        two_n_minus_6 = (two_n - 6) % MOD\n        \n        # 2^n modulo MOD - 7\n        two_n_minus_7 = (two_n - 7) % MOD\n        \n        # 2^n modulo MOD - 8\n        two_n_minus_8 = (two_n - 8) % MOD\n        \n        # 2^n modulo MOD - 9\n        two_n_minus_9 = (two_n - 9) % MOD\n        \n        # 2^n modulo MOD - 10\n        two_n_minus_10 = (two_n - 10) % MOD\n        \n        # 2^n modulo MOD - 11\n        two_n_minus_11 = (two_n - 11) % MOD\n        \n        # 2^n modulo MOD - 12\n        two_n_minus_12 = (two_n - 12) % MOD\n        \n        # 2^n modulo MOD - 13\n        two_n_minus_13 = (two_n - 13) % MOD\n        \n        # 2^n modulo MOD - 14\n        two_n_minus_14 = (two_n - 14) % MOD\n        \n        # 2^n modulo MOD - 15\n        two_n_minus_15 = (two_n - 15) % MOD\n        \n        # 2^n modulo MOD - 16\n        two_n_minus_16 = (two_n - 16) % MOD\n        \n        # 2^n modulo MOD - 17\n        two_n_minus_17 = (two_n - 17) % MOD\n        \n        # 2^n modulo MOD - 18\n        two_n_minus_18 = (two_n - 18) % MOD\n        \n        # 2^n modulo MOD - 19\n        two_n_minus_19 = (two_n - 19) % MOD\n        \n        # 2^n modulo MOD - 20\n        two_n_minus_20 = (two_n - 20) % MOD\n        \n        # 2^n modulo MOD - 21\n        two_n_minus_21 = (two_n - 21) % MOD\n        \n        # 2^n modulo MOD - 22\n        two_n_minus_22 = (two_n - 22) % MOD\n        \n        # 2^n modulo MOD - 23\n        two_n_minus_23 = (two_n - 23) % MOD\n        \n        # 2^n modulo MOD - 24\n        two_n_minus_24 = (two_n - 24) % MOD"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 19 -> 1^2 + 9^2 = 82\n        # 82 -> 8^2 + 2^2 = 68\n        # 68 -> 6^2 + 8^2 = 100\n        # 100 -> 1^2 + 0^2 + 0^2 = 1\n        # 1 -> True\n        # 82 -> 8^2 + 2^2 = 68\n        # 68 -> 6^2 + 8^2 = 100\n        # 100 -> 1^2 + 0^2 + 0^2 = 1\n        # 1 -> True\n        # 68 -> 6^2 + 8^2 = 100\n        # 100 -> 1^2 + 0^2 + 0^2 = 1\n        # 1 -> True\n        # 100 -> 1^2 + 0^2 + 0^2 = 1\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True\n        # 1 -> True"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        low = 0\n        high = len(nums) - 1\n        if target < nums[low]:\n            return 0\n        elif target > nums[high]:\n            return high + 1\n        while low < high:\n            mid = (low + high) // 2\n            if nums[mid] < target:\n                low = mid + 1\n            else:\n                high = mid\n        return low"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if nums[0] >= len(nums) - 1:\n        #     return True\n        # if nums[0] == 0:\n        #     return False\n        # if nums[0] == 1:\n        #     return True\n        # if nums[0] > 1:\n        #     return False\n        # if nums[0] > 2:\n        #     return False\n        # if nums[0] > 3:\n        #     return False\n        # if nums[0] > 4:\n        #     return False\n        # if nums[0] > 5:\n        #     return False\n        # if nums[0] > 6:\n        #     return False\n        # if nums[0] > 7:\n        #     return False\n        # if nums[0] > 8:\n        #     return False\n        # if nums[0] > 9:\n        #     return False\n        # if nums[0] > 10:\n        #     return False\n        # if nums[0] > 11:\n        #     return False\n        # if nums[0] > 12:\n        #     return False\n        # if nums[0] > 13:\n        #     return False\n        # if nums[0] > 14:\n        #     return False\n        # if nums[0] > 15:\n        #     return False\n        # if nums[0] > 16:\n        #     return False\n        # if nums[0] > 17:\n        #     return False\n        # if nums[0] > 18:\n        #     return False\n        # if nums[0] > 19:\n        #     return False\n        # if nums[0] > 20:\n        #     return False\n        # if nums[0] > 21:\n        #     return False\n        # if nums[0] > 22:\n        #     return False\n        # if nums[0] > 23:\n        #     return False\n        # if nums[0] > 24:\n        #     return False\n        # if nums[0] > 25:\n        #     return False\n        # if nums[0] > 26:\n        #     return False\n        # if nums[0] > 27:\n        #     return False\n        # if nums[0] > 28:\n        #     return False\n        # if nums[0] > 29:\n        #     return False\n        # if nums[0] > 30:\n        #     return False\n        # if nums[0] > 31:\n        #     return False\n        # if nums[0] > 32:\n        #     return False\n        # if nums[0] > 33:\n        #     return False\n        # if nums[0] > 34:\n        #     return False\n        # if nums[0] > 35:\n        #     return False\n        # if nums[0] > 36:\n        #     return False\n        # if nums[0] > 37:\n        #     return False\n        # if nums[0] > 38:\n        #     return False\n        # if nums[0] > 39:\n        #     return False\n        # if nums[0] > 40:\n        #     return False\n        # if nums[0] > 41:\n        #     return False\n        # if nums[0] > 42:\n        #     return False\n        # if nums[0] > 43:\n        #     return False\n        # if nums[0] > 44:\n        #     return False\n        # if nums[0] > 45:\n        #     return False\n        # if nums[0] > 46:\n        #     return False\n        # if nums[0] > 47:\n        #     return False\n        # if nums[0] > 48:\n        #     return False\n        # if nums[0] > 49:\n        #     return False\n        # if nums[0] > 50:\n        #     return False\n        # if nums[0] > 51:\n        #     return False\n        # if"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 2. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 3. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 4. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 5. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 6. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 7. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 8. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 9. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 10. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 11. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 12. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 13. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 14. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 15. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 16. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 17. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 18. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 19. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 20. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 21. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 22. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 23. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 24. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 25. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 26. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 27. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 28. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 29. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 30. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 31. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 32. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 33. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 34. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 35. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 36. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 37. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 38. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u5217\u6700\u5c0f\u503c\n        # 39. \u4ece\u4e0a\u5230\u4e0b\uff0c\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u8bb0\u5f55\u6bcf\u884c\u6700\u5c0f\u503c\n        # 40. \u4ece\u4e0b\u5230\u4e0a\uff0c\u4ece\u53f3\u5230\u5de6\u904d\u5386\uff0c"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        else:\n            res = '1'\n            for i in range(1, n):\n                res = self.next_res(res)\n            return res\n        \n    def next_res(self, res):\n        # 1211\n        # 111221\n        # 312211\n        # 13112221\n        # 1113213211\n        # 31131221131221\n        # 132113112221131221\n        # 11131221131221131221\n        # 311322113112221131221131221\n        # 1321132132113112221131221131221131221\n        # 1113221132132113112221131221132132113112221131221131221221\n        # 31132211321321132221131122211321321132221131122211321321132221131122211321321131222123211211411\n        # 13211321321132221131122211321321132221131122211321321132221131122211321321131222123211211421\n        # 11132211321321132221131122211321321132221131122211321321132221131122211321321131222123211211421221\n        # 31132211321321132221131122211321321132221131122211321321132221131122211321321131222123211211421221221\n        # 13211321321132221131122211321321132221131122211321321132221131122211321321131222123211211421221221221\n        # 11132211321321132221131122211321321132221131122211321321132221131122211321321131222123211211421221221221\n        # 311322113213211322211311222113213211322211311222113213211322211311222113213211312221232112"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search for the largest possible subarray sum\n        # if the sum is too large, we need to decrease the subarray count\n        # if the sum is too small, we need to increase the subarray count\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum\n        # we can use binary search to find the smallest possible subarray sum\n        # we can use binary search to find the largest possible subarray sum"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        # if pivot is not found, return -1\n        if pivot == -1:\n            return self.binary_search(nums, target)\n        # if target is less than the first element, search in the right subarray\n        if target < nums[0]:\n            return self.binary_search(nums[pivot:], target)\n        # otherwise, search in the left subarray\n        return self.binary_search(nums[:pivot], target)\n        \n    def find_pivot(self, nums):\n        # find the pivot\n        left, right = 0, len(nums) - 1\n        if nums[left] < nums[right]:\n            return -1\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[mid + 1]:\n                left = mid\n            else:\n                right = mid\n        return right\n        \n    def binary_search(self, nums, target):\n        # binary search\n        left, right = 0, len(nums) - 1\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid\n            else:\n                right = mid\n        if nums[left] == target:\n            return left\n        if nums[right] == target:\n            return right\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone_map = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        res = [phone_map[digits[0]]\n        for i in digits[1:]:\n            res = [r + p for r in res for p in phone_map[i]]\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the candidates\n        candidates.sort()\n        # initialize the result list\n        result = []\n        # initialize the index\n        index = 0\n        # loop through the candidates\n        while index < len(candidates) and candidates[index] < target:\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target - index:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index += 1\n        # initialize the index\n        index -= 1\n        # loop through the candidates\n        while index >= 0:\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index -= 1\n        # initialize the index\n        index += 1\n        # loop through the candidates\n        while index < len(candidates):\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index += 1\n        # initialize the index\n        index -= 1\n        # loop through the candidates\n        while index >= 0:\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index -= 1\n        # initialize the index\n        index += 1\n        # loop through the candidates\n        while index < len(candidates):\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index += 1\n        # initialize the index\n        index -= 1\n        # loop through the candidates\n        while index >= 0:\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index -= 1\n        # initialize the index\n        index += 1\n        # loop through the candidates\n        while index < len(candidates):\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index += 1\n        # initialize the index\n        index -= 1\n        # loop through the candidates\n        while index >= 0:\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index -= 1\n        # initialize the index\n        index += 1\n        # loop through the candidates\n        while index < len(candidates):\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index += 1\n        # initialize the index\n        index -= 1\n        # loop through the candidates\n        while index >= 0:\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index -= 1\n        # initialize the index\n        index += 1\n        # loop through the candidates\n        while index < len(candidates):\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop\n                break\n            # otherwise, we can use it\n            index += 1\n        # initialize the index\n        index -= 1\n        # loop through the candidates\n        while index >= 0:\n            # if the current candidate is larger than the target,\n            # then we can't use it\n            if candidates[index] > target:\n                # break the loop"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of the number\n        length = len(n)\n        # 2. if the number is 1, return 0\n        if length == 1:\n            return '0'\n        # 3. if the number is 2, return 9\n        if length == 2:\n            return '9' if n[0] == '1' else '1'\n        # 4. if the number is 3, return 99\n        if length == 3:\n            return '99' if n[0] == '1' else '10'\n        # 5. if the number is 4, return 999\n        if length == 4:\n            return '999' if n[0] == '1' else '100'\n        # 6. if the number is 5, return 9999\n        if length == 5:\n            return '9999' if n[0] == '1' else '1000'\n        # 7. if the number is 6, return 99999\n        if length == 6:\n            return '99999' if n[0] == '1' else '10000'\n        # 8. if the number is 7, return 999999\n        if length == 7:\n            return '999999' if n[0] == '1' else '100000'\n        # 9. if the number is 8, return 9999999\n        if length == 8:\n            return '9999999' if n[0] == '1' else '1000000'\n        # 10. if the number is 9, return 99999999\n        if length == 9:\n            return '99999999' if n[0] == '1' else '10000000'\n        # 11. if the number is 10, return 999999999\n        if length == 10:\n            return '999999999' if n[0] == '1' else '100000000'\n        # 12. if the number is 11, return 9999999999\n        if length == 11:\n            return '9999999999' if n[0] == '1' else '1000000000'\n        # 13. if the number is 12, return 99999999999\n        if length == 12:\n            return '99999999999' if n[0] == '1' else '10000000000'\n        # 14. if the number is 13, return 999999999999\n        if length == 13:\n            return '999999999999' if n[0] == '1' else '100000000000'\n        # 15. if the number is 14, return 9999999999999\n        if length == 14:\n            return '9999999999999' if n[0] == '1' else '1000000000000'\n        # 16. if the number is 15, return 99999999999999\n        if length == 15:\n            return '99999999999999' if n[0] == '1' else '10000000000000'\n        # 17. if the number is 16, return 999999999999999\n        if length == 16:\n            return '999999999999999' if n[0] == '1' else '100000000000000'\n        # 18. if the"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u521d\u59cb\u5316\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\n        matrix = [[0] * n\n        for i in range(n):\n            matrix[i] = [0] * n\n        \n        # 2. \u521d\u59cb\u5316\u56db\u4e2a\u53d8\u91cf\n        left, right, top, bottom = 0, n-1, 0, n-1\n        num = 1\n        \n        # 3. \u904d\u5386\u6570\u7ec4\n        while left < right and top < bottom:\n            # \u4ece\u5de6\u5230\u53f3\n            for i in range(left, right):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            # \u4ece\u4e0a\u5230\u4e0b\n            for i in range(top, bottom):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            # \u4ece\u53f3\u5230\u5de6\n            for i in range(right, left, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            # \u4ece\u4e0b\u5230\u4e0a\n            for i in range(bottom, top, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        # 4. \u5982\u679cn\u4e3a\u5947\u6570\uff0c\u5219\u5728\u4e2d\u95f4\u4f4d\u7f6e\u586b\u5145\u4e00\u4e2a\u6570\u5b57\n        if n % 2 == 1:\n            matrix[n//2][n//2] = num\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        x = abs(x)\n        res = 0\n        while x:\n            res = res * 10 + x % 10\n            x //= 10\n        if res * sign < -2**31 or res * sign > 2**31 - 1:\n            return 0\n        return res * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # reverse the matrix\n        matrix.reverse()\n        \n        # transpose the matrix\n        for i in range(len(matrix)):\n            for j in range(i+1, len(matrix[0])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i] = matrix[i][::-1]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if all numbers are negative, the largest product will be the largest negative number\n        # if all numbers are positive, the largest product will be the largest positive number\n        # if there is one positive and one negative number, the largest product will be the largest number times the largest negative number\n        # if there are two positive numbers, the largest product will be the product of the two positive numbers\n        # if there are two negative numbers, the largest product will be the product of the two negative numbers\n        # if there are three or more numbers, the largest product will be the product of the largest three numbers\n        \n        # if the array has only one number, the largest product will be that number\n        # if the array has two numbers, the largest product will be the product of those two numbers\n        \n        # if the array has three or more numbers, the largest product will be the product of the largest three numbers\n        \n        # if the array has four or more numbers, the largest product will be the product of the largest four numbers\n        \n        # if the array has five or more numbers, the largest product will be the product of the largest five numbers\n        \n        # if the array has six or more numbers, the largest product will be the product of the largest six numbers\n        \n        # if the array has seven or more numbers, the largest product will be the product of the largest seven numbers\n        \n        # if the array has eight or more numbers, the largest product will be the product of the largest eight numbers\n        \n        # if the array has nine or more numbers, the largest product will be the product of the largest nine numbers\n        \n        # if the array has ten or more numbers, the largest product will be the product of the largest ten numbers\n        \n        # if the array has eleven or more numbers, the largest product will be the product of the largest eleven numbers\n        \n        # if the array has twelve or more numbers, the largest product will be the product of the largest twelve numbers\n        \n        # if the array has thirteen or more numbers, the largest product will be the product of the largest thirteen numbers\n        \n        # if the array has fourteen or more numbers, the largest product will be the product of the largest fourteen numbers\n        \n        # if the array has fifteen or more numbers, the largest product will be the product of the largest fifteen numbers\n        \n        # if the array has sixteen or more numbers, the largest product will be the product of the largest sixteen numbers\n        \n        # if the array has seventeen or more numbers, the largest product will be the product of the largest seventeen numbers\n        \n        # if the array has eighteen or more numbers, the largest product will be the product of the largest eighteen numbers\n        \n        # if the array has nineteen or more numbers, the largest product will be the product of the largest nineteen numbers\n        \n        # if the array has twenty or more numbers, the largest product will be the product of the largest twenty numbers\n        \n        # if the array has twenty-one or more numbers, the largest product will be the product of the largest twenty-one numbers\n        \n        # if the array has twenty-two or more numbers, the largest product will be the product of the largest twenty-two numbers\n        \n        # if the array has twenty-three or more numbers, the largest product will be the product of the largest twenty-three numbers\n        \n        # if the array has twenty-four or more numbers, the largest product will be the product of the largest twenty-four numbers\n        \n        # if the array has twenty-five or more numbers, the largest product will be the product of the largest twenty-five numbers\n        \n        # if the array has twenty-six or more numbers, the largest product will be the product of the largest twenty-six numbers\n        \n        # if the array has twenty-seven or more numbers, the largest product will be the product of the largest twenty-seven numbers\n        \n        # if the array has twenty-eight or more numbers, the largest product will be the product of the largest twenty-eight numbers\n        \n        # if the array has twenty-nine or more numbers, the largest product will be the product of the largest twenty-nine numbers\n        \n        # if the array has thirty or more numbers, the largest product will be the product of the largest thirty numbers\n        \n        # if the array has thirty-one or more numbers, the largest product will be the product of the largest thirty-one numbers\n        \n        # if the array has thirty-two or more numbers, the largest product will be the product of the largest thirty-two numbers\n        \n        # if the array has thirty-"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the last stone is 0, return False\n        if stones[0] == 0:\n            return False\n        \n        # if the last stone is 1, return True\n        if stones[-1] == 1:\n            return True\n        \n        # create a dict to store the index of each stone\n        stone_index = {stone: i for i, stone in enumerate(stones)}\n        \n        # initialize the jump_set with the first jump\n        jump_set = {0}\n        \n        # iterate through the stones\n        for stone in stones:\n            # if the stone is larger than the largest jump, return False\n            if stone > largest_jump:\n                return False\n            # if the stone is in the jump_set, update the jump_set\n            if stone in jump_set:\n                jump_set = jump_set_jump\n            # iterate through the jump_set\n            for j in jump_set:\n                # if the jump is larger than the largest jump, return False\n                if j + j + 1 > largest_jump:\n                    return False\n                # if the jump is in the jump_set, update the jump_set\n                if j + j + 1 in jump_set:\n                    jump_set = jump_set_jump\n                # if the jump is in stone_index, update the jump_set\n                if j + j + 1 in stone_index:\n                    jump_set_jump = jump_set_jump | {j + j + 1}\n                # if the jump is in stone_index, update the jump_set\n                if j + j in stone_index:\n                    jump_set_jump = jump_set_jump | {j + j}\n        \n        # if the jump_set is empty, return False\n        if not jump_set:\n            return False\n        \n        # if the jump_set is not empty, return True\n        return True"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # hashmap to store the index of the score in the sorted list\n        score_index_map = {score_sorted[i]: i for i in range(len(score_sorted))}\n        \n        # assign the rank to the score in the sorted list\n        score_rank = [None] * len(score)\n        for i, score_rank_i in enumerate(score_rank):\n            if i in score_index_map:\n                score_rank[i] = score_index_map[i] + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score_rank[i] is None:\n                score_rank[i] = score_i]\n        \n        # assign the rank to the score in the sorted list\n        for i, score_i in enumerate(score_rank):\n            if score_i is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score_rank[i] is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the sorted list\n        for i, score_i in enumerate(score_rank):\n            if score_i is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score_rank[i] is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the sorted list\n        for i, score_i in enumerate(score_rank):\n            if score_i is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score_rank[i] is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the sorted list\n        for i, score_i in enumerate(score_rank):\n            if score_i is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score_rank[i] is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the sorted list\n        for i, score_i in enumerate(score_rank):\n            if score_i is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score_rank[i] is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the sorted list\n        for i, score_i in enumerate(score_rank):\n            if score_i is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score_rank[i] is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the sorted list\n        for i, score_i in enumerate(score_rank):\n            if score_i is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score_rank[i] is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the sorted list\n        for i, score_i in enumerate(score_rank):\n            if score_i is None:\n                score_rank[i] = i + 1\n        \n        # assign the rank to the score in the original list\n        for i, score_i in enumerate(score):\n            if score"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) == 0:\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        # if len(s) == 2:\n        #     if s[0] != s[1]:\n        #         return 2\n        #     else:\n        #         return 1\n        # if len(s) > 2:\n        #     if s[0] != s[1] and s[0] != s[2]:\n        #         return 3\n        #     elif s[0] == s[1] and s[0] != s[2]:\n        #         return 2\n        #     elif s[0] != s[1] and s[0] == s[2]:\n        #         return 1\n        #     else:\n        #         return 1\n        # if len(s) > 2:\n        #     if s[0] != s[1] and s[0] != s[2] and s[0] != s[3]:\n        #         return 4\n        #     elif s[0] == s[1] and s[0] != s[2] and s[0] != s[3]:\n        #         return 3\n        #     elif s[0] != s[1] and s[0] == s[2] and s[0] != s[3]:\n        #         return 2\n        #     elif s[0] != s[1] and s[0] != s[2] and s[0] == s[3]:\n        #         return 1\n        #     else:\n        #         return 1\n        # if len(s) > 2:\n        #     if s[0] != s[1] and s[0] != s[2] and s[0] != s[3] and s[0] != s[4]:\n        #         return 5\n        #     elif s[0] == s[1] and s[0] != s[2] and s[0] != s[3] and s[0] != s[4]:\n        #         return 4\n        #     elif s[0] != s[1] and s[0] == s[2] and s[0] != s[3] and s[0] != s[4]:\n        #         return 3\n        #     elif s[0] != s[1] and s[0] != s[2] and s[0] == s[3] and s[0] != s[4]:\n        #         return 2\n        #     elif s[0] != s[1] and s[0] != s[2] and s[0] != s[3] and s[0] == s[4]:\n        #         return 1\n        #     else:\n        #         return 1\n        # if len(s) > 2:\n        #     if s[0] != s[1] and s[0] != s[2] and s[0] != s[3] and s[0] != s[4] and s[0] != s[5]:\n        #         return 6\n        #     elif s[0] == s[1] and s[0] != s[2] and s[0] != s[3] and s[0] != s[4] and s[0] != s[5]:\n        #         return 5\n        #     elif s[0] != s[1] and s[0] == s[2] and s[0] != s[3] and s[0] != s[4] and s[0] != s[5]:\n        #         return 4\n        #     elif s[0] != s[1] and s[0] != s[2] and s[0] == s[3] and s[0] != s[4] and s[0] != s[5]:\n        #         return 3\n        #     elif s[0] != s[1] and s[0] != s[2] and s[0] != s[3] and s[0] == s[4] and s[0] != s[5]:"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_dict = {}\n        for word in words:\n            if word not in word_dict:\n                word_dict[word] = 0\n            word_dict[word] += 1\n        \n        word_num = len(word_dict)\n        word_num_len = word_num * word_len\n        word_num_len_dict = {}\n        for i in range(word_num_len):\n            word_num_len_dict[i] = 0\n        \n        word_num_len_dict[0] = 1\n        \n        res = []\n        for i in range(word_len):\n            left = i\n            right = i\n            word_num_len_dict[0] = 0\n            word_num_len_dict_len = len(word_num_len_dict)\n            word_num_len_dict_len_i = word_num_len_dict_len\n            while right + word_len <= len(s):\n                if s[right] not in word_dict:\n                    word_num_len_dict[right] = 1\n                    word_num_len_dict_len_i += 1\n                else:\n                    word_num_len_dict[s[right]] -= 1\n                    if word_num_len_dict[s[right]] == 0:\n                        word_num_len_dict_len_i -= 1\n                    word_num_len_dict_len_i += 1\n                if word_num_len_dict_len_i == word_num_len:\n                    res.append(left)\n                left += word_len\n                right += word_len\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max element in the array\n        # 2. find the index of the max element\n        # 3. if the index is i, then the max element is the ith element\n        # 4. if the index is j, then the max element is the jth element\n        # 5. if the index is k, then the max element is the kth element\n        # 6. if the index is l, then the max element is the lth element\n        # 7. if the index is m, then the max element is the mth element\n        # 8. if the index is n, then the max element is the nth element\n        # 9. if the index is o, then the max element is the oth element\n        # 10. if the index is p, then the max element is the pth element\n        # 11. if the index is q, then the max element is the qth element\n        # 12. if the index is r, then the max element is the rth element\n        # 13. if the index is s, then the max element is the sth element\n        # 14. if the index is t, then the max element is the tth element\n        # 15. if the index is u, then the max element is the uth element\n        # 16. if the index is v, then the max element is the vth element\n        # 17. if the index is w, then the max element is the wth element\n        # 18. if the index is x, then the max element is the xth element\n        # 19. if the index is y, then the max element is the yth element\n        # 20. if the index is z, then the max element is the zth element\n        # 21. if the index is a, then the max element is the ath element\n        # 22. if the index is b, then the max element is the bth element\n        # 23. if the index is c, then the max element is the cth element\n        # 24. if the index is d, then the max element is the dth element\n        # 25. if the index is e, then the max element is the eth element\n        # 26. if the index is f, then the max element is the fth element\n        # 27. if the index is g, then the max element is the gth element\n        # 28. if the index is h, then the max element is the hth element\n        # 29. if the index is i, then the max element is the ith element\n        # 30. if the index is j, then the max element is the jth element\n        # 31. if the index is k, then the max element is the kth element\n        # 32. if the index is l, then the max element is the lth element\n        # 33. if the index is m, then the max element is the mth element\n        # 34. if the index is n, then the max element is the nth element\n        # 35. if the index is o, then the max element is the oth element\n        # 36. if the index is p, then the max element is the pth element\n        # 37. if the index is q, then the max element is the qth element\n        # 38. if the index is r, then the max element is the rth element\n        # 39. if the index is s, then the max element is the sth element\n        # 40. if the index is t, then the max element is the tth element\n        # 41. if the index is u, then the max element is the uth element\n        # 42. if the index is v, then the max element is the vth element\n        # 43. if the index is w, then the max element is the wth element\n        # 44. if the index is x, then the max element is the xth element\n        # 45. if the index is y, then the max element is the yth element\n        # 46. if the index is z, then the max element is the zth element\n        # 47. if the index is a, then the max element is the ath element\n        # 48. if the index is b, then the max element"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # 1. Find the sorted tail position\n        sorted_tail = head\n        curr = head.next\n        while curr and curr.next:\n            if curr.next.val < sorted_tail.val:\n                sorted_tail = sorted_tail.next\n                curr = curr.next\n            else:\n                break\n        \n        # 2. Use the sorted tail position to split the list\n        sorted_head = head\n        head = head.next\n        sorted_tail.next = None\n        \n        # 3. Insertion sort\n        curr = head\n        while curr:\n            next_node = curr.next\n            if curr.val < sorted_head.val:\n                curr.next = sorted_head\n                sorted_head = curr\n            else:\n                prev = sorted_head\n                while prev.next and prev.next.val < curr.val:\n                    prev = prev.next\n                curr.next = prev.next\n                prev.next = curr\n            curr = next_node\n        \n        return sorted_head"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        # 1. find the last node with the same value as head.next\n        # 2. set the next pointer of the last node to None\n        # 3. set the next pointer of head to the next pointer of the last node\n        # 4. return head\n        \n        # 1. find the last node with the same value as head.next\n        last_node = head\n        while last_node.next and last_node.next.val == head.next.val:\n            last_node = last_node.next\n        \n        # 2. set the next pointer of the last node to None\n        last_node.next = None\n        \n        # 3. set the next pointer of head to the next pointer of the last node\n        head = head.next\n        \n        # 4. return head\n        return head"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) < 3:\n            return []\n        \n        nums.sort()\n        res = []\n        if nums[0] <0 or nums[-1] > 0:\n            return res\n        \n        seen = {}\n        for i in range(len(nums)-2):\n            if nums[i] in seen:\n                seen[nums[i]] += 1\n            else:\n                seen[nums[i]] = 1\n        \n        for j in range(len(nums)-2):\n            if seen.get(-nums[j]-1) is not None:\n                res.append([-nums[j]-1, nums[j], nums[j+1])\n            seen[nums[j]] -= 1\n        \n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(word1) < len(word2):\n        #     return self.minDistance(word2, word1)\n        # if not word1:\n        #     return len(word2)\n        # if not word2:\n        #     return len(word1)\n        # if word1[0] == word2[0]:\n        #     return self.minDistance(word1[1:], word2[1:])\n        # return 1 + min(self.minDistance(word1[1:], word2), self.minDistance(word1, word2[1:]))\n        # return 1 + min(self.minDistance(word1[1:], word2[1:]), self.minDistance(word1, word2[1:]))\n        # return 1 + min(self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]))\n        # return 1 + min(self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]))\n        # return 1 + min(self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]))\n        # return 1 + min(self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]))\n        # return 1 + min(self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]))\n        # return 1 + min(self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1[1:], word2[1:]), self.minDistance(word1["}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # xor = x ^ y\n        # count = 0\n        # while xor:\n        #     count += xor & 1\n        #     xor >>= 1\n        # return count\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')\n        \n        # return bin(x ^ y).count('1')"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [str(root.val)]\n        if not root.left:\n            return [str(root.val) + '->' + p for p in self.binaryTreePaths(root.right)]\n        if not root.right:\n            return [p + '->' + str(root.val) for p in self.binaryTreePaths(root.left)]\n        return [p + '->' + q for p in self_binaryTreePaths(root.left) for q in self_binaryTreePaths(root.right)]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 66. 67. 68. 69. 70. 71. 72. 73. 74. 75. 76. 77. 78. 79. 80. 81. 82. 83. 84. 85. 86. 87. 88. 89. 90. 91. 92. 93. 94. 95. 96. 97. 98. 99. 100. 101. 102. 103. 104. 105. 106. 107. 108. 109. 110. 111. 112. 113. 114. 115. 116. 117. 118. 119. 120. 121. 122. 123. 124. 125. 126. 127. 128. 129. 130. 131. 132. 133. 134. 135. 136. 137. 138. 139. 140. 141. 142. 143. 144. 145. 146. 147. 148. 149. 150. 151. 152. 153. 154. 155. 156. 157. 158. 159. 160. 161. 162. 163. 164. 165. 166. 167. 168. 169. 170. 171. 172. 173. 174. 175. 176. 177. 178. 179. 180. 181. 182. 183. 184. 185. 186. 187. 188. 189. 190. 191. 192. 193. 194. 195. 196. 197. 198. 199. 200. 201. 202. 203. 204. 205. 206. 207. 208. 209. 210. 211. 212. 213. 214. 215. 216. 217. 218. 219. 220. 221. 222. 223. 224. 225. 2"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return True\n        # if sy == ty and sx < tx:\n        #     return True\n        # if sx == tx and sy == ty:\n        #     return True\n        # if sx > ty or sy > tx:\n        #     return False\n        # if sx == tx and sy < ty:\n        #     return"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        if len(v1) > len(v2):\n            v2 += [0] * (len(v1) - len(v2))\n        elif len(v1) < len(v2):\n            v1 += [0] * (len(v2) - len(v1))\n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(prices) < 2:\n        #     return 0\n        #\n        # min_price = prices[0]\n        # max_profit = 0\n        #\n        # for price in prices[1:]:\n        #     if price < min_price:\n        #         min_price = price\n        #     elif price - min_price > max_profit:\n        #         max_profit = price - min_price\n        #\n        # return max_profit\n\n        # if len(prices) < 2:\n        #     return 0\n        #\n        # min_price = prices[0]\n        # max_profit = 0\n        #\n        # for price in prices[1:]:\n        #     if price < min_price:\n        #         min_price = price\n        #     elif price - min_price > max_profit:\n        #         max_profit = price - min_price\n        #\n        # return max_profit\n\n        # if len(prices) < 2:\n        #     return 0\n        #\n        # min_price = prices[0]\n        # max_profit = 0\n        #\n        # for price in prices[1:]:\n        #     if price < min_price:\n        #         min_price = price\n        #     elif price - min_price > max_profit:\n        #         max_profit = price - min_price\n        #\n        # return max_profit\n\n        if len(prices) < 2:\n            return 0\n\n        min_price = prices[0]\n        max_profit = 0\n        max_profit_so_far = 0\n\n        for price in prices[1:]:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n                max_profit_so_far = max_profit\n            elif price - min_price == max_profit:\n                max_profit_so_far += price - min_price\n\n        return max_profit_so_far"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end time\n        courses.sort(key=lambda x: x[1])\n        # priority queue, max heap\n        pq = []\n        # total time\n        total = 0\n        # iterate over courses\n        for c in courses:\n            # if the course is longer than the time limit, we can't take it\n            if c[0] > duration:\n                # if the priority queue is empty, we can't take any course\n                if not pq:\n                    continue\n                # if the priority queue is not empty, and the top of the priority queue is larger than the course duration, we can't take it\n                if pq[0] > c[0]:\n                    continue\n                # if the top of the priority queue is larger than the course duration, we can take it\n                # pop the top of the priority queue\n                pq.pop()\n                # subtract the duration of the top of the priority queue from the total time\n                total -= pq[0]\n            # if the priority queue is empty, we can take the course\n            elif not pq:\n                pq.append(c[0])\n                total += c[0]\n            # if the priority queue is not empty, and the top of the priority queue is larger than the course duration, we can take it\n            elif pq[0] > c[0]:\n                pq.append(c[0])\n                total += c[0]\n            # if the top of the priority queue is larger than the course duration, we can take it\n            else:\n                # add the duration of the course to the total time\n                total += c[0]\n                # if the total time is larger than the time limit, we can't take any course\n                if total > duration:\n                    # pop the top of the priority queue\n                    pq.pop()\n                    # subtract the duration of the top of the priority queue from the total time\n                    total -= pq[0]\n                # if the total time is larger than the time limit, we can't take any course\n                elif total > duration:\n                    continue\n        # return the length of the priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the kth node from the end\n        kth = head\n        for _ in range(length - length % k):\n            kth = kth.next\n        \n        # reverse the first k nodes\n        prev = None\n        curr = head\n        for _ in range(k):\n            next_ = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_\n        \n        # recursively reverse the rest of the list\n        head.next = self.reverseKGroup(kth, length - length % k)\n        \n        # reverse the first k nodes\n        prev = None\n        curr = head\n        for _ in range(k):\n            next_ = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_\n        \n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 == 1:\n        #     return False\n        #\n        # if s in s + s[:len(s)//2]:\n        #     return True\n        #\n        # return False\n        \n        # return s in s + s[:len(s)//2]\n        \n        # return (s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) != -1\n        \n        # return s*2).find(s) !"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845\n        # 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 167"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR all the numbers in the array\n        # 2. XOR the result with itself\n        # 3. return the result\n        \n        # 1\n        result = 0\n        for num in nums:\n            result ^= num\n        return result"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict with the frequency of each letter in target\n        # 2. build a dict with the frequency of each letter in stickers\n        # 3. iterate through the dict with the frequency of each letter in target\n        # 4. if the letter is not in the dict, return -1\n        # 5. if the letter is in the dict, add the frequency to the dict\n        # 6. if the letter is in the dict, subtract the frequency from the dict\n        # 7. if the letter is in the dict, subtract the frequency from the dict\n        # 8. if the letter is in the dict, subtract the frequency from the dict\n        # 9. if the letter is in the dict, subtract the frequency from the dict\n        # 10. if the letter is in the dict, subtract the frequency from the dict\n        # 11. if the letter is in the dict, subtract the frequency from the dict\n        # 12. if the letter is in the dict, subtract the frequency from the dict\n        # 13. if the letter is in the dict, subtract the frequency from the dict\n        # 14. if the letter is in the dict, subtract the frequency from the dict\n        # 15. if the letter is in the dict, subtract the frequency from the dict\n        # 16. if the letter is in the dict, subtract the frequency from the dict\n        # 17. if the letter is in the dict, subtract the frequency from the dict\n        # 18. if the letter is in the dict, subtract the frequency from the dict\n        # 19. if the letter is in the dict, subtract the frequency from the dict\n        # 20. if the letter is in the dict, subtract the frequency from the dict\n        # 21. if the letter is in the dict, subtract the frequency from the dict\n        # 22. if the letter is in the dict, subtract the frequency from the dict\n        # 23. if the letter is in the dict, subtract the frequency from the dict\n        # 24. if the letter is in the dict, subtract the frequency from the dict\n        # 25. if the letter is in the dict, subtract the frequency from the dict\n        # 26. if the letter is in the dict, subtract the frequency from the dict\n        # 27. if the letter is in the dict, subtract the frequency from the dict\n        # 28. if the letter is in the dict, subtract the frequency from the dict\n        # 29. if the letter is in the dict, subtract the frequency from the dict\n        # 30. if the letter is in the dict, subtract the frequency from the dict\n        # 31. if the letter is in the dict, subtract the frequency from the dict\n        # 32. if the letter is in the dict, subtract the frequency from the dict\n        # 33. if the letter is in the dict, subtract the frequency from the dict\n        # 34. if the letter is in the dict, subtract the frequency from the dict\n        # 35. if the letter is in the dict, subtract the frequency from the dict\n        # 36. if the letter is in the dict, subtract the frequency from the dict\n        # 37. if the letter is in the dict, subtract the frequency from the dict\n        # 38. if the letter is in the dict, subtract the frequency from the dict\n        # 39. if the letter is in the dict, subtract the frequency from the dict\n        # 40. if the letter is in the dict, subtract the frequency from the dict\n        # 41. if the letter is in the dict, subtract the frequency from the dict\n        # 42. if the letter is in the dict, subtract the frequency from the dict\n        # 43. if the letter is in the dict, subtract the frequency from the dict\n        # 44. if the letter is in the dict, subtract the frequency from the dict\n        # 45. if the letter is in the dict, subtract the frequency from the dict\n        # 46. if the letter is in the dict, subtract the frequency from the dict\n        # 47. if the letter is in the dict, subtract the frequency from the dict\n        # 48. if the letter is in the"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] +1\n        # dp[i] = min(dp[j] + 1) if s[j] == s[i]\n        # dp[i] = min(dp[j] + dp[j+1] + 1) if s[j] != s[i]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + 1) if s[j] != s[i] and j+1] != i+1]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k] + 1) if s[j] != s[i] and j+k] < i+1]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k] + dp[j+k+1] + 1) if s[j] != s[i] and j+k] >= i+1]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k] + dp[j+k+1] + dp[j+k+2] + 1) if s[j] != s[i] and j+k] >= i+2]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k] + dp[j+k+1] + dp[j+k+2] + ... + dp[j+k+k] + 1) if s[j] != s[i] and j+k] >= i+k]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k] + dp[j+k+1] + dp[j+k+2] + ... + dp[j+k+k] + dp[j+k+k+1] + 1) if s[j] != s[i] and j+k] >= i+k+1]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k] + dp[j+k+1] + dp[j+k+2] + ... + dp[j+k+k] + dp[j+k+k+1] + dp[j+k+k+2] + 1) if s[j] != s[i] and j+k] >= i+k+2]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k] + dp[j+k+1] + dp[j+k+2] + ... + dp[j+k+k] + dp[j+k+k+1] + dp[j+k+k+2] + ... + dp[j+k+k+k] + 1) if s[j] != s[i] and j+k] >= i+k+k]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k] + dp[j+k+1] + dp[j+k+2] + ... + dp[j+k+k] + dp[j+k+k+1] + dp[j+k+k+2] + ... + dp[j+k+k+k] + dp[j+k+k+k+1] + 1) if s[j] != s[i] and j+k] >= i+k+k+1]\n        # dp[i] = min(dp[j] + dp[j+1] + dp[j+2] + ... + dp[j+k"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x < 3:\n            return x - 1\n        if x < 9:\n            return 2\n        if x < 49:\n            return 3\n        if x < 249:\n            return 4\n        if x < 1000:\n            return 5\n        if x < 4000:\n            return 6\n        if x < 10000:\n            return 7\n        if x < 40000:\n            return 8\n        if x < 100000:\n            return 9\n        if x < 400000:\n            return 10\n        if x < 1000000:\n            return 11\n        if x < 4000000:\n            return 12\n        if x < 10000000:\n            return 13\n        if x < 40000000:\n            return 14\n        if x < 100000000:\n            return 15\n        if x < 400000000:\n            return 16\n        if x < 1000000000:\n            return 17\n        if x < 4000000000:\n            return 18\n        if x < 10000000000:\n            return 19\n        if x < 40000000000:\n            return 20\n        if x < 100000000000:\n            return 21\n        if x < 400000000000:\n            return 22\n        if x < 1000000000000:\n            return 23\n        if x < 4000000000000:\n            return 24\n        if x < 10000000000000:\n            return 25\n        if x < 40000000000000:\n            return 26\n        if x < 100000000000000:\n            return 27\n        if x < 400000000000000:\n            return 28\n        if x < 1000000000000000:\n            return 29\n        if x < 4000000000000000:\n            return 30\n        if x < 10000000000000000:\n            return 31\n        if x < 40000000000000000:\n            return 32\n        if x < 100000000000000000:\n            return 33\n        if x < 400000000000000000:\n            return 34\n        if x < 1000000000000000000:\n            return 35\n        if x < 4000000000000000000:\n            return 36\n        if x < 10000000000000000000:\n            return 37\n        if x < 40000000000000000000:\n            return 38\n        if x < 100000000000000000000:\n            return 39\n        if x < 400000000000000000000:\n            return 40\n        if x < 1000000000000000000000:\n            return 41\n        if x < 4000000000000000000000:\n            return 42\n        if"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 400\n        # 500 - 100 = 400\n        # 100 - 50 = 90\n        # 50 - 10 = 40\n        # 10 - 5 = 9\n        # 5 - 1 = 4\n        # 1 - 0 = 1\n        # 0 - 0 = 0\n        # 1000 - 500 = 4"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## Time: O(n)\n        ## Space: O(n)\n        ## Hash table\n        ## return True if the element is already in the set\n        ## return False if the element is not in the set\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table\n        ## return False if the loop completes\n        ## return False if the loop completes\n        ## create a hash table\n        ## iterate through the list\n        ## if the element is already in the hash table, return True\n        ## otherwise, add the element to the hash table"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. use a deque to store the index of the max element in the window\n        # 2. when the window is full, pop the leftmost element if it is out of the window\n        # 3. when a new element is added, pop the leftmost element if it is smaller than the new element\n        # 4. the result is the rightmost element of the window\n        # 5. if the window is empty, the result is None\n        # 6. if the window is full, the result is the max element\n        # 7. if the window is empty, the result is None\n        # 8. if the window is full, the result is the max element\n        # 9. if the window is empty, the result is None\n        # 10. if the window is full, the result is the max element\n        # 11. if the window is empty, the result is None\n        # 12. if the window is full, the result is the max element\n        # 13. if the window is empty, the result is None\n        # 14. if the window is full, the result is the max element\n        # 15. if the window is empty, the result is None\n        # 16. if the window is full, the result is the max element\n        # 17. if the window is empty, the result is None\n        # 18. if the window is full, the result is the max element\n        # 19. if the window is empty, the result is None\n        # 20. if the window is full, the result is the max element\n        # 21. if the window is empty, the result is None\n        # 22. if the window is full, the result is the max element\n        # 23. if the window is empty, the result is None\n        # 24. if the window is full, the result is the max element\n        # 25. if the window is empty, the result is None\n        # 26. if the window is full, the result is the max element\n        # 27. if the window is empty, the result is None\n        # 28. if the window is full, the result is the max element\n        # 29. if the window is empty, the result is None\n        # 30. if the window is full, the result is the max element\n        # 31. if the window is empty, the result is None\n        # 32. if the window is full, the result is the max element\n        # 33. if the window is empty, the result is None\n        # 34. if the window is full, the result is the max element\n        # 35. if the window is empty, the result is None\n        # 36. if the window is full, the result is the max element\n        # 37. if the window is empty, the result is None\n        # 38. if the window is full, the result is the max element\n        # 39. if the window is empty, the result is None\n        # 40. if the window is full, the result is the max element\n        # 41. if the window is empty, the result is None\n        # 42. if the window is full, the result is the max element\n        # 43. if the window is empty, the result is None\n        # 44. if the window is full, the result is the max element\n        # 45. if the window is empty, the result is None\n        # 46. if the window is full, the result is the max element\n        # 47. if the window is empty, the result is None\n        # 48. if the window is full, the result is the max element\n        # 49. if the window is empty, the result is None\n        # 50. if the window is full, the result is the max element\n        # 51. if the window is empty, the result is None\n        # 52. if the window is full, the result is the max element\n        # 53. if the window is empty, the result is None\n        # 54. if the window is full, the result is the max element\n        # 55. if the window is empty, the result is None\n        # 56. if the window is full, the result is the max element\n        # 57."}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) < len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        #\n        # if len(nums1) == 0:\n        #     return 0\n        #\n        # if len(nums2) == 0:\n        #     return 0\n        #\n        # if len(nums1) == 1:\n        #     return nums1[0]\n        #\n        # if len(nums2) == 1:\n        #     return nums2[0]\n\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        if len(nums1) == 0:\n            return 0\n\n        if len(nums2) == 0:\n            return 0\n\n        if len(nums1) == 1:\n            return nums1[0]\n\n        if len(nums2) == 1:\n            return nums2[0]\n\n        if len(nums1) == 2:\n            return (nums1[0] + nums1[1]) / 2\n\n        if len(nums2) == 2:\n            return (nums2[0] + nums2[1]) / 2\n\n        if len(nums1) == 3:\n            return (nums1[0] + nums1[1] + nums1[2]) / 3\n\n        if len(nums2) == 3:\n            return (nums2[0] + nums2[1] + nums2[2]) / 3\n\n        if len(nums1) == 4:\n            return (nums1[0] + nums1[1] + nums1[2] + nums1[3]) / 4\n\n        if len(nums2) == 4:\n            return (nums2[0] + nums2[1] + nums2[2] + nums2[3]) / 4\n\n        if len(nums1) == 5:\n            return (nums1[0] + nums1[1] + nums1[2] + nums1[3] + nums1[4]) / 5\n\n        if len(nums2) == 5:\n            return (nums2[0] + nums2[1] + nums2[2] + nums2[3] + nums2[4]) / 5\n\n        if len(nums1) == 6:\n            return (nums1[0] + nums1[1] + nums1[2] + nums1[3] + nums1[4] + nums1[5]) / 6\n\n        if len(nums2) == 6:\n            return (nums2[0] + nums2[1] + nums2[2] + nums2[3] + nums2[4] + nums2[5]) / 6\n\n        if len(nums1) == 7:\n            return (nums1[0] + nums1[1] + nums1[2] + nums1[3] + nums1[4] + nums1[5] + nums1[6]) / 7\n\n        if len(nums2) == 7:\n            return (nums2[0] + nums2[1] + nums2[2] + nums2[3] + nums2[4] + nums2[5] + nums2[6]) / 7\n\n        if len(nums1) == 8:\n            return (nums1[0] + nums1[1] + nums1[2] + nums1[3] + nums1[4] + nums1[5] + nums1[6] + nums1[7]) / 8\n\n        if len(nums2) == 8:\n            return (nums2[0] + nums2[1] + nums2[2] + nums2[3] + nums2[4] + nums2[5] + nums2[6] + nums2[7]) / 8\n\n        if len(nums1) == 9:\n            return (nums"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[0] > nums[-2]:\n        #     return nums[-2]\n        # if nums[0] > nums[-3]:\n        #     return nums[-3]\n        # if nums[0] > nums[-4]:\n        #     return nums[-4]\n        # if nums[0] > nums[-5]:\n        #     return nums[-5]\n        # if nums[0] > nums[-6]:\n        #     return nums[-6]\n        # if nums[0] > nums[-7]:\n        #     return nums[-7]\n        # if nums[0] > nums[-8]:\n        #     return nums[-8]\n        # if nums[0] > nums[-9]:\n        #     return nums[-9]\n        # if nums[0] > nums[-10]:\n        #     return nums[-10]\n        # if nums[0] > nums[-11]:\n        #     return nums[-11]\n        # if nums[0] > nums[-12]:\n        #     return nums[-12]\n        # if nums[0] > nums[-13]:\n        #     return nums[-13]\n        # if nums[0] > nums[-14]:\n        #     return nums[-14]\n        # if nums[0] > nums[-15]:\n        #     return nums[-15]\n        # if nums[0] > nums[-16]:\n        #     return nums[-16]\n        # if nums[0] > nums[-17]:\n        #     return nums[-17]\n        # if nums[0] > nums[-18]:\n        #     return nums[-18]\n        # if nums[0] > nums[-19]:\n        #     return nums[-19]\n        # if nums[0] > nums[-20]:\n        #     return nums[-20]\n        # if nums[0] > nums[-21]:\n        #     return nums[-21]\n        # if nums[0] > nums[-22]:\n        #     return nums[-22]\n        # if nums[0] > nums[-23]:\n        #     return nums[-23]\n        # if nums[0] > nums[-24]:\n        #     return nums[-24]\n        # if nums[0] > nums[-25]:\n        #     return nums[-25]\n        # if nums[0] > nums[-26]:\n        #     return nums[-26]\n        # if nums[0] > nums[-27]:\n        #     return nums[-27]\n        # if nums[0] > nums[-28]:\n        #     return nums[-28]\n        # if nums[0] > nums[-29]:\n        #     return nums[-29]\n        # if nums[0] > nums[-30]:\n        #     return nums[-30]\n        # if nums[0] > nums[-31]:\n        #     return nums[-31]\n        # if nums[0] > nums[-32]:\n        #     return nums[-32]\n        # if nums[0] > nums[-33]:\n        #     return nums[-33]\n        # if nums[0] > nums[-34]:\n        #     return nums[-34]\n        # if nums[0] > nums[-35]:\n        #     return nums[-35]\n        # if nums[0] > nums[-36]:\n        #     return nums[-36]\n        # if nums[0] > nums[-37]:\n        #     return nums[-37]\n        # if nums[0] > nums[-38]:\n        #"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,868,1681,2640,2640,1681,868,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,441,1234,2432,3432,3432,2432,1234,441,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,495,1400,3003,4430,4430,3003,1400,495,100,16,1]\n        if rowIndex == 17:\n            return [1,17,111,569,1820,4032,7242,9292,9292,7242,4032,1820,569,111,17,1]\n        if rowIndex == 18:\n            return [1,18,122,676,2520,6224,12060,16060,16060,12060,6224,2520,676,122,18,1]\n        if rowIndex == 19:\n            return [1,19,133,765,2806,7158,12886,17170,17170,12886,7158,2806,765,133,19,1]\n        if rowIndex == 20:\n            return [1,20,144,822,3188,8462,15408,21408,21408,15408,8462,3188,822,144,20,1]\n        if rowIndex == 21:\n            return [1,21,15"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]\n        #     else:\n        #         return []\n        # if root.left is None:\n        #     return self.pathSum(root.right, targetSum - root.val)\n        # if root.right is None:\n        #     return self.pathSum(root.left, targetSum - root.val)\n        # return self.pathSum(root.left, targetSum - root.val) + self.pathSum(root.right, targetSum - root.val)\n        # if root is None:\n        #     return []\n        # if root.left is None and root.right is None:\n        #     if root.val == targetSum:\n        #         return [[targetSum]]"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * n = area\n        # 2. n^2 = area\n        # 3. n = sqrt(area)\n        # 4. n = area / sqrt(area)\n        # 5. n = area / n\n        # 6. n = area / (area / n)\n        # 7. n = area / (area / (area / n))\n        # 8. n = area / (area / (area / (area / n)))\n        # 9. n = area / (area / (area / (area / (area / n))))\n        # 10. n = area / (area / (area / (area / (area / (area / n)))))\n        # 11. n = area / (area / (area / (area / (area / (area / (area / n))))))\n        # 12. n = area / (area / (area / (area / (area / (area / (area / (area / n)))))))\n        # 13. n = area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))\n        # 14. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n)))))))))\n        # 15. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))))\n        # 16. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n)))))))))))\n        # 17. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))))))\n        # 18. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))))))))\n        # 19. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))))))))))\n        # 20. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))))))))))))\n        # 21. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))))))))))))))\n        # 22. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))))))))))))))))\n        # 23. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / n))))))))))))))))))))))))))\n        # 24. n = area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area / (area /"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a hashmap of the wordList\n        word_map = {}\n        for word in wordList:\n            if word not in word_map:\n                word_map[word] = 1\n            else:\n                word_map[word] += 1\n        \n        # build a hashmap of the next_words\n        next_words = {}\n        for word in word_map:\n            if word[0] not in next_words:\n                next_words[word[0]] = [word]\n            else:\n                next_words[word[0]] += [word]\n        \n        # build a hashmap of the prev_words\n        prev_words = {}\n        for word in word_map:\n            if word[1:] not in prev_words:\n                prev_words[word[1:] = [word]\n            else:\n                prev_words[word[1:] += [word]\n        \n        # build a queue of the next_words\n        queue = [beginWord]\n        level = 1\n        # build a hashmap of the level_words\n        level_words = {beginWord]\n        \n        # build a hashmap of the shortest_path\n        shortest_path = {}\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length = {}\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[beginWord] = 0\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[endWord] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length[None] = None\n        \n        # build a hashmap of the shortest_path_length\n        shortest_path_length"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        # if root is None:\n        #     return True\n        # return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return abs(self.height(root.left) - self.height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.isBalanced(root.left) and self.isBalanced(root.right)\n        \n        # if not root:\n        #     return True\n        # return self.is"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n & (n - 1) == 0:\n            return True\n        else:\n            return False"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the list\n        nums.sort()\n        # initialize the result list\n        result = [[]]\n        # initialize the index\n        i = 0\n        # iterate through the list\n        while i < len(nums):\n            # if the current number is the same as the previous number,\n            # add the previous number to the result list\n            if i == 0 or nums[i] != nums[i-1]:\n                # initialize the j\n                j = i\n                # iterate through the list\n                while j < len(nums) and nums[j] == nums[j-1]:\n                    j += 1\n                # add the sublist to the result list\n                result.append(nums[i:j])\n                # set i to j\n                i = j\n            # otherwise, add the current number to the result list\n            else:\n                result.append([nums[i]])\n                # set i to i+1\n                i += 1\n        # return the result list\n        return result"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u51fa\u6700\u5927\u503c\u7684\u7d22\u5f15\n        # 2. \u4ece\u6700\u5927\u503c\u7d22\u5f15\u5f00\u59cb\u5f80\u5de6\u627e\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5c0f\u7684\u503c\n        # 3. \u4ece\u6700\u5927\u503c\u7d22\u5f15\u5f00\u59cb\u5f80\u53f3\u627e\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5c0f\u7684\u503c\n        # 4. \u8ba1\u7b97\u9762\u79ef\n        # 5. \u66f4\u65b0\u6700\u5927\u503c\n        # 6. \u91cd\u590d\u6b65\u9aa42,3,4\n        # 7. \u8fd4\u56de\u6700\u5927\u9762\u79ef\n        # 8. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 9. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 10. \u4f7f\u7528\u5355\u8c03\u6808\n        # 11. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 12. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 13. \u4f7f\u7528\u5355\u8c03\u6808\n        # 14. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 15. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 16. \u4f7f\u7528\u5355\u8c03\u6808\n        # 17. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 18. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 19. \u4f7f\u7528\u5355\u8c03\u6808\n        # 20. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 21. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 22. \u4f7f\u7528\u5355\u8c03\u6808\n        # 23. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 24. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 25. \u4f7f\u7528\u5355\u8c03\u6808\n        # 26. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 27. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 28. \u4f7f\u7528\u5355\u8c03\u6808\n        # 29. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 30. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 31. \u4f7f\u7528\u5355\u8c03\u6808\n        # 32. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 33. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 34. \u4f7f\u7528\u5355\u8c03\u6808\n        # 35. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 36. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 37. \u4f7f\u7528\u5355\u8c03\u6808\n        # 38. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 39. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 40. \u4f7f\u7528\u5355\u8c03\u6808\n        # 41. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 42. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 43. \u4f7f\u7528\u5355\u8c03\u6808\n        # 44. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 45. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 46. \u4f7f\u7528\u5355\u8c03\u6808\n        # 47. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 48. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 49. \u4f7f\u7528\u5355\u8c03\u6808\n        # 50. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 51. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 52. \u4f7f\u7528\u5355\u8c03\u6808\n        # 53. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 54. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 55. \u4f7f\u7528\u5355\u8c03\u6808\n        # 56. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 57. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 58. \u4f7f\u7528\u5355\u8c03\u6808\n        # 59. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 60. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 61. \u4f7f\u7528\u5355\u8c03\u6808\n        # 62. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 63. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 64. \u4f7f\u7528\u5355\u8c03\u6808\n        # 65. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 66. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 67. \u4f7f\u7528\u5355\u8c03\u6808\n        # 68. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 69. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # 70. \u4f7f\u7528\u5355\u8c03\u6808\n        # 71. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # 72."}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a+b)\n                elif token == \"-\":\n                    stack.append(a-b)\n                elif token == \"*\":\n                    stack.append(a*b)\n                else:\n                    if a*b < 0:\n                        stack.append(abs(a)//abs(b))\n                    else:\n                        stack.append(a//b)\n            else:\n                stack.append(int(token))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the four corners with the smallest x and y\n        # 2. find the four corners with the largest x and y\n        # 3. find the area of the rectangle with the smallest x and largest y\n        # 4. find the area of the rectangle with the largest x and smallest y\n        # 5. find the area of the rectangle with the largest x and largest y\n        # 6. find the area of the rectangle with the smallest x and smallest y\n        # 7. if the sum of all the areas is equal to the area of the rectangle, return True\n        # 8. otherwise, return False\n        \n        # 1. find the four corners with the smallest x and y\n        x_min, y_min = float('inf'), float('inf')\n        x_max, y_max = -float('inf'), -float('inf')\n        for x, y in rectangles[0][:2]:\n            x_min, y_min = min(x_min, x), min(y_min, y)\n            x_max, y_max = max(x_max, x), max(y_max, y)\n        x_min, y_min = min(x_min, 0), min(y_min, 0)\n        x_max, y_max = max(x_max, 0), max(y_max, 0)\n        \n        # 2. find the four corners with the largest x and y\n        x_max, y_max = max(x_max, 1000000), max(y_max, 1000000)\n        x_min, y_min = min(x_min, -1000000), min(y_min, -1000000)\n        \n        # 3. find the area of the rectangle with the smallest x and largest y\n        area_smallest_x = (x_max - x_min) * (y_max - y_min)\n        \n        # 4. find the area of the rectangle with the largest x and smallest y\n        area_largest_x = (x_max - x_min) * (y_max - y_min)\n        \n        # 5. find the area of the rectangle with the largest x and largest y\n        area_largest_y = (x_max - x_min) * (y_max - y_min)\n        \n        # 6. find the area of the rectangle with the smallest x and smallest y\n        area_smallest_y = (x_max - x_min) * (y_max - y_min)\n        \n        # 7. if the sum of all the areas is equal to the area of the rectangle, return True\n        if area_smallest_x + area_largest_x + area_largest_y + area_smallest_y == area_smallest_x * 4:\n            return True\n        \n        # 8. otherwise, return False\n        return False"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        # 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\u7684\u516c\u5f0f\uff1a\n        #"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[0]\n        #"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 is the empty space\n        # 1,2,3,4,5 are the numbers in the puzzle\n        # 6 is the goal\n        # 7 is the goal's position\n        # 8 is the goal's position's position\n        # 9 is the goal's position's position's position\n        # 10 is the goal's position's position's position's position\n        # 11 is the goal's position's position's position's position's position\n        # 12 is the goal's position's position's position's position's position's position\n        # 13 is the goal's position's position's position's position's position's position's position\n        # 14 is the goal's position's position's position's position's position's position's position's position\n        # 15 is the goal's position's position's position's position's position's position's position's position's position\n        # 16 is the goal's position's position's position's position's position's position's position's position's position's position\n        # 17 is the goal's position's position's position's position's position's position's position's position's position's position's position\n        # 18 is the goal's position's position's position's position's position's position's position's position's position's position's position's position\n        # 19 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 20 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 21 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 22 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 23 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 24 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 25 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 26 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 27 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 28 is the goal's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position's position\n        # 29 is the goal's position's position's position's position's position's position's position's position's"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        d1, d2 = {}, {}\n        for i in range(len(s)):\n            if s[i] in d1:\n                if d1[s[i]] != t[i]:\n                    return False\n            else:\n                d1[s[i]] = t[i]\n                \n            if t[i] in d2:\n                if d2[t[i]] != s[i]:\n                    return False\n            else:\n                d2[t[i]] = s[i]\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the pivot is not found, the target is not in the array\n        if pivot == -1:\n            return target in nums\n        \n        # if the target is smaller than the first element, search the right side\n        if nums[pivot] < nums[0]:\n            # search the right side\n            return self.binary_search(nums[pivot:] , target)\n        # otherwise, search the left side\n        else:\n            # search the left side\n            return self.binary_search(nums[:pivot], target)\n        \n    def find_pivot(self, nums):\n        # find the pivot\n        left, right = 0, len(nums) - 1\n        if nums[left] > nums[right]:\n            # find the pivot\n            while left + 1 < right:\n                mid = (left + right) // 2\n                if nums[mid] > nums[mid + 1]:\n                    return mid\n                elif nums[mid] < nums[mid - 1]:\n                    return mid - 1\n                elif nums[mid] > nums[left]:\n                    left = mid\n                else:\n                    right = mid\n            # if the pivot is not found, return -1\n            if nums[left] > nums[right]:\n                return left\n            else:\n                return -1\n        else:\n            return -1\n        \n    def binary_search(self, nums, target):\n        # binary search\n        left, right = 0, len(nums) - 1\n        while left + 1 < right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid\n            else:\n                right = mid\n        # if the target is not found, return False\n        if nums[left] == target:\n            return True\n        else:\n            return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [0] * m\n        dp[0] = 1\n        for i in range(m):\n            if obstacleGrid[i][0] == 1:\n                dp = [0] * i\n            else:\n                for j in range(1, n):\n                    if obstacleGrid[i][j] == 1:\n                        dp[j] = 0\n                    else:\n                        dp[j] = dp[j - 1] + dp[j]\n        return dp[n - 1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        if len(s) == 2 and s[1] < '7':\n            return 2\n        if len(s) == 2 and s[1] > '7':\n            return 1\n        if len(s) == 3:\n            if s[1] == '7' and s[2] < '8':\n                return 2\n            elif s[1] == '7' and s[2] >= '8':\n                return 1\n            elif s[1] == '8' and s[2] < '0':\n                return 1\n            elif s[1] == '8' and s[2] >= '0':\n                return 2\n            elif s[1] == '9' and s[2] < '0':\n                return 1\n            elif s[1] == '9' and s[2] >= '0':\n                return 2\n        if len(s) > 2:\n            if s[1] == '0':\n                return 0\n            elif s[1] == '1':\n                if s[2] < '7':\n                    return 2\n                elif s[2] >= '7':\n                    return 1\n                elif s[2] == '8':\n                    if s[3] < '8':\n                        return 2\n                    elif s[3] >= '8':\n                        return 1\n                elif s[2] == '9':\n                    if s[3] < '9':\n                        return 2\n                    elif s[3] >= '9':\n                        return 1\n            elif s[1] == '2':\n                if s[2] < '7':\n                    return 2\n                elif s[2] >= '7':\n                    return 1\n                elif s[2] == '8':\n                    if s[3] < '8':\n                        return 2\n                    elif s[3] >= '8':\n                        return 1\n                elif s[2] == '9':\n                    if s[3] < '9':\n                        return 2\n                    elif s[3] >= '9':\n                        return 1\n            elif s[1] == '3':\n                if s[2] < '7':\n                    return 2\n                elif s[2] >= '7':\n                    return 1\n                elif s[2] == '8':\n                    if s[3] < '8':\n                        return 2\n                    elif s[3] >= '8':\n                        return 1\n                elif s[2] == '9':\n                    if s[3] < '9':\n                        return 2\n                    elif s[3] >= '9':\n                        return 1\n            elif s[1] == '4':\n                if s[2] < '7':\n                    return 2\n                elif s[2] >= '7':\n                    return 1\n                elif s[2] == '8':\n                    if s[3] < '8':\n                        return 2\n                    elif s[3] >= '8':\n                        return 1\n                elif s[2] == '9':\n                    if s[3] < '9':\n                        return 2\n                    elif s[3] >= '9':\n                        return 1\n            elif s[1] == '5':\n                if s[2] < '7':\n                    return 2\n                elif s[2] >= '7':\n                    return 1\n                elif s[2] == '8':\n                    if s[3] < '8':\n                        return 2\n                    elif s[3] >= '8':\n                        return 1\n                elif s[2] == '9':\n                    if s[3] < '9':\n                        return 2\n                    elif s[3] >= '9':\n                        return 1\n            elif s[1] == '6':\n                if s[2] < '7':\n                    return 2\n                elif s[2] >= '7':\n                    return 1\n                elif s[2] == '8':\n                    if s[3] < '8':\n                        return 2\n                    elif s[3] >= '8':\n                        return 1\n                elif s[2] == '9':\n                    if s[3] < '9':\n                        return 2\n                    elif s"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        l, r = 0, len(nums) - 1\n        while l < r:\n            if abs(nums[l] + nums[r] - target) < abs(closest - target):\n                closest = nums[l] + nums[r]\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                l += 1\n        if closest == target:\n            return closest\n        l, r = 0, len(nums) - 1\n        while l < r:\n            if abs(nums[l] + nums[r] - target) < abs(closest - target):\n                closest = nums[l] + nums[r]\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                l += 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        else:\n            # Your code here\n            return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        if not nums1:\n            return []\n        \n        d = {}\n        res = []\n        for n in nums1:\n            if n not in d:\n                d[n] = 0\n            d[n] += 1\n        \n        for n in nums2:\n            if n in d:\n                res.append(n)\n                d[n] -= 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # inorder traversal\n        # find the leftmost node and rightmost node\n        # return the difference between the two\n        # if the leftmost node is None, return the rightmost node\n        # if the rightmost node is None, return the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the two\n        # if the leftmost node is not None and the rightmost node is None, return the difference between the leftmost node and the rightmost node\n        # if the rightmost node is not None and the leftmost node is None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the leftmost node and the rightmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the rightmost node is not None and the leftmost node is not None, return the difference between the rightmost node and the leftmost node\n        # if the leftmost node is not None and the rightmost node"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        # find the most frequent number\n        most_freq, _ = self.find_most_freq(root)\n        \n        # find the number of nodes with the most frequent number\n        num_nodes_with_most_freq = self.find_num_nodes_with_most_freq(root, most_freq)\n        \n        # if the number of nodes with the most frequent number is 1,\n        # then the most frequent number is the mode\n        if num_nodes_with_most_freq == 1:\n            return [most_freq]\n        \n        # find the number of nodes with the second most frequent number\n        second_most_freq, _ = self.find_second_most_freq(root, most_freq)\n        \n        # if the number of nodes with the second most frequent number is 1,\n        # then the second most frequent number is the mode\n        if second_most_freq == 1:\n            return [second_most_freq]\n        \n        # find the number of nodes with the third most frequent number\n        third_most_freq, _ = self.find_third_most_freq(root, most_freq, second_most_freq)\n        \n        # if the number of nodes with the third most frequent number is 1,\n        # then the third most frequent number is the mode\n        if third_most_freq == 1:\n            return [third_most_freq]\n        \n        # if the number of nodes with the third most frequent number is 2,\n        # then the third most frequent number is the mode\n        return [third_most_freq, second_most_freq]\n        \n    def find_most_freq(self, root):\n        most_freq, most_freq_count = None, 0\n        most_freq_node = root\n        \n        while most_freq_node:\n            if most_freq_count == 0:\n                most_freq = most_freq_node.val\n                most_freq_count = 1\n            elif most_freq_node.val == most_freq:\n                most_freq_count += 1\n            elif most_freq_node.val > most_freq:\n                most_freq = most_freq_node.val\n                most_freq_count = 1\n            most_freq_node = most_freq_node.left\n        \n        return most_freq, most_freq_count\n    \n    def find_num_nodes_with_most_freq(self, root, most_freq):\n        num_nodes_with_most_freq = 0\n        most_freq_node = root\n        \n        while most_freq_node:\n            if most_freq_node.val == most_freq:\n                num_nodes_with_most_freq += 1\n            most_freq_node = most_freq_node.left\n        \n        return num_nodes_with_most_freq\n    \n    def find_second_most_freq(self, root, most_freq):\n        second_most_freq, second_most_freq_count = None, 0\n        second_most_freq_node = root\n        \n        while second_most_freq_node:\n            if second_most_freq_node.val == most_freq:\n                second_most_freq_count += 1\n            elif second_most_freq_node.val > second_most_freq:\n                second_most_freq = second_most_freq_node.val\n                second_most_freq_count = 1\n            second_most_freq_node = second_most_freq_node.left\n        \n        return second_most_freq, second_most_freq_count\n    \n    def find_third_most_freq(self, root, most_freq, second_most_freq):\n        third_most_freq, third_most_freq_count = None, 0\n        third_most_freq_node = root\n        \n        while third_most_freq_node:\n            if third_most_freq_node.val == most_freq:\n                third_most_freq_count"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        if needle not in haystack:\n            return -1\n        \n        if needle in haystack:\n            return haystack.find(needle)\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is too short\n        # 2. check if password contains at least 1 lowercase, 1 uppercase, 1 digit\n        # 3. check if password contains 3 repeating characters in a row\n        # 4. check if password contains 2 repeating characters in a row\n        # 5. check if password contains 1 repeating character\n        # 6. check if password contains 0 repeating characters\n        # 7. check if password contains 1 repeating character\n        # 8. check if password contains 0 repeating characters\n        # 9. check if password contains 1 repeating character\n        # 10. check if password contains 0 repeating characters\n        # 11. check if password contains 1 repeating character\n        # 12. check if password contains 0 repeating characters\n        # 13. check if password contains 1 repeating character\n        # 14. check if password contains 0 repeating characters\n        # 15. check if password contains 1 repeating character\n        # 16. check if password contains 0 repeating characters\n        # 17. check if password contains 1 repeating character\n        # 18. check if password contains 0 repeating characters\n        # 19. check if password contains 1 repeating character\n        # 20. check if password contains 0 repeating characters\n        # 21. check if password contains 1 repeating character\n        # 22. check if password contains 0 repeating characters\n        # 23. check if password contains 1 repeating character\n        # 24. check if password contains 0 repeating characters\n        # 25. check if password contains 1 repeating character\n        # 26. check if password contains 0 repeating characters\n        # 27. check if password contains 1 repeating character\n        # 28. check if password contains 0 repeating characters\n        # 29. check if password contains 1 repeating character\n        # 30. check if password contains 0 repeating characters\n        # 31. check if password contains 1 repeating character\n        # 32. check if password contains 0 repeating characters\n        # 33. check if password contains 1 repeating character\n        # 34. check if password contains 0 repeating characters\n        # 35. check if password contains 1 repeating character\n        # 36. check if password contains 0 repeating characters\n        # 37. check if password contains 1 repeating character\n        # 38. check if password contains 0 repeating characters\n        # 39. check if password contains 1 repeating character\n        # 40. check if password contains 0 repeating characters\n        # 41. check if password contains 1 repeating character\n        # 42. check if password contains 0 repeating characters\n        # 43. check if password contains 1 repeating character\n        # 44. check if password contains 0 repeating characters\n        # 45. check if password contains 1 repeating character\n        # 46. check if password contains 0 repeating characters\n        # 47. check if password contains 1 repeating character\n        # 48. check if password contains 0 repeating characters\n        # 49. check if password contains 1 repeating character\n        # 50. check if password contains 0 repeating characters\n        # 51. check if password contains 1 repeating character\n        # 52. check if password contains 0 repeating characters\n        # 53. check if password contains 1 repeating character\n        # 54. check if password contains 0 repeating characters\n        # 55. check if password contains 1 repeating character\n        # 56. check if password contains 0 repeating characters\n        # 57. check if password contains 1 repeating character\n        # 58. check if password contains 0 repeating characters\n        # 59. check if password contains 1 repeating character\n        # 60. check if password contains 0 repeating characters\n        # 61. check if password contains 1 repeating character\n        # 62. check if password contains 0 repeating characters\n        # 63. check if password contains 1 repeating character\n        # 64. check if password contains 0 repeating characters\n        # 65. check if password contains 1 repeating character\n        # 66. check if password contains 0 repeating characters\n        # 67. check if password contains 1 repeating character\n        # 68. check if password contains 0 repeating"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 10 = 2 * 5\n        # 20 = 2 * 2 * 5\n        # 30 = 3 * 5\n        # 40 = 2 * 2 * 2 * 5\n        # 50 = 5 * 5\n        # 60 = 2 * 3 * 5\n        # 70 = 2 * 2 * 2 * 2 * 5\n        # 80 = 2 * 2 * 2 * 2 * 2 * 5\n        # 90 = 2 * 5 * 5\n        # 100 = 2 * 2 * 5 * 5\n        # 110 = 10 * 5\n        # 120 = 2 * 2 * 5 * 5\n        # 130 = 2 * 3 * 5 * 5\n        # 140 = 2 * 2 * 2 * 5 * 5\n        # 150 = 2 * 5 * 5 * 5\n        # 160 = 2 * 2 * 2 * 2 * 5 * 5\n        # 170 = 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 180 = 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 190 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 200 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 210 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 220 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 230 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 240 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 250 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 260 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 270 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 280 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 290 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 300 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 310 = 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5\n        # 320 = 2 *"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        idx = 0\n        step = 1\n        \n        for c in s:\n            res[idx] += c\n            if idx == 0:\n                step = 1\n            elif idx == numRows - 1:\n                step = -1\n            idx += step\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # left_max, right_max = 0, 0\n        # left, right = 0, len(height) - 1\n        # ans = 0\n        # while left < right:\n        #     if height[left] < height[right]:\n        #         if height[left] > left_max:\n        #             left_max = height[left]\n        #         else:\n        #             ans += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         if height[right] > right_max:\n        #             right_max = height[right]\n        #         else:\n        #             ans += right_max - height[right]\n        #         right -= 1\n        # return ans\n        \n        # left_max, right_max = 0, 0\n        # left, right = 0, len(height) - 1\n        # ans = 0\n        # while left < right:\n        #     if height[left] < height[right]:\n        #         if height[left] > left_max:\n        #             left_max = height[left]\n        #         else:\n        #             ans += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         if height[right] > right_max:\n        #             right_max = height[right]\n        #         else:\n        #             ans += right_max - height[right]\n        #         right -= 1\n        # return ans\n        \n        # left_max, right_max = 0, 0\n        # left, right = 0, len(height) - 1\n        # ans = 0\n        # while left < right:\n        #     if height[left] < height[right]:\n        #         if height[left] > left_max:\n        #             left_max = height[left]\n        #         else:\n        #             ans += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         if height[right] > right_max:\n        #             right_max = height[right]\n        #         else:\n        #             ans += right_max - height[right]\n        #         right -= 1\n        # return ans\n        \n        # left_max, right_max = 0, 0\n        # left, right = 0, len(height) - 1\n        # ans = 0\n        # while left < right:\n        #     if height[left] < height[right]:\n        #         if height[left] > left_max:\n        #             left_max = height[left]\n        #         else:\n        #             ans += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         if height[right] > right_max:\n        #             right_max = height[right]\n        #         else:\n        #             ans += right_max - height[right]\n        #         right -= 1\n        # return ans\n        \n        # left_max, right_max = 0, 0\n        # left, right = 0, len(height) - 1\n        # ans = 0\n        # while left < right:\n        #     if height[left] < height[right]:\n        #         if height[left] > left_max:\n        #             left_max = height[left]\n        #         else:\n        #             ans += left_max - height[left]\n        #         left += 1\n        #     else:\n        #         if height[right] > right_max:\n        #             right_max = height[right]\n        #         else:\n        #             ans += right_max - height[right]\n        #         right -= 1\n        # return ans\n        \n        # left_max, right_max = 0, 0\n        # left, right = 0, len(height) - 1\n        # ans = 0\n        # while left < right:\n        #     if height[left] < height[right]:\n        #         if height[left] > left_max:\n        #             left_max = height[left]\n        #         else:\n        #             ans += left_max - height[left]\n        #"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ## 1. use the array as a hash table\n        ## 2. iterate the array and mark the index as negative\n        ## 3. iterate the array again and collect the positive indices\n        ## 4. return the list\n        \n        ##"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array in reverse order\n        # 2. use binary search to find the position of each element in the sorted array\n        # 3. use a hashmap to store the number of smaller elements to the right of each element\n        # 4. iterate through the array in reverse order and update the hashmap\n        # 5. return the hashmap\n        \n        # 1. sort the array in reverse order\n        sorted_nums = sorted(nums)[::-1]\n        \n        # 2. use binary search to find the position of each element in the sorted array\n        # 3. use a hashmap to store the number of smaller elements to the right of each element\n        # 4. iterate through the array in reverse order and update the hashmap\n        # 5. return the hashmap\n        \n        # 2. use binary search to find the position of each element in the sorted array\n        # 3. use a hashmap to store the number of smaller elements to the right of each element\n        # 4. iterate through the array in reverse order and update the hashmap\n        # 5. return the hashmap\n        \n        # 3. use a hashmap to store the number of smaller elements to the right of each element\n        # 4. iterate through the array in reverse order and update the hashmap\n        # 5. return the hashmap\n        \n        # 4. iterate through the array in reverse order and update the hashmap\n        # 5. return the hashmap\n        \n        # 5. return the hashmap\n        \n        # 6. return the hashmap\n        \n        # 7. return the hashmap\n        \n        # 8. return the hashmap\n        \n        # 9. return the hashmap\n        \n        # 10. return the hashmap\n        \n        # 11. return the hashmap\n        \n        # 12. return the hashmap\n        \n        # 13. return the hashmap\n        \n        # 14. return the hashmap\n        \n        # 15. return the hashmap\n        \n        # 16. return the hashmap\n        \n        # 17. return the hashmap\n        \n        # 18. return the hashmap\n        \n        # 19. return the hashmap\n        \n        # 20. return the hashmap\n        \n        # 21. return the hashmap\n        \n        # 22. return the hashmap\n        \n        # 23. return the hashmap\n        \n        # 24. return the hashmap\n        \n        # 25. return the hashmap\n        \n        # 26. return the hashmap\n        \n        # 27. return the hashmap\n        \n        # 28. return the hashmap\n        \n        # 29. return the hashmap\n        \n        # 30. return the hashmap\n        \n        # 31. return the hashmap\n        \n        # 32. return the hashmap\n        \n        # 33. return the hashmap\n        \n        # 34. return the hashmap\n        \n        # 35. return the hashmap\n        \n        # 36. return the hashmap\n        \n        # 37. return the hashmap\n        \n        # 38. return the hashmap\n        \n        # 39. return the hashmap\n        \n        # 40. return the hashmap\n        \n        # 41. return the hashmap\n        \n        # 42. return the hashmap\n        \n        # 43. return the hashmap\n        \n        # 44. return the hashmap\n        \n        # 45. return the hashmap\n        \n        # 46. return the hashmap\n        \n        # 47. return the hashmap\n        \n        # 48. return the hashmap\n        \n        # 49. return the hashmap\n        \n        # 50. return the hashmap\n        \n        # 51. return the hashmap\n        \n        # 52. return the hashmap\n        \n        # 53. return the hashmap\n        \n        # 54. return the hashmap\n        \n        # 55. return the hashmap\n        \n        # 56. return the hashmap\n        \n        # 5"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        # sort by start\n        intervals.sort(key=lambda x: x[0])\n        # ans\n        ans = 0\n        # end_max\n        end_max = -1\n        # i\n        i = 0\n        # l\n        l = len(intervals)\n        # r\n        r = l - 1\n        # j\n        j = l - 1\n        # k\n        k = 0\n        # m\n        m = l - 1\n        # n\n        n = l - 1\n        # p\n        p = l - 1\n        # q\n        q = l - 1\n        # r\n        r = l - 1\n        # s\n        s = l - 1\n        # t\n        t = l - 1\n        # u\n        u = l - 1\n        # v\n        v = l - 1\n        # w\n        w = l - 1\n        # x\n        x = l - 1\n        # y\n        y = l - 1\n        # z\n        z = l - 1\n        # A\n        A = l - 1\n        # B\n        B = l - 1\n        # C\n        C = l - 1\n        # D\n        D = l - 1\n        # E\n        E = l - 1\n        # F\n        F = l - 1\n        # G\n        G = l - 1\n        # H\n        H = l - 1\n        # I\n        I = l - 1\n        # J\n        J = l - 1\n        # K\n        K = l - 1\n        # L\n        L = l - 1\n        # M\n        M = l - 1\n        # N\n        N = l - 1\n        # O\n        O = l - 1\n        # P\n        P = l - 1\n        # Q\n        Q = l - 1\n        # R\n        R = l - 1\n        # S\n        S = l - 1\n        # T\n        T = l - 1\n        # U\n        U = l - 1\n        # V\n        V = l - 1\n        # W\n        W = l - 1\n        # X\n        X = l - 1\n        # Y\n        Y = l - 1\n        # Z\n        Z = l - 1\n        # a\n        a = l - 1\n        # b\n        b = l - 1\n        # c\n        c = l - 1\n        # d\n        d = l - 1\n        # e\n        e = l - 1\n        # f\n        f = l - 1\n        # g\n        g = l - 1\n        # h\n        h = l - 1\n        # i\n        i = l - 1\n        # j\n        j = l - 1\n        # k\n        k = l - 1\n        # l\n        l = l - 1\n        # m\n        m = l - 1\n        # n\n        n = l - 1\n        # o\n        o = l - 1\n        # p\n        p = l - 1\n        # q\n        q = l - 1\n        # r\n        r = l - 1\n        # s\n        s = l - 1\n        # t\n        t = l - 1\n        # u\n        u = l - 1\n        # v\n        v = l - 1\n        # w\n        w = l - 1\n        # x\n        x = l - 1\n        # y\n        y = l - 1\n        # z\n        z = l - 1\n        # A\n        A = l - 1\n        # B\n        B = l - 1\n        # C\n        C = l - 1\n        # D\n        D = l - 1\n        # E\n        E = l - 1\n        # F\n        F = l - 1\n        # G\n        G = l - 1\n        # H\n        H = l - 1\n        # I\n        I = l - 1\n        # J\n        J = l - 1\n        #"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return True\n        return self.isMirror(root.left, root.right)\n    \n    def isMirror(self, left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \u5148\u628a\u539f\u6765\u7684\u62ec\u53f7\u5206\u79bb\u51fa\u6765\n        # 2. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u5206\u79bb\u51fa\u6765\n        # 3. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 4. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 5. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 6. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 7. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 8. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 9. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 10. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 11. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 12. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 13. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 14. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 15. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 16. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 17. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 18. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 19. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 20. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 21. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 22. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 23. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 24. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 25. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 26. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 27. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 28. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 29. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 30. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 31. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 32. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 33. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 34. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 35. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 36. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 37. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 38. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 39. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 40. \u628a\u539f\u6765\u7684\u62ec\u53f7\u4e2d\u7684\u539f\u5b50\u6309\u7167\u539f\u5b50\u4e2a\u6570\u7684\u5012\u5e8f\u6392\u5217\n        # 41. \u628a\u539f"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        stack, res = [root], []\n        while stack:\n            node = stack.pop()\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n            res.append(node.val)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        if n == 2:\n            return ['()()','(())']\n        res = ['()']\n        res += ['(' + x + ')' for x in res]\n        res += [x + y for x in res for y in self.generateParenthesis(n-2)]\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # initialize the missing number as 1\n        missing_num = 1\n        # initialize the index of nums\n        i = 0\n        # initialize the number of patches\n        patches = 0\n        # loop until the missing number is greater than n\n        while missing_num <= n:\n            # if the index of nums is less than the length of nums\n            if i < len(nums) and nums[i] < missing_num:\n                # add the missing number to the missing number\n                missing_num += nums[i]\n                # add 1 to the number of patches\n                patches += 1\n            # otherwise, if the index of nums is greater than the length of nums\n            else:\n                # add the missing number to the missing number\n                missing_num += missing_num\n                # add 1 to the number of patches\n                patches += 1\n            # add 1 to the index of nums\n            i += 1\n        # return the number of patches\n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \u7528\u4e00\u4e2a\u6808\u6765\u8bb0\u5f55\u5de6\u62ec\u53f7\u7684\u4e0b\u6807\n        ## 2. \u5982\u679c\u9047\u5230\u53f3\u62ec\u53f7\uff0c\u5982\u679c\u6808\u4e3a\u7a7a\uff0c\u5219\u5c06\u5f53\u524d\u4e0b\u6807\u5165\u6808\n        ## 3. \u5982\u679c\u6808\u4e0d\u4e3a\u7a7a\uff0c\u5219\u5c06\u6808\u9876\u5143\u7d20\u51fa\u6808\uff0c\u5e76\u66f4\u65b0\u6700\u5927\u957f\u5ea6\n        ## 4. \u5982\u679c\u6808\u4e3a\u7a7a\uff0c\u5219\u5c06\u5f53\u524d\u4e0b\u6807\u5165\u6808\n        ## 5. \u6700\u540e\u8fd4\u56de\u6700\u5927\u957f\u5ea6\n        ## 6. \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        ## 7. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 8. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 9. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 10. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 11. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 12. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 13. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 14. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 15. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 16. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 17. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 18. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 19. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 20. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 21. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 22. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 23. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 24. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 25. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 26. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 27. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 28. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 29. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 30. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 31. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 32. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 33. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 34. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 35. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 36. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 37. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 38. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 39. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 40. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 41. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 42. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 43. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 44. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 45. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 46. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 47. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 48. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 49. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 50. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 51. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 52. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927\u957f\u5ea6\n        ## 53. \u7528\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u5f53\u524d\u7684\u6700\u5927"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        if numerator == 0:\n            return \"0\"\n        \n        res = \"\"\n        if (numerator < 0) ^ (denominator < 0):\n            res += \"-\"\n        numerator, denominator = abs(numerator), abs(denominator)\n        res += str(numerator // denominator)\n        numerator %= denominator\n        if numerator == 0:\n            return res\n        res += \".\"\n        seen = {}\n        seen[numerator] = len(res)\n        while numerator:\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n            if numerator in seen:\n                res = res[:seen[numerator]] + \"(\" + res[seen[numerator]:\n                break\n            seen[numerator] = len(res)\n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # find the middle of the list\n        # reverse the second half\n        # merge the two lists\n        # return the head\n        \n        # find the middle of the list\n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        # slow is the middle\n        # fast is the head\n        prev = None\n        curr = slow\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # merge the two lists\n        # slow is the head\n        # fast is the middle\n        slow = prev\n        fast = head\n        while fast != slow:\n            # slow is the head\n            # fast is the middle\n            slow = slow.next\n            # fast is the head\n            fast = fast.next\n        \n        # return the head\n        return slow\n        \n    def merge(self, l1, l2):\n        # l1 is the head\n        # l2 is the middle\n        # return the head\n        \n        # merge the two lists\n        # l1 is the head\n        # l2 is the middle\n        # prev is the head\n        # curr is the head\n        prev = None\n        curr = l1\n        while curr:\n            # l1 is the head\n            # l2 is the middle\n            # prev is the head\n            # curr is the head\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # return the head\n        return prev\n        \n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # find the middle of the list\n        # reverse the second half\n        # merge the two lists\n        # return the head\n        \n        # find the middle of the list\n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        # slow is the middle\n        # fast is the head\n        prev = None\n        curr = slow\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # merge the two lists\n        # slow is the head\n        # fast is the middle\n        slow = prev\n        fast = head\n        while fast != slow:\n            # slow is the head\n            # fast is the middle\n            slow = slow.next\n            # fast is the head\n            fast = fast.next\n        \n        # return the head\n        return slow\n        \n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # find the middle of the list\n        # reverse the second half\n        # merge the two lists\n        # return the head\n        \n        # find the middle of the list\n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        # slow is the middle\n        # fast is the head\n        prev = None\n        curr = slow\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        \n        # merge the two lists\n        # slow is the head\n        # fast is the middle\n        slow = prev\n        fast = head\n        while fast != slow:\n            # slow is the head\n            # fast is the middle\n            slow = slow.next\n            # fast is the head\n            fast = fast.next\n        \n        # return the head\n        return slow"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by width, then height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        # find longest increasing subsequence\n        # O(nlogn)\n        # use binary search to find the position of the current height\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find the position of the current width\n        # O(logn)\n        # use binary search to find"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols again and set the matrix to 0\n        \n        ## 1. mark the rows and cols that need to be set to 0\n        ## 2. iterate over the matrix again and set the rows and cols to 0\n        ## 3. iterate over the rows and cols"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the node to be removed\n        if length - n == 0:\n            return head.next\n        elif length - n < 0:\n            return head\n        else:\n            # find the node to be removed\n            curr = head\n            for i in range(length - n - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n            return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersection(nums2, nums1)\n        \n        res = set()\n        m = {}\n        for n in nums1:\n            if n not in m:\n                m[n] = 1\n            else:\n                m[n] += 1\n        \n        for n in nums2:\n            if n in m:\n                res.add(n)\n        \n        return list(res)"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines) % n:\n            return -1\n        target = sum(machines) // n\n        ans = left = 0\n        # \u5982\u679c\u6709\u591a\u4e2atarget\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5c0f\u7684target\n        # \u5982\u679ctarget\u662f0\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f1\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f2\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f3\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f4\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f5\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f6\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f7\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f8\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f9\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f10\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f11\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f12\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f13\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f14\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f15\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f16\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f17\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f18\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f19\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f20\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f21\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f22\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f23\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f24\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f25\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f26\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f27\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f28\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f29\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f30\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f31\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f32\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f33\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f34\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f35\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f36\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f37\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f38\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f39\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f40\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f41\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f42\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f43\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f44\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f45\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f46\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f47\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f48\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f49\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f50\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f51\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f52\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f53\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f54\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f55\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f56\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f57\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f58\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f59\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget\u662f60\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u627e\u5230\u6700\u5927\u7684target\n        # \u5982\u679ctarget"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # if k is 1, return 1\n        if k == 1:\n            return 1\n        \n        # if k is larger than m*n, return m*n\n        if k > m*n:\n            return m*n\n        \n        # if k is larger than m, return m\n        if k > m:\n            return m\n        \n        # if k is larger than n, return n\n        if k > n:\n            return n\n        \n        # if k is larger than m*n/2, return m*n/2\n        if k > m*n/2:\n            return m*n/2\n        \n        # if k is larger than m*n/4, return m*n/4\n        if k > m*n/4:\n            return m*n/4\n        \n        # if k is larger than m*n/8, return m*n/8\n        if k > m*n/8:\n            return m*n/8\n        \n        # if k is larger than m*n/16, return m*n/16\n        if k > m*n/16:\n            return m*n/16\n        \n        # if k is larger than m*n/32, return m*n/32\n        if k > m*n/32:\n            return m*n/32\n        \n        # if k is larger than m*n/64, return m*n/64\n        if k > m*n/64:\n            return m*n/64\n        \n        # if k is larger than m*n/128, return m*n/128\n        if k > m*n/128:\n            return m*n/128\n        \n        # if k is larger than m*n/256, return m*n/256\n        if k > m*n/256:\n            return m*n/256\n        \n        # if k is larger than m*n/512, return m*n/512\n        if k > m*n/512:\n            return m*n/512\n        \n        # if k is larger than m*n/1024, return m*n/1024\n        if k > m*n/1024:\n            return m*n/1024\n        \n        # if k is larger than m*n/2048, return m*n/2048\n        if k > m*n/2048:\n            return m*n/2048\n        \n        # if k is larger than m*n/4096, return m*n/4096\n        if k > m*n/4096:\n            return m*n/4096\n        \n        # if k is larger than m*n/8192, return m*n/8192\n        if k > m*n/8192:\n            return m*n/8192\n        \n        # if k is larger than m*n/16384, return m*n/16384\n        if k > m*n/16384:\n            return m*n/16384\n        \n        # if k is larger than m*n/32768, return m*n/32768\n        if k > m*n/32768:\n            return m*n/32768\n        \n        # if k is larger than m*n/65536, return m*n/65536\n        if k > m*n/65536:\n            return m*n/65536\n        \n        # if k is larger than m*n/131072, return m*n/131072\n        if k > m*n/131072:\n            return m*n/131072\n        \n        # if k is larger than m*n/262144, return m*n/262144\n        if k > m*n/262144:\n            return m*n/262144\n        \n        # if k is"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the middle of the list\n        slow = head\n        fast = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        # break the list into two parts\n        prev.next = None\n        \n        # recursively build the right subtree\n        right = self.sortedListToBST(slow)\n        \n        # recursively build the left subtree\n        left = self.sortedListToBST(head)\n        \n        # return the root node\n        root = TreeNode(slow.val)\n        root.left = left\n        root.right = right\n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        p = head\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                p.next = list1\n                list1 = list1.next\n            else:\n                p.next = list2\n                list2 = list2.next\n            p = p.next\n        \n        if list1:\n            p.next = list1\n        elif list2:\n            p.next = list2\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9ad8\u5ea6\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 5. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 6. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 7. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 8. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 9. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 10. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 11. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 12. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 13. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 14. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 15. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 16. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 17. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 18. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 19. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 20. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 21. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 22. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 23. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 24. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 25. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 26. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 27. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 28. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 29. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 30. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 31. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 32. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 33. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 34. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 35. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 36. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 37. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 38. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 39. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 40. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 41. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 42. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 43. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 44. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 45. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 46. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 47. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 48. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 49. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 50. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 51. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 52. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 53. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 54. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 55. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 56. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 57. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 58. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 59. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 60. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 61. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 62. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 63. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 64. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 65. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 66. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 67. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 68. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 69. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 70. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 71. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 72. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 73. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 74. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 75. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 76. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 77. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 78. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 79."}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. 2**n - 1\n        # 2. 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        # if nums[0] > nums[-2]:\n        #     return nums[-2]\n        # if nums[0] > nums[-3]:\n        #     return nums[-3]\n        # if nums[0] > nums[-4]:\n        #     return nums[-4]\n        # if nums[0] > nums[-5]:\n        #     return nums[-5]\n        # if nums[0] > nums[-6]:\n        #     return nums[-6]\n        # if nums[0] > nums[-7]:\n        #     return nums[-7]\n        # if nums[0] > nums[-8]:\n        #     return nums[-8]\n        # if nums[0] > nums[-9]:\n        #     return nums[-9]\n        # if nums[0] > nums[-10]:\n        #     return nums[-10]\n        # if nums[0] > nums[-11]:\n        #     return nums[-11]\n        # if nums[0] > nums[-12]:\n        #     return nums[-12]\n        # if nums[0] > nums[-13]:\n        #     return nums[-13]\n        # if nums[0] > nums[-14]:\n        #     return nums[-14]\n        # if nums[0] > nums[-15]:\n        #     return nums[-15]\n        # if nums[0] > nums[-16]:\n        #     return nums[-16]\n        # if nums[0] > nums[-17]:\n        #     return nums[-17]\n        # if nums[0] > nums[-18]:\n        #     return nums[-18]\n        # if nums[0] > nums[-19]:\n        #     return nums[-19]\n        # if nums[0] > nums[-20]:\n        #     return nums[-20]\n        # if nums[0] > nums[-21]:\n        #     return nums[-21]\n        # if nums[0] > nums[-22]:\n        #     return nums[-22]\n        # if nums[0] > nums[-23]:\n        #     return nums[-23]\n        # if nums[0] > nums[-24]:\n        #     return nums[-24]\n        # if nums[0] > nums[-25]:\n        #     return nums[-25]\n        # if nums[0] > nums[-26]:\n        #     return nums[-26]\n        # if nums[0] > nums[-27]:\n        #     return nums[-27]\n        # if nums[0] > nums[-28]:\n        #     return nums[-28]\n        # if nums[0] > nums[-29]:\n        #     return nums[-29]\n        # if nums[0] > nums[-30]:\n        #     return nums[-30]\n        # if nums[0] > nums[-31]:\n        #     return nums[-31]\n        # if nums[0] > nums[-32]:\n        #     return nums[-32]\n        # if nums[0] > nums[-33]:\n        #     return nums[-33]\n        # if nums[0] > nums[-34]:\n        #     return nums[-34]\n        # if nums[0] > nums[-35]:\n        #     return nums[-35]\n        # if nums[0] > nums[-36]:\n        #     return nums[-36]\n        # if nums[0] > nums[-37]:\n        #     return nums[-37]\n        # if nums[0] > nums[-38]:\n        #"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if there is e\n        if 'e' in s:\n            # 2.1 split e\n            e_idx = s.index('e')\n            # 2.2 left part\n            left = s[:e_idx]\n            # 2.3 right part\n            right = s[e_idx+1:]\n            # 2.4 check if left part is valid\n            if not self.isInteger(left):\n                return False\n            # 2.5 check if right part is valid\n            if not self.isInteger(right):\n                return False\n            # 2.6 if both parts are valid, return True\n            return True\n        # 3. if there is no e, check if there is a dot\n        elif '.' in s:\n            # 3.1 split dot\n            dot_idx = s.index('.')\n            # 3.2 left part\n            left = s[:dot_idx]\n            # 3.3 right part\n            right = s[dot_idx+1:]\n            # 3.4 check if left part is valid\n            if not self.isInteger(left):\n                return False\n            # 3.5 check if right part is valid\n            if not self.isInteger(right):\n                return False\n            # 3.6 if both parts are valid, return True\n            return True\n        # 4. if there is no e and no dot, check if there is a sign\n        elif s[0] in ['+','-']:\n            # 4.1 if there is a sign, return True\n            if len(s) > 1:\n                return self.isInteger(s[1:])\n            # 4.2 if there is no sign, return False\n            else:\n                return False\n        # 5. if there is no e, no dot, and no sign, return False\n        else:\n            return False\n        \n    def isInteger(self, s):\n        # 5.1 if there is no sign, check if there is a digit\n        if s[0] in ['+','-']:\n            # 5.2 if there is a sign, return True\n            if len(s) > 1:\n                return self.isInteger(s[1:])\n            # 5.3 if there is no sign, return False\n            else:\n                return False\n        # 6. if there is a sign, check if there is a digit\n        elif s[0] in digits:\n            # 6.1 if there is a digit, return True\n            if len(s) > 1:\n                return self.isInteger(s[1:])\n            # 6.2 if there is no digit, return False\n            else:\n                return False\n        # 7. if there is no sign, no digit, return False\n        else:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XI, XII, XIII, XIV, XV, XVI, XVII, XVIII, XIX, XX\n        # 1000, 900, 500, 400,"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## XOR\n        ## 1. XOR all the elements in s\n        ## 2. XOR all the elements in t\n        ## 3. The difference between the two is the missing letter\n        ## 4. Time complexity: O(n)\n        ## 5. Space complexity: O(1)\n        ## 6. XOR is commutative, so we can use XOR to find the missing letter\n        ## 7. XOR is associative, so we can use XOR to find the missing letter\n        ## 8. XOR is commutative, so we can use XOR to find the missing letter\n        ## 9. XOR is associative, so we can use XOR to find the missing letter\n        ## 10. XOR is associative, so we can use XOR to find the missing letter\n        ## 11. XOR is associative, so we can use XOR to find the missing letter\n        ## 12. XOR is associative, so we can use XOR to find the missing letter\n        ## 13. XOR is associative, so we can use XOR to find the missing letter\n        ## 14. XOR is associative, so we can use XOR to find the missing letter\n        ## 15. XOR is associative, so we can use XOR to find the missing letter\n        ## 16. XOR is associative, so we can use XOR to find the missing letter\n        ## 17. XOR is associative, so we can use XOR to find the missing letter\n        ## 18. XOR is associative, so we can use XOR to find the missing letter\n        ## 19. XOR is associative, so we can use XOR to find the missing letter\n        ## 20. XOR is associative, so we can use XOR to find the missing letter\n        ## 21. XOR is associative, so we can use XOR to find the missing letter\n        ## 22. XOR is associative, so we can use XOR to find the missing letter\n        ## 23. XOR is associative, so we can use XOR to find the missing letter\n        ## 24. XOR is associative, so we can use XOR to find the missing letter\n        ## 25. XOR is associative, so we can use XOR to find the missing letter\n        ## 26. XOR is associative, so we can use XOR to find the missing letter\n        ## 27. XOR is associative, so we can use XOR to find the missing letter\n        ## 28. XOR is associative, so we can use XOR to find the missing letter\n        ## 29. XOR is associative, so we can use XOR to find the missing letter\n        ## 30. XOR is associative, so we can use XOR to find the missing letter\n        ## 31. XOR is associative, so we can use XOR to find the missing letter\n        ## 32. XOR is associative, so we can use XOR to find the missing letter\n        ## 33. XOR is associative, so we can use XOR to find the missing letter\n        ## 34. XOR is associative, so we can use XOR to find the missing letter\n        ## 35. XOR is associative, so we can use XOR to find the missing letter\n        ## 36. XOR is associative, so we can use XOR to find the missing letter\n        ## 37. XOR is associative, so we can use XOR to find the missing letter\n        ## 38. XOR is associative, so we can use XOR to find the missing letter\n        ## 39. XOR is associative, so we can use XOR to find the missing letter\n        ## 40. XOR is associative, so we can use XOR to find the missing letter\n        ## 41. XOR is associative, so we can use XOR to find the missing letter\n        ## 42. XOR is associative, so we can use XOR to find the missing letter\n        ## 43. XOR is associative, so we can use XOR to find the missing letter"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        ## 1. Find empty cells\n        empty_cells = []\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    empty_cells.append((i,j))\n        ## 2. Try to fill empty cells with 1-9\n        for k in range(len(empty_cells)):\n            ## 2.1 Find empty cell with least possible candidates\n            candidates = set(range(1,10)) - {i // 3 * 3 + j // 3 + 1 for i,j in empty_cells[k]}\n            ## 2.2 Try to fill empty cell with candidates\n            if not self.try_fill(board, empty_cells[k], candidates):\n                ## 2.3 If failed, try next empty cell\n                k += 1\n            else:\n                ## 2.4 If succeeded, try next empty cell\n                if k == len(empty_cells):\n                    return True\n        ## 3. If all empty cells are filled, return True\n        return True\n        \n    def try_fill(self, board, empty_cell, candidates):\n        ## 3.1 Find empty cell row\n        i = empty_cell[0]\n        ## 3.2 Find empty cell column\n        j = empty_cell[1]\n        ## 3.3 Find empty cell block\n        block_i = i // 3 * 3\n        block_j = j // 3\n        ## 3.4 Find possible candidates in empty cell row\n        row_candidates = set(range(1,10)) - {board[i][j] for j in range(9)}\n        ## 3.5 Find possible candidates in empty cell column\n        col_candidates = set(range(1,10)) - {board[j][i] for j in range(9)}\n        ## 3.6 Find possible candidates in empty cell block\n        block_candidates = set(range(1,10)) - {board[block_i + k][block_j + k] for k in range(3)}\n        ## 3.7 Find possible candidates in empty cell row and column\n        row_col_candidates = row_candidates & col_candidates\n        ## 3.8 Find possible candidates in empty cell row and block\n        row_block_candidates = row_candidates & block_candidates\n        ## 3.9 Find possible candidates in empty cell column and block\n        col_block_candidates = col_candidates & block_candidates\n        ## 3.10 Find possible candidates in empty cell row, column and block\n        row_col_block_candidates = row_col_candidates & block_candidates\n        ## 3.11 Find possible candidates in empty cell row, column, block and candidates\n        candidates = candidates - row_candidates - col_candidates - block_candidates - row_col_candidates - row_block_candidates - col_block_candidates - row_col_block_candidates\n        ## 3.12 If no possible candidates, return False\n        if not candidates:\n            return False\n        ## 3.13 Try to fill empty cell with candidates\n        for candidate in candidates:\n            ## 3.14 If succeeded, return True\n            if self.try_fill(board, (i,j), candidates - {candidate}):\n                return True\n            ## 3.15 If failed, try next candidate\n            else:\n                ## 3.16 If all candidates are tried, return False\n                if not candidates:\n                    return False\n        ## 3.17 If all candidates are tried, return False\n        return False"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node that are swapped\n        # first_node, second_node = find_swapped(root)\n        # if first_node and second_node:\n        #     first_node.val, second_node.val = second_node.val, first_node.val\n\n        # find the first node that is not swapped\n        # first_node = find_not_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is not swapped\n        # second_node = find_not_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is swapped\n        # first_node = find_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is swapped\n        # second_node = find_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is not swapped\n        # first_node = find_not_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is not swapped\n        # second_node = find_not_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is swapped\n        # first_node = find_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is swapped\n        # second_node = find_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is not swapped\n        # first_node = find_not_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is not swapped\n        # second_node = find_not_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is swapped\n        # first_node = find_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is swapped\n        # second_node = find_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is not swapped\n        # first_node = find_not_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is not swapped\n        # second_node = find_not_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is swapped\n        # first_node = find_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is swapped\n        # second_node = find_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is not swapped\n        # first_node = find_not_swapped(root)\n        # if first_node:\n        #     first_node.val = -first_node.val\n\n        # find the second node that is not swapped\n        # second_node = find_not_swapped(root)\n        # if second_node:\n        #     second_node.val = -second_node.val\n\n        # find the first node that is swapped\n        # first_node = find_swapped(root"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle node\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        first_half_start = head\n        second_half_start = prev\n        while first_half_start and first_half_start.val == second_half_start.val:\n            first_half_start = first_half_start.next\n            second_half_start = second_half_start.next\n        \n        # return the result\n        return first_half_start is None"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # 1, 4, 9, 16, 25, 36, 49, 64, 81, 100\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\n        # 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 13"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return head.next\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        # if head is None:\n        #     return None\n        # if head.val == val:\n        #     return head.next\n        # head.next = self.removeElements(head.next, val)\n        # return head\n        if not head:\n            return None\n        head.next = self.removeElements(head.next, val)\n        if head.val == val:\n            return head.next\n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s1 and s2 are equal, return True\n        if s1 == s2:\n            return True\n        \n        # if lengths are different, return False\n        if len(s1) != len(s2):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) == 1:\n            return True\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s2)) == 1:\n            return True\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled\n        if len(set(s1)) != len(set(s2)):\n            return False\n        \n        # if lengths are the same, check if they are scrambled"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of directories\n        dirs = path.split('/')\n        # use a stack to keep track of the directories\n        stack = []\n        # iterate over the list of directories\n        for d in dirs:\n            # if the directory is '..'\n            if d == '..':\n                # if the stack is not empty, pop the top directory\n                if stack:\n                    stack.pop()\n            # if the directory is not '..'\n            elif d and d != '.':\n                # push the directory onto the stack\n                stack.append(d)\n        # join the stack with a '/'\n        # if the stack is empty, return '/'\n        # otherwise, return the stack\n        return '/' + '/'.join(stack) if stack else '/'"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a trie\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node[#] = word\n        \n        # search trie\n        res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] in trie:\n                    res.append((i, j))\n                    self.search(board, i, j, trie)\n        return list(set(res))\n    \n    def search(self, board, i, j, node):\n        if board[i][j] in node:\n            # found a word\n            res.append(node[board[i][j]\n            node[board[i][j]] = None\n            if i > 0:\n                self.search(board, i-1, j, node[board[i][j]\n            if j < len(board[0])-1:\n                self.search(board, i, j+1, node[board[i][j]\n            if i < len(board)-1:\n                self.search(board, i+1, j, node[board[i][j]\n            if j > 0:\n                self.search(board, i, j-1, node[board[i][j]"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        # if len(s) != len(t):\n        #     return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return False\n        #     # return"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1st pass: check rows\n        # 2nd pass: check columns\n        # 3rd pass: check 3x3 sub-boxes\n        \n        # 1st pass: check rows\n        # 1st pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 1st pass: check rows\n        # 2nd pass: check columns\n        # 3rd pass: check 3x3 sub-boxes\n        \n        # 1st pass: check rows\n        # 1st pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 1st pass: check rows\n        # 1st pass: check columns\n        # 3rd pass: check 3x3 sub-boxes\n        \n        # 1st pass: check rows\n        # 2nd pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 1st pass: check rows\n        # 2nd pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 1st pass: check rows\n        # 3rd pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 1st pass: check rows\n        # 3rd pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 2nd pass: check rows\n        # 1st pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 2nd pass: check rows\n        # 1st pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 2nd pass: check rows\n        # 2nd pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 2nd pass: check rows\n        # 2nd pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 3rd pass: check rows\n        # 1st pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 3rd pass: check rows\n        # 1st pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 3rd pass: check rows\n        # 2nd pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 3rd pass: check rows\n        # 2nd pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 3rd pass: check rows\n        # 3rd pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 3rd pass: check rows\n        # 3rd pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 3rd pass: check rows\n        # 3rd pass: check columns\n        # 3rd pass: check 3x3 sub-boxes\n        \n        # 4th pass: check rows\n        # 1st pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 4th pass: check rows\n        # 1st pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 4th pass: check rows\n        # 2nd pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 4th pass: check rows\n        # 2nd pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 4th pass: check rows\n        # 3rd pass: check columns\n        # 1st pass: check 3x3 sub-boxes\n        \n        # 4th pass: check rows\n        # 3rd pass: check columns\n        # 2nd pass: check 3x3 sub-boxes\n        \n        # 4th pass: check rows"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. 3, 6, 9, 12, ...\n        # 2. 5, 10, 15, ...\n        # 3. 7, 14, 21, ...\n        # 4. 8, 16, 24, ...\n        # 5. 9, 18, 27, ...\n        # 6. 10, 20, 30, ...\n        # 7. 11, 22, 33, ...\n        # 8. 12, 24, 36, ...\n        # 9. 13, 26, 39, ...\n        # 10. 14, 28, 42, ...\n        # 11. 15, 30, 45, ...\n        # 12. 16, 32, 48, ...\n        # 13. 17, 34, 51, ...\n        # 14. 18, 36, 54, ...\n        # 15. 19, 38, 57, ...\n        # 16. 20, 40, 60, ...\n        # 17. 21, 42, 63, ...\n        # 18. 22, 44, 66, ...\n        # 19. 23, 46, 69, ...\n        # 20. 24, 48, 72, ...\n        # 21. 25, 50, 75, ...\n        # 22. 26, 52, 78, ...\n        # 23. 27, 54, 81, ...\n        # 24. 28, 56, 84, ...\n        # 25. 29, 58, 87, ...\n        # 26. 30, 60, 90, ...\n        # 27. 31, 62, 92, ...\n        # 28. 32, 64, 96, ...\n        # 29. 33, 66, 99, ...\n        # 30. 34, 68, 102, ...\n        # 31. 35, 70, 105, ...\n        # 32. 36, 72, 108, ...\n        # 33. 37, 74, 111, ...\n        # 34. 38, 76, 114, ...\n        # 35. 39, 78, 117, ...\n        # 36. 40, 80, 120, ...\n        # 37. 41, 82, 122, ...\n        # 38. 42, 84, 124, ...\n        # 39. 43, 86, 126, ...\n        # 40. 44, 88, 128, ...\n        # 41. 45, 90, 130, ...\n        # 42. 46, 92, 132, ...\n        # 43. 47, 94, 134, ...\n        # 44. 48, 96, 136, ...\n        # 45. 49, 98, 138, ...\n        # 46. 50, 100, 140, ...\n        # 47. 51, 102, 142, ...\n        # 48. 52, 104, 144, ...\n        # 49. 53, 106, 146, ...\n        # 50. 54, 108, 148, ...\n        # 51. 55,"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the whole string\n        s = s[::-1]\n        # reverse each word\n        words = s.split()\n        # reverse each word\n        words = [word[::-1]\n        # join all the words together\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 * 26^1 * 26^2 * ... * 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26^n * 26\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n * 26^n\n        # 26^n * (columnTitle[n-1] - 'A' + 1) / 26"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679cratings[i] > ratings[i-1], \u5219ratings[i] = ratings[i] + 1\n        # 2. \u5982\u679cratings[i] < ratings[i-1], \u5219ratings[i] = ratings[i-1] + 1\n        # 3. \u5982\u679cratings[i] == ratings[i-1], \u5219ratings[i] = ratings[i-1] + 1\n        # 4. \u5982\u679cratings[i] > ratings[i+1], \u5219ratings[i] = ratings[i+1] + 1\n        # 5. \u5982\u679cratings[i] < ratings[i+1], \u5219ratings[i] = ratings[i+1] + 1\n        # 6. \u5982\u679cratings[i] == ratings[i+1], \u5219ratings[i] = ratings[i+1] + 1\n        # 7. \u5982\u679cratings[i] > ratings[i+2], \u5219ratings[i] = ratings[i+2] + 1\n        # 8. \u5982\u679cratings[i] < ratings[i+2], \u5219ratings[i] = ratings[i+2] + 1\n        # 9. \u5982\u679cratings[i] == ratings[i+2], \u5219ratings[i] = ratings[i+2] + 1\n        # 10. \u5982\u679cratings[i] > ratings[i+3], \u5219ratings[i] = ratings[i+3] + 1\n        # 11. \u5982\u679cratings[i] < ratings[i+3], \u5219ratings[i] = ratings[i+3] + 1\n        # 12. \u5982\u679cratings[i] == ratings[i+3], \u5219ratings[i] = ratings[i+3] + 1\n        # 13. \u5982\u679cratings[i] > ratings[i+4], \u5219ratings[i] = ratings[i+4] + 1\n        # 14. \u5982\u679cratings[i] < ratings[i+4], \u5219ratings[i] = ratings[i+4] + 1\n        # 15. \u5982\u679cratings[i] == ratings[i+4], \u5219ratings[i] = ratings[i+4] + 1\n        # 16. \u5982\u679cratings[i] > ratings[i+5], \u5219ratings[i] = ratings[i+5] + 1\n        # 17. \u5982\u679cratings[i] < ratings[i+5], \u5219ratings[i] = ratings[i+5] + 1\n        # 18. \u5982\u679cratings[i] == ratings[i+5], \u5219ratings[i] = ratings[i+5] + 1\n        # 19. \u5982\u679cratings[i] > ratings[i+6], \u5219ratings[i] = ratings[i+6] + 1\n        # 20. \u5982\u679cratings[i] < ratings[i+6], \u5219ratings[i] = ratings[i+6] + 1\n        # 21. \u5982\u679cratings[i] == ratings[i+6], \u5219ratings[i] = ratings[i+6] + 1\n        # 22. \u5982\u679cratings[i] > ratings[i+7], \u5219ratings[i] = ratings[i+7] + 1\n        # 23. \u5982\u679cratings[i] < ratings[i+7], \u5219ratings[i] = ratings[i+7] + 1\n        # 24. \u5982\u679cratings[i] == ratings[i+7], \u5219ratings[i] = ratings[i+7] + 1\n        # 25. \u5982\u679cratings[i] > ratings[i+8], \u5219ratings[i] = ratings[i+8] + 1\n        # 26. \u5982\u679cratings[i] < ratings[i+8], \u5219ratings[i] = ratings[i+8] + 1\n        # 27. \u5982\u679cratings[i] == ratings[i+8], \u5219ratings[i] = ratings[i+8] + 1\n        # 28. \u5982\u679cratings[i] > ratings[i+9], \u5219ratings[i] = ratings"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = head\n        fast = head\n        prev = None\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev.next = None\n        curr = slow\n        prev = None\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        # merge the two lists\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        # return the head of the reordered list\n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(pattern) != len(s_list):\n        #     return False\n        # p_dict = {}\n        # s_dict = {}\n        # for i in range(len(pattern)):\n        #     if pattern[i] in p_dict:\n        #         if p_dict[pattern[i]] != s_list[i]:\n        #             return False\n        #     else:\n        #         p_dict[pattern[i]] = s_list[i]\n        #         if s_list[i] in s_dict:\n        #             return False\n        #         else:\n        #             s_dict[s_list[i]] = pattern[i]\n        # return True\n        \n        p_dict = {}\n        s_dict = {}\n        pattern_list = pattern.split()\n        s_list = s.split()\n        if len(pattern_list) != len(s_list):\n            return False\n        for i in range(len(pattern_list)):\n            if pattern_list[i] in p_dict:\n                if p_dict[pattern_list[i]] != s_list[i]:\n                    return False\n            else:\n                p_dict[pattern_list[i]] = s_list[i]\n                if s_list[i] in s_dict:\n                    return False\n                else:\n                    s_dict[s_list[i]] = pattern_list[i]\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [nums]\n        if len(nums) == 2:\n            return [[nums[1], nums[0]]\n        if len(nums) == 3:\n            return [[nums[1], nums[2], nums[0]]\n        if len(nums) == 4:\n            return [[nums[1], nums[3], nums[2], nums[0]]\n        if len(nums) == 5:\n            return [[nums[1], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 6:\n            return [[nums[1], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 7:\n            return [[nums[1], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 8:\n            return [[nums[1], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 9:\n            return [[nums[1], nums[8], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 10:\n            return [[nums[1], nums[9], nums[8], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 11:\n            return [[nums[1], nums[10], nums[9], nums[8], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 12:\n            return [[nums[1], nums[11], nums[10], nums[9], nums[8], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 13:\n            return [[nums[1], nums[12], nums[11], nums[10], nums[9], nums[8], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 14:\n            return [[nums[1], nums[13], nums[12], nums[11], nums[10], nums[9], nums[8], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 15:\n            return [[nums[1], nums[14], nums[13], nums[12], nums[11], nums[10], nums[9], nums[8], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 16:\n            return [[nums[1], nums[15], nums[14], nums[13], nums[12], nums[11], nums[10], nums[9], nums[8], nums[7], nums[6], nums[5], nums[4], nums[3], nums[2], nums[0]]\n        if len(nums) == 17:\n            return [[nums[1], nums[16], nums[15], nums[14], nums[13], nums[12], nums[11], nums[10], num"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search for the row\n        low, high = 0, len(matrix)-1\n        row = -1\n        while low <= high:\n            mid = (low+high)//2\n            if target > matrix[mid][0]:\n                low = mid+1\n            elif target < matrix[mid][0]:\n                high = mid-1\n            else:\n                row = mid\n                break\n        \n        # if row is -1, then target is not in the matrix\n        if row == -1:\n            return False\n        \n        # binary search for the target in the row\n        low, high = 0, len(matrix[row])-1\n        col = -1\n        while low <= high:\n            mid = (low+high)//2\n            if target > matrix[row][mid]:\n                low = mid+1\n            elif target < matrix[row][mid]:\n                high = mid-1\n            else:\n                col = mid\n                break\n        \n        # if col is -1, then target is not in the row\n        if col == -1:\n            return False\n        else:\n            return True"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a new list node\n        head = ListNode(0)\n        # create a pointer to the head of the new list\n        p = head\n        # create a pointer to the first list\n        p1 = l1\n        # create a pointer to the second list\n        p2 = l2\n        # create a carry variable\n        carry = 0\n        # loop until both lists are empty\n        while p1 or p2:\n            # if p1 is empty, set p1 to the second list\n            if not p1:\n                p1 = l2\n            # if p2 is empty, set p2 to the first list\n            if not p2:\n                p2 = l1\n            # add the values of the lists\n            sum_val = p1.val + p2.val + carry\n            # set the value of the new list node to the sum modulo 10\n            p.next = ListNode(sum_val % 10)\n            # set the carry to the sum divided by 10\n            carry = sum_val // 10\n            # set the pointer to the next node\n            p = p.next\n            # set the pointers to the next nodes\n            p1 = p1.next\n            p2 = p2.next\n        # if the carry is greater than 0, set the value of the new list node to the carry\n        if carry > 0:\n            p.next = ListNode(carry)\n        # return the head of the new list\n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2**n - 1\n        # 2. 2**n - 2\n        # 3. 2**n - 3\n        # 4. 2**n - 4\n        # 5. 2**n - 5\n        # 6. 2**n - 6\n        # 7. 2**n - 7\n        # 8. 2**n - 8\n        # 9. 2**n - 9\n        # 10. 2**n - 10\n        # 11. 2**n - 11\n        # 12. 2**n - 12\n        # 13. 2**n - 13\n        # 14. 2**n - 14\n        # 15. 2**n - 15\n        # 16. 2**n - 16\n        # 17. 2**n - 17\n        # 18. 2**n - 18\n        # 19. 2**n - 19\n        # 20. 2**n - 20\n        # 21. 2**n - 21\n        # 22. 2**n - 22\n        # 23. 2**n - 23\n        # 24. 2**n - 24\n        # 25. 2**n - 25\n        # 26. 2**n - 26\n        # 27. 2**n - 27\n        # 28. 2**n - 28\n        # 29. 2**n - 29\n        # 30. 2**n - 30\n        # 31. 2**n - 31\n        # 32. 2**n - 32\n        # 33. 2**n - 33\n        # 34. 2**n - 34\n        # 35. 2**n - 35\n        # 36. 2**n - 36\n        # 37. 2**n - 37\n        # 38. 2**n - 38\n        # 39. 2**n - 39\n        # 40. 2**n - 40\n        # 41. 2**n - 41\n        # 42. 2**n - 42\n        # 43. 2**n - 43\n        # 44. 2**n - 44\n        # 45. 2**n - 45\n        # 46. 2**n - 46\n        # 47. 2**n - 47\n        # 48. 2**n - 48\n        # 49. 2**n - 49\n        # 50. 2**n - 50\n        # 51. 2**n - 51\n        # 52. 2**n - 52\n        # 53. 2**n - 53\n        # 54. 2**n - 54\n        # 55. 2**n - 55\n        # 56. 2**n - 56\n        # 57. 2**n - 57\n        # 58. 2**n - 58\n        # 59. 2**n - 59\n        # 60. 2**n - 60\n        # 61. 2**n - 61\n        # 62. 2**n - 62\n        # 63. 2**n - 63\n        # 64. 2**n - 64\n        # 65. 2**n - 65\n        # 66. 2**n - 66\n        # 67. 2**n - 67\n        # 68. 2**n - 68\n        # 69. 2**n - 69\n        # 70."}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        # dp[i] = dp[i] - dp[i-2]\n        # dp[i] = dp[i] - 2*dp[i-3] + dp[i-4]\n        # dp[i] = dp[i] - 3*dp[i-4] + ... + dp[2] + dp[1]\n        # dp[i] = dp[i] - (i-1)*(i-2)/2\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) + ... + (i-2)*(i-1)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) - ... - (i-2)*(i-1)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) - ... - (i-2)*(i-1) - (i-3)*(i-4) + ... + (i-3)*(i-2)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) - ... - (i-2)*(i-1) - (i-3)*(i-4) - ... - (i-3)*(i-2) + (i-4)*(i-5)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) - ... - (i-2)*(i-1) - (i-3)*(i-4) - ... - (i-3)*(i-2) - ... - (i-3)*(i-1) + (i-4)*(i-5) - ... + (i-4)*(i-3)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) - ... - (i-2)*(i-1) - (i-3)*(i-4) - ... - (i-3)*(i-2) - ... - (i-3)*(i-1) - ... - (i-2)*(i-1) + (i-3)*(i-2) - ... + (i-2)*(i-1)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) - ... - (i-2)*(i-1) - (i-3)*(i-4) - ... - (i-3)*(i-2) - ... - (i-3)*(i-1) - ... - (i-2)*(i-1) - ... - (i-1)*(i)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) - ... - (i-2)*(i-1) - (i-3)*(i-4) - ... - (i-3)*(i-2) - ... - (i-3)*(i-1) - ... - (i-2)*(i-1) - ... - (i-1)*(i-2) + (i-2)*(i-3) - ... + (i-1)*(i-2)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2)*(i-3) - ... - (i-2)*(i-1) - (i-3)*(i-4) - ... - (i-3)*(i-2) - ... - (i-3)*(i-1) - ... - (i-2)*(i-1) - ... - (i-1)*(i-2) - ... + (i-1)*(i-3)\n        # dp[i] = dp[i] - (i-1)*(i-2) - (i-2"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. find the length of each word\n        # 2. find the number of spaces\n        # 3. find the number of words\n        # 4. find the number of spaces between words\n        # 5. find the number of spaces between words and the last word\n        # 6. find the number of spaces between words and the last word\n        # 7. find the number of spaces between words and the last word\n        # 8. find the number of spaces between words and the last word\n        # 9. find the number of spaces between words and the last word\n        # 10. find the number of spaces between words and the last word\n        # 11. find the number of spaces between words and the last word\n        # 12. find the number of spaces between words and the last word\n        # 13. find the number of spaces between words and the last word\n        # 14. find the number of spaces between words and the last word\n        # 15. find the number of spaces between words and the last word\n        # 16. find the number of spaces between words and the last word\n        # 17. find the number of spaces between words and the last word\n        # 18. find the number of spaces between words and the last word\n        # 19. find the number of spaces between words and the last word\n        # 20. find the number of spaces between words and the last word\n        # 21. find the number of spaces between words and the last word\n        # 22. find the number of spaces between words and the last word\n        # 23. find the number of spaces between words and the last word\n        # 24. find the number of spaces between words and the last word\n        # 25. find the number of spaces between words and the last word\n        # 26. find the number of spaces between words and the last word\n        # 27. find the number of spaces between words and the last word\n        # 28. find the number of spaces between words and the last word\n        # 29. find the number of spaces between words and the last word\n        # 30. find the number of spaces between words and the last word\n        # 31. find the number of spaces between words and the last word\n        # 32. find the number of spaces between words and the last word\n        # 33. find the number of spaces between words and the last word\n        # 34. find the number of spaces between words and the last word\n        # 35. find the number of spaces between words and the last word\n        # 36. find the number of spaces between words and the last word\n        # 37. find the number of spaces between words and the last word\n        # 38. find the number of spaces between words and the last word\n        # 39. find the number of spaces between words and the last word\n        # 40. find the number of spaces between words and the last word\n        # 41. find the number of spaces between words and the last word\n        # 42. find the number of spaces between words and the last word\n        # 43. find the number of spaces between words and the last word\n        # 44. find the number of spaces between words and the last word\n        # 45. find the number of spaces between words and the last word\n        # 46. find the number of spaces between words and the last word\n        # 47. find the number of spaces between words and the last word\n        # 48. find the number of spaces between words and the last word\n        # 49. find the number of spaces between words and the last word\n        # 50. find the number of spaces between words and the last word\n        # 51. find the number of spaces between words and the last word\n        # 52. find the number of spaces between words and the last word\n        # 53. find the number of spaces between words and the last word\n        # 54. find the number of spaces between words and the last word\n        # 55. find the number of spaces between words and the last word\n        # 56. find the number of spaces between words and the last word\n        # 57. find the number of spaces between words and the last word\n        # 58. find the number of spaces between words and the last word\n        # 59. find the number of"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack, res = [root], []\n        \n        while stack:\n            node = stack.pop()\n            if node.left:\n                stack.append(node.left)\n            elif node.right:\n                stack.append(node.right)\n            else:\n                res.append(node.val)\n        \n        res.reverse()\n        return res"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     if height[left] < height[right]:\n        #         max_area = max(max_area, height[left] * (right - left))\n        #         left += 1\n        #     else:\n        #         max_area = max(max_area, height[right] * (right - left))\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        while left < right:\n            if height[left] < height[right]:\n                max_area = max(max_area, (right - left) * height[left])\n                left += 1\n            else:\n                max_area = max(max_area, (right - left) * height[right])\n                right -= 1\n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build a hashmap with all the words\n        # 2. for each word, check if it can be split into two words in the hashmap\n        # 3. if it can, add it to the result\n        # 4. if it can't, check if it can be split into any other word in the hashmap\n        # 5. if it can't, add it to the hashmap\n        # 6. return the result\n        \n        # build a hashmap with all the words\n        word_hashmap = {}\n        for word in words:\n            if word not in word_hashmap:\n                word_hashmap[word] = 1\n            else:\n                word_hashmap[word] += 1\n        \n        # for each word, check if it can be split into two words in the hashmap\n        # if it can, add it to the result\n        # if it can't, check if it can be split into any other word in the hashmap\n        # if it can't, add it to the hashmap\n        result = []\n        for word in words:\n            if self.can_split(word, word_hashmap):\n                result.append(word)\n            else:\n                word_hashmap[word] = 1\n        \n        # return the result\n        return result\n    \n    def can_split(self, word, word_hashmap):\n        # use a set to store the visited words\n        visited = set()\n        # use a queue to store the words that can be split\n        queue = [word]\n        # use a visited set to store the visited words\n        visited.add(word)\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words\n        visited = set()\n        # use a visited set to store the visited words"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        elif num < 7:\n            return str(num)\n        else:\n            return self.convertToBase7(num//7) + str(num%7)"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # if n % 4 == 0:\n        #     return False\n        # return True\n        \n        # return not n & 3\n        \n        # return not n & 0x3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3\n        \n        # return not n & 3"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. \u521d\u59cb\u5316\u4e00\u4e2a\u4e8c\u7ef4\u6570\u7ec4\uff0c\u7528'.'\u8868\u793a\u7a7a\u767d\uff0c\u7528'Q'\u8868\u793a\u7687\u540e\n        board = [['.'] * n for _ in range(n)]\n        # 2. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        cols = [0] * n\n        # 3. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 4. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 5. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 6. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 7. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 8. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 9. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 10. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 11. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 12. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 13. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 14. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 15. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 16. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 17. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 18. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 19. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 20. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 21. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 22. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 23. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 24. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 25. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 26. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 27. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 28. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 29. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 30. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 31. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 32. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 33. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 34. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 35. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 36. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 37. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 38. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 39. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 40. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 41. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 42. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 43. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 44. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 45. \u521d\u59cb\u5316\u4e00\u4e2a\u5217\u8868\uff0c\u8bb0\u5f55\u6bcf\u4e00\u5217\u662f\u5426\u6709\u7687\u540e\n        # 46."}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return False\n        \n        if not board:\n            return False\n        \n        if not word[0]:\n            return False\n        \n        if not board[0]:\n            return False\n        \n        if len(word) > len(board[0]) * len(board):\n            return False\n        \n        if len(word) > len(board) * len(board[0]):\n            return False\n        \n        if len(word) == 1:\n            return True\n        \n        # create a lookup table for the first letter of the word\n        lookup = {}\n        for i in range(len(board)):\n            if board[i][0] not in lookup:\n                lookup[board[i][0]] = 1\n            else:\n                lookup[board[i][0]] += 1\n        \n        # create a lookup table for the last letter of the word\n        lookup2 = {}\n        for i in range(len(board[0]) - 1, -1, -1):\n            if board[0][i] not in lookup2:\n                lookup2[board[0][i]] = 1\n            else:\n                lookup2[board[0][i]] += 1\n        \n        # create a lookup table for the first letter of the word\n        lookup3 = {}\n        for i in range(len(board) - 1, -1, -1):\n            if board[i][0] not in lookup3:\n                lookup3[board[i][0]] = 1\n            else:\n                lookup3[board[i][0]] += 1\n        \n        # create a lookup table for the last letter of the word\n        lookup4 = {}\n        for i in range(len(board[0]) - 1, -1, -1):\n            if board[0][i] not in lookup4:\n                lookup4[board[0][i]] = 1\n            else:\n                lookup4[board[0][i]] += 1\n        \n        # create a lookup table for the first letter of the word\n        lookup5 = {}\n        for i in range(len(board) - 1, -1, -1):\n            if board[i][0] not in lookup5:\n                lookup5[board[i][0]] = 1\n            else:\n                lookup5[board[i][0]] += 1\n        \n        # create a lookup table for the last letter of the word\n        lookup6 = {}\n        for i in range(len(board[0]) - 1, -1, -1):\n            if board[0][i] not in lookup6:\n                lookup6[board[0][i]] = 1\n            else:\n                lookup6[board[0][i]] += 1\n        \n        # create a lookup table for the first letter of the word\n        lookup7 = {}\n        for i in range(len(board) - 1, -1, -1):\n            if board[i][0] not in lookup7:\n                lookup7[board[i][0]] = 1\n            else:\n                lookup7[board[i][0]] += 1\n        \n        # create a lookup table for the last letter of the word\n        lookup8 = {}\n        for i in range(len(board[0]) - 1, -1, -1):\n            if board[0][i] not in lookup8:\n                lookup8[board[0][i]] = 1\n            else:\n                lookup8[board[0][i]] += 1\n        \n        # create a lookup table for the first letter of the word\n        lookup9 = {}\n        for i in range(len(board) - 1, -1, -1):\n            if board[i][0] not in lookup9:\n                lookup9[board[i][0]] = 1\n            else:\n                lookup9[board[i][0]] += 1\n        \n        # create a lookup table for the last letter of the word\n        lookup10 = {}\n        for i in range(len(board[0]) - 1, -1, -1):\n            if board[0][i] not in lookup10:\n                lookup10[board[0][i]] = 1\n            else:\n                lookup10[board[0][i]] += 1\n        \n        # create a lookup table for the first letter of the word\n        lookup11 = {}\n        for i in range(len(board) - 1"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # if nums1 is empty, just return nums2\n        if m == 0:\n            return nums2\n        \n        # if nums2 is empty, just return nums1\n        if n == 0:\n            return nums1\n        \n        # pointer for nums1\n        p1 = m - 1\n        # pointer for nums2\n        p2 = n - 1\n        # pointer for nums1\n        p = m + n - 1\n        \n        # while p1 is not negative and p2 is not negative\n        while p1 >= 0 and p2 >= 0:\n            # if nums1[p1] is greater than nums2[p2], then we need to move nums1[p1] to the end\n            if nums1[p1] > nums2[p2]:\n                nums1[p] = nums1[p1]\n                p1 -= 1\n            # otherwise, we need to move nums2[p2] to the end\n            else:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            # decrement p\n            p -= 1\n        \n        # if p2 is still positive, we need to move all the remaining elements in nums2 to the end\n        while p2 >= 0:\n            nums1[p] = nums2[p2]\n            p2 -= 1\n            p -= 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1st pass: find the maximum number\n        # 2nd pass: find the second maximum number\n        # 3rd pass: find the third maximum number\n        # if the second maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is found, return the third maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found, return the maximum number\n        # if the third maximum number is not found"}]}