{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            next_i, next_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= next_i < m and 0 <= next_j < n and not visited[next_i][next_j]:\n                i, j = next_i, next_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Sort the array\n        ## 2. Iterate through the array and check if the current number is positive\n        ## 3. If the current number is positive, check if the current number is equal to the index\n        ## 4. If the current number is positive and the current number is equal to the index, continue\n        ## 5. If the current number is positive and the current number is not equal to the index, return the current number\n        ## 6. If the current number is not positive, continue\n        ## 7. If the current number is not positive, return the current number + 1\n        \n        ## 1. Sort the array\n        nums.sort()\n        \n        ## 2. Iterate through the array and check if the current number is positive\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                ## 3. If the current number is positive, check if the current number is equal to the index\n                if nums[i] == i + 1:\n                    continue\n                ## 4. If the current number is positive and the current number is equal to the index, continue\n                else:\n                    ## 5. If the current number is positive and the current number is not equal to the index, return the current number\n                    return i + 1\n        ## 6. If the current number is not positive, continue\n        ## 7. If the current number is not positive, return the current number + 1\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        \n        # 1. generate all permutations\n        # 2. find"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        ## Two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, prod + curr, res)\n                    backtrack(j+1, curr, prev - curr, (prod - prev) + curr, res)\n                    backtrack(j+1, curr, prev * curr, prod * curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, 0, res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left_sum = dfs(root.left, curr_sum * 10 + root.val)\n            right_sum = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left_sum + right_sum\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the sum of gas and cost\n        ## 2. if the sum is less than the sum of gas, return -1\n        ## 3. if the sum is greater than the sum of gas, return 0\n        ## 4. if the sum is equal to the sum of gas, return the index of the first gas station\n        \n        sum_gas = sum(gas)\n        sum_cost = sum(cost)\n        \n        if sum_gas < sum_cost:\n            return -1\n        elif sum_gas == sum_cost:\n            return 0\n        else:\n            for i in range(len(gas)):\n                if gas[i] + sum_gas >= sum_cost:\n                    return i\n            return -1"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # add 1 to the end and start\n        nums = [1] + nums + [1]\n        \n        # create a dp array\n        dp = [[0] * len(nums) for _ in range(len(nums))]\n        \n        # fill the dp array\n        for i in range(len(nums) - 2, -1, -1):\n            for j in range(i + 2, len(nums)):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][len(nums) - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1 = nums1[1:]\n                    else:\n                        out.append(nums2[0])\n                        nums2 = nums2[1:]\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    out.append(nums2[0])\n                    nums2 = nums2[1:]\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5("}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i\n                if i ** 2 != num:\n                    sum += num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_list = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_list.append(s_list[i])\n        vowel_list.reverse()\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # 1. Create a graph\n        # 2. BFS\n        # 3. Return the distance\n        \n        # Create a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"_\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        distance = 1\n        \n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == endWord:\n                    return distance\n                for i in range(len(curr)):\n                    pattern = curr[:i] + \"_\" + curr[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            distance += 1\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        carry = 0\n        res = \"\"\n        for i in range(len(a)-1, -1, -1):\n            if i < len(b):\n                carry += int(a[i]) + int(b[i])\n            else:\n                carry += int(a[i])\n            res = str(carry % 2) + res\n            carry //= 2\n        if carry:\n            res = \"1\" + res\n        return res"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, lower):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (lower and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        left_idx = binary_search(nums, target, True)\n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        return [left_idx, binary_search(nums, target, False) - 1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        if nums[0] >= n - 1:\n            return 1\n        \n        if nums[0] == 0:\n            return -1\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(1, n):\n            if i > max_reach:\n                return -1\n            \n            if i + nums[i] > max_reach:\n                max_reach = i + nums[i]\n            \n            if i == curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices):\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for i in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(1,k+1):\n            max_diff = -prices[0]\n            for j in range(1,len(prices)):\n                dp[i][0] = max(dp[i][0],dp[i-1][1]+prices[j])\n                dp[i][1] = max(dp[i][1],dp[i-1][0]-prices[j])\n                \n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n        hex_list = []\n        \n        while num > 0:\n            rem = num % 16\n            if rem >= 10:\n                rem = hex_dict[rem]\n            hex_list.append(rem)\n            num = num // 16\n        \n        hex_list.reverse()\n        return ''.join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.48% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.4 MB, less than 99.48% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2022-09-28\n        ## 2"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if indexDiff < 0 or valueDiff < 0:\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if indexDiff == 0 and valueDiff == 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff == 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff == 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff == 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff == 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff == 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff == 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff > 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff == 0 and valueDiff > 0:\n            return False\n        \n        if indexDiff"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. convert to int\n        ## 2. add\n        ## 3. convert to str\n        \n        ## 1. convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        ## 2. add\n        sum = num1 + num2\n        \n        ## 3. convert to str\n        sum = str(sum)\n        \n        return sum"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i):\n            if i >= len(s):\n                return 0\n            if s[i] == ' ':\n                return helper(s, i + 1)\n            if s[i] == '+':\n                return helper(s, i + 1) + helper(s, i + 2)\n            if s[i] == '-':\n                return helper(s, i + 1) - helper(s, i + 2)\n            if s[i] == '(':\n                return helper(s, i + 1) + helper(s, helper(s, i + 1) + 1)\n            if s[i] == ')':\n                return helper(s, i + 1)\n            num = 0\n            while i < len(s) and s[i].isdigit():\n                num = num * 10 + int(s[i])\n                i += 1\n            return num\n        \n        return helper(s, 0)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the point\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1,i,-1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[j] = nums[j],nums[i]\n        \n        # reverse the numbers after the point\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary to store the indices of the elements\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n-1, 2)]\n        couples.sort()\n        \n        couples_set = set(couples)\n        couples_set.add((row[0], row[1]))\n        couples_set.add((row[n-1], row[n-2]))\n        \n        couples_set_list = list(couples_set)\n        couples_set_list.sort()\n        \n        couples_dict = {}\n        for i in range(len(couples_set_list)):\n            couples_dict[couples_set_list[i][0]] = i\n            couples_dict[couples_set_list[i][1]] = i\n        \n        couples_dict[row[0]] = 0\n        couples_dict[row[n-1]] = n-1\n        \n        for i in range(1, n-1):\n            couples_dict[row[i]] = i\n        \n        for i in range(n-1):\n            if row[i] % 2 == 0:\n                couples_dict[row[i]] = couples_dict[row[i]+1]\n            else:\n                couples_dict[row[i]] = couples_dict[row[i]-1]\n        \n        couples_dict[row[n-1]] = couples_dict[row[0]]\n        \n        count = 0\n        for i in range(n-1):\n            if couples_dict[row[i]] != i:\n                count += 1\n                temp = row[i]\n                row[i] = row[couples_dict[row[i]]]\n                row[couples_dict[row[i]]] = temp\n        \n        return count"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        tail = curr\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            count += 1\n        \n        tail.next = curr\n        head = prev\n        \n        return head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring\n        # reverse the string\n        # append the reverse string to the front of the original string\n        # return the result\n        \n        # find the longest palindrome substring"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            if s == t:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for i in t:\n            if i not in t_dict:\n                t_dict[i] = 1\n            else:\n                t_dict[i] += 1\n        \n        s_dict = {}\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s[end] in s_dict:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] = 1\n            end += 1\n            \n            while True:\n                if len(s_dict) == len(t_dict):\n                    if end - start < min_len:\n                        min_len = end - start\n                        min_start = start\n                        min_end = end\n                    if s[start] in s_dict:\n                        s_dict[s[start]] += 1\n                    start += 1\n                else:\n                    break\n        \n        if min_len == len(s):\n            return \"\"\n        else:\n            return s[min_start:min_end]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a hashmap to store the frequency of each character\n        # 2. iterate through the hashmap and add the max of odd and even\n        # 3. if the hashmap has a value of 1, add 1 to the result\n        # 4. return the result\n        \n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        result = 0\n        for key in hashmap:\n            if hashmap[key] % 2 == 0:\n                result += hashmap[key]\n            else:\n                result += hashmap[key] - 1\n        \n        if result < len(s):\n            result += 1\n        \n        return result"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    x, y = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] > 0 and (nx, ny) not in visited:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = []\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        steps = 0\n        for tree, x, y in trees:\n            steps += bfs((0, 0), (x, y))\n            if steps < 0:\n                return steps\n            steps += 1\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        # \n        # Approach 2:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 3:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 4:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 5:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 6:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 7:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 8:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 9:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 10:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 11:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 12:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 13:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 14:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 15:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 16:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 17:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 18:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 19:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 20:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 21:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 22:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 23:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 24:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 25:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 26:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 27:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # \n        # Approach 28:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        for i in range(2**n):\n            res.append(i ^ (i>>1))\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root, lower, upper):\n            if not root:\n                return True\n            \n            if root.val <= lower or root.val >= upper:\n                return False\n            \n            return inorder(root.left, lower, root.val) and inorder(root.right, root.val, upper)\n        \n        return inorder(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the original list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element of the original list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element of the original list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element of the original list, merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element of the original list, merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements of the original list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path+[s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, t, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return t\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), t+1, x, y))\n                    visited.add((x, y))\n        return -1"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # Initialize the first row and column with 1\n        # The number of unique paths to reach the bottom-right corner is the value in the last cell\n        # The number of unique paths to reach any other cell is the sum of the number of unique paths to reach the cell above and the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of unique paths to reach the cell to the left minus the number of unique paths to reach the cell above\n        # The number of unique paths to reach the cell above is the number of unique paths to reach the cell above minus the number of unique paths to reach the cell to the left\n        # The number of unique paths to reach the cell to the left is the number of"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n            \n        return ''.join(map(str, res))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 98.42% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.2 MB, less than 98.42% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-05-24\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                result.append(curr.val)\n                curr = curr.right\n        \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, path, res):\n            if left == 0 and right == 0:\n                if isValid(path):\n                    res.append(path)\n                return\n            for i in range(len(s)):\n                if i > 0 and s[i] == s[i-1]:\n                    continue\n                if s[i] == '(' or s[i] == ')':\n                    if left > 0 and s[i] == '(':\n                        dfs(s[:i] + s[i+1:], left - 1, right, path + s[i], res)\n                    elif right > 0 and s[i] == ')':\n                        dfs(s[:i] + s[i+1:], left, right - 1, path + s[i], res)\n        \n        res = []\n        dfs(s, 0, 0, '', res)\n        return res"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not l1:\n            return l2\n        \n        if not l2:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x//5\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l+r)//2\n            if f(m) < k:\n                l = m+1\n            else:\n                r = m\n        return l-k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPairs(s):\n            pairs = []\n            for i in range(len(s)):\n                if isPalindrome(s[i:]):\n                    pairs.append(len(s) - i - 1)\n                if i and isPalindrome(s[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        return [(i, j) for i in range(len(words)) for j in getPairs(words[i])]"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, r, c):\n            q = deque([(r, c)])\n            while q:\n                r, c = q.popleft()\n                for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                        isInfected[nr][nc] = 2\n                        q.append((nr, nc))\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for r in range(len(isInfected)):\n                    for c in range(len(isInfected[0])):\n                        if isInfected[r][c] == 1:\n                            infected.add((r, c))\n                if not infected:\n                    break\n                q = deque(infected)\n                while q:\n                    r, c = q.popleft()\n                    for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                        if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                            isInfected[nr][nc] = 2\n                            q.append((nr, nc))\n                walls += 1\n            return walls\n        \n        walls = build_walls(isInfected)\n        for r in range(len(isInfected)):\n            for c in range(len(isInfected[0])):\n                if isInfected[r][c] == 1:\n                    spread(isInfected, r, c)\n        return walls"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10\n        \n        if n < 1000:\n            return 100\n        \n        if n < 10000:\n            return 1000\n        \n        if n < 100000:\n            return 10000\n        \n        if n < 1000000:\n            return 100000\n        \n        if n < 10000000:\n            return 1000000\n        \n        if n < 100000000:\n            return 10000000\n        \n        if n < 1000000000:\n            return 100000000\n        \n        if n < 10000000000:\n            return 1000000000\n        \n        if n < 100000000000:\n            return 10000000000\n        \n        if n < 1000000000000:\n            return 100000000000\n        \n        if n < 10000000000000:\n            return 1000000000000\n        \n        if n < 100000000000000:\n            return 10000000000000\n        \n        if n < 1000000000000000:\n            return 100000000000000\n        \n        if n < 10000000000000000:\n            return 1000000000000000\n        \n        if n < 100000000000000000:\n            return 10000000000000000\n        \n        if n < 1000000000000000000:\n            return 100000000000000000\n        \n        if n < 10000000000000000000:\n            return 1000000000000000000\n        \n        if n < 100000000000000000000:\n            return 10000000000000000000\n        \n        if n < 1000000000000000000000:\n            return 100000000000000000000\n        \n        if n < 10000000000000000000000:\n            return 1000000000000000000000\n        \n        if n < 100000000000000000000000:\n            return 10000000000000000000000\n        \n        if n < 1000000000000000000000000:\n            return 100000000000000000000000\n        \n        if n < 10000000000000000000000000:\n            return 1000000000000000000000000\n        \n        if n < 100000000000000000000000000:\n            return"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        # If dp[len(s)] is True, then we have found a valid word break.\n        # We will start from the end of the string and build the sentence.\n        if dp[len(s)]:\n            res = []\n            self.dfs(s, wordDict, dp, len(s), '', res)\n            return res\n        else:\n            return []\n        \n    def dfs(self, s, wordDict, dp, i, curr, res):\n        if i == 0:\n            res.append(curr)\n            return\n        \n        for j in range(i):\n            if dp[j] and s[j:i] in wordDict:\n                self.dfs(s, wordDict, dp, j, curr + ' ' + s[j:i], res)"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_times_helper(h, m, turnedOn):\n            if turnedOn == 0:\n                return [get_time(h, m)]\n            else:\n                if h < 12:\n                    return get_times_helper(h + 1, m, turnedOn - 1) + get_times_helper(h, m + 1, turnedOn - 1)\n                else:\n                    return get_times_helper(h, m + 1, turnedOn - 1)\n        \n        return get_times_helper(0, 0, turnedOn)"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        pascal = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(pascal[i-1][j-1] + pascal[i-1][j])\n            row.append(1)\n            pascal.append(row)\n        \n        return pascal"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = curr_i + di, curr_j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(e for e in s if e.isalnum())\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n        \n        # reverse the string\n        s = s[::-1]\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. create a list of lists\n        # 2. create a list of medians\n        # 3. create a list of medians\n        # 4. create a list of medians\n        # 5. create a list of medians\n        # 6. create a list of medians\n        # 7. create a list of medians\n        # 8. create a list of medians\n        # 9. create a list of medians\n        # 10. create a list of medians\n        # 11. create a list of medians\n        # 12. create a list of medians\n        # 13. create a list of medians\n        # 14. create a list of medians\n        # 15. create a list of medians\n        # 16. create a list of medians\n        # 17. create a list of medians\n        # 18. create a list of medians\n        # 19. create a list of medians\n        # 20. create a list of medians\n        # 21. create a list of medians\n        # 22. create a list of medians\n        # 23. create a list of medians\n        # 24. create a list of medians\n        # 25. create a list of medians\n        # 26. create a list of medians\n        # 27. create a list of medians\n        # 28. create a list of medians\n        # 29. create a list of medians\n        # 30. create a list of medians\n        # 31. create a list of medians\n        # 32. create a list of medians\n        # 33. create a list of medians\n        # 34. create a list of medians\n        # 35. create a list of medians\n        # 36. create a list of medians\n        # 37. create a list of medians\n        # 38. create a list of medians\n        # 39. create a list of medians\n        # 40. create a list of medians\n        # 41. create a list of medians\n        # 42. create a list of medians\n        # 43. create a list of medians\n        # 44. create a list of medians\n        # 45. create a list of medians\n        # 46. create a list of medians\n        # 47. create a list of medians\n        # 48. create a list of medians\n        # 49. create a list of medians\n        # 50. create a list of medians\n        # 51. create a list of medians\n        # 52. create a list of medians\n        # 53. create a list of medians\n        # 54. create a list of medians\n        # 55. create a list of medians\n        # 56. create a list of medians\n        # 57. create a list of medians\n        # 58. create a list of medians\n        # 59. create a list of medians\n        # 60. create a list of medians\n        # 61. create a list of medians\n        # 62. create a list of medians\n        # 63. create a list of medians\n        # 64. create a list of medians\n        # 65. create a list of medians\n        # 66. create a list of medians\n        # 67. create a list of medians\n        # 68. create a list of medians\n        # 69. create a list of medians\n        # 70. create a list of medians\n        # 71. create a list of medians\n        # 72. create a list of medians\n        # 73. create a list of medians\n        # 74. create a list of medians\n        # 75. create a list of medians\n        # 76. create a list of medians\n        # 77. create a list of medians\n        # 78. create a list of medians\n        # 79. create a list of medians\n        # 80. create"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr.next = head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.left.val + root.right.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0000000001\n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if len(p) == 0:\n            return len(s) == 0\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in sorted(tickets):\n            graph[from_city].append(to_city)\n            \n        # dfs\n        res = []\n        def dfs(from_city):\n            # if there is no more city to visit, add the current city to the result\n            if len(graph[from_city]) == 0:\n                res.append(from_city)\n                return\n            # if there is still more city to visit, visit the next city\n            for i in range(len(graph[from_city])):\n                next_city = graph[from_city][i]\n                graph[from_city].pop(i)\n                dfs(next_city)\n                graph[from_city].insert(i, next_city)\n                \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current building index\n        current_building_index = 0\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None or the current building is not the same as the current building\n            if current_building is None or current_building[0] != building[0]:\n                # if the current building is not None\n                if current_building is not None:\n                    # add the current building to the result list\n                    result.append([current_building[0], current_building[1], current_height])\n                # set the current building to the current building\n                current_building = building\n                # set the current building index to the current building index\n                current_building_index = building[0]\n            # if the current building is not None\n            if current_building is not None:\n                # if the current building is not the same as the current building\n                if current_building[0] != building[0]:\n                    # if the current building is not None\n                    if current_building is not None:\n                        # add the current building to the result list\n                        result.append([current_building[0], current_building[1], current_height])\n                    # set the current building to the current building\n                    current_building = building\n                    # set the current building index to the current building index\n                    current_building_index = building[0]\n                # if the current building is not None\n                if current_building is not None:\n                    # if the current building is not the same as the current building\n                    if current_building[0] != building[0]:\n                        # if the current building is not None\n                        if current_building is not None:\n                            # add the current building to the result list\n                            result.append([current_building[0], current_building[1], current_height])\n                        # set the current building to the current building\n                        current_building = building\n                        # set the current building index to the current building index\n                        current_building_index = building[0]\n                    # if the current building is not None\n                    if current_building is not None:\n                        # if the current building is not the same as the current building\n                        if current_building[0] != building[0]:\n                            # if the current building is not None\n                            if current_building is not None:\n                                # add the current building to the result list\n                                result.append([current_building[0], current_building[1], current_height])\n                            # set the current building to the current building\n                            current_building = building\n                            # set the current building index to the current building index\n                            current_building_index = building[0]\n                        # if the current building is not None\n                        if current_building is not None:\n                            # if the current building is not the same as the current building\n                            if current_building[0] != building[0]:\n                                # if the current building is not None\n                                if current_building is not None:\n                                    # add the current building to the result list\n                                    result.append([current_building[0], current_building[1], current_height])\n                                # set the current building to the current building\n                                current_building = building\n                                # set the current building index to the current building index\n                                current_building_index = building[0]\n                            # if the current building is not None\n                            if current_building is not None:\n                                # if the current building is not the same as the current building\n                                if current_building[0] != building[0]:\n                                    # if the current building is not None\n                                    if current_building is not None:\n                                        # add the current building to the result list\n                                        result.append([current_building[0], current_building[1], current_height])\n                                    # set the current building to the current building\n                                    current_building = building\n                                    # set the current building index to the current building index\n                                    current_building_index = building[0]\n                                # if the current building is not None\n                                if current_building is not None:\n                                    # if the current building is not the same as the current building\n                                    if current_building[0] != building[0]:"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1,len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i-1][j]\n                elif j == len(triangle[i])-1:\n                    triangle[i][j] += triangle[i-1][j-1]\n                else:\n                    triangle[i][j] += min(triangle[i-1][j],triangle[i-1][j-1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        def helper(num):\n            if num < 10:\n                return ones[num]\n            elif num < 20:\n                return teens[num - 10]\n            elif num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            elif num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            elif num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            elif num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            else:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        p1 = dummy1\n        p2 = dummy2\n        \n        while head:\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            else:\n                p2.next = head\n                p2 = p2.next\n            head = head.next\n        \n        p1.next = dummy2.next\n        p2.next = None\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. build a graph\n        # 2. find the root\n        # 3. find the cycle\n        # 4. find the edge that is not in the cycle\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        \n        # find the root\n        root = None\n        for u in graph:\n            if len(graph[u]) == 0:\n                root = u\n                break\n        \n        # find the cycle\n        visited = set()\n        cycle = None\n        def dfs(u):\n            nonlocal cycle\n            if u in visited:\n                return False\n            visited.add(u)\n            for v in graph[u]:\n                if dfs(v):\n                    cycle = (u, v)\n                    return True\n            return False\n        \n        dfs(root)\n        \n        # find the edge that is not in the cycle\n        if cycle:\n            u, v = cycle\n            graph[u].remove(v)\n            graph[v].remove(u)\n            return [u, v]\n        else:\n            return [root, root]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            \n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n                \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Using set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 104 ms, faster than 98.24% of Python online submissions for Single Number.\n        ## Memory Usage: 14.9 MB, less than 98.24% of Python online submissions for Single Number.\n        ## set() is a built-in data structure in Python that allows you to store a collection of unique elements.\n        ## It is a set, which means that it contains only unique elements.\n        ## The set() constructor takes a list of elements as an argument, and it creates a new set with those elements.\n        ## The set() constructor is used to create an empty set.\n        ## The add() method is used to add an element to the set.\n        ## The remove() method is used to remove an element from the set.\n        ## The discard() method is used to remove an element from the set if it is present.\n        ## The pop() method is used to remove and return an element from the set.\n        ## The clear() method is used to remove all the elements from the set.\n        ## The len() method is used to get the length of the set.\n        ## The in and not in operators are used to check if an element is present in the set.\n        ## The union() method is used to combine two sets and return a new set with all the elements from both sets.\n        ## The intersection() method is used to find the intersection of two sets and return a new set with all the common elements.\n        ## The difference() method is used to find the difference of two sets and return a new set with all the elements from the first set that are not in the second set.\n        ## The symmetric_difference() method is used to find the symmetric difference of two sets and return a new set with all the elements from the first set that are not in the second set, or all the elements from the second set that are not in the first set.\n        ## The update() method is used to add elements from another set to the current set.\n        ## The copy() method is used to create a shallow copy of the set.\n        ## The frozenset() method is used to create a frozen set, which is a read-only version of a set.\n        ## The set() constructor is used to create a new set.\n        ## The add() method is used to add an element to the set.\n        ## The remove() method is used to remove an element from the set.\n        ## The discard() method is used to remove an element from the set if it is present.\n        ## The pop() method is used to remove and return an element from the set.\n        ## The clear() method is used to remove all the elements from the set.\n        ## The len() method is used to get the length of the set.\n        ## The in and not in operators are used to check if an element is present in the set.\n        ## The union() method is used to combine two sets and return a new set with all the elements from both sets.\n        ## The intersection() method is used to find the intersection of two sets and return a new set with all the common elements.\n        ## The difference() method is used to find the difference of two sets and return a new set with all the elements from the first set that are not in the second set.\n        ## The symmetric_difference() method is used to find the symmetric difference of two sets and return a new set with all the elements from the first set that are not in the second set, or all the elements from the second set that are not in the first set.\n        ## The update() method is used to add elements from another set to the current set.\n        ## The copy() method is used to create a shallow copy of the set.\n        ## The frozenset() method is used to create a frozen set, which is a read-only version of a set.\n        ## The set() constructor is used to create a new set.\n        ## The add() method is used to add an element to the set.\n        ## The remove() method is used to remove an element from the set.\n        ## The discard() method is used to remove an element from the set if it is present.\n        ## The pop() method is used to remove and return an element from the set.\n        ## The clear() method is used to"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + dp[i][j - 1][k] + dp[i][j][k - 1]\n                    if grid[i][j] != -1:\n                        dp[i][j][k] += grid[i][j]\n                        if j > 0:\n                            dp[i][j][k] += dp[i - 1][j - 1][k]\n                        if k > 0:\n                            dp[i][j][k] += dp[i][j][k - 1]\n                        if j > 0 and k > 0:\n                            dp[i][j][k] -= grid[i][j]\n        return max(dp[n - 1][n - 1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # O(log n) runtime\n        # O(1) space\n        \n        # edge case\n        if target < nums[0]:\n            return 0\n        if target > nums[-1]:\n            return len(nums)\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # return the index where it would be if it were inserted in order\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211211131221131211131221'\n        \n        if n == 13:\n            return '132113213211231131221121113122112311311222113121132122212321322211'\n        \n        if n == 14:\n            return '11131221133112132133221123113122112111312211231131122211312113212221232132221123113122112111312211231131221113122123213222112311312211211131221123113122111312212321322211231131221121113122112311312211131221232132221123113122112111312211231131221113122123213222112311312211211131221123113122111312212321322211231131221121113122112311312211131221232132221123113122112111312211231131221113122123213222112311312211211131221123113122111312212321322211231131221121113122112311312211131221232132221123113122112111312211231131221113122123213222112311312211211131221123113122111312212321322211231131221121113122112311312211131221232"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    cnt += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return cnt <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the pivot is not found, return -1\n        if pivot == -1:\n            return -1\n        \n        # if the target is less than the first element, search the right side\n        if target >= nums[0]:\n            return self.binary_search(nums, target, 0, pivot)\n        \n        # if the target is greater than the first element, search the left side\n        else:\n            return self.binary_search(nums, target, pivot, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        \"\"\"\n        Find the pivot in the rotated array\n        \"\"\"\n        left = 0\n        right = len(nums) - 1\n        \n        # if the array is not rotated, return -1\n        if nums[left] < nums[right]:\n            return -1\n        \n        # binary search to find the pivot\n        while left <= right:\n            mid = (left + right) // 2\n            \n            # if the mid element is greater than the next element, it is the pivot\n            if nums[mid] > nums[mid + 1]:\n                return mid + 1\n            \n            # if the mid element is less than the previous element, it is the pivot\n            elif nums[mid - 1] > nums[mid]:\n                return mid\n            \n            # if the mid element is greater than the first element, search the right side\n            elif nums[mid] > nums[left]:\n                left = mid + 1\n            \n            # if the mid element is less than the first element, search the left side\n            else:\n                right = mid - 1\n        \n        return -1\n    \n    def binary_search(self, nums, target, left, right):\n        \"\"\"\n        Binary search to find the target in the rotated array\n        \"\"\"\n        while left <= right:\n            mid = (left + right) // 2\n            \n            # if the target is found, return the index\n            if nums[mid] == target:\n                return mid\n            \n            # if the target is greater than the mid element, search the right side\n            elif nums[mid] < target:\n                left = mid + 1\n            \n            # if the target is less than the mid element, search the left side\n            else:\n                right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def backtrack(combination, next_digits, mapping):\n            if len(next_digits) == 0:\n                combinations.append(combination)\n            else:\n                for letter in mapping[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:], mapping)\n        \n        combinations = []\n        backtrack(\"\", digits, mapping)\n        return combinations"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of the string\n        length = len(n)\n        \n        # 2. get the number of digits in the string\n        digits = length // 2\n        \n        # 3. get the left and right halves of the string\n        left = n[:digits]\n        right = n[digits:]\n        \n        # 4. get the possible palindromes\n        possible = [int(left + right), int(left + \"0\" + right[::-1]), int(left + \"1\" + right[1:]), int(left + \"9\" + right[1:])]\n        \n        # 5. get the closest palindrome\n        closest = min(possible, key=lambda x: abs(x - int(n)))\n        \n        # 6. return the closest palindrome\n        return str(closest)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n-1\n        col_start = 0\n        col_end = n-1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            for i in range(col_end, col_start-1, -1):\n                matrix[row_end][i] = num\n                num += 1\n            row_end -= 1\n            \n            for i in range(row_end, row_start-1, -1):\n                matrix[i][col_start] = num\n                num += 1\n            col_start += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        else:\n            return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]\n                \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## TLE\n        ## 2022.04.20\n        ## 1. Brute force\n        ## 2. DP\n        ## 3. DP + Prefix and Suffix\n        ## 4. DP + Prefix and Suffix + Maximum Subarray\n        ## 5. DP + Prefix and Suffix + Maximum Subarray + Maximum Product\n        ## 6. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray\n        ## 7. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray\n        ## 8. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 9. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 10. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 11. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 12. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 13. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 14. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 15. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 16. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 17. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 18. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 19. DP + Prefix and Suffix + Maximum Subarray + Maximum Product + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray + Maximum Subarray\n        ## 20. D"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in encoma(score_sorted):\n            score_rank[s] = i\n        \n        # create a list of the ranks\n        rank = []\n        for s in score:\n            rank.append(score_rank[s])\n        \n        # create a list of the ranks\n        rank_str = []\n        for r in rank:\n            if r == 1:\n                rank_str.append(\"Gold Medal\")\n            elif r == 2:\n                rank_str.append(\"Silver Medal\")\n            elif r == 3:\n                rank_str.append(\"Bronze Medal\")\n            else:\n                rank_str.append(str(r))\n        \n        return rank_str"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        curr_str = \"\"\n        for i in range(len(s)):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n            else:\n                if curr_len > max_len:\n                    max_len = curr_len\n                curr_str = curr_str[curr_str.index(s[i])+1:] + s[i]\n                curr_len = len(curr_str)\n        if curr_len > max_len:\n            max_len = curr_len\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        for i in range(word_len):\n            word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list_len)\n        word_dict_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len):\n            word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the current element is less than the previous element\n        # 3. if it is, then we have a chunk\n        # 4. if it is not, then we have a new chunk\n        # 5. return the number of chunks\n        \n        # 1. sort the array\n        arr.sort()\n        \n        # 2. iterate through the array and check if the current element is less than the previous element\n        # 3. if it is, then we have a chunk\n        # 4. if it is not, then we have a new chunk\n        # 5. return the number of chunks\n        \n        # 2. iterate through the array and check if the current element is less than the previous element\n        # 3. if it is, then we have a chunk\n        # 4. if it is not, then we have a new chunk\n        # 5. return the number of chunks\n        \n        # 3. if it is, then we have a chunk\n        # 4. if it is not, then we have a new chunk\n        # 5. return the number of chunks\n        \n        # 4. if it is, then we have a chunk\n        # 5. if it is not, then we have a new chunk\n        # 6. return the number of chunks\n        \n        # 5. if it is, then we have a chunk\n        # 6. if it is not, then we have a new chunk\n        # 7. return the number of chunks\n        \n        # 6. if it is, then we have a chunk\n        # 7. if it is not, then we have a new chunk\n        # 8. return the number of chunks\n        \n        # 7. if it is, then we have a chunk\n        # 8. if it is not, then we have a new chunk\n        # 9. return the number of chunks\n        \n        # 8. if it is, then we have a chunk\n        # 9. if it is not, then we have a new chunk\n        # 10. return the number of chunks\n        \n        # 9. if it is, then we have a chunk\n        # 10. if it is not, then we have a new chunk\n        # 11. return the number of chunks\n        \n        # 10. if it is, then we have a chunk\n        # 11. if it is not, then we have a new chunk\n        # 12. return the number of chunks\n        \n        # 11. if it is, then we have a chunk\n        # 12. if it is not, then we have a new chunk\n        # 13. return the number of chunks\n        \n        # 12. if it is, then we have a chunk\n        # 13. if it is not, then we have a new chunk\n        # 14. return the number of chunks\n        \n        # 13. if it is, then we have a chunk\n        # 14. if it is not, then we have a new chunk\n        # 15. return the number of chunks\n        \n        # 14. if it is, then we have a chunk\n        # 15. if it is not, then we have a new chunk\n        # 16. return the number of chunks\n        \n        # 15. if it is, then we have a chunk\n        # 16. if it is not, then we have a new chunk\n        # 17. return the number of chunks\n        \n        # 16. if it is, then we have a chunk\n        # 17. if it is not, then we have a new chunk\n        # 18. return the number of chunks\n        \n        # 17. if it is, then we have a chunk\n        # 18. if it is not, then we have a new chunk\n        # 19. return the number of chunks\n        \n        # 18. if it is, then we have a chunk\n        # 19. if it is not, then we have a new chunk\n        # 20. return the number of chunks\n        \n        # 19. if it is, then we have a chunk\n        # 20. if it is"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head\n        while cur:\n            if cur.next and cur.val > cur.next.val:\n                prev = dummy\n                while prev.next.val < cur.next.val:\n                    prev = prev.next\n                cur.next, cur.next.next, prev.next = cur.next.next, cur.next, prev.next\n            else:\n                cur = cur.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the matrix with the length of word1 + 1 and word2 + 1\n        # The first row and column will be initialized to 0\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first row will be initialized to the length of word1 + 1\n        # The first column will be initialized to the length of word2 + 1\n        # The first"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        \n        left_paths = self.binaryTreePaths(root.left)\n        right_paths = self.binaryTreePaths(root.right)\n        \n        paths = []\n        for left_path in left_paths:\n            paths.append(str(root.val) + \"->\" + left_path)\n            \n        for right_path in right_paths:\n            paths.append(str(root.val) + \"->\" + right_path)\n            \n        return paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n        \n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total\n            total += course[0]\n            \n            # if total exceeds course duration\n            if total > course[1]:\n                # remove course with longest duration\n                total -= heapq.heappop(pq)\n                \n        # return number of courses\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = nxt\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % len(s[0]) != 0:\n        #     return False\n        # for i in range(len(s)//len(s[0])):\n        #     if s[i*len(s[0]):] == s[0:len(s[0])]:\n        #         return True\n        # return False\n        \n        return s in (s+s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O("}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not set(target).issubset(set(sticker)):\n                    continue\n                res = min(res, dfs(target.replace(sticker, '', 1)) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## O(n) time and O(n) space\n        ## return True if any value appears at least twice in the array, and return false if every element is distinct.\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        return median"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1650,2401,2401,1650,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,405,1140,2520,4062,5714,6435,5714,4062,2520,1140,405,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,420,1260,3003,5679,8762,11540,13428,13428,11540,8762,5679,3003,1260,420,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,442,1386,3430,7014,11430,16878,22804,27720,28204,22804,16878,11430,7014,3430,1386,442,102,18,1]\n        if rowIndex == 19:\n            return [1,19,103,466,1486,3876,8324,14470,22792,32752,43788,54272,54272,43788,32752,22792,14470,832"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub204\uace0, \ub098\uba38\uc9c0\ub97c \ub4a4\uc5d0 \uc788\ub294 \uc218\ub85c \ub098\ub208\ub2e4.\n        # 3. \ub098\uba38\uc9c0\uac00 0\uc774 \ub418\uba74 \uc81c\uacf1\uadfc\uc774 \ub41c\ub2e4.\n        # 4. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 5. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 6. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 7. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 8. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 9. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 10. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 11. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 12. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 13. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 14. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 15. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 16. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \uc544\ub2c8\ub41c\ub2e4.\n        # 17. \ub098\uba38\uc9c0\uac00 0\uc774 \uc544\ub2c8\uba74 \uc81c\uacf1\uadfc\uc774 \ufffd"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"_\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # build the queue\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        distance = 1\n        res = []\n        \n        while queue:\n            for i in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    res.append([])\n                for i in range(len(word)):\n                    pattern = word[:i] + \"_\" + word[i+1:]\n                    for nei in graph[pattern]:\n                        if nei not in visited:\n                            queue.append(nei)\n                            visited.add(nei)\n            distance += 1\n        \n        # build the result\n        if len(res) == 0:\n            return []\n        res = res[::-1]\n        for i in range(len(res)):\n            res[i] = [beginWord] + res[i]\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n            \n        if n == 1:\n            return True\n        else:\n            return False"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path)\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                backtrack(i+1, path+[nums[i]])\n        backtrack(0, [])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        \n        area = 0\n        \n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            \n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n            \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        for rect in rectangles:\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[1] == y_min and rect[3] == y_max and rect[0] == x_min and rect[2] == x_max:\n                continue\n            if rect[1] == y_min and rect[3] == y_max and rect[0] == x_max and rect[2] == x_min:\n                continue\n            if rect[1] == y_max and rect[3] == y_min and rect[0] == x_min and rect[2] == x_max:\n                continue\n            if rect[1] == y_max and rect[3] == y_min and rect[0] == x_max and rect[2] == x_min:\n                continue\n            \n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a string\n        board_str = \"\"\n        for row in board:\n            for num in row:\n                board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a string\n        board_str = \"\"\n        for num in board_list:\n            board_str += str(num)\n        \n        # convert"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = t[i]\n            else:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            \n            if t[i] not in t_dict:\n                t_dict[t[i]] = s[i]\n            else:\n                if t_dict[t[i]] != s[i]:\n                    return False\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            return nums[0] == target\n        \n        if nums[0] < nums[-1]:\n            return binary_search(nums, target)\n        \n        pivot = -1\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                pivot = mid + 1\n                break\n            elif nums[mid] < nums[mid - 1]:\n                pivot = mid\n                break\n            else:\n                if nums[mid] > nums[left]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        if pivot == -1:\n            return binary_search(nums, target)\n        \n        if nums[pivot] == target:\n            return True\n        \n        if nums[0] <= target:\n            return binary_search(nums[:pivot + 1], target) or binary_search(nums[pivot + 1:], target)\n        else:\n            return binary_search(nums[pivot + 1:], target) or binary_search(nums[:pivot + 1], target)"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            \n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n                \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root == None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            left = dfs(root.left)\n            right = dfs(root.right)\n            return [root.val] + left + right\n        \n        def count(root):\n            if not root:\n                return []\n            left = count(root.left)\n            right = count(root.right)\n            if root.val in left:\n                return [root.val] + left\n            elif root.val in right:\n                return [root.val] + right\n            else:\n                return [root.val] + left + right\n        \n        return count(root)"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        curr_row = 0\n        going_down = False\n        \n        for c in s:\n            res[curr_row] += c\n            if curr_row == 0 or curr_row == numRows - 1:\n                going_down = not going_down\n            curr_row += 1 if going_down else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-05-25\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        ## 12:00\n        #"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## 1 <= n <= 10\u2075\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <="}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            i = j = 0\n            res = []\n            \n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n                    \n            while i < len(left):\n                res.append(left[i])\n                i += 1\n                \n            while j < len(right):\n                res.append(right[j])\n                j += 1\n                \n            return res\n        \n        return [x[1] for x in mergeSort([(num, i) for i, num in enumerate(nums)])]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max and min\n        max_num = -1\n        min_num = 10**9\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # update the max and min\n            max_num = max(max_num, interval[1])\n            min_num = min(min_num, interval[0])\n            \n        # iterate over the intervals\n        for interval in intervals:\n            # update the result\n            res += max_num - interval[1]\n            \n            # update the max and min\n            max_num = max(max_num, interval[1] + 1)\n            min_num = min(min_num, interval[0] + 1)\n            \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n            \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(float('inf'))\n        \n        # iterate\n        while i < len(nums):\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                if n >= nums[i]:\n                    n = n + nums[i]\n                else:\n                    count += 1\n                    n = n + nums[i]\n            if n < 0:\n                break\n        return count"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c \ubc29\ubc95\n        # 2. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 3. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 4. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 5. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 6. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 7. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 8. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 9. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 10. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 11. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 12. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 13. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 14. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 15. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 16. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 17. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 18. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\ufffd"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        fraction = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            fraction += str(quotient)\n            \n            if remainder in remainder_dict:\n                fraction = fraction[:remainder_dict[remainder]] + \"(\" + fraction[remainder_dict[remainder]:] + \")\"\n                break\n            else:\n                remainder_dict[remainder] = len(remainder_dict)\n        \n        return str(sign * quotient) + \".\" + fraction"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        l1 = self.sortList(head)\n        l2 = self.sortList(mid)\n        \n        return self.merge(l1, l2)\n    \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        if l1:\n            curr.next = l1\n        if l2:\n            curr.next = l2\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # find the longest increasing subsequence\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## row = [0]*m\n        ## col = [0]*n\n        ## for i in range(m):\n        ##     for j in range(n):\n        ##         if matrix[i][j] == 0:\n        ##             row[i] = 1\n        ##             col[j] = 1\n        ## for i in range(m):\n        ##     for j in range(n):\n        ##         if row[i] == 1 or col[j] == 1:\n        ##             matrix[i][j] = 0\n        \n        ## O(1) space\n        m = len(matrix)\n        n = len(matrix[0])\n        row = [0]*m\n        col = [0]*n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row[i] = 1\n                    col[j] = 1\n        for i in range(m):\n            for j in range(n):\n                if row[i] == 1 or col[j] == 1:\n                    matrix[i][j] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move the slow and fast pointers until fast reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the updated head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the sum of all the dresses\n        # 2. find the max dresses in a machine\n        # 3. find the min dresses in a machine\n        # 4. find the max dresses in a machine\n        # 5. find the min dresses in a machine\n        # 6. find the max dresses in a machine\n        # 7. find the min dresses in a machine\n        # 8. find the max dresses in a machine\n        # 9. find the min dresses in a machine\n        # 10. find the max dresses in a machine\n        # 11. find the min dresses in a machine\n        # 12. find the max dresses in a machine\n        # 13. find the min dresses in a machine\n        # 14. find the max dresses in a machine\n        # 15. find the min dresses in a machine\n        # 16. find the max dresses in a machine\n        # 17. find the min dresses in a machine\n        # 18. find the max dresses in a machine\n        # 19. find the min dresses in a machine\n        # 20. find the max dresses in a machine\n        # 21. find the min dresses in a machine\n        # 22. find the max dresses in a machine\n        # 23. find the min dresses in a machine\n        # 24. find the max dresses in a machine\n        # 25. find the min dresses in a machine\n        # 26. find the max dresses in a machine\n        # 27. find the min dresses in a machine\n        # 28. find the max dresses in a machine\n        # 29. find the min dresses in a machine\n        # 30. find the max dresses in a machine\n        # 31. find the min dresses in a machine\n        # 32. find the max dresses in a machine\n        # 33. find the min dresses in a machine\n        # 34. find the max dresses in a machine\n        # 35. find the min dresses in a machine\n        # 36. find the max dresses in a machine\n        # 37. find the min dresses in a machine\n        # 38. find the max dresses in a machine\n        # 39. find the min dresses in a machine\n        # 40. find the max dresses in a machine\n        # 41. find the min dresses in a machine\n        # 42. find the max dresses in a machine\n        # 43. find the min dresses in a machine\n        # 44. find the max dresses in a machine\n        # 45. find the min dresses in a machine\n        # 46. find the max dresses in a machine\n        # 47. find the min dresses in a machine\n        # 48. find the max dresses in a machine\n        # 49. find the min dresses in a machine\n        # 50. find the max dresses in a machine\n        # 51. find the min dresses in a machine\n        # 52. find the max dresses in a machine\n        # 53. find the min dresses in a machine\n        # 54. find the max dresses in a machine\n        # 55. find the min dresses in a machine\n        # 56. find the max dresses in a machine\n        # 57. find the min dresses in a machine\n        # 58. find the max dresses in a machine\n        # 59. find the min dresses in a machine\n        # 60. find the max dresses in a machine\n        # 61. find the min dresses in a machine\n        # 62. find the max dresses in a machine\n        # 63. find the min dresses in a machine\n        # 64. find the max dresses in a machine\n        # 65. find the min dresses in a machine\n        # 66. find the max dresses in a machine\n        # 67. find the min dresses in a machine\n        # 68. find the max dresses in a machine\n        # 69. find the min dresses in a machine\n        # 70. find the max dresses in a machine\n        # 71. find the min dresses in a machine\n        # 72. find the max dresses in a machine\n        # 73. find the min dresses in a machine\n        # 74. find the max dresses in"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.next.val)\n        slow.next = None\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        max_area = 0\n        for i in range(n):\n            height = [0] * m\n            for j in range(m):\n                if matrix[j][i] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        for i in range(m):\n            height = [0] * n\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            height = [0] * n\n            for j in range(n-1, -1, -1):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for j in range(n):\n            height = [0] * m\n            for i in range(m-1, -1, -1):\n                if matrix[i][j] == '1':\n                    height[i] += 1\n                else:\n                    height[i] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        return max_area\n    \n    def largestRectangleArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n        \n        stack = []\n        max_area = 0\n        for i in range(len(height)):\n            while stack and height[stack[-1]] > height[i]:\n                h = height[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = height[stack.pop()]\n            w = len(height) if not stack else len(height) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. binary search\n        \n        # 1. find the pivot point\n        # 1.1 find the pivot point\n        # 1.2 find the pivot point\n        # 1.3 find the pivot point\n        # 1.4 find the pivot point\n        # 1.5 find the pivot point\n        # 1.6 find the pivot point\n        # 1.7 find the pivot point\n        # 1.8 find the pivot point\n        # 1.9 find the pivot point\n        # 1.10 find the pivot point\n        # 1.11 find the pivot point\n        # 1.12 find the pivot point\n        # 1.13 find the pivot point\n        # 1.14 find the pivot point\n        # 1.15 find the pivot point\n        # 1.16 find the pivot point\n        # 1.17 find the pivot point\n        # 1.18 find the pivot point\n        # 1.19 find the pivot point\n        # 1.20 find the pivot point\n        # 1.21 find the pivot point\n        # 1.22 find the pivot point\n        # 1.23 find the pivot point\n        # 1.24 find the pivot point\n        # 1.25 find the pivot point\n        # 1.26 find the pivot point\n        # 1.27 find the pivot point\n        # 1.28 find the pivot point\n        # 1.29 find the pivot point\n        # 1.30 find the pivot point\n        # 1.31 find the pivot point\n        # 1.32 find the pivot point\n        # 1.33 find the pivot point\n        # 1.34 find the pivot point\n        # 1.35 find the pivot point\n        # 1.36 find the pivot point\n        # 1.37 find the pivot point\n        # 1.38 find the pivot point\n        # 1.39 find the pivot point\n        # 1.40 find the pivot point\n        # 1.41 find the pivot point\n        # 1.42 find the pivot point\n        # 1.43 find the pivot point\n        # 1.44 find the pivot point\n        # 1.45 find the pivot point\n        # 1.46 find the pivot point\n        # 1.47 find the pivot point\n        # 1.48 find the pivot point\n        # 1.49 find the pivot point\n        # 1.50 find the pivot point\n        # 1.51 find the pivot point\n        # 1.52 find the pivot point\n        # 1.53 find the pivot point\n        # 1.54 find the pivot point\n        # 1.55 find the pivot point\n        # 1.56 find the pivot point\n        # 1.57 find the pivot point\n        # 1.58 find the pivot point\n        # 1.59 find the pivot point\n        # 1.60 find the pivot point\n        # 1.61 find the pivot point\n        # 1.62 find the pivot point\n        # 1.63 find the pivot point\n        # 1.64 find the pivot point\n        # 1.65 find the pivot point\n        # 1.66 find the pivot point\n        # 1.67 find the pivot point\n        # 1.68 find the pivot point\n        # 1.69 find the pivot point\n        # 1.70 find the pivot point\n        # 1.71 find the pivot point\n        # 1.72 find the pivot point\n        # 1.73 find the pivot point\n        # 1.74 find the pivot point\n        # 1.75 find the pivot point\n        # 1.76 find the pivot point\n        # 1"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or len(s) == 0:\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] == '-' or s[0] == '+':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if not s or len(s) == 0:\n            return False\n        \n        if s[0] == 'e':\n            return False\n        \n        if s["}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        roman_dict = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_num = ''\n        \n        for key in sorted(roman_dict.keys(), reverse=True):\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n                \n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 12:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 13:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 14:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 15:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 16:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 17:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 18:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 19:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 20:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 21:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 22:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 23:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 24:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 25:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 26:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 27:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Solution 2"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def is_valid(board,row,col,num):\n            return not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row - row%3,col - col%3,num)\n        \n        def solve_sudoku(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if is_valid(board,row,col,str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        #"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        if num < 1:\n            return False\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        if i * i == num:\n            return True\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        while head != None and head.val == val:\n            head = head.next\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n            \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, board, word, visited, res):\n            if len(word) == 0:\n                res.append(word)\n                return\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            if board[i][j] != word[0]:\n                return\n            if (i, j) in visited:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j, board, word[1:], visited, res)\n            dfs(i - 1, j, board, word[1:], visited, res)\n            dfs(i, j + 1, board, word[1:], visited, res)\n            dfs(i, j - 1, board, word[1:], visited, res)\n            visited.remove((i, j))\n            \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        dfs(i, j, board, word, set(), res)\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for i in range(9):\n            col = [row[i] for row in board]\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                if len(set(box)) != len(box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list\n        # 2. reverse the list\n        # 3. iterate through the list\n        # 4. multiply the current number by 26^(index)\n        # 5. add the current number to the total\n        # 6. return the total\n        \n        # 1. convert the string to a list\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle)):\n            \n            # 4. multiply the current number by 26^(index)\n            current_number = ord(columnTitle[i]) - 64\n            current_number = current_number * (26**i)\n            \n            # 5. add the current number to the total\n            total += current_number\n            \n        # 6. return the total\n        return total"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        # connect the first half back to the second half\n        first.next = second\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the dictionary, check if the word is the same as the previous word\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the dictionary, add it to the dictionary with the word as the value\n            else:\n                mapping[letter] = word\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)\n        \n        # binary search\n        # O(log(m*n))\n        # O(1)"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a new list node\n        head = ListNode()\n        # create a pointer to the new list node\n        ptr = head\n        # create a carry variable\n        carry = 0\n        # loop until both lists are empty\n        while l1 and l2:\n            # add the values of the two lists\n            sum = l1.val + l2.val + carry\n            # if the sum is greater than 10, set carry to 1\n            if sum > 9:\n                carry = 1\n                sum = sum % 10\n            else:\n                carry = 0\n            # create a new list node with the sum\n            ptr.next = ListNode(sum)\n            # move the pointers to the next node\n            ptr = ptr.next\n            # move the pointers to the next node\n            l1 = l1.next\n            l2 = l2.next\n        # if the first list is longer than the second list, add the remaining nodes to the new list\n        while l1:\n            sum = l1.val + carry\n            if sum > 9:\n                carry = 1\n                sum = sum % 10\n            else:\n                carry = 0\n            ptr.next = ListNode(sum)\n            ptr = ptr.next\n            l1 = l1.next\n        # if the second list is longer than the first list, add the remaining nodes to the new list\n        while l2:\n            sum = l2.val + carry\n            if sum > 9:\n                carry = 1\n                sum = sum % 10\n            else:\n                carry = 0\n            ptr.next = ListNode(sum)\n            ptr = ptr.next\n            l2 = l2.next\n        # if there is a carry, add a new node to the new list\n        if carry == 1:\n            ptr.next = ListNode(1)\n        # return the new list\n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert to binary\n        ## 2. reverse the binary\n        ## 3. convert back to decimal\n        \n        ## 1. convert to binary\n        binary = bin(num)[2:]\n        ## 2. reverse the binary\n        binary = binary[::-1]\n        ## 3. convert back to decimal\n        decimal = int(binary, 2)\n        \n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        dp = [0] * len(nums)\n        for i in range(1, len(nums)):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Brute force\n        # Time complexity: O(n^2)\n        # Space complexity: O(1)\n        # max_area = 0\n        # for i in range(len(height)):\n        #     for j in range(i+1, len(height)):\n        #         area = min(height[i], height[j]) * (j-i)\n        #         max_area = max(max_area, area)\n        # return max_area\n        \n        # Two pointers\n        # Time complexity: O(n)\n        # Space complexity: O(1)\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n), range(col, n)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    count += backtrack(board, row + 1)\n                    board[row][col] = '.'\n            return count\n        \n        board = [['.' for _ in range(n)] for _ in range(n)]\n        return backtrack(board, 0)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third max\n        # 3. if the third max is not in the list, return the last max\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            if nums[-3] not in nums[-2:-1]:\n                return nums[-3]\n            else:\n                return nums[-2]"}]}