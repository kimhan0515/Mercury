{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n - 1\n        top, bottom = 0, m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\""}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] that equals t[:j]\n        # dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] if s[i - 1] == t[j - 1]\n        #         = dp[i - 1][j]\n        # dp[0][j] = 1 if s[0] == t[j]\n        # dp[i][0] = 0 for i > 0\n        # dp[0][0] = 1\n        # dp[0][j] = 0 for j > 0\n        # dp[i][0] = 0 for i > 0\n        # dp[0][0] = 1\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j] = 0 for i, j > 0\n        # dp[i][j]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. Mark all negative numbers as 0\n        ## 2. Mark all numbers that are in the range [1, n] as 1\n        ## 3. Iterate through the array and find the first number that is not 1\n        ## 4. If all numbers are 1, return n + 1\n        ## 5. Otherwise, return the first number that is not 1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        ans = ''\n        nums = [i for i in range(1, n + 1)]\n        for i in range(n - 1, -1, -1):\n            fact //= i\n            ans += str(nums[k // fact])\n            nums.pop(k // fact)\n            k %= fact\n        \n        return ans"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Two Pointer Approach\n        # Since the array is sorted, we can use two pointers\n        # One pointer will be at the start of the array\n        # The other pointer will be at the end of the array\n        # We will keep moving the pointer towards the middle\n        # If the sum of the two pointers is less than the target, we will move the left pointer\n        # If the sum of the two pointers is greater than the target, we will move the right pointer\n        # If the sum of the two pointers is equal to the target, we will return the indices\n        # We will keep moving the pointer towards the middle until we find the sum\n        # If we cannot find the sum, we will return [-1, -1]\n        \n        # Initialize the left pointer at the start of the array\n        left = 0\n        # Initialize the right pointer at the end of the array\n        right = len(numbers) - 1\n        # While the left pointer is less than the right pointer\n        while left < right:\n            # If the sum of the two pointers is less than the target, we will move the left pointer\n            if numbers[left] + numbers[right] < target:\n                left += 1\n            # If the sum of the two pointers is greater than the target, we will move the right pointer\n            elif numbers[left] + numbers[right] > target:\n                right -= 1\n            # If the sum of the two pointers is equal to the target, we will return the indices\n            else:\n                return [left + 1, right + 1]\n        # We cannot find the sum, we will return [-1, -1]\n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\""}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, prev):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return prev * 10 + root.val\n            return dfs(root.left, prev * 10 + root.val) + dfs(root.right, prev * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        if total_gas < total_cost:\n            return -1\n        \n        curr_gas = 0\n        start = 0\n        for i in range(n):\n            curr_gas += gas[i] - cost[i]\n            if curr_gas < 0:\n                start = i + 1\n                curr_gas = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for l in range(2, n):\n            for i in range(n - l):\n                j = i + l\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp[i][j] = True if s[0:i] matches p[0:j]\n        # dp[i][j] = dp[i][j-1] if p[j-1] is '.'\n        # dp[i][j] = dp[i][j-2] if p[j-2] is '*' and the preceding character matches\n        # dp[i][j] = dp[i-1][j] if p[j-1] is not '*'\n        # dp[i][j] = dp[i][j] or dp[i-1][j-1]\n        # dp[0][0] = True\n        # dp[0][j] = dp[0][j-1] if p[j-1] is '*'\n        # dp[i][0] = False\n        # dp[i][0] = dp[i-1][0] if p[0] is '*'\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i][j-2]\n                else:\n                    dp[i][j] = dp[i][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')\n        \n        return dp[m][n]"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\""}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i ** 2 != num:\n                    sum += i + num // i\n                else:\n                    sum += i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n + 1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\n        for i in range(m - 2, -1, -1):\n            dp[i][-1] = max(1, dp[i + 1][-1] - dungeon[i][-1])\n        for j in range(n - 2, -1, -1):\n            dp[-1][j] = max(1, dp[-1][j + 1] - dungeon[-1][j])\n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            m = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= m:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = m\n            else:\n                l = m + 1\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i, j = 0, len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                longest = max(longest, curr_len)\n                \n        return longest"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## We can use the XOR property of the sum of the numbers in the range [0, n]\n        ## and the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in the range [0, n] with the sum of the numbers in the array.\n        ## We can XOR the sum of the numbers in"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(N * 26^L)\n        # Space: O(N)\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #\n        #"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        return bin(a + b)[2:]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] < target or (left < right and nums[mid + 1] == target):\n                    return mid\n                elif target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return -1\n        \n        left = binary_search(nums, target, True)\n        right = binary_search(nums, target, False)\n        return [left, right] if left != -1 else [-1, -1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        k = 0\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[k]:\n                k += 1\n                nums[k] = nums[i]\n        return k + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        cur_reach = 0\n        \n        for i in range(1, n):\n            if i > cur_reach:\n                jumps += 1\n                cur_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i], 0) for i in range(0, len(prices) - 1))\n        \n        dp = [0] * (k + 1)\n        for price in prices:\n            for i in range(1, k + 1):\n                dp[i] = max(dp[i], dp[i - 1] + price)\n                dp[i] = max(dp[i], dp[i - 1] - price)\n        return dp[k]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        hex_map = {10: \"a\", 11: \"b\", 12: \"c\", 13: \"d\", 14: \"e\", 15: \"f\"}\n        hex_map_inv = {10: \"0\", 11: \"1\", 12: \"2\", 13: \"3\", 14: \"4\", 15: \"5\"}\n        hex_map_inv_inv = {10: \"a\", 11: \"b\", 12: \"c\", 13: \"d\", 14: \"e\", 15: \"f\"}\n        hex_map_inv_inv_inv = {10: \"0\", 11: \"1\", 12: \"2\", 13: \"3\", 14: \"4\", 15: \"5\"}\n        \n        if num < 0:\n            num = 2 ** 32 + num\n        \n        hex_str = \"\"\n        while num > 0:\n            rem = num % 16\n            if rem < 10:\n                hex_str = str(rem) + hex_str\n            else:\n                hex_str = hex_map_inv[rem] + hex_str\n            num = num // 16\n        \n        if hex_str == \"\":\n            return \"0\"\n        \n        if hex_str[0] == \"0\":\n            return hex_str[1:]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we have not found a unique character.\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we have not found a unique character.\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we have not found a unique character.\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we have not found a unique character.\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we have not found a unique character.\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we have not found a unique character.\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we have not found a unique character.\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we have not found a unique character.\n        \n        # We can use a hashmap to store the frequency of each character in the string.\n        # We can also use a set to store the unique characters in the string.\n        # We can then iterate through the string and check if the character is in the set.\n        # If it is, we can return the index of the character.\n        # If it is not, we can increment the index by 1.\n        # We can then return -1 if we"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\""}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Use 2 pointers, one for 0, one for 2.\n        # 2. Move 0 to the left, and 2 to the right.\n        # 3. Move 1 to the middle.\n        # 4. If the element is 0, swap it with the left pointer.\n        # 5. If the element is 2, swap it with the right pointer.\n        # 6. If the element is 1, move it to the middle.\n        # 7. Repeat steps 2-6 until all elements are sorted.\n        \n        # 1. Use 2 pointers, one for 0, one for 2.\n        # 2. Move 0 to the left, and 2 to the right.\n        # 3. Move 1 to the middle.\n        # 4. If the element is 0, swap it with the left pointer.\n        # 5. If the element is 2, swap it with the right pointer.\n        # 6. If the element is 1, move it to the middle.\n        # 7. Repeat steps 2-6 until all elements are sorted.\n        \n        # 1. Use 2 pointers, one for 0, one for 2.\n        # 2. Move 0 to the left, and 2 to the right.\n        # 3. Move 1 to the middle.\n        # 4. If the element is 0, swap it with the left pointer.\n        # 5. If the element is 2, swap it with the right pointer.\n        # 6. If the element is 1, move it to the middle.\n        # 7. Repeat steps 2-6 until all elements are sorted.\n        \n        # 1. Use 2 pointers, one for 0, one for 2.\n        # 2. Move 0 to the left, and 2 to the right.\n        # 3. Move 1 to the middle.\n        # 4. If the element is 0, swap it with the left pointer.\n        # 5. If the element is 2, swap it with the right pointer.\n        # 6. If the element is 1, move it to the middle.\n        # 7. Repeat steps 2-6 until all elements are sorted.\n        \n        # 1. Use 2 pointers, one for 0, one for 2.\n        # 2. Move 0 to the left, and 2 to the right.\n        # 3. Move 1 to the middle.\n        # 4. If the element is 0, swap it with the left pointer.\n        # 5. If the element is 2, swap it with the right pointer.\n        # 6. If the element is 1, move it to the middle.\n        # 7. Repeat steps 2-6 until all elements are sorted.\n        \n        # 1. Use 2 pointers, one for 0, one for 2.\n        # 2. Move 0 to the left, and 2 to the right.\n        # 3. Move 1 to the middle.\n        # 4. If the element is 0, swap it with the left pointer.\n        # 5. If the element is 2, swap it with the right pointer.\n        # 6. If the element is 1, move it to the middle.\n        # 7. Repeat steps 2-6 until all elements are sorted.\n        \n        # 1. Use 2 pointers, one for 0, one for 2.\n        # 2. Move 0 to the left, and 2 to the right.\n        # 3. Move 1 to the middle.\n        # 4. If the element is 0, swap it with the left pointer.\n        # 5. If the element is 2, swap it with the right pointer.\n        # 6. If the element is 1, move it to the middle.\n        # 7. Repeat steps 2-6 until all elements are sorted.\n        \n        # 1. Use 2 pointers, one for 0, one for 2.\n        # 2. Move 0 to the left, and 2 to the right.\n        # 3. Move 1 to the middle.\n        # 4. If the element is 0, swap it with the"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        i = len(num1) - 1\n        j = len(num2) - 1\n        carry = 0\n        ans = \"\"\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(num1[i])\n                i -= 1\n            if j >= 0:\n                carry += int(num2[j])\n                j -= 1\n            ans = str(carry % 10) + ans\n            carry //= 10\n        return ans"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\""}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\""}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        d = {')': '(', ']': '[', '}': '{'}\n        for c in s:\n            if c not in d:\n                stack.append(c)\n            elif not stack or d[c] != stack.pop():\n                return False\n        return not stack"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first number that is smaller than the number to its right\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # If there is no such number, it means that the array is in descending order\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # Find the number that is closest to the number to its right but bigger than the number to its right\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        \n        # Swap the numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # Reverse the part of the array that is after the number to its right\n        nums[i + 1:] = nums[i + 1:][::-1]\n        \n        return"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        d = {}\n        for i, n in enumerate(nums):\n            if n in d and i - d[n] <= k:\n                return True\n            d[n] = i\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        \n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i + 1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(0, n, 2):\n            if couples[i][0] / 2 != couples[i + 1][0] / 2:\n                swaps += 1\n                couples[i + 1] = couples[i]\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        for word in words:\n            if word[0].lower() in row1:\n                row = row1\n            elif word[0].lower() in row2:\n                row = row2\n            else:\n                row = row3\n            for c in word:\n                if c.lower() not in row:\n                    break\n            else:\n                ans.append(word)\n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for _ in range(left - 1):\n            prev = prev.next\n        cur = prev.next\n        for _ in range(right - left):\n            tmp = cur.next\n            cur.next = tmp.next\n            tmp.next = prev.next\n            prev.next = tmp\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning\n        # 3. Return the result\n        \n        # 1. Find the longest palindrome that can be centered at each index\n        # 2. Add the rest of the string to the beginning"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        t_count = collections.Counter(t)\n        s_count = collections.Counter()\n        left = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        \n        for right in range(len(s)):\n            s_count[s[right]] += 1\n            \n            if s_count[s[right]] <= t_count[s[right]]:\n                if len(s_count) == len(t_count):\n                    while s_count[s[left]] > 1:\n                        s_count[s[left]] -= 1\n                        left += 1\n                    if right - left + 1 < min_len:\n                        min_len = right - left + 1\n                        min_left = left\n                        min_right = right\n            \n        if min_len == len(s) + 1:\n            return \"\"\n        else:\n            return s[min_left:min_right + 1]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(distance)\n        if n <= 2:\n            return False\n        if distance[0] >= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <= distance[2]:\n            return True\n        if distance[0] <= distance[1] and distance[1] >= distance[2]:\n            return True\n        if distance[0] >= distance[1] and distance[1] <="}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the frequency of each letter\n        # 2. if the frequency is odd, add 1 to the result\n        # 3. if the frequency is even, add it to the result\n        # 4. if the frequency is 1, add 1 to the result\n        # 5. return the result\n        \n        # 1.\n        freq = {}\n        for letter in s:\n            if letter not in freq:\n                freq[letter] = 1\n            else:\n                freq[letter] += 1\n        \n        # 2.\n        result = 0\n        for letter in freq:\n            if freq[letter] % 2 == 1:\n                result += 1\n            else:\n                result += freq[letter]\n        \n        # 3.\n        if result < len(s):\n            result += 1\n        \n        # 4.\n        return result"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        i = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:i], postorder[:i])\n        root.right = self.buildTree(inorder[i+1:], postorder[i:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\""}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\""}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2 * n + 0.25) ** 0.5 - 0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\""}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        a = 1\n        b = 2\n        for i in range(3, n + 1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # DP\n        # dp[i] = True if s[:i] is a word in wordDict\n        # dp[i] = dp[j] and s[j:i] is a word in wordDict\n        # dp[0] = True\n        # dp[i] = False if s[:i] is not a word in wordDict\n        \n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for i in range(1, n + 1):\n            for j in range(0, i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (left and node.val <= left.val) or (right and node.val >= right.val):\n                return False\n            \n            return valid(node.left, left, node) and valid(node.right, node, right)\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\n        # Return intervals after the insertion.\n\n        # Example 1:\n\n        # Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        # Output: [[1,5],[6,9]]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, i):\n            if i == len(s):\n                res.append(path[:])\n                return\n            for j in range(i, len(s)):\n                if isPalindrome(s[i:j+1]):\n                    path.append(s[i:j+1])\n                    dfs(s, j+1)\n                    path.pop()\n        \n        res = []\n        path = []\n        dfs(s, 0)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\""}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # The number of pigs needed is the number of buckets minus 1.\n        # The number of buckets needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of minutes to test.\n        # The number of minutes needed is the number of pigs multiplied by the number of minutes to test.\n        # The number of minutes needed is the number of buckets divided by the number of minutes to die.\n        # The number of minutes needed is the number of pigs plus 1.\n        # The number of pigs needed is the number of minutes divided by the number of"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\""}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Dynamic programming\n        # Time complexity: O(m*n)\n        # Space complexity: O(m*n)\n        \n        # Initialize a 2D array with all zeros\n        dp = [[0] * n for _ in range(m)]\n        \n        # Set the first row and column to 1\n        for i in range(m):\n            dp[i][0] = 1\n        for j in range(n):\n            dp[0][j] = 1\n        \n        # Fill in the rest of the array\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        # Return the value at the bottom-right corner\n        return dp[m - 1][n - 1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i + j] += int(num1[i]) * int(num2[j])\n                res[i + j + 1] += res[i + j] // 10\n                res[i + j] %= 10\n        \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n        \n        return \"\".join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the same approach as the problem \"Best Time to Buy and Sell Stock II\"\n        ## 2. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Cooldown\"\n        ## 3. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 4. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Cooldown\"\n        ## 5. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 6. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 7. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 8. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 9. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 10. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 11. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 12. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 13. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 14. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 15. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 16. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 17. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 18. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 19. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 20. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 21. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 22. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 23. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 24. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 25. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 26. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 27. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 28. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 29. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 30. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 31. We can use the same approach as the problem \"Best Time to Buy and Sell Stock with Transaction Fee\"\n        ## 3"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        ans = []\n        def dfs(i, cur, target):\n            if target == 0:\n                ans.append(cur[:])\n                return\n            for j in range(i, len(candidates)):\n                if j > i and candidates[j] == candidates[j-1]:\n                    continue\n                if candidates[j] > target:\n                    break\n                cur.append(candidates[j])\n                dfs(j+1, cur, target-candidates[j])\n                cur.pop()\n        dfs(0, [], target)\n        return ans"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        return word.isupper() or word.islower() or word.istitle()"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        i = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:i+1], inorder[:i])\n        root.right = self.buildTree(preorder[i+1:], inorder[i+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\""}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        def merge(l1, l2):\n            if not l1:\n                return l2\n            if not l2:\n                return l1\n            if l1.val < l2.val:\n                l1.next = merge(l1.next, l2)\n                return l1\n            else:\n                l2.next = merge(l1, l2.next)\n                return l2\n        \n        if not lists:\n            return None\n        while len(lists) > 1:\n            merged = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\n                merged.append(merge(l1, l2))\n            lists = merged\n        return lists[0]"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j < i\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] +"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. binary search\n        # 2. binary search\n        # 3. binary search\n        # 4. binary search\n        # 5. binary search\n        # 6. binary search\n        # 7. binary search\n        # 8. binary search\n        # 9. binary search\n        # 10. binary search\n        # 11. binary search\n        # 12. binary search\n        # 13. binary search\n        # 14. binary search\n        # 15. binary search\n        # 16. binary search\n        # 17. binary search\n        # 18. binary search\n        # 19. binary search\n        # 20. binary search\n        # 21. binary search\n        # 22. binary search\n        # 23. binary search\n        # 24. binary search\n        # 25. binary search\n        # 26. binary search\n        # 27. binary search\n        # 28. binary search\n        # 29. binary search\n        # 30. binary search\n        # 31. binary search\n        # 32. binary search\n        # 33. binary search\n        # 34. binary search\n        # 35. binary search\n        # 36. binary search\n        # 37. binary search\n        # 38. binary search\n        # 39. binary search\n        # 40. binary search\n        # 41. binary search\n        # 42. binary search\n        # 43. binary search\n        # 44. binary search\n        # 45. binary search\n        # 46. binary search\n        # 47. binary search\n        # 48. binary search\n        # 49. binary search\n        # 50. binary search\n        # 51. binary search\n        # 52. binary search\n        # 53. binary search\n        # 54. binary search\n        # 55. binary search\n        # 56. binary search\n        # 57. binary search\n        # 58. binary search\n        # 59. binary search\n        # 60. binary search\n        # 61. binary search\n        # 62. binary search\n        # 63. binary search\n        # 64. binary search\n        # 65. binary search\n        # 66. binary search\n        # 67. binary search\n        # 68. binary search\n        # 69. binary search\n        # 70. binary search\n        # 71. binary search\n        # 72. binary search\n        # 73. binary search\n        # 74. binary search\n        # 75. binary search\n        # 76. binary search\n        # 77. binary search\n        # 78. binary search\n        # 79. binary search\n        # 80. binary search\n        # 81. binary search\n        # 82. binary search\n        # 83. binary search\n        # 84. binary search\n        # 85. binary search\n        # 86. binary search\n        # 87. binary search\n        # 88. binary search\n        # 89. binary search\n        # 90. binary search\n        # 91. binary search\n        # 92. binary search\n        # 93. binary search\n        # 94. binary search\n        # 95. binary search\n        # 96. binary search\n        # 97. binary search\n        # 98. binary search\n        # 99. binary search\n        # 100. binary search\n        # 101. binary search\n        # 102. binary search\n        # 103. binary search\n        # 104. binary search\n        # 105. binary search\n        # 106. binary search\n        # 107. binary search\n        # 108. binary search\n        # 109. binary search\n        # 110. binary search\n        # 111. binary search\n        # 112. binary search\n        # 113. binary search\n        #"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\""}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\""}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        ans = 0\n        \n        def dfs(i, j):\n            if not dp[i][j]:\n                val = matrix[i][j]\n                for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                    if 0 <= x < m and 0 <= y < n and matrix[x][y] > val:\n                        dp[i][j] = max(dp[i][j], dfs(x, y))\n                dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i, j))\n        \n        return ans"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # DP\n        # dp[i] = True if s[:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True for all j < i and s[j:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and dp[j] is True"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        leftToRight = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if not leftToRight:\n                level = level[::-1]\n            result.append(level)\n            leftToRight = not leftToRight\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\""}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1, 1]]\n        \n        res = [[1], [1, 1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, len(res[-1])):\n                temp.append(res[-1][j] + res[-1][j - 1])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            self.ans = max(self.ans, left + right + node.val)\n            return max(left, right) + node.val\n        \n        self.ans = float('-inf')\n        dfs(root)\n        return self.ans"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\""}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # Convert to lowercase\n        s = s.lower()\n        \n        # Remove all non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # Check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\""}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        slow = fast = head\n        for i in range(k):\n            fast = fast.next\n        \n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        fast.next = head\n        head = slow.next\n        slow.next = None\n        \n        return head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        while n % 3 == 0:\n            n = n // 3\n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\""}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def sumOfLeftLeaves(root):\n            if not root:\n                return 0\n            if root.left and not root.left.left and not root.left.right:\n                return root.left.val + sumOfLeftLeaves(root.right)\n            return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right)\n        \n        return sumOfLeftLeaves(root)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\""}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        sign = 1\n        if dividend < 0:\n            sign = -sign\n            dividend = -dividend\n        if divisor < 0:\n            sign = -sign\n            divisor = -divisor\n        \n        if dividend < divisor:\n            return 0\n        \n        if dividend == divisor:\n            return sign\n        \n        if dividend < divisor * 2:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 5:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 10:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 20:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 50:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 100:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 200:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 500:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 1000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 2000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 5000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 10000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 20000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 50000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 100000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 200000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 500000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 1000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 2000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 5000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 10000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 20000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 50000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 100000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 200000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 500000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 1000000000:\n            return sign * (dividend // divisor)\n        \n        if dividend < divisor * 2000000000:\n            return sign * (dividend // divisor)\n        \n        if dividend"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i, j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board) - 1 or j == 0 or j == len(board[0]) - 1:\n                    dfs(i, j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table\n        # Hash Table"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target, op):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    new_cards = [a, b] + list(set(cards) - set([a, b]))\n                    if op == '+':\n                        new_cards.append(a + b)\n                    elif op == '-':\n                        new_cards.append(a - b)\n                    elif op == '*':\n                        new_cards.append(a * b)\n                    elif op == '/':\n                        new_cards.append(float(a) / b)\n                    if dfs(new_cards, target, op):\n                        return True\n            return False\n        \n        return dfs(cards, 24, '+')"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] if s[i-1] == p[j-1] or p[j-1] == '?'\n        #         = dp[i][j-1] if p[j-1] == '*' and (dp[i-1][j] or dp[i][j-1])\n        #         = True if p[j-1] == '*' and dp[i-1][j]\n        #         = False otherwise\n        # dp[0][0] = True\n        # dp[0][j] = dp[0][j-1] if p[j-1] == '*'\n        #         = False otherwise\n        # dp[i][0] = False\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '?')\n        return dp[m][n]"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Since the majority element always exists in the array,\n        # we can use the Boyer-Moore Voting Algorithm to find the majority element.\n        # The idea is to use two variables, candidate and count, to keep track of the majority element and its count.\n        # We iterate through the array and for each element, we increment the count if the element is the same as the candidate,\n        # or decrement the count if the element is not the same as the candidate.\n        # If the count becomes 0, we set the candidate to the current element and set the count to 1.\n        # After the loop, the majority element will be the candidate if it exists, otherwise it will be None.\n        \n        candidate = None\n        count = 0\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n            \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\""}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        ans = []\n        n = len(nums)\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                l = j + 1\n                r = n - 1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        ans.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l - 1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r + 1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return ans"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\""}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        \n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\""}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod\n                if j >= i:\n                    dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Find the node with two parents\n        # 2. Find the node with the largest number of children\n        # 3. Find the node with the largest number of children\n        # 4. Find the node with the largest number of children\n        # 5. Find the node with the largest number of children\n        # 6. Find the node with the largest number of children\n        # 7. Find the node with the largest number of children\n        # 8. Find the node with the largest number of children\n        # 9. Find the node with the largest number of children\n        # 10. Find the node with the largest number of children\n        # 11. Find the node with the largest number of children\n        # 12. Find the node with the largest number of children\n        # 13. Find the node with the largest number of children\n        # 14. Find the node with the largest number of children\n        # 15. Find the node with the largest number of children\n        # 16. Find the node with the largest number of children\n        # 17. Find the node with the largest number of children\n        # 18. Find the node with the largest number of children\n        # 19. Find the node with the largest number of children\n        # 20. Find the node with the largest number of children\n        # 21. Find the node with the largest number of children\n        # 22. Find the node with the largest number of children\n        # 23. Find the node with the largest number of children\n        # 24. Find the node with the largest number of children\n        # 25. Find the node with the largest number of children\n        # 26. Find the node with the largest number of children\n        # 27. Find the node with the largest number of children\n        # 28. Find the node with the largest number of children\n        # 29. Find the node with the largest number of children\n        # 30. Find the node with the largest number of children\n        # 31. Find the node with the largest number of children\n        # 32. Find the node with the largest number of children\n        # 33. Find the node with the largest number of children\n        # 34. Find the node with the largest number of children\n        # 35. Find the node with the largest number of children\n        # 36. Find the node with the largest number of children\n        # 37. Find the node with the largest number of children\n        # 38. Find the node with the largest number of children\n        # 39. Find the node with the largest number of children\n        # 40. Find the node with the largest number of children\n        # 41. Find the node with the largest number of children\n        # 42. Find the node with the largest number of children\n        # 43. Find the node with the largest number of children\n        # 44. Find the node with the largest number of children\n        # 45. Find the node with the largest number of children\n        # 46. Find the node with the largest number of children\n        # 47. Find the node with the largest number of children\n        # 48. Find the node with the largest number of children\n        # 49. Find the node with the largest number of children\n        # 50. Find the node with the largest number of children\n        # 51. Find the node with the largest number of children\n        # 52. Find the node with the largest number of children\n        # 53. Find the node with the largest number of children\n        # 54. Find the node with the largest number of children\n        # 55. Find the node with the largest number of children\n        # 56. Find the node with the largest number of children\n        # 57. Find the node with the largest number of children\n        # 58. Find the node with the largest number of children\n        # 59. Find the node with the largest number of children\n        # 60. Find the node with the largest number of children\n        # 61. Find the node with the largest number of children\n        # 62. Find the node with the largest number of children\n        # 63. Find the node with the largest number of children\n        # 64. Find the node with the largest number of children\n        # 65. Find the node with the largest"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        ans = []\n        used = [False] * len(nums)\n        def backtrack(perm):\n            if len(perm) == len(nums):\n                ans.append(perm[:])\n                return\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                    continue\n                used[i] = True\n                perm.append(nums[i])\n                backtrack(perm)\n                perm.pop()\n                used[i] = False\n        backtrack([])\n        return ans"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2 * sum(set(nums)) - sum(nums)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.strip().split(' ')[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\""}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 1] + dp[i - 2]) % mod\n        return (dp[n] + dp[n - 1] + dp[n - 2]) % mod"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i, num in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + num)\n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j-1]\n                elif j == 0:\n                    grid[i][j] += grid[i-1][j]\n                else:\n                    grid[i][j] += min(grid[i][j-1], grid[i-1][j])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n - 1)\n        res = \"\"\n        count = 1\n        for i in range(1, len(prev)):\n            if prev[i] == prev[i - 1]:\n                count += 1\n            else:\n                res += str(count) + prev[i - 1]\n                count = 1\n        res += str(count) + prev[-1]\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the largest sum of the subarray\n        # if the sum is larger than the largest sum, then the largest sum of the subarray is too large\n        # if the sum is smaller than the largest sum, then the largest sum of the subarray is too small\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest sum, then the largest sum of the subarray is the largest sum\n        # if the sum is equal to the largest"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return m\n            if nums[m] < nums[r]:\n                if nums[m] < target <= nums[r]:\n                    l = m + 1\n                else:\n                    r = m - 1\n            else:\n                if nums[l] <= target < nums[m]:\n                    r = m - 1\n                else:\n                    l = m + 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_map = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(digits, index, path, res):\n            if len(digits) == index:\n                res.append(''.join(path))\n                return\n            \n            for i in range(index, len(digits)):\n                for c in digit_map[digits[i]]:\n                    path.append(c)\n                    backtrack(digits, i + 1, path, res)\n                    path.pop()\n        \n        res = []\n        backtrack(digits, 0, [], res)\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, cur, target):\n            if target == 0:\n                res.append(cur[:])\n                return\n            for j in range(i, len(candidates)):\n                if target - candidates[j] < 0:\n                    break\n                dfs(j, cur + [candidates[j]], target - candidates[j])\n        dfs(0, [], target)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\""}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        left, right = 0, n - 1\n        top, bottom = 0, n - 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        if rev > 2**31 - 1:\n            return 0\n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            matrix[i].reverse()"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 2 pointer approach\n        # 3. 2 pointer approach\n        # 4. 2 pointer approach\n        # 5. 2 pointer approach\n        # 6. 2 pointer approach\n        # 7. 2 pointer approach\n        # 8. 2 pointer approach\n        # 9. 2 pointer approach\n        # 10. 2 pointer approach\n        # 11. 2 pointer approach\n        # 12. 2 pointer approach\n        # 13. 2 pointer approach\n        # 14. 2 pointer approach\n        # 15. 2 pointer approach\n        # 16. 2 pointer approach\n        # 17. 2 pointer approach\n        # 18. 2 pointer approach\n        # 19. 2 pointer approach\n        # 20. 2 pointer approach\n        # 21. 2 pointer approach\n        # 22. 2 pointer approach\n        # 23. 2 pointer approach\n        # 24. 2 pointer approach\n        # 25. 2 pointer approach\n        # 26. 2 pointer approach\n        # 27. 2 pointer approach\n        # 28. 2 pointer approach\n        # 29. 2 pointer approach\n        # 30. 2 pointer approach\n        # 31. 2 pointer approach\n        # 32. 2 pointer approach\n        # 33. 2 pointer approach\n        # 34. 2 pointer approach\n        # 35. 2 pointer approach\n        # 36. 2 pointer approach\n        # 37. 2 pointer approach\n        # 38. 2 pointer approach\n        # 39. 2 pointer approach\n        # 40. 2 pointer approach\n        # 41. 2 pointer approach\n        # 42. 2 pointer approach\n        # 43. 2 pointer approach\n        # 44. 2 pointer approach\n        # 45. 2 pointer approach\n        # 46. 2 pointer approach\n        # 47. 2 pointer approach\n        # 48. 2 pointer approach\n        # 49. 2 pointer approach\n        # 50. 2 pointer approach\n        # 51. 2 pointer approach\n        # 52. 2 pointer approach\n        # 53. 2 pointer approach\n        # 54. 2 pointer approach\n        # 55. 2 pointer approach\n        # 56. 2 pointer approach\n        # 57. 2 pointer approach\n        # 58. 2 pointer approach\n        # 59. 2 pointer approach\n        # 60. 2 pointer approach\n        # 61. 2 pointer approach\n        # 62. 2 pointer approach\n        # 63. 2 pointer approach\n        # 64. 2 pointer approach\n        # 65. 2 pointer approach\n        # 66. 2 pointer approach\n        # 67. 2 pointer approach\n        # 68. 2 pointer approach\n        # 69. 2 pointer approach\n        # 70. 2 pointer approach\n        # 71. 2 pointer approach\n        # 72. 2 pointer approach\n        # 73. 2 pointer approach\n        # 74. 2 pointer approach\n        # 75. 2 pointer approach\n        # 76. 2 pointer approach\n        # 77. 2 pointer approach\n        # 78. 2 pointer approach\n        # 79. 2 pointer approach\n        # 80. 2 pointer approach\n        # 81. 2 pointer approach\n        # 82. 2 pointer approach\n        # 83. 2 pointer approach\n        # 84. 2 pointer approach\n        # 85. 2 pointer approach\n        # 86. 2 pointer approach\n        # 87. 2 pointer approach\n        # 88. 2 pointer approach\n        # 89. 2 pointer approach\n        # 90. 2 pointer approach\n        # 91. 2 pointer approach\n        # 92. 2 pointer approach\n        # 93. 2 pointer approach\n        # 94. 2 pointer approach"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\n        # Given a list of stones positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n\n        # If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n\n        # Example 1:\n\n        # Input: stones = [0,1,3,5,6,8,12,17]\n        # Output: true\n        # Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array in descending order\n        sorted_score = sorted(score, reverse=True)\n        \n        # create a dictionary to map the index of the sorted array to the rank\n        rank_map = {sorted_score[i]: i + 1 for i in range(len(sorted_score))}\n        \n        # map the rank to the corresponding rank in the sorted array\n        return [rank_map[s] for s in score]"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        seen = {}\n        left = 0\n        for right in range(len(s)):\n            if s[right] in seen:\n                left = max(left, seen[s[right]] + 1)\n            seen[s[right]] = right\n            max_len = max(max_len, right - left + 1)\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_set = set(words)\n        word_map = {}\n        \n        for word in words:\n            if word in word_map:\n                word_map[word] += 1\n            else:\n                word_map[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            seen = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                word = s[j:j + word_len]\n                if word in word_set:\n                    if word in seen:\n                        seen[word] += 1\n                    else:\n                        seen[word] = 1\n            \n            if seen == word_map:\n                res.append(i)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        chunks = 1\n        for i in range(1, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            else:\n                chunks += 1\n                max_val = arr[i]\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n            \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\""}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty >= sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                a = v1[i]\n            else:\n                a = 0\n            if i < len(v2):\n                b = v2[i]\n            else:\n                b = 0\n            if a > b:\n                return 1\n            elif a < b:\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## We can buy and sell the stock at any time.\n        ## We can only hold at most one share of the stock at any time.\n        ## We can buy it then immediately sell it on the same day.\n        ## So, we can keep track of the minimum price and the maximum profit.\n        ## We can update the maximum profit as we go.\n        ## We can update the minimum price as we go.\n        ## We can return the maximum profit.\n        \n        ## Initialize the minimum price to infinity.\n        min_price = float('inf')\n        ## Initialize the maximum profit to 0.\n        max_profit = 0\n        \n        ## Iterate over the prices.\n        for price in prices:\n            ## Update the minimum price.\n            min_price = min(min_price, price)\n            ## Update the maximum profit.\n            max_profit = max(max_profit, price - min_price)\n            \n        ## Return the maximum profit.\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\""}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while True:\n            kth = prev\n            for i in range(k):\n                if kth.next:\n                    kth = kth.next\n                else:\n                    return dummy.next\n            next = kth.next\n            kth.next = None\n            prev.next = self.reverse(head, next)\n            for i in range(k):\n                prev = prev.next\n            head = kth\n        \n        return dummy.next\n    \n    def reverse(self, head, next):\n        prev = None\n        while head:\n            n = head.next\n            head.next = prev\n            prev = head\n            head = n\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s + s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 / i\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 / i + dp[i-3] * 3 / i + ... + dp[i-i] * i / i\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 / i + dp[i-3] * 3 / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 / i + dp[i-3] * 3 / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i + ... + dp[i-i] * i / i\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 / i + dp[i-3] * 3 / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i + ... + dp[i-i] * i / i + dp[i-i-1] * i / i + ... + dp[i-2i] * i / i + dp[i-2i-1] * i / i + ... + dp[i-3i] * i / i"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR\n        # 2. XOR with 0\n        # 3. XOR with 1\n        # 4. XOR with 2\n        # 5. XOR with 3\n        # 6. XOR with 4\n        # 7. XOR with 5\n        # 8. XOR with 6\n        # 9. XOR with 7\n        # 10. XOR with 8\n        # 11. XOR with 9\n        # 12. XOR with 10\n        # 13. XOR with 11\n        # 14. XOR with 12\n        # 15. XOR with 13\n        # 16. XOR with 14\n        # 17. XOR with 15\n        # 18. XOR with 16\n        # 19. XOR with 17\n        # 20. XOR with 18\n        # 21. XOR with 19\n        # 22. XOR with 20\n        # 23. XOR with 21\n        # 24. XOR with 22\n        # 25. XOR with 23\n        # 26. XOR with 24\n        # 27. XOR with 25\n        # 28. XOR with 26\n        # 29. XOR with 27\n        # 30. XOR with 28\n        # 31. XOR with 29\n        # 32. XOR with 30\n        # 33. XOR with 31\n        # 34. XOR with 32\n        # 35. XOR with 33\n        # 36. XOR with 34\n        # 37. XOR with 35\n        # 38. XOR with 36\n        # 39. XOR with 37\n        # 40. XOR with 38\n        # 41. XOR with 39\n        # 42. XOR with 40\n        # 43. XOR with 41\n        # 44. XOR with 42\n        # 45. XOR with 43\n        # 46. XOR with 44\n        # 47. XOR with 45\n        # 48. XOR with 46\n        # 49. XOR with 47\n        # 50. XOR with 48\n        # 51. XOR with 49\n        # 52. XOR with 50\n        # 53. XOR with 51\n        # 54. XOR with 52\n        # 55. XOR with 53\n        # 56. XOR with 54\n        # 57. XOR with 55\n        # 58. XOR with 56\n        # 59. XOR with 57\n        # 60. XOR with 58\n        # 61. XOR with 59\n        # 62. XOR with 60\n        # 63. XOR with 61\n        # 64. XOR with 62\n        # 65. XOR with 63\n        # 66. XOR with 64\n        # 67. XOR with 65\n        # 68. XOR with 66\n        # 69. XOR with 67\n        # 70. XOR with 68\n        # 71. XOR with 69\n        # 72. XOR with 70\n        # 73. XOR with 71\n        # 74. XOR with 72\n        # 75. XOR with 73\n        # 76. XOR with 74\n        # 77. XOR with 75\n        # 78. XOR with 76\n        # 79. XOR with 77\n        # 80. XOR with 78\n        # 81. X"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\""}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 1, n):\n                dp[i][j] = dp[i][j - 1]\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n                    if s[k] == s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j - 1])\n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_map = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        i = 0\n        \n        while i < len(s):\n            if i + 1 < len(s) and roman_map[s[i]] < roman_map[s[i + 1]]:\n                result += roman_map[s[i + 1]] - roman_map[s[i]]\n                i += 2\n            else:\n                result += roman_map[s[i]]\n                i += 1\n                \n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(set(nums)) < len(nums)"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # sliding window\n        # use deque\n        # deque is a double-ended queue\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end\n        # deque is a queue that supports adding and removing elements from either end"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\""}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        return nums[l]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        row = [1]\n        for i in range(rowIndex):\n            row.append(row[-1] * (rowIndex - i) // (i + 1))\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            path.append(root.val)\n            if not root.left and not root.right and targetSum == root.val:\n                return [path]\n            return dfs(root.left, targetSum - root.val, path) + dfs(root.right, targetSum - root.val, path)\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * (area / 2) = area\n        # 2. 2 * (area / 2) + 1 = area\n        # 3. 2 * (area / 2) + 1 - 1 = area\n        # 4. 2 * (area / 2) + 1 - 2 = area\n        # 5. 2 * (area / 2) + 1 - 3 = area\n        # 6. 2 * (area / 2) + 1 - 4 = area\n        # 7. 2 * (area / 2) + 1 - 5 = area\n        # 8. 2 * (area / 2) + 1 - 6 = area\n        # 9. 2 * (area / 2) + 1 - 7 = area\n        # 10. 2 * (area / 2) + 1 - 8 = area\n        # 11. 2 * (area / 2) + 1 - 9 = area\n        # 12. 2 * (area / 2) + 1 - 10 = area\n        # 13. 2 * (area / 2) + 1 - 11 = area\n        # 14. 2 * (area / 2) + 1 - 12 = area\n        # 15. 2 * (area / 2) + 1 - 13 = area\n        # 16. 2 * (area / 2) + 1 - 14 = area\n        # 17. 2 * (area / 2) + 1 - 15 = area\n        # 18. 2 * (area / 2) + 1 - 16 = area\n        # 19. 2 * (area / 2) + 1 - 17 = area\n        # 20. 2 * (area / 2) + 1 - 18 = area\n        # 21. 2 * (area / 2) + 1 - 19 = area\n        # 22. 2 * (area / 2) + 1 - 20 = area\n        # 23. 2 * (area / 2) + 1 - 21 = area\n        # 24. 2 * (area / 2) + 1 - 22 = area\n        # 25. 2 * (area / 2) + 1 - 23 = area\n        # 26. 2 * (area / 2) + 1 - 24 = area\n        # 27. 2 * (area / 2) + 1 - 25 = area\n        # 28. 2 * (area / 2) + 1 - 26 = area\n        # 29. 2 * (area / 2) + 1 - 27 = area\n        # 30. 2 * (area / 2) + 1 - 28 = area\n        # 31. 2 * (area / 2) + 1 - 29 = area\n        # 32. 2 * (area / 2) + 1 - 30 = area\n        # 33. 2 * (area / 2) + 1 - 31 = area\n        # 34. 2 * (area / 2) + 1 - 32 = area\n        # 35. 2 * (area / 2) + 1 - 33 = area\n        # 36. 2 * (area / 2) + 1 - 34 = area\n        # 37. 2 * (area / 2) + 1 - 35 = area\n        # 38. 2 * (area / 2) + 1 - 36 = area\n        # 39. 2 * (area / 2) + 1 - 37 = area\n        # 40. 2 * (area / 2) + 1 - 38 = area\n        # 41. 2 * (area / 2) + 1 - 39 = area\n        # 42. 2 * (area / 2) + 1 - 40 = area\n        # 43. 2 * (area / 2) + 1 - 41 = area\n        # 44. 2 * (area / 2) + 1 - 4"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\""}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            return max(height(root.left), height(root.right)) + 1\n        \n        if not root:\n            return True\n        \n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n > 0 and not (n & (n - 1))"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        i = 0\n        while i < len(nums):\n            j = i + 1\n            while j < len(nums) and nums[j] == nums[i]:\n                j += 1\n            k = len(res)\n            while k > 0:\n                k -= 1\n                res.append(res[k] + [nums[i]])\n            i = j\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        \n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the largest area.\n        # We can use a stack to keep track of the indices of the bars that are increasing.\n        # We can then use the stack to find the"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i not in \"+-*/\":\n                stack.append(int(i))\n            else:\n                a = stack.pop()\n                b = stack.pop()\n                if i == \"+\":\n                    stack.append(a + b)\n                elif i == \"-\":\n                    stack.append(b - a)\n                elif i == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(b) / a))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        xmin, ymin, xmax, ymax = float('inf'), float('inf'), -float('inf'), -float('inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            xmin, ymin, xmax, ymax = min(xmin, x1), min(ymin, y1), max(xmax, x2), max(ymax, y2)\n            area += (x2 - x1) * (y2 - y1)\n        return area == (xmax - xmin) * (ymax - ymin) and area == (xmax - xmin) * (ymax - ymin) + (xmax - xmin) * (ymax - ymin) - (xmax - xmin) * (ymax - ymin)"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + ord('A')) + ans\n            columnNumber //= 26\n        return ans"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\""}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n                \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return True\n            if nums[m] < nums[r]:\n                if nums[m] < target <= nums[r]:\n                    l = m + 1\n                else:\n                    r = m - 1\n            else:\n                if nums[l] <= target < nums[m]:\n                    r = m - 1\n                else:\n                    l = m + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[-1][-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        if len(s) == 2:\n            if s[0] == '0':\n                return 0\n            if int(s[0]) == 1 and int(s[1]) in range(1, 7):\n                return 2\n            else:\n                return 1\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2]) in range(1, 7):\n                dp[i] += dp[i - 2]\n            dp[i] %= 10 ** 9 + 7\n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = float('inf')\n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == target:\n                    return s\n                if abs(s - target) < abs(closest - target):\n                    closest = s\n                if s > target:\n                    r -= 1\n                else:\n                    l += 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root, min_diff, prev):\n            if root is None:\n                return\n            inorder(root.left, min_diff, prev)\n            min_diff = min(min_diff, root.val - prev)\n            prev = root.val\n            inorder(root.right, min_diff, prev)\n            \n        min_diff = float('inf')\n        prev = -float('inf')\n        inorder(root, min_diff, prev)\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\""}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        return haystack.find(needle)"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\""}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2020-01-05 15:45:00\n        # 2. 2020-01-05 15:50:00\n        # 3. 2020-01-05 15:55:00\n        # 4. 2020-01-05 16:00:00\n        # 5. 2020-01-05 16:05:00\n        # 6. 2020-01-05 16:10:00\n        # 7. 2020-01-05 16:15:00\n        # 8. 2020-01-05 16:20:00\n        # 9. 2020-01-05 16:25:00\n        # 10. 2020-01-05 16:30:00\n        # 11. 2020-01-05 16:35:00\n        # 12. 2020-01-05 16:40:00\n        # 13. 2020-01-05 16:45:00\n        # 14. 2020-01-05 16:50:00\n        # 15. 2020-01-05 16:55:00\n        # 16. 2020-01-05 17:00:00\n        # 17. 2020-01-05 17:05:00\n        # 18. 2020-01-05 17:10:00\n        # 19. 2020-01-05 17:15:00\n        # 20. 2020-01-05 17:20:00\n        # 21. 2020-01-05 17:25:00\n        # 22. 2020-01-05 17:30:00\n        # 23. 2020-01-05 17:35:00\n        # 24. 2020-01-05 17:40:00\n        # 25. 2020-01-05 17:45:00\n        # 26. 2020-01-05 17:50:00\n        # 27. 2020-01-05 17:55:00\n        # 28. 2020-01-05 18:00:00\n        # 29. 2020-01-05 18:05:00\n        # 30. 2020-01-05 18:10:00\n        # 31. 2020-01-05 18:15:00\n        # 32. 2020-01-05 18:20:00\n        # 33. 2020-01-05 18:25:00\n        # 34. 2020-01-05 18:30:00\n        # 35. 2020-01-05 18:35:00\n        # 36. 2020-01-05 18:40:00\n        # 37. 2020-01-05 18:45:00\n        # 38. 2020-01-05 18:50:00\n        # 39."}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        down = True\n        for c in s:\n            res[i] += c\n            if i == 0:\n                down = True\n            elif i == numRows - 1:\n                down = False\n            i += 1 if down else -1\n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = 0, 0\n        ans = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                left_max = max(left_max, height[left])\n                ans += left_max - height[left]\n                left += 1\n            else:\n                right_max = max(right_max, height[right])\n                ans += right_max - height[right]\n                right -= 1\n                \n        return ans"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(nums)\n        for i in range(n):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] = -nums[index]\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\""}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\""}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\""}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n > 0 and (n & (n - 1)) == 0 and n & 0x55555555 != 0"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\""}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Approach:\n        # 1. We can use a stack to keep track of the indices of the left parentheses.\n        # 2. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 3. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 4. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 5. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 6. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 7. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 8. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 9. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 10. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 11. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 12. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 13. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 14. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 15. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 16. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 17. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 18. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 19. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 20. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 21. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 22. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 23. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 24. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 25. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 26. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 27. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 28. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring so far.\n        # 29. We can keep track of the longest valid parentheses substring by keeping track of the longest valid parentheses substring"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator, denominator = abs(numerator), abs(denominator)\n        \n        if numerator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        if numerator % denominator == 0:\n            return sign + str(numerator // denominator)\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        numerator, remainder = divmod(numerator, denominator)\n        numerator_dict = {remainder: len(numerator_dict)}\n        numerator_list = []\n        \n        while remainder != 0:\n            remainder *= 10\n            numerator, remainder = divmod(remainder, denominator)\n            if remainder in numerator_dict:\n                return sign + str(numerator) + \".\" + \"(\" + \"\".join(numerator_list[:numerator_dict[remainder]]) + \")\"\n            numerator_list.append(str(numerator))\n            numerator_dict[remainder] = len(numerator_list)\n        \n        return sign + str(numerator) + \".\" + \"\".join(numerator_list)"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the left and right halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left or right halves\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for i in envelopes:\n            left, right = 0, len(dp) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if dp[mid] < i[1]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            if left == len(dp):\n                dp.append(i[1])\n            else:\n                dp[left] = i[1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        rowZero = False\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    matrix[0][j] = 0\n                    if i > 0:\n                        matrix[i][0] = 0\n                    else:\n                        rowZero = True\n        \n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[0][j] == 0 or matrix[i][0] == 0:\n                    matrix[i][j] = 0\n        \n        if matrix[0][0] == 0:\n            for i in range(rows):\n                matrix[i][0] = 0\n        \n        if rowZero:\n            for i in range(rows):\n                matrix[i][0] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n        \n        while n > 0 and right:\n            right = right.next\n            n -= 1\n        \n        while right:\n            left = left.next\n            right = right.next\n        \n        left.next = left.next.next\n        \n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\""}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        \n        max_area = 0\n        for i in range(m):\n            for j in range(n):\n                heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n            \n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        i = 0\n        \n        while i < len(heights):\n            if not stack or heights[stack[-1]] <= heights[i]:\n                stack.append(i)\n                i += 1\n            else:\n                top = stack.pop()\n                max_area = max(max_area, heights[top] * (i - stack[-1] - 1 if stack else i))\n        \n        while stack:\n            top = stack.pop()\n            max_area = max(max_area, heights[top] * (i - stack[-1] - 1 if stack else i))\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        ans = [[]]\n        for i in nums:\n            ans += [a + [i] for a in ans]\n        return ans"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] < nums[r]:\n                r = m\n            elif nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r -= 1\n        return nums[l]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        if not s:\n            return False\n        \n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n        res = ''\n        for key in roman:\n            res += roman[key] * (num // key)\n            num %= key\n        return res"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        return chr(sum(map(ord, s)) ^ sum(map(ord, t)))"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def solve(board):\n            # find an empty cell\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for c in '123456789':\n                            if valid(board, i, j, c):\n                                board[i][j] = c\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        def valid(board, row, col, c):\n            # check row\n            for i in range(9):\n                if board[row][i] == c:\n                    return False\n            \n            # check column\n            for i in range(9):\n                if board[i][col] == c:\n                    return False\n            \n            # check box\n            box_row = row // 3 * 3\n            box_col = col // 3 * 3\n            for i in range(3):\n                for j in range(3):\n                    if board[box_row + i][box_col + j] == c:\n                        return False\n            \n            return True\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree\n        ## Recursively traverse the right subtree\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Inorder traversal\n        ## Find the two nodes that are swapped\n        ## Swap the values of the two nodes\n        ## Recursively traverse the left subtree"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        left = head\n        right = prev\n        while right:\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        l, r = 0, num\n        while l <= r:\n            m = (l + r) // 2\n            if m ** 2 == num:\n                return True\n            elif m ** 2 < num:\n                l = m + 1\n            else:\n                r = m - 1\n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0]\n        for i in range(1, n + 1):\n            ans.append(ans[i & (i - 1)] + 1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\""}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        return sorted(s) == sorted(t)"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] != '.':\n                    num = int(board[i][j])\n                    box_idx = (i // 3) * 3 + j // 3\n                    if num in rows[i] or num in cols[j] or num in boxes[box_idx]:\n                        return False\n                    rows[i].add(num)\n                    cols[j].add(num)\n                    boxes[box_idx].add(num)\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\""}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(len(columnTitle)):\n            ans = ans * 26 + (ord(columnTitle[i]) - ord('A') + 1)\n        return ans"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # Find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # Reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # Merge the two halves\n        left = head\n        right = prev\n        while right.next:\n            temp = left.next\n            left.next = right\n            left = temp\n            \n            temp = right.next\n            right.next = left\n            right = temp\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i, j in zip(pattern, s):\n            if i in d:\n                if d[i] != j:\n                    return False\n            else:\n                if j in d.values():\n                    return False\n                d[i] = j\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        l = 0\n        r = m * n - 1\n        \n        while l <= r:\n            mid = (l + r) // 2\n            if matrix[mid // n][mid % n] == target:\n                return True\n            elif matrix[mid // n][mid % n] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            sum = val1 + val2 + carry\n            carry = sum // 10\n            curr.next = ListNode(sum % 10)\n            curr = curr.next\n            \n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n            \n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert num to binary\n        # 2. Flip all the 0's to 1's and all the 1's to 0's\n        # 3. Convert the binary to decimal\n        # 4. Return the decimal\n        \n        # 1. Convert num to binary\n        binary = bin(num)[2:]\n        \n        # 2. Flip all the 0's to 1's and all the 1's to 0's\n        complement = ''\n        for bit in binary:\n            if bit == '0':\n                complement += '1'\n            else:\n                complement += '0'\n        \n        # 3. Convert the binary to decimal\n        complement = int(complement, 2)\n        \n        # 4. Return the decimal\n        return complement"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(1, n):\n            if nums[i] - nums[i - 1] == nums[1] - nums[0]:\n                dp[i] = dp[i - 1] + 1\n        \n        return sum(dp)"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\""}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(height) - 1\n        max_area = 0\n        \n        while l < r:\n            area = min(height[l], height[r]) * (r - l)\n            max_area = max(max_area, area)\n            \n            if height[l] < height[r]:\n                l += 1\n            else:\n                r -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\""}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        \n        if num < 7:\n            return str(num)\n        \n        return self.convertToBase7(num // 7) + str(num % 7)"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def isValid(board, row, col):\n            for i in range(row):\n                if board[i] == col:\n                    return False\n                if board[i] + i == col + row:\n                    return False\n                if board[i] - i == col - row:\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if isValid(board, row, col):\n                    board[row] = col\n                    count += backtrack(board, row + 1)\n            return count\n        \n        return backtrack([0] * n, 0)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\""}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # Time Complexity: O(m + n)\n        # Space Complexity: O(1)\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We can then copy the remaining elements of nums2 to nums1.\n        \n        # We can use two pointers to keep track of the current index of nums1 and nums2.\n        # We can start at the end of nums1 and nums2, and move backwards until we reach the beginning of nums1.\n        # We"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        return nums[-1] if len(nums) >= 3 else nums[-2]"}]}