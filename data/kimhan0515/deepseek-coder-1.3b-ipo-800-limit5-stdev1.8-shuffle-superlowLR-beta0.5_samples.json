{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1] + 1:\n                if start == nums[i-1]:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(nums[i-1]))\n                start = nums[i]\n        if start == nums[-1]:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(nums[-1]))\n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of distinct subsequences of s[:i] that equals t\n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        \n        for i in range(1, len(s) + 1):\n            count = 0\n            for j in range(i):\n                if s[j] == t[0]:\n                    count += dp[j]\n            dp[i] = count\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Mark all negative numbers, 0s, and numbers larger than n as invalid\n        # 2. Iterate through the array and mark the numbers as present\n        # 3. Iterate through the array again and return the first number that is not present\n        # 4. If all numbers are present, return n + 1\n        \n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        ans = \"\"\n        nums = [i for i in range(1, n+1)]\n        for i in range(n-1, -1, -1):\n            fact //= i\n            idx = k // fact\n            ans += str(nums[idx])\n            nums.pop(idx)\n            k %= fact\n        \n        return ans"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Two pointers\n        # 2. O(n) time and O(1) space\n        \n        # 1. Two pointers\n        # 2. O(n) time and O(1) space\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr_num = int(num[i:j+1])\n                if op == None:\n                    backtrack(j+1, curr_num, curr_num, res, curr_num)\n                else:\n                    backtrack(j+1, curr - prev + curr_num, curr_num, res, op * curr_num)\n                    backtrack(j+1, curr + prev - curr_num, -curr_num, res, op + '+' + curr_num)\n                    backtrack(j+1, curr - prev + prev_num, prev_num * curr_num, res, op + '-' + curr_num)\n        \n        res = []\n        backtrack(0, 0, 0, res, None)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '?')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (first_match and self.isMatch(s[1:], p))\n        \n        return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            drop = len(nums) - k\n            out = []\n            for num in nums:\n                while drop and out and out[-1] < num:\n                    out.pop()\n                    drop -= 1\n                out.append(num)\n            return out\n        \n        def merge(nums1, nums2, k):\n            out = []\n            while nums1 and nums2 and k:\n                if nums1 > nums2:\n                    nums1.pop()\n                else:\n                    nums2.pop()\n                k -= 1\n                out.append(nums1[-1])\n            return out + nums1 + nums2\n        \n        return max(merge(pick(nums1, i), pick(nums2, k-i), k) for i in range(k+1))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i + num // i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a, b = 0, 1\n        for i in range(2, n+1):\n            a, b = b, a+b\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        lo, hi = 0, nums[-1] - nums[0]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                hi = mid\n            else:\n                lo = mid + 1\n        return lo"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and s[left] not in vowels:\n                left += 1\n            while left < right and s[right] not in vowels:\n                right -= 1\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time: O(n)\n        ## Space: O(1)\n        ## 1. Sum of all numbers from 0 to n\n        ## 2. Sum of all numbers in nums\n        ## 3. Difference\n        return sum(range(len(nums) + 1)) - sum(nums)"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        \n        while queue:\n            word, steps = queue.popleft()\n            \n            for i in range(len(word)):\n                for j in range(ord('a'), ord('z') + 1):\n                    new_word = word[:i] + chr(j) + word[i + 1:]\n                    if new_word == endWord:\n                        return steps + 1\n                    if new_word in wordList:\n                        queue.append((new_word, steps + 1))\n                        wordList.remove(new_word)\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        carry = 0\n        res = []\n        for i in range(len(a)-1, -1, -1):\n            if a[i] == '1':\n                carry += 1\n            if i < len(b):\n                if b[i] == '1':\n                    carry += 1\n            res.append(str(carry % 2))\n            carry //= 2\n        if carry:\n            res.append(str(carry))\n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return [-1, -1]\n        \n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        if nums[left] != target:\n            return [-1, -1]\n        else:\n            left = right\n            right = len(nums) - 1\n            while left < right:\n                mid = (left + right + 1) // 2\n                if nums[mid] > target:\n                    right = mid - 1\n                else:\n                    left = mid\n            return [left, right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return len(nums)\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        cur_reach = 0\n        \n        for i in range(n):\n            if i > cur_reach:\n                jumps += 1\n                cur_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i] - prices[i - 1] for i in range(1, len(prices))) for _ in range(k))\n        \n        buy = [float('-inf')] * (k + 1)\n        sell = [0] * (k + 1)\n        \n        for price in prices:\n            for i in range(1, k + 1):\n                buy[i] = max(buy[i], sell[i - 1] - price)\n                sell[i] = max(sell[i], buy[i] + price)\n        \n        return sell[-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        if num < 0:\n            num = 2 ** 32 + num\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        ans = ''\n        for i in hex_list:\n            if i < 10:\n                ans += str(i)\n            else:\n                ans += hex_dict[i]\n        \n        return ans"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list has more than 1 element, return the first element\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list has more than 1 element, return the first element\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list has more than 1 element, return the first element\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list has more than 1 element, return the first element\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list has more than 1 element, return the first element\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list has more than 1 element, return the first element\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        # if the character has a frequency of 1, add its index to the list\n        # if the list is empty, return -1\n        # if the list has more than 1 element, return the first element\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first non-repeating character\n        # iterate through the string\n        # if the character is not in the hashmap, add it to the hashmap with a frequency of 1\n        # if the character is in the hashmap, increment its frequency by 1\n        #"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        if valueDiff < 0:\n            return False\n        \n        if indexDiff < 0:\n            indexDiff = len(nums) + indexDiff\n        \n        if indexDiff > len(nums):\n            return False\n        \n        bucket = {}\n        \n        for i in range(len(nums)):\n            bucket_id = nums[i] // (valueDiff + 1)\n            \n            if bucket_id in bucket:\n                return True\n            \n            if bucket_id - 1 in bucket and abs(bucket[bucket_id - 1] - nums[i]) <= valueDiff:\n                return True\n            \n            if bucket_id + 1 in bucket and abs(bucket[bucket_id + 1] - nums[i]) <= valueDiff:\n                return True\n            \n            bucket[bucket_id] = nums[i]\n            \n            if i >= indexDiff:\n                del bucket[nums[i - indexDiff] // (valueDiff + 1)]\n                \n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        \n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n        \n        num1, num2 = list(num1), list(num2)\n        \n        carry = 0\n        for i in range(len(num1)):\n            if i < len(num2):\n                carry += int(num1[-i-1]) + int(num2[-i-1])\n            else:\n                carry += int(num1[-i-1])\n            num1[-i-1] = str(carry % 10)\n            carry //= 10\n        \n        if carry:\n            num1.append(str(carry))\n        \n        return ''.join(num1[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        for i in range(len(s)):\n            if s[i] == ' ':\n                continue\n            elif s[i] == '+':\n                num += sign\n            elif s[i] == '-':\n                num += sign\n            elif s[i] == '(':\n                stack.append(num)\n                stack.append(sign)\n                num = 0\n                sign = 1\n            elif s[i] == ')':\n                num += sign * stack.pop()\n                num += stack.pop()\n            else:\n                num = num * 10 + int(s[i])\n        return num"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # heap for profits\n        heap = []\n        \n        # iterate over sorted capital\n        for c, p in sorted_capital:\n            # add profits to heap\n            heapq.heappush(heap, p)\n            \n            # if we have enough capital\n            if len(heap) > k:\n                # remove the smallest profit\n                heapq.heappop(heap)\n        \n        # return the sum of profits\n        return sum(heap)"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '{':\n                stack.append('}')\n            elif i == '[':\n                stack.append(']')\n            elif stack and stack[-1] == i:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is bigger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # find the number that is bigger than the first number\n        j = len(nums) - 1\n        while j > i and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap the two numbers\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the numbers after the first number\n        nums[i+1:] = nums[len(nums)-1:i:-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time: O(n)\n        # Space: O(n)\n        seen = set()\n        for i, num in en.umerate(nums):\n            if num in seen and i - seen[num] <= k:\n                return True\n            seen[num] = i\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(1, len(couples)):\n            if couples[i][0] != couples[i-1][1]:\n                swaps += 1\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        firstRow = set('qwertyuiop')\n        secondRow = set('asdfghjkl')\n        thirdRow = set('zxcvbnm')\n        \n        return [word for word in words if firstRow & set(word.lower()) in (firstRow, secondRow, thirdRow)]"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right - left):\n            tmp = curr.next\n            curr.next = tmp.next\n            tmp.next = prev.next\n            prev.next = tmp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # then add the rest of the string to the beginning\n        # e.g. abcde -> edcba + cde\n        #     abcde -> edcba + bcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abcde\n        #     abcde -> edcba + abc"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        # create a hashmap for t\n        t_map = {}\n        for c in t:\n            t_map[c] = t_map.get(c, 0) + 1\n        \n        # create a hashmap for s\n        s_map = {}\n        for c in s:\n            s_map[c] = s_map.get(c, 0) + 1\n        \n        # create a hashmap for s\n        match = 0\n        min_len = len(s) + 1\n        min_start = 0\n        min_end = 0\n        \n        for i in range(len(s)):\n            if s[i] in t_map:\n                s_map[s[i]] -= 1\n                if s_map[s[i]] < t_map[s[i]]:\n                    match += 1\n            \n            if match == len(t_map):\n                while s[min_start] not in t_map or s_map[s[min_start]] > t_map[s[min_start]]:\n                    s_map[s[min_start]] -= 1\n                    min_start += 1\n                \n                if min_len > i - min_start + 1:\n                    min_len = i - min_start + 1\n                    min_end = i\n                \n                s_map[s[min_start]] += 1\n                match -= 1\n                min_start += 1\n        \n        return s[min_start:min_end + 1] if min_len < len(s) + 1 else \"\""}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] == distance[i - 3] and distance[i - 1] == distance[i - 4]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 6 and distance[i] + distance[i - 5] >= distance[i - 2] and distance[i - 2] == distance[i - 4] and distance[i - 1] == distance[i - 3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. count the number of each letter\n        # 2. if the number of each letter is odd, add 1 to the result\n        # 3. if the number of each letter is even, add it to the result\n        # 4. return the result\n        \n        count = {}\n        for c in s:\n            if c not in count:\n                count[c] = 1\n            else:\n                count[c] += 1\n        \n        result = 0\n        for c in count:\n            if count[c] % 2 == 0:\n                result += count[c]\n            else:\n                result += count[c] - 1\n        \n        return result if result < len(s) else result + 1"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                if not q:\n                    return float('inf')\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                steps += 1\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y in q if (x, y) not in visited]\n                q = [(x, y) for x, y in q if (x, y) in end]\n                if q:\n                    return steps\n                q = [(x, y) for x, y"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. calculate the prefix sum\n        # 2. use the prefix sum as the key to a hashmap\n        # 3. count the number of pairs that sum to the range [lower, upper]\n        # 4. return the number of pairs\n        \n        # 1. calculate the prefix sum\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        # 2. use the prefix sum as the key to a hashmap\n        # 3. count the number of pairs that sum to the range [lower, upper]\n        # 4. return the number of pairs\n        ans = 0\n        d = {0: 1}\n        for i in range(n):\n            ans += d.get(prefix_sum[i] - lower, 0)\n            ans += d.get(prefix_sum[i] - upper, 0)\n            d[prefix_sum[i]] = d.get(prefix_sum[i], 0) + 1\n        return ans"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2*n+0.25)**0.5-0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        for c in t:\n            if i < len(s) and c == s[i]:\n                i += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2^n - 1 is the max number we can have\n        # 2"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is larger than the last interval in the list,\n        # append the new interval to the end of the list\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if the new interval is smaller than the first interval in the list,\n        # prepend the new interval to the beginning of the list\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # otherwise, merge the new interval with the first interval in the list\n        # if the new interval overlaps with the first interval,\n        # update the first interval to the larger of the two\n        if newInterval[0] <= intervals[0][0]:\n            intervals[0][0] = newInterval[0]\n        # if the new interval overlaps with the last interval,\n        # update the last interval to the larger of the two\n        if newInterval[1] >= intervals[-1][1]:\n            intervals[-1][1] = newInterval[1]\n        # remove the first interval from the list\n        intervals.pop(0)\n        \n        # return the merged list\n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of all the numbers in the first list\n        # 2. iterate over the rest of the lists, and for each list,\n        #    check if the current min is greater than the current max\n        #    if so, update the min and max\n        # 3. return the range\n        \n        min_val = float('inf')\n        max_val = float('-inf')\n        for num in nums[0]:\n            min_val = min(min_val, num)\n            max_val = max(max_val, num)\n        \n        res = [min_val, max_val]\n        for i in range(1, len(nums)):\n            for num in nums[i]:\n                if num > max_val:\n                    max_val = num\n                if num < min_val:\n                    min_val = num\n                if max_val - min_val < res[1] - res[0]:\n                    res = [min_val, max_val]\n        return res"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 1 bucket, 2 pigs can test 2 buckets, 3 pigs can test 4 buckets, 4 pigs can test 8 buckets, 5 pigs can test 16 buckets, 6 pigs can test 32 buckets, 7 pigs can test 64 buckets, 8 pigs can test 128 buckets, 9 pigs can test 256 buckets, 10 pigs can test 512 buckets, 11 pigs can test 1024 buckets, 12 pigs can test 2048 buckets, 13 pigs can test 4096 buckets, 14 pigs can test 8192 buckets, 15 pigs can test 16384 buckets, 16 pigs can test 32768 buckets, 17 pigs can test 65536 buckets, 18 pigs can test 131072 buckets, 19 pigs can test 262144 buckets, 20 pigs can test 524288 buckets, 21 pigs can test 1048576 buckets, 22 pigs can test 2097152 buckets, 23 pigs can test 4194304 buckets, 24 pigs can test 8388608 buckets, 25 pigs can test 16777216 buckets, 26 pigs can test 33554432 buckets, 27 pigs can test 67108864 buckets, 28 pigs can test 134217728 buckets, 29 pigs can test 268435456 buckets, 30 pigs can test 536870912 buckets, 31 pigs can test 1073741824 buckets, 32 pigs can test 2147483648 buckets, 33 pigs can test 4294967296 buckets, 34 pigs can test 8589934592 buckets, 35 pigs can test 17179869184 buckets, 36 pigs can test 34359738368 buckets, 37 pigs can test 68719476736 buckets, 38 pigs can test 137438953472 buckets, 39 pigs can test 274877906944 buckets, 40 pigs can test 549755813888 buckets, 41 pigs can test 1099511627776 buckets, 42 pigs can test 2199023255552 buckets, 43 pigs can test 4398046511104 buckets, 44 pigs can test 8796093022208 buckets, 45 pigs can test 17592186044416 buckets, 46 pigs can test 35184372088832 buckets, 47 pigs can test 70368744177664 buckets, 48 pigs can test 140737488355328 buckets, 49 pigs can test 281474976710656 buckets, 50 pigs can test 562949952421312 buckets, 51 pigs can test 1125899904842624 buckets, 52 pigs can test 2251799809685248 buckets, 53 pigs can test 4503599619370496 buckets, 54 p"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set((0, 0))\n        ans = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            ans = max(ans, t)\n            if i == j == n - 1:\n                return ans\n            for ni, nj in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    seen.add((ni, nj))\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[m - 1][n - 1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1) - 1, -1, -1):\n            for j in range(len(num2) - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1 = i + j\n                p2 = i + j + 1\n                sum = mul + res[p2]\n                res[p1] += sum // 10\n                res[p2] = sum % 10\n        \n        i = 0\n        while i < len(res) - 1 and res[i] == 0:\n            i += 1\n        \n        return ''.join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1 pointer to keep track of the min price\n        # 3. 1 pointer to keep track of the max profit\n        # 4. if price[i] < min, update min\n        # 5. if price[i] - min > max, update max\n        # 6. return max\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr or stack:\n            if curr:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n                \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            cnt = 0\n            for c in s:\n                if c == '(':\n                    cnt += 1\n                elif c == ')':\n                    if cnt > 0:\n                        cnt -= 1\n                    else:\n                        return False\n            return cnt == 0\n        \n        q = collections.deque([s])\n        seen = {s}\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] != '(' and s[i] != ')':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\n                mergedLists.append(self.mergeTwoLists(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [n] * (n + 1)\n        dp[0] = -1\n        \n        for i in range(n):\n            for j in range(i + 1):\n                if s[j:i + 1] == s[j:i + 1][::-1]:\n                    dp[i + 1] = min(dp[i + 1], dp[j] + 1)\n        \n        return dp[n]"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^n <= k < 10^(n+1)\n        # 2. 10^n <= k < 10^(n+1)\n        # 3. 10^n <= k < 10^(n+1)\n        # 4. 10^n <= k < 10^(n+1)\n        # 5. 10^n <= k < 10^(n+1)\n        # 6. 10^n <= k < 10^(n+1)\n        # 7. 10^n <= k < 10^(n+1)\n        # 8. 10^n <= k < 10^(n+1)\n        # 9. 10^n <= k < 10^(n+1)\n        # 10. 10^n <= k < 10^(n+1)\n        # 11. 10^n <= k < 10^(n+1)\n        # 12. 10^n <= k < 10^(n+1)\n        # 13. 10^n <= k < 10^(n+1)\n        # 14. 10^n <= k < 10^(n+1)\n        # 15. 10^n <= k < 10^(n+1)\n        # 16. 10^n <= k < 10^(n+1)\n        # 17. 10^n <= k < 10^(n+1)\n        # 18. 10^n <= k < 10^(n+1)\n        # 19. 10^n <= k < 10^(n+1)\n        # 20. 10^n <= k < 10^(n+1)\n        # 21. 10^n <= k < 10^(n+1)\n        # 22. 10^n <= k < 10^(n+1)\n        # 23. 10^n <= k < 10^(n+1)\n        # 24. 10^n <= k < 10^(n+1)\n        # 25. 10^n <= k < 10^(n+1)\n        # 26. 10^n <= k < 10^(n+1)\n        # 27. 10^n <= k < 10^(n+1)\n        # 28. 10^n <= k < 10^(n+1)\n        # 29. 10^n <= k < 10^(n+1)\n        # 30. 10^n <= k < 10^(n+1)\n        # 31. 10^n <= k < 10^(n+1)\n        # 32. 10^n <= k < 10^(n+1)\n        # 33. 10^n <= k < 10^(n+1)\n        # 34. 10^n <= k < 10^(n+1)\n        # 35. 10^n <= k < 10^(n+1)\n        # 36. 10^n <= k < 10^(n+1)\n        # 37. 10^n <= k < 10^(n+1)\n        # 38. 10^n <= k < 10^(n+1)\n        # 39. 10^n <= k < 10^(n+1)\n        # 40. 10^n <= k < 10^(n+1)\n        # 41. 10^n <= k < 10^(n+1)\n        # 42. 10^n <= k < 10^(n+1)\n        # 43. 10^n <= k < 10^(n+1)\n        # 44. 10^n <= k < 10^(n+1)\n        # 45. 10^n <= k < 10^(n+1"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # build a reverse lookup table\n        reverse_lookup = {word[::-1]: i for i, word in enumerate(words)}\n        \n        # build the result\n        result = []\n        \n        # iterate over all words\n        for i, word in enumerate(words):\n            # iterate over all prefixes of word\n            for j in range(len(word) + 1):\n                # get the prefix and the suffix\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                # check if the suffix is a palindrome\n                if suffix in reverse_lookup:\n                    # check if the suffix is itself\n                    if i != reverse_lookup[suffix]:\n                        result.append([i, reverse_lookup[suffix]])\n                \n                # check if the prefix is a palindrome\n                if prefix in reverse_lookup:\n                    # check if the prefix is itself\n                    if i != reverse_lookup[prefix]:\n                        result.append([reverse_lookup[prefix], i])\n        \n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        walls = 0\n        while True:\n            infected = set()\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        infected.add((i, j))\n            if not infected:\n                return walls\n            walls += self.spread(isInfected, infected)\n\n    def spread(self, isInfected, infected):\n        m, n = len(isInfected), len(isInfected[0])\n        while infected:\n            i, j = infected.pop()\n            for x, y in ((i, j-1), (i, j+1), (i-1, j), (i+1, j)):\n                if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 0:\n                    isInfected[x][y] = 2\n                    infected.add((x, y))\n        return 1"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                res = max(res, self.dfs(matrix, dp, i, j))\n        \n        return res\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                dp[i][j] = max(dp[i][j], self.dfs(matrix, dp, x, y))\n        \n        return dp[i][j] + 1"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n        \n        return [s[:i + 1] for i in range(len(s)) if dp[i + 1]]"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        left_to_right = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(level)\n            left_to_right = not left_to_right\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def gen_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return \"%d:%02d\" % (h, m)\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append(gen_time(h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            newpath = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, newpath)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            seen.add((i, j))\n            for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                    ans += max(0, h - heightMap[ni][nj])\n                    heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-z0-9]', '', s)\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. get the median\n        # 3. return the median\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. get the median\n        # 2.1 if the length of the array is odd, return the middle element\n        # 2.2 if the length of the array is even, return the mean of the two middle elements\n        if len(nums) % 2 == 1:\n            return float(nums[len(nums) // 2])\n        else:\n            return (nums[len(nums) // 2] + nums[len(nums) // 2 - 1]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k % length - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = new_head\n        while new_tail.next:\n            new_tail = new_tail.next\n        \n        # connect the new tail to the old head\n        new_tail.next = head\n        \n        # cut the old head\n        new_head = new_head.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        while n % 3 == 0:\n            n = n // 3\n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        ans = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                sums = [max(sums[i] - k, 0) for i in range(m)]\n                sums = [0] + sums\n                q = collections.deque()\n                q.append(0)\n                for s in sums:\n                    while q and q[-1] < s:\n                        q.pop()\n                    q.append(s)\n                    ans = max(ans, q[-1])\n        return ans"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend / divisor)\n        elif dividend > 0 and divisor < 0:\n            return -int(abs(dividend) / abs(divisor))\n        elif dividend < 0 and divisor > 0:\n            return -int(abs(dividend) / abs(divisor))\n        else:\n            return int(abs(dividend) / abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the number and its index\n        num_dict = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            \n            # check if the difference between the target and the current number is in the dictionary\n            if target - num in num_dict:\n                \n                # return the index of the current number and the index of the difference\n                return [num_dict[target - num], i]\n            \n            # add the number to the dictionary with its index\n            num_dict[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards):\n            if len(cards) == 1:\n                return abs(cards[0] - 24) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [cards[i] + cards[j], cards[j] - cards[i], cards[k] - cards[j], cards[k] + cards[j]]\n                            elif op == '-':\n                                new_cards = [cards[i] - cards[j], cards[j] + cards[i], cards[k] + cards[j], cards[k] - cards[j]]\n                            elif op == '*':\n                                new_cards = [cards[i] * cards[j], cards[j] * cards[i], cards[k] - cards[j], cards[k] - cards[i]]\n                            else:\n                                new_cards = [float(cards[i] * cards[j]) / cards[k], float(cards[j] * cards[i]) / cards[k], float(cards[k] - cards[i]) / cards[j], float(cards[k] - cards[j]) / cards[i]]\n                            if any(x > 0 and x < 24 for x in new_cards):\n                                return True\n                            if op != '/' or cards[j] != 0:\n                                if dfs(new_cards):\n                                    return True\n            return False\n        \n        return dfs(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p.replace('*', ''):\n            return not s\n        \n        if not s.replace('*', ''):\n            return False\n        \n        if p[0] != '*':\n            return s[0] == p[0] and self.isMatch(s[1:], p[1:])\n        \n        while s and p and p[0] == '*':\n            p = p[1:]\n            if not self.isMatch(s, p):\n                s = s[1:]\n        \n        return s == ''"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for fromi, toi in sorted(tickets):\n            graph[fromi].append(toi)\n        \n        # dfs\n        res = []\n        def dfs(node):\n            # terminate condition\n            if node not in graph:\n                return\n            # visit all neighbors\n            for neighbor in sorted(graph[node]):\n                graph[node].remove(neighbor)\n                dfs(neighbor)\n            # add to result\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = [[0, 0]]\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the building is ending\n            if building[1] > 0:\n                # add the building to the result\n                result.append(building)\n            else:\n                # find the index of the building to remove\n                i = 0\n                while i < len(result) and result[i][1] < -building[1]:\n                    i += 1\n                # remove the building\n                result.pop(i)\n                \n            # find the index of the building to replace\n            i = 0\n            while i < len(result) and result[i][0] <= building[0]:\n                i += 1\n            # replace the building\n            result[i] = (building[0], max(result[i][1], building[2]))\n        \n        # return the result\n        return result[1:]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + \" \" + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred \" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand \" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million \" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion \" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        MOD = 10**9 + 7\n        dp = [0] * (k+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            for j in range(min(k, i*(i-1)//2), k+1):\n                dp[j] = (dp[j] + dp[j-i]) % MOD\n        return dp[k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent = {}\n        child = {}\n        for u, v in edges:\n            if v in child:\n                return [child[v], u]\n            if u in parent:\n                return [u, parent[u]]\n            child[v] = u\n            parent[u] = v\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if v in child:\n                continue\n            if u in parent:\n                child[u] = v\n            else:\n                return [u, v]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i - 1]:\n                    continue\n                backtrack(nums[:i] + nums[i + 1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # XOR operation\n        # 0 ^ 0 = 0\n        # 0 ^ 1 = 1\n        # 1 ^ 0 = 1\n        # 1 ^ 1 = 0\n        # 0 ^ 1 ^ 1 = 0\n        # 0 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 0 = 1\n        # 1 ^ 0 ^ 1 = 0\n        # 0 ^ 1 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 0 ^ 0 = 1\n        # 1 ^ 0 ^ 1 ^ 0 = 1\n        # 1 ^ 0 ^ 0 ^ 1 = 1\n        # 0 ^ 1 ^ 1 ^ 0 = 1\n        # 0 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 1 = 1\n        # 1 ^ 1 ^ 0 ^ 0 = 1\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 1 ^ 0 = 1\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 = 0\n        # 1 ^ 1 ^ 0 ^ 1 = 0\n        # 0 ^ 0 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 1 = 0\n        # 1 ^ 1 ^ 0 ^ 1 = 0\n        # 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 0 ="}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split()[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n                if j > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1])\n                if j < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1])\n        return dp[-1][-1]"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i, num in en\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + num)\n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(1, m):\n            grid[i][0] += grid[i-1][0]\n        \n        for j in range(1, n):\n            grid[0][j] += grid[0][j-1]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n        \n        return grid[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        res = '1'\n        for i in range(1, n):\n            res = self.helper(res)\n        return res\n        \n    def helper(self, s):\n        res = ''\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n            else:\n                res += str(count) + s[i-1]\n                count = 1\n        res += str(count) + s[-1]\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer\n        # if the max sum is less than the sum of the subarray, then the max sum is too small\n        # if the max sum is greater than the sum of the subarray, then the max sum is too large\n        # if the max sum is equal to the sum of the subarray, then the max sum is the answer"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the pivot is not found, return -1\n        if pivot == -1:\n            return self.binary_search(nums, target)\n        \n        # if the target is less than the first element, search the right side\n        if target >= nums[0]:\n            return self.binary_search(nums[pivot:], target)\n        \n        # otherwise, search the left side\n        return self.binary_search(nums[:pivot], target)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left if nums[left] > nums[0] else -1\n        \n    def binary_search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}\n        \n        def dfs(i, path):\n            if i == len(digits):\n                res.append(path)\n                return\n            for c in phone[digits[i]]:\n                dfs(i+1, path+c)\n        \n        res = []\n        dfs(0, '')\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if nums[i] > target:\n                break\n            self.dfs(nums, target - nums[i], i, path + [nums[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of n\n        length = len(n)\n        \n        # 2. get the number of digits\n        digits = length // 2\n        \n        # 3. get the left and right part of n\n        left, right = n[:digits], n[digits:]\n        \n        # 4. get the list of all possible candidates\n        candidates = [int(left + str(i) + right) for i in (int(left) - 1, int(left), int(left) + 1)]\n        \n        # 5. get the closest palindrome\n        return min(candidates, key=lambda x: (abs(x - int(n)), x))"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        else:\n            return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n//2):\n            for j in range(i, n-i-1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n-j-1][i]\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                matrix[j][n-i-1] = temp"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        res = max_prod\n        \n        for i in range(1, len(nums)):\n            curr_max = max_prod\n            max_prod = max(nums[i], nums[i] * max_prod, nums[i] * min_prod)\n            min_prod = min(nums[i], nums[i] * curr_max, nums[i] * min_prod)\n            res = max(res, max_prod)\n            \n        return res"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = {stones[0]: set([1])}\n        \n        for stone in stones[1:]:\n            for prev in dp.get(stone - 1, set()):\n                for jump in range(prev + 1, prev + stone + 1):\n                    if jump in dp:\n                        dp[jump].add(jump)\n                    else:\n                        dp[jump] = set([jump])\n        \n        return len(dp) > 0 and (stones[-1] in dp[stones[-1]])"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a hashmap to store the score and rank\n        score_rank = {}\n        for i, s in en.umerate(score_sorted):\n            score_rank[s] = i + 1\n        \n        # create a list of ranks\n        ranks = []\n        for s in score:\n            ranks.append(score_rank[s])\n        \n        # create a list of ranks\n        ranks = [str(r) for r in ranks]\n        \n        # create a list of ranks\n        ranks = [r if r != '1' else 'Gold Medal' if r == '2' else 'Silver Medal' if r == '3' else 'Bronze Medal' for r in ranks]\n        \n        return ranks"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        start = 0\n        end = 0\n        seen = {}\n        \n        while end < len(s):\n            if s[end] in seen:\n                start = max(start, seen[s[end]] + 1)\n            seen[s[end]] = end\n            max_len = max(max_len, end - start + 1)\n            end += 1\n            \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            word_dict_copy = word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                else:\n                    left = j + 1 + word_len\n                    word_dict_copy = word_dict.copy()\n                if not word_dict_copy:\n                    res.append(left)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        res = 1\n        \n        for i in range(1, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if max_val == i:\n                res += 1\n        \n        return res"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr.next, curr\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i, j = left, mid\n            while i < mid:\n                while j < right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - mid\n                i += 1\n            nums[left:right] = sorted(nums[left:right])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left + 1 >= right:\n                return 0\n            mid = (left + right) // 2\n            return merge(nums, left, mid, right) + mergeSort(nums, mid, right) + mergeSort(nums, left, mid)\n        \n        return mergeSort(nums, 0, len(nums))"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if v1[i] > v2[i]:\n                    return 1\n                elif v1[i] < v2[i]:\n                    return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # greedy\n        # max heap\n        heap = []\n        \n        # sum of durations\n        total = 0\n        \n        for duration, end in courses:\n            # add to heap\n            heapq.heappush(heap, duration)\n            # add duration to total\n            total += duration\n            # if total exceeds end date, remove from heap\n            if total > end:\n                total -= heapq.heappop(heap)\n        \n        return len(heap)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        while True:\n            tail = prev\n            for i in range(k):\n                if not tail:\n                    return dummy.next\n                tail = tail.next\n            head = prev.next\n            for i in range(k - 1):\n                tmp = head.next\n                head.next = tmp.next\n                tmp.next = tail.next\n                tail.next = tmp\n            prev = head\n            head = head.next\n        \n        return dummy.next"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s+s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR all the numbers\n        # 2. XOR all the numbers again\n        # 3. The remaining number will be the answer\n        \n        a = 0\n        for num in nums:\n            a ^= num\n            \n        return a"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to form target[i]\n        # dp[i] = min(dp[i], dp[i - s] + 1) for s in stickers\n        # dp[0] = 0\n        # dp[i] = -1 if target[i] not in stickers\n        # dp[i] = len(target) if target[i] in stickers\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j] + 1) for j in stickers if target[j] in i\n        # dp[i] = min(dp[i], dp[j]"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1] + 1, dp[j][j])\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        total = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total -= roman_dict[s[i]]\n            else:\n                total += roman_dict[s[i]]\n        return total"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        q = []\n        res = []\n        for i in range(len(nums)):\n            while q and q[0] <= i - k:\n                q.pop(0)\n            while q and nums[q[-1]] < nums[i]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                res.append(nums[q[0]])\n        return res"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge nums1 and nums2 into a single list\n        nums = nums1 + nums2\n        \n        # sort the merged list\n        nums.sort()\n        \n        # find the median\n        if len(nums) % 2 == 1:\n            return nums[len(nums) // 2]\n        else:\n            return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2.0"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            elif nums[m] < nums[r]:\n                r = m\n            else:\n                r -= 1\n        return nums[l]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and root.val == targetSum:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 * (area // 2) = area\n        # 2. 2 * (area // 2) + 1 = area\n        # 3. 2 * (area // 2) + 1 - area = area\n        # 4. 2 * (area // 2) + 1 - area = area\n        # 5. 2 * (area // 2) + 1 - area = area\n        # 6. 2 * (area // 2) + 1 - area = area\n        # 7. 2 * (area // 2) + 1 - area = area\n        # 8. 2 * (area // 2) + 1 - area = area\n        # 9. 2 * (area // 2) + 1 - area = area\n        # 10. 2 * (area // 2) + 1 - area = area\n        # 11. 2 * (area // 2) + 1 - area = area\n        # 12. 2 * (area // 2) + 1 - area = area\n        # 13. 2 * (area // 2) + 1 - area = area\n        # 14. 2 * (area // 2) + 1 - area = area\n        # 15. 2 * (area // 2) + 1 - area = area\n        # 16. 2 * (area // 2) + 1 - area = area\n        # 17. 2 * (area // 2) + 1 - area = area\n        # 18. 2 * (area // 2) + 1 - area = area\n        # 19. 2 * (area // 2) + 1 - area = area\n        # 20. 2 * (area // 2) + 1 - area = area\n        # 21. 2 * (area // 2) + 1 - area = area\n        # 22. 2 * (area // 2) + 1 - area = area\n        # 23. 2 * (area // 2) + 1 - area = area\n        # 24. 2 * (area // 2) + 1 - area = area\n        # 25. 2 * (area // 2) + 1 - area = area\n        # 26. 2 * (area // 2) + 1 - area = area\n        # 27. 2 * (area // 2) + 1 - area = area\n        # 28. 2 * (area // 2) + 1 - area = area\n        # 29. 2 * (area // 2) + 1 - area = area\n        # 30. 2 * (area // 2) + 1 - area = area\n        # 31. 2 * (area // 2) + 1 - area = area\n        # 32. 2 * (area // 2) + 1 - area = area\n        # 33. 2 * (area // 2) + 1 - area = area\n        # 34. 2 * (area // 2) + 1 - area = area\n        # 35. 2 * (area // 2) + 1 - area = area\n        # 36. 2 * (area // 2) + 1 - area = area\n        # 37. 2 * (area // 2) + 1 - area = area\n        # 38. 2 * (area // 2) + 1 - area = area\n        # 39. 2 * (area // 2) + 1 - area = area\n        # 40. 2 * (area // 2) + 1 - area = area\n        # 41. 2 * (area // 2) + 1 - area = area\n        # 42. 2 * (area // 2) + 1 - area = area\n        # 43. 2 * (area // 2) + 1 - area = area\n        # 44. 2 * (area // 2) + 1 - area = area\n        # 45. 2 * (area // 2) + 1 - area = area\n        # 46. 2 * (area // 2) + 1 - area = area\n        # 47. 2 * (area // 2) + 1 - area = area\n        # 48"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # build a queue and a set\n        queue = collections.deque([beginWord])\n        visited = set(beginWord)\n        \n        # build a dict to store the shortest path\n        shortest_path = {beginWord: [beginWord]}\n        \n        # BFS\n        while queue:\n            curr_len = len(queue)\n            for _ in range(curr_len):\n                curr_word = queue.popleft()\n                for i in range(len(curr_word)):\n                    for j in range(26):\n                        neighbor = curr_word[:i] + chr(ord(\"a\") + j) + curr_word[i+1:]\n                        for word in graph[neighbor]:\n                            if word == endWord:\n                                return shortest_path[curr_word] + [word]\n                            if word not in shortest_path:\n                                shortest_path[word] = shortest_path[curr_word] + [word]\n                                queue.append(word)\n        \n        return []"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            if left == -1:\n                return -1\n            right = height(root.right)\n            if right == -1:\n                return -1\n            if abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n /= 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(float(first) / second))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min = float('inf'), float('inf')\n        x_max, y_max = float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if (x_min, y_min) not in rectangles or (x_min, y_max) not in rectangles or (x_max, y_min) not in rectangles or (x_max, y_max) not in rectangles:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber, rem = divmod(columnNumber - 1, 26)\n            res = chr(ord('A') + rem) + res\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = num\n            else:\n                curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = [0] * 12\n        for i in range(2):\n            for j in range(3):\n                board_1d[i * 3 + j] = board[i][j]\n        \n        # convert board_1d to a string\n        board_str = ''.join(map(str, board_1d))\n        \n        # convert board_str to a 6-bit binary number\n        board_bin = int(board_str, 2)\n        \n        # convert board_bin to a list of 3-bit binary numbers\n        board_bin_list = [board_bin // (10 ** i) % 10 for i in range(2, -1, -1)]\n        \n        # convert board_bin_list to a string\n        board_str_list = ''.join(map(str, board_bin_list))\n        \n        # convert board_str_list to a 6-bit binary number\n        board_bin_list_str = int(board_str_list, 2)\n        \n        # convert board_bin_list_str to a list of 3-bit binary numbers\n        board_bin_list_str_list = [board_bin_list_str // (10 ** i) % 10 for i in range(2, -1, -1)]\n        \n        # convert board_bin_list_str_list to a string\n        board_str_list_list = ''.join(map(str, board_bin_list_str_list))\n        \n        # convert board_str_list_list to a 6-bit binary number\n        board_bin_list_str_list_str = int(board_str_list_list, 2)\n        \n        # convert board_bin_list_str_list_str to a list of 3-bit binary numbers\n        board_bin_list_str_list_str_list = [board_bin_list_str_list_str // (10 ** i) % 10 for i in range(2, -1, -1)]\n        \n        # convert board_bin_list_str_list_str_list to a string\n        board_str_list_list_list = ''.join(map(str, board_bin_list_str_list_str_list))\n        \n        # convert board_str_list_list_list to a 6-bit binary number\n        board_bin_list_str_list_str_list_str = int(board_str_list_list_list, 2)\n        \n        # convert board_bin_list_str_list_str_list_str to a list of 3-bit binary numbers\n        board_bin_list_str_list_str_list_str_list = [board_bin_list_str_list_str_list_str // (10 ** i) % 10 for i in range(2, -1, -1)]\n        \n        # convert board_bin_list_str_list_str_list_str_list to a string\n        board_str_list_list_list_list = ''.join(map(str, board_bin_list_str_list_str_list_str_list))\n        \n        # convert board_str_list_list_list_list to a 6-bit binary number\n        board_bin_list_str_list_str_list_str_list_str = int(board_str_list_list_list_list, 2)\n        \n        # convert board_bin_list_str_list_str_list_str_list_str to a list of 3-bit binary numbers\n        board_bin_list_str_list_str_list_str_list_str_list = [board_bin_list_str_list_str_list_str_list_str // (10 ** i) % 10 for i in range(2, -1, -1)]\n        \n        # convert board_bin_list_str_list_str_list_str_list_str_list to a string\n        board_str_list_list_list_list_list = ''.join(map(str, board_bin_list_str_list_str_list_str_list_str_list))\n        \n        # convert board_str_list_list_"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_to_t:\n                if s_to_t[s[i]] != t[i]:\n                    return False\n            else:\n                if t[i] in t_to_s:\n                    return False\n                s_to_t[s[i]] = t[i]\n                t_to_s[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r = m\n        pivot = l\n        \n        # search in the left part\n        l, r = 0, pivot - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m + 1\n            else:\n                r = m - 1\n        if nums[l] == target:\n            return True\n        \n        # search in the right part\n        l, r = pivot, len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] > target:\n                r = m - 1\n            else:\n                l = m + 1\n        if nums[l] == target:\n            return True\n        \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [0] * n\n        dp[0] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                elif j > 0:\n                    dp[j] += dp[j-1]\n                    \n        return dp[n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == target:\n                    return s\n                if abs(s - target) < abs(closest - target):\n                    closest = s\n                if s > target:\n                    r -= 1\n                else:\n                    l += 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root, min_diff, prev):\n            if root:\n                inorder(root.left, min_diff, prev)\n                min_diff = min(min_diff, root.val - prev)\n                prev = root.val\n                inorder(root.right, min_diff, prev)\n            return min_diff\n        \n        return inorder(root, float('inf'), float('-inf'))"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.prev_val = None\n        self.curr_count = 0\n        self.res = []\n        \n        def inorder(node):\n            if not node:\n                return\n            \n            inorder(node.left)\n            \n            if self.prev_val == node.val:\n                self.curr_count += 1\n            else:\n                self.curr_count = 1\n                \n            if self.curr_count > self.max_count:\n                self.max_count = self.curr_count\n                self.res = [node.val]\n            elif self.curr_count == self.max_count:\n                self.res.append(node.val)\n                \n            self.prev_val = node.val\n            \n            inorder(node.right)\n        \n        inorder(root)\n        \n        return self.res"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the number of lowercase, uppercase, digit\n        # 3. check the number of repeating characters in a row\n        # 4. check the number of steps\n        \n        # 1. check the length of password\n        if len(password) < 6:\n            return max(6 - len(password), 3)\n        if len(password) > 20:\n            return max(20 - len(password), 3)\n        \n        # 2. check the number of lowercase, uppercase, digit\n        lower, upper, digit = 0, 0, 0\n        for c in password:\n            if c.islower():\n                lower += 1\n            elif c.isupper():\n                upper += 1\n            else:\n                digit += 1\n        \n        # 3. check the number of repeating characters in a row\n        steps = max(lower - 2, 0)\n        \n        # 4. check the number of steps\n        if len(password) - steps > 20:\n            return len(password) - 20\n        else:\n            return steps"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5\n        # 10 = 2 * 5\n        # 2 = 5\n        # 5 = 5"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not height:\n            return 0\n        \n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        res = 0\n        \n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                res += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                res += right_max - height[right]\n                \n        return res"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the number as negative if it is in nums\n        ## 3. iterate through the list again and return the numbers that are still positive\n        \n        n = len(nums)\n        for i in range(n):\n            idx = abs(nums[i]) - 1\n            if nums[idx] > 0:\n                nums[idx] *= -1\n        \n        return [i + 1 for i in range(n) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use a dict to store the number of smaller elements to the left\n        # 5. use a list to store the number of smaller elements to the right\n        # 6. return the list\n        \n        # 1. sort the array\n        nums = [(num, i) for i, num in enumerate(nums)]\n        nums.sort()\n        \n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use a dict to store the number of smaller elements to the left\n        # 5. use a list to store the number of smaller elements to the right\n        # 6. return the list\n        \n        res = [0] * len(nums)\n        d = {}\n        for i in range(len(nums) - 1, -1, -1):\n            num, idx = nums[i]\n            res[i] = d.get(num, 0)\n            d[num] = d.get(num, 0) + 1\n            nums[i] = (num, idx)\n        \n        return res"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = cur = 2\n        for i in intervals:\n            if i[0] > cur:\n                cur += 1\n                ans += 1\n            if i[1] < cur:\n                cur -= 1\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(self.parse(formula, i))\n            elif formula[i] == ')':\n                num = stack.pop()\n                j = i + 1\n                while j < len(formula) and formula[j].isdigit():\n                    j += 1\n                if j < len(formula):\n                    stack[-1][0] *= int(formula[j:j+1])\n                else:\n                    stack[-1][0] = 1\n            else:\n                j = i + 1\n                while j < len(formula) and formula[j].islower():\n                    j += 1\n                stack.append([int(formula[i:j])] if i == 0 else [stack[-1][0] * int(formula[i:j])])\n                i = j\n        return ''.join(atom[1] + ('' if atom[0] == 1 else str(atom[0])) for atom in sorted(stack))"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                if node.right:\n                    stack.append(node.right)\n                if node.left:\n                    stack.append(node.left)\n                res.append(node.val)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - i - 1):\n                    res.append('({}){}'.format(left, right))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        num_sum = 0\n        \n        # iterate\n        while num_sum < n:\n            if i < len(nums) and nums[i] <= num_sum + 1:\n                num_sum += nums[i]\n                i += 1\n            else:\n                patches += 1\n                num_sum += num_sum + 1\n        \n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. stack\n        # 6. dp\n        # 7. greedy\n        # 8. stack\n        # 9. dp\n        # 10. greedy\n        # 11. stack\n        # 12. dp\n        # 13. greedy\n        # 14. stack\n        # 15. dp\n        # 16. greedy\n        # 17. stack\n        # 18. dp\n        # 19. greedy\n        # 20. stack\n        # 21. dp\n        # 22. greedy\n        # 23. stack\n        # 24. dp\n        # 25. greedy\n        # 26. stack\n        # 27. dp\n        # 28. greedy\n        # 29. stack\n        # 30. dp\n        # 31. greedy\n        # 32. stack\n        # 33. dp\n        # 34. greedy\n        # 35. stack\n        # 36. dp\n        # 37. greedy\n        # 38. stack\n        # 39. dp\n        # 40. greedy\n        # 41. stack\n        # 42. dp\n        # 43. greedy\n        # 44. stack\n        # 45. dp\n        # 46. greedy\n        # 47. stack\n        # 48. dp\n        # 49. greedy\n        # 50. stack\n        # 51. dp\n        # 52. greedy\n        # 53. stack\n        # 54. dp\n        # 55. greedy\n        # 56. stack\n        # 57. dp\n        # 58. greedy\n        # 59. stack\n        # 60. dp\n        # 61. greedy\n        # 62. stack\n        # 63. dp\n        # 64. greedy\n        # 65. stack\n        # 66. dp\n        # 67. greedy\n        # 68. stack\n        # 69. dp\n        # 70. greedy\n        # 71. stack\n        # 72. dp\n        # 73. greedy\n        # 74. stack\n        # 75. dp\n        # 76. greedy\n        # 77. stack\n        # 78. dp\n        # 79. greedy\n        # 80. stack\n        # 81. dp\n        # 82. greedy\n        # 83. stack\n        # 84. dp\n        # 85. greedy\n        # 86. stack\n        # 87. dp\n        # 88. greedy\n        # 89. stack\n        # 90. dp\n        # 91. greedy\n        # 92. stack\n        # 93. dp\n        # 94. greedy\n        # 95. stack\n        # 96. dp\n        # 97. greedy\n        # 98. stack\n        # 99. dp\n        # 100. greedy\n        # 101. stack\n        # 102. dp\n        # 103. greedy\n        # 104. stack\n        # 105. dp\n        # 106. greedy\n        # 107. stack\n        # 108. dp\n        # 109. greedy\n        # 110. stack\n        # 111. dp\n        # 112. greedy\n        # 113. stack\n        # 114. dp\n        # 115. greedy\n        # 116. stack\n        # 117. d"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return '0'\n        \n        res = ''\n        if (numerator < 0) ^ (denominator < 0):\n            res += '-'\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        res += str(numerator // denominator)\n        \n        if numerator % denominator == 0:\n            return res\n        \n        res += '.'\n        numerator %= denominator\n        seen = {numerator: len(res)}\n        \n        while numerator:\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n            if numerator in seen:\n                res = res[:seen[numerator]] + '(' + res[seen[numerator]:] + ')'\n                break\n            seen[numerator] = len(res)\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # merge the remaining nodes\n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # Use a list to store the longest increasing subsequence\n        dp = []\n        \n        # Iterate over the envelopes\n        for envelope in envelopes:\n            # If the envelope is larger than the last element in the list, append it to the list\n            if not dp or envelope[1] > dp[-1]:\n                dp.append(envelope[1])\n            # Otherwise, update the element in the list with the smallest larger height\n            else:\n                left = 0\n                right = len(dp) - 1\n                while left <= right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelope[1]:\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n                dp[left] = envelope[1]\n        \n        # Return the length of the list\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O(1) space\n        ## O("}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0, head)\n        \n        # create two pointers\n        left = dummy\n        right = head\n        \n        # move right pointer n steps\n        for i in range(n):\n            right = right.next\n        \n        # move both pointers until right is None\n        while right:\n            left = left.next\n            right = right.next\n        \n        # delete the node\n        left.next = left.next.next\n        \n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if sum(machines) % n:\n            return -1\n        avg = sum(machines) // n\n        ans = cur = 0\n        for i in machines:\n            cur += i - avg\n            ans = max(ans, abs(cur))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            cnt = 0\n            for i in range(1, m + 1):\n                cnt += min(n, x // i)\n            return cnt\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1, list2 = list1.next, list2\n        \n        head = list1\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                list1 = list1.next\n            else:\n                list1.next, list2 = list2, list1\n                list1 = list1.next\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = [-1]\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while len(stack) > 1:\n            h = heights[stack.pop()]\n            w = len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [item + [num] for item in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # l, r = 0, len(nums) - 1\n        # while l < r:\n        #     m = (l + r) // 2\n        #     if nums[m] > nums[r]:\n        #         l = m + 1\n        #     elif nums[m] < nums[r]:\n        #         r = m\n        # return nums[l]\n        \n        # binary search\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # l, r = 0, len(nums) - 1\n        # while l < r:\n        #     m = (l + r) // 2\n        #     if nums[m] > nums[r]:\n        #         l = m + 1\n        #     elif nums[m] < nums[r]:\n        #         r = m\n        # return nums[l]\n        \n        # binary search\n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # l, r = 0, len(nums) - 1\n        # while l < r:\n        #     m = (l + r) // 2\n        #     if nums[m] > nums[r]:\n        #         l = m + 1\n        #     elif nums[m] < nums[r]:\n        #         r = m\n        # return nums[l]\n        \n        # binary search\n        if nums[0] < nums[-1]:\n            return nums[0]\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[r]:\n                l = m + 1\n            elif nums[m] < nums[r]:\n                r = m\n            else:\n                r -= 1\n        return nums[l]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, IV, V, IX, X, XL, L, XC, C, CD, D, CM, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, V, X, L, C, D, M\n        #"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR\n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)\n        # 5. Space complexity: O(1)\n        \n        # 1. XOR all the characters in s\n        # 2. XOR all the characters in t\n        # 3. The difference between the two is the missing character\n        # 4. Time complexity: O(n)"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_space(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        return (i, j)\n            return None\n        \n        def is_valid(board, num, pos):\n            # check row\n            for i in range(9):\n                if board[pos[0]][i] == num and pos[1] != i:\n                    return False\n            \n            # check column\n            for i in range(9):\n                if board[i][pos[1]] == num and pos[0] != i:\n                    return False\n            \n            # check box\n            box_x = pos[0] // 3\n            box_y = pos[1] // 3\n            \n            for i in range(box_x * 3, box_x * 3 + 3):\n                for j in range(box_y * 3, box_y * 3 + 3):\n                    if board[i][j] == num and (i, j) != pos:\n                        return False\n            \n            return True\n        \n        def solve(board):\n            empty = find_empty_space(board)\n            if empty is None:\n                return True\n            \n            for i in range(1, 10):\n                if is_valid(board, str(i), empty):\n                    board[empty[0]][empty[1]] = str(i)\n                    \n                    if solve(board):\n                        return True\n                    \n                    board[empty[0]][empty[1]] = '.'\n            \n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node that is out of order\n        # find the first node that is larger than the second node\n        # find the second node that is smaller than the first node\n        # swap the values of the two nodes\n        \n        # find the first and second node that is out of order\n        first_out_of_order = second_out_of_order = prev = TreeNode(float('-inf'))\n        stack = []\n        \n        while True:\n            # traverse the tree in inorder\n            while root:\n                stack.append(root)\n                root = root.left\n            if not stack:\n                break\n            # find the first node that is larger than the second node\n            node = stack.pop()\n            if node.val <= prev.val:\n                if first_out_of_order is None:\n                    first_out_of_order = prev\n                second_out_of_order = node\n            prev = node\n            root = node.right\n        \n        # swap the values of the two nodes\n        first_out_of_order.val, second_out_of_order.val = second_out_of_order.val, first_out_of_order.val"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if head.val != prev.val:\n                return False\n            head = head.next\n            prev = prev.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 1\n        right = num\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        ans = [0]\n        for i in range(1, n+1):\n            ans.append(ans[i >> 1] + (i & 1))\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                if letter not in node:\n                    node[letter] = {}\n                node = node[letter]\n            node['#'] = word\n        \n        res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                self.dfs(board, i, j, trie, res)\n        return res\n    \n    def dfs(self, board, i, j, node, res):\n        letter = board[i][j]\n        if letter not in node:\n            return\n        \n        word = node.pop(letter)\n        if '#' in node:\n            res.append(node.pop('#'))\n        \n        if i > 0:\n            self.dfs(board, i-1, j, node, res)\n        if i < len(board)-1:\n            self.dfs(board, i+1, j, node, res)\n        if j > 0:\n            self.dfs(board, i, j-1, node, res)\n        if j < len(board[0])-1:\n            self.dfs(board, i, j+1, node, res)\n        \n        node[letter] = word"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for c in s_dict:\n            if s_dict[c] != t_dict.get(c, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. check each row\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # 2. check each column\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # 3. check each 3x3 box\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(box)) != len(box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        res = 0\n        for i in range(len(columnTitle)):\n            res = res * 26 + (ord(columnTitle[i]) - ord('A') + 1)\n        return res"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        second = slow.next\n        slow.next = None\n        \n        second = self.reverse(second)\n        \n        first = head\n        \n        while second:\n            temp = first.next\n            first.next = second\n            first = temp\n            \n            temp = second.next\n            second.next = first\n            second = temp\n        \n        return head\n    \n    def reverse(self, head):\n        prev = None\n        curr = head\n        \n        while curr:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        \n        return prev"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of pattern and words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for c, w in zip(pattern, words):\n            # if the word is not in the mapping, add it\n            if w not in mapping:\n                mapping[w] = c\n            # if the word is in the mapping, check if it matches the pattern\n            elif mapping[w] != c:\n                return False\n        \n        # if we reach here, all words are mapped correctly\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        l = 0\n        r = m * n - 1\n        \n        while l <= r:\n            mid = (l + r) // 2\n            if matrix[mid // n][mid % n] == target:\n                return True\n            elif matrix[mid // n][mid % n] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry % 10)\n            carry //= 10\n            curr = curr.next\n            \n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip bits\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip bits\n        binary = ''.join('1' if bit == '0' else '0' for bit in binary)\n        \n        # 3. convert back to decimal\n        return int(binary, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += i - 1\n            else:\n                diff = nums[i] - nums[i-1]\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        cur_len = 0\n        cur_words = []\n        \n        for word in words:\n            if cur_len + len(word) + len(cur_words) > maxWidth:\n                if len(cur_words) == 1:\n                    res.append(cur_words[0] + ' ' * (maxWidth - cur_len))\n                else:\n                    spaces = (maxWidth - cur_len) // (len(cur_words) - 1)\n                    extra = (maxWidth - cur_len) % (len(cur_words) - 1)\n                    res.append(''.join(cur_words[i] + ' ' * (spaces + 1) + (' ' * extra) if i < len(cur_words) - 1 else cur_words[i] + ' ' * (spaces + extra)) for i in range(len(cur_words)))\n                cur_len = 0\n                cur_words = []\n            cur_len += len(word)\n            cur_words.append(word)\n        if cur_len:\n            res.append(' '.join(cur_words + [' '] * (maxWidth - len(' '.join(cur_words)))) if len(cur_words) > 1 else cur_words[0] + ' ' * (maxWidth - len(cur_words[0])))\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area ="}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time: O(N^2)\n        # Space: O(N)\n        \n        # 1. Create a set of words\n        # 2. Iterate through each word\n        # 3. For each word, check if it can be formed by concatenating other words in the set\n        # 4. If it can, add it to the result\n        # 5. If it can't, add it to the set\n        \n        word_set = set(words)\n        result = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                result.append(word)\n            word_set.add(word)\n        \n        return result\n    \n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and (suffix in word_set or self.dfs(suffix, word_set)):\n                return True\n        return False"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = -num\n            sign = -1\n        else:\n            sign = 1\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res if sign == 1 else '-' + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(row + 1, cols | {col}, diag1 | {row + col}, diag2 | {row - col})\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def solve(row, cols, diag1, diag2):\n            if row == n:\n                return [['.'*col + 'Q' + '.'*(n-col-1) for col in cols]]\n            \n            ans = []\n            for col in range(n):\n                if cols & (1 << col) == 0 and diag1 & (1 << (row+col)) == 0 and diag2 & (1 << (row-col+n-1)) == 0:\n                    ans.extend(solve(row+1, cols | (1 << col), (diag1 | (1 << (row+col))) | (1 << (row-col+n-1)), diag2 | (1 << (row-col+n-1))))\n            return ans\n        \n        return solve(0, 0, 0, 0)"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.dfs(board, word, i, j):\n                    return True\n        return False\n    \n    def dfs(self, board, word, i, j):\n        if len(word) == 0:\n            return True\n        \n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n            return False\n        \n        tmp = board[i][j]\n        board[i][j] = '#'\n        \n        res = self.dfs(board, word[1:], i + 1, j) or self.dfs(board, word[1:], i - 1, j) or self.dfs(board, word[1:], i, j + 1) or self.dfs(board, word[1:], i, j - 1)\n        \n        board[i][j] = tmp\n        \n        return res"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted(nums1[:m] + nums2[:n])\n        \n        # nums1[:m+n] = sorted("}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max\n        # 3. else return the third element\n        \n        nums = sorted(set(nums))\n        return nums[-3] if len(nums) < 3 else nums[-1]"}]}