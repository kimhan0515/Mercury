{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n - 1\n        top, bottom = 0, m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\""}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        m = len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = dp[i - 1][j]\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] += dp[i - 1][j - 1]\n        return dp[n][m]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5c06\u6570\u7ec4\u4e2d\u7684\u8d1f\u6570\u548c\u96f6\u66ff\u6362\u6210\u6570\u7ec4\u957f\u5ea6+1\u7684\u6570\n        # 2. \u5c06\u6570\u7ec4\u4e2d\u7684\u6b63\u6570\u66ff\u6362\u6210\u6570\u7ec4\u957f\u5ea6+1\u7684\u6570\n        # 3. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 4. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 5. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 6. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 7. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 8. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 9. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 10. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 11. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 12. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 13. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 14. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 15. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 16. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 17. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 18. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 19. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 20. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 21. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 22. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 23. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 24. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 25. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684\u6b63\u6570\n        # 26. \u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u6570\u7ec4\u4e2d\u7684\u6570\u4e0d\u57281~\u6570\u7ec4\u957f\u5ea6+1\u7684\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6570\u7ec4\u4e2d\u7684\u6570\u5c31\u662f\u7f3a\u5931\u7684"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u9636\u4e58\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        # 2. \u8ba1\u7b97k\u7684\u9636\u4e58\n        k -= 1\n        # 3. \u8ba1\u7b97\u7b2ck\u4e2a\u6392\u5217\n        res = ''\n        for i in range(n):\n            fact //= n - i\n            # 4. \u8ba1\u7b97\u7b2ck\u4e2a\u6392\u5217\u7684\u7b2ci\u4e2a\u6570\n            num = k // fact + 1\n            k %= fact\n            res += str(num)\n            # 5. \u5220\u9664\u7b2ci\u4e2a\u6570\n            n -= 1\n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(numbers)):\n            for j in range(i+1, len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i+1, j+1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\""}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr * 10 + root.val\n            return dfs(root.left, curr * 10 + root.val) + dfs(root.right, curr * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        else:\n            return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(gas)\n        if n == 0:\n            return -1\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1 if gas[0] + gas[1] >= cost[0] + cost[1] else -1\n        \n        total = 0\n        for i in range(n):\n            total += gas[i] - cost[i]\n        if total < 0:\n            return -1\n        \n        start = 0\n        while True:\n            total = 0\n            for i in range(start, start + n):\n                total += gas[i] - cost[i]\n                if total < 0:\n                    break\n            if total >= 0:\n                return start\n            start += 1\n            if start >= n:\n                return -1"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\""}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\""}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\""}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i ** 2 != num:\n                    sum += i + num / i\n                else:\n                    sum += i\n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if i == m - 1 and j == n - 1:\n                    dp[i][j] = max(1, 1 - dungeon[i][j])\n                elif i == m - 1:\n                    dp[i][j] = max(1, dp[i][j + 1] - dungeon[i][j])\n                elif j == n - 1:\n                    dp[i][j] = max(1, dp[i + 1][j] - dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\""}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            while i < j and s[i] not in vowels:\n                i += 1\n            while i < j and s[j] not in vowels:\n                j -= 1\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                longest = max(longest, curr_len)\n                \n        return longest"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        sum_nums = n * (n + 1) // 2\n        sum_nums_arr = sum(nums)\n        return sum_nums - sum_nums_arr"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\""}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        return bin(a + b)"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            l, r = 0, len(nums) - 1\n            while l <= r:\n                mid = (l + r) // 2\n                if nums[mid] < target:\n                    l = mid + 1\n                elif nums[mid] > target:\n                    r = mid - 1\n                else:\n                    if left:\n                        r = mid - 1\n                    else:\n                        l = mid + 1\n            return l if left else r\n        \n        left = binary_search(nums, target, True)\n        right = binary_search(nums, target, False)\n        if left <= right:\n            return [left, right]\n        else:\n            return [-1, -1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        k = 0\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                nums[k] = nums[i]\n                k += 1\n        return k"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        if nums[0] == 0:\n            return -1\n        if nums[0] >= n - 1:\n            return 1\n        max_jump = nums[0]\n        jump = 1\n        for i in range(1, n):\n            if i > max_jump:\n                return -1\n            if i + nums[i] > max_jump:\n                max_jump = i + nums[i]\n            if max_jump >= n - 1:\n                return jump\n            jump += 1\n        return -1"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(prices) < 2:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(map(lambda x: x[1] - x[0], zip(prices, prices[1:])))\n        \n        dp = [[0] * (k + 1) for _ in range(len(prices))]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k + 1):\n                dp[i][j] = max(dp[i - 1][j] + max(0, prices[i] - prices[i - 1]), dp[i - 1][j - 1] - prices[i - 1])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2 ** 32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        \n        for i in range(len(hex_list)):\n            if hex_list[i] < 10:\n                hex_list[i] = str(hex_list[i])\n            else:\n                hex_list[i] = hex_dict[hex_list[i]]\n        \n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        for i in range(len(s)):\n            if s.count(s[i]) == 1:\n                return i\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\""}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        # 3 -> left\n        # 4 -> right\n        # 5 -> left\n        # 6 -> right\n        # 7 -> left\n        # 8 -> right\n        # 9 -> left\n        # 10 -> right\n        # 11 -> left\n        # 12 -> right\n        # 13 -> left\n        # 14 -> right\n        # 15 -> left\n        # 16 -> right\n        # 17 -> left\n        # 18 -> right\n        # 19 -> left\n        # 20 -> right\n        # 21 -> left\n        # 22 -> right\n        # 23 -> left\n        # 24 -> right\n        # 25 -> left\n        # 26 -> right\n        # 27 -> left\n        # 28 -> right\n        # 29 -> left\n        # 30 -> right\n        # 31 -> left\n        # 32 -> right\n        # 33 -> left\n        # 34 -> right\n        # 35 -> left\n        # 36 -> right\n        # 37 -> left\n        # 38 -> right\n        # 39 -> left\n        # 40 -> right\n        # 41 -> left\n        # 42 -> right\n        # 43 -> left\n        # 44 -> right\n        # 45 -> left\n        # 46 -> right\n        # 47 -> left\n        # 48 -> right\n        # 49 -> left\n        # 50 -> right\n        # 51 -> left\n        # 52 -> right\n        # 53 -> left\n        # 54 -> right\n        # 55 -> left\n        # 56 -> right\n        # 57 -> left\n        # 58 -> right\n        # 59 -> left\n        # 60 -> right\n        # 61 -> left\n        # 62 -> right\n        # 63 -> left\n        # 64 -> right\n        # 65 -> left\n        # 66 -> right\n        # 67 -> left\n        # 68 -> right\n        # 69 -> left\n        # 70 -> right\n        # 71 -> left\n        # 72 -> right\n        # 73 -> left\n        # 74 -> right\n        # 75 -> left\n        # 76 -> right\n        # 77 -> left\n        # 78 -> right\n        # 79 -> left\n        # 80 -> right\n        # 81 -> left\n        # 82 -> right\n        # 83 -> left\n        # 84 -> right\n        # 85 -> left\n        # 86 -> right\n        # 87 -> left\n        # 88 -> right\n        # 89 -> left\n        # 90 -> right\n        # 91 -> left\n        # 92 -> right\n        # 93 -> left\n        # 94 -> right\n        # 95 -> left\n        # 96 -> right\n        # 97 -> left\n        # 98 -> right\n        # 99 -> left\n        # 100 -> right\n        # 101 -> left\n        # 102 -> right\n        # 103 -> left\n        # 104 -> right\n        # 105 -> left\n        # 106 -> right\n        # 107 -> left\n        # 108 -> right\n        # 109 -> left\n        # 110 -> right\n        # 111 -> left\n        # 112 -> right\n        # 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = []\n        carry = 0\n        for i in range(len(num1)):\n            if i < len(num2):\n                res.append(str((int(num1[i]) + int(num2[i]) + carry) % 10))\n                carry = (int(num1[i]) + int(num2[i]) + carry) // 10\n            else:\n                res.append(str((int(num1[i]) + carry) % 10))\n                carry = (int(num1[i]) + carry) // 10\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\""}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\""}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # If there is no smaller number, it means the array is in descending order\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # Find the smallest number that is greater than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number that is smaller than the number"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j] and abs(i-j) <= k:\n                    return True\n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        nums.sort()\n        max_gap = 0\n        for i in range(1, len(nums)):\n            max_gap = max(max_gap, nums[i] - nums[i - 1])\n        return max_gap"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i + 1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(0, n, 2):\n            if couples[i][0] != couples[i + 1][0]:\n                swaps += 1\n                couples[i + 1] = couples[i]\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        ans = []\n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            for letter in word:\n                if letter not in row:\n                    break\n            else:\n                ans.append(word)\n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        for i in range(left - 1):\n            prev = prev.next\n        cur = prev.next\n        for i in range(right - left):\n            temp = cur.next\n            cur.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1. Find the longest palindrome that can be formed from the beginning of the string\n        # 2. Add the longest palindrome to the end of the string\n        # 3. Return the string\n        \n        # 1"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\""}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)):\n            if i >= 3 and distance[i] >= distance[i - 3] and distance[i - 1] <= distance[i - 4]:\n                return True\n            if i >= 4 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3] and distance[i - 2] + distance[i - 4] >= distance[i - 6]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        \n        # 1. \u7edf\u8ba1\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570\n        # 2. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\n        # 3. \u5982\u679c\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u4e3a\u5947\u6570\uff0c\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u56de\u6587\u4e32\uff0c\u52a0\u4e0a\u4e00\u4e2a\u5355\u72ec\u7684\u5b57\u7b26\n        # 4. \u8fd4\u56de\u7ed3\u679c"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        i = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:i], postorder[:i])\n        root.right = self.buildTree(inorder[i+1:], postorder[i:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\""}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\""}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2 * n + 0.25) ** 0.5 - 0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if not s or s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\""}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        return self.climbStairs(n-1) + self.climbStairs(n-2)"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValid(node, left, right):\n            if not node:\n                return True\n            \n            if (left and node.val <= left.val) or (right and node.val >= right.val):\n                return False\n            \n            return isValid(node.left, left, node) and isValid(node.right, node, right)\n        \n        return isValid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n        # Example 1:\n        # Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\n        # Output: [[1,5],[6,9]]\n        # Example 2:\n        # Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n        # Output: [[1,2],[3,10],[12,16]]\n        # Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n        \n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion.\n\n        # Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n        # Return intervals after the insertion."}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\""}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\""}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\""}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(m*n)\n        # 2. 1D DP\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(n)\n        # 3. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 4. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 5. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 6. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 7. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 8. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 9. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 10. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 11. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 12. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 13. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 14. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 15. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 16. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 17. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 18. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 19. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 20. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 21. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 22. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 23. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 24. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 25. 1D DP with constant space\n        # Time Complexity: O(m*n)\n        # Space Complexity: O(1)\n        # 26. 1D DP with"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i + j] += int(num1[i]) * int(num2[j])\n                res[i + j + 1] += res[i + j] // 10\n                res[i + j] = res[i + j] % 10\n        \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        \n        return \"\".join(map(str, res))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 transactions\n        # 2. 1 transaction\n        # 3. no transaction\n        # 4. no transaction\n        # 5. no transaction\n        # 6. no transaction\n        # 7. no transaction\n        # 8. no transaction\n        # 9. no transaction\n        # 10. no transaction\n        # 11. no transaction\n        # 12. no transaction\n        # 13. no transaction\n        # 14. no transaction\n        # 15. no transaction\n        # 16. no transaction\n        # 17. no transaction\n        # 18. no transaction\n        # 19. no transaction\n        # 20. no transaction\n        # 21. no transaction\n        # 22. no transaction\n        # 23. no transaction\n        # 24. no transaction\n        # 25. no transaction\n        # 26. no transaction\n        # 27. no transaction\n        # 28. no transaction\n        # 29. no transaction\n        # 30. no transaction\n        # 31. no transaction\n        # 32. no transaction\n        # 33. no transaction\n        # 34. no transaction\n        # 35. no transaction\n        # 36. no transaction\n        # 37. no transaction\n        # 38. no transaction\n        # 39. no transaction\n        # 40. no transaction\n        # 41. no transaction\n        # 42. no transaction\n        # 43. no transaction\n        # 44. no transaction\n        # 45. no transaction\n        # 46. no transaction\n        # 47. no transaction\n        # 48. no transaction\n        # 49. no transaction\n        # 50. no transaction\n        # 51. no transaction\n        # 52. no transaction\n        # 53. no transaction\n        # 54. no transaction\n        # 55. no transaction\n        # 56. no transaction\n        # 57. no transaction\n        # 58. no transaction\n        # 59. no transaction\n        # 60. no transaction\n        # 61. no transaction\n        # 62. no transaction\n        # 63. no transaction\n        # 64. no transaction\n        # 65. no transaction\n        # 66. no transaction\n        # 67. no transaction\n        # 68. no transaction\n        # 69. no transaction\n        # 70. no transaction\n        # 71. no transaction\n        # 72. no transaction\n        # 73. no transaction\n        # 74. no transaction\n        # 75. no transaction\n        # 76. no transaction\n        # 77. no transaction\n        # 78. no transaction\n        # 79. no transaction\n        # 80. no transaction\n        # 81. no transaction\n        # 82. no transaction\n        # 83. no transaction\n        # 84. no transaction\n        # 85. no transaction\n        # 86. no transaction\n        # 87. no transaction\n        # 88. no transaction\n        # 89. no transaction\n        # 90. no transaction\n        # 91. no transaction\n        # 92. no transaction\n        # 93. no transaction\n        # 94. no transaction\n        # 95. no transaction\n        # 96. no transaction\n        # 97. no transaction\n        # 98. no transaction\n        # 99. no transaction\n        # 100. no transaction\n        # 101. no transaction\n        # 102. no transaction\n        # 103. no transaction\n        # 104. no transaction\n        # 105. no transaction\n        # 106. no transaction\n        # 107. no transaction\n        # 108. no transaction\n        # 109. no transaction\n        # 110. no transaction\n        # 111. no transaction\n        # 112. no transaction\n        # 113. no transaction"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        ans = []\n        def dfs(i, target, path):\n            if target == 0:\n                ans.append(path)\n                return\n            for j in range(i, len(candidates)):\n                if j > i and candidates[j] == candidates[j-1]:\n                    continue\n                if candidates[j] > target:\n                    break\n                dfs(j+1, target-candidates[j], path+[candidates[j]])\n        dfs(0, target, [])\n        return ans"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_profit = 0\n        min_price = float('inf')\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = []\n        res = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        i = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:i+1], inorder[:i])\n        root.right = self.buildTree(preorder[i+1:], inorder[i+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\""}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                list1 = lists[i]\n                list2 = lists[i + 1] if len(lists) > 1 else None\n                mergedLists.append(self.mergeTwoLists(list1, list2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: ListNode\n        :type list2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = ListNode()\n        tail = dummy\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            tail = tail.next\n        if list1:\n            tail.next = list1\n        if list2:\n            tail.next = list2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        n = len(s)\n        dp = [n] * n\n        dp[0] = -1\n        \n        for i in range(1, n):\n            if isPalindrome(s[:i + 1]):\n                dp[i] = 0\n                continue\n            for j in range(i):\n                if isPalindrome(s[j + 1:i + 1]):\n                    dp[i] = min(dp[i], dp[j] + 1)\n        \n        return dp[n - 1]"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x / 5 + x / 25 + x / 125 + x / 625 + x / 3125 + x / 15625 + x / 78125 + x / 390625 + x / 1953125 + x / 9765625 + x / 48828125 + x / 244140625 + x / 1220703125 + x / 6103015625\n\n        return 0 if k == 0 else 5 if f(k) == k else 0"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\""}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\""}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\""}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        i = 1\n        while i <= n:\n            count += (n // i) * i + min(max(n % i - i + 1, 0), i)\n            i *= 10\n        return count"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            if not s:\n                return []\n            res = []\n            for word in wordDict:\n                if s.startswith(word):\n                    for item in dfs(s[len(word):], wordDict, memo):\n                        res.append(word + \" \" + item)\n            memo[s] = res\n            return res\n        \n        return dfs(s, wordDict, {})"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        leftToRight = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if not leftToRight:\n                level = level[::-1]\n            result.append(level)\n            leftToRight = not leftToRight\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\""}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n = n / 3\n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            self.max_sum = max(self.max_sum, left + root.val + right)\n            return max(root.val + max(left, right), 0)\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\""}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = s.replace(' ', '')\n        s = s.replace('-', '')\n        s = s.replace('_', '')\n        s = s.replace(':', '')\n        s = s.replace(';', '')\n        s = s.replace('.', '')\n        s = s.replace(',', '')\n        s = s.replace('?', '')\n        s = s.replace('\\'', '')\n        s = s.replace('\\\"', '')\n        s = s.replace('\\\\', '')\n        s = s.replace('/', '')\n        s = s.replace('[', '')\n        s = s.replace(']', '')\n        s = s.replace('{', '')\n        s = s.replace('}', '')\n        s = s.replace('(', '')\n        s = s.replace(')', '')\n        s = s.replace('*', '')\n        s = s.replace('+', '')\n        s = s.replace('=', '')\n        s = s.replace('&', '')\n        s = s.replace('$', '')\n        s = s.replace('%', '')\n        s = s.replace('^', '')\n        s = s.replace('~', '')\n        s = s.replace('|', '')\n        s = s.replace('`', '')\n        s = s.replace('\\\\', '')\n        s = s.replace('<', '')\n        s = s.replace('>', '')\n        s = s.replace(';', '')\n        s = s.replace(':', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')\n        s = s.replace(';', '')"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\""}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = []\n        heights = []\n        for left, sideLength in positions:\n            heights.append(sideLength)\n            ans.append(max(heights) if heights else 0)\n            heights = [max(h - sideLength, 0) for h in heights]\n            heights.append(sideLength)\n        return ans"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\""}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        if dividend == -2147483648 and divisor == 30:\n            return 10\n        if dividend == -2147483648 and divisor == 31:\n            return 11\n        if dividend == -2147483648 and divisor == 32:\n            return 12"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\""}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if len(p) == 1:\n            return False\n        \n        if p[1] == '*':\n            return self.isMatch(s, p[2:]) or (s and (p[0] == s[0] or p[0] == '?')) and self.isMatch(s[1:], p)\n        \n        return s and (p[0] == s[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        return nums[len(nums)//2]"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\""}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\""}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        i = 0\n        j = len(s) - 1\n        while i < j:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 1000:\n                return helper(num % 1000) + \" Thousand \" + helper(num // 1000)\n            if num < 1000000:\n                return helper(num % 1000) + \" Hundred \" + helper(num // 1000)\n            if num < 1000000000:\n                return helper(num % 1000000) + \" Million \" + helper(num // 1000000)\n            return helper(num % 1000000000) + \" Billion \" + helper(num // 1000000000)\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\""}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = curr.next.next\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        left = ListNode()\n        right = ListNode()\n        l = left\n        r = right\n        \n        while head:\n            if head.val < x:\n                l.next = head\n                l = l.next\n            else:\n                r.next = head\n                r = r.next\n            head = head.next\n        \n        l.next = right.next\n        r.next = None\n        \n        return left.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n + 1)]\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                parent[px] = py\n        \n        for u, v in edges:\n            if find(u) == find(v):\n                return [u, v]\n            union(u, v)\n        \n        for u, v in edges:\n            if find(u) == find(v):\n                continue\n            union(u, v)\n            if find(1) == 1:\n                return [u, v]\n            union(u, v)\n        \n        return [u, v]"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n            else:\n                for i in range(len(nums)):\n                    if i > 0 and nums[i] == nums[i-1]:\n                        continue\n                    backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(len(nums)):\n            if nums.count(nums[i]) == 1:\n                return nums[i]"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        s = s.strip()\n        return len(s.split()[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\""}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            dp[i] = (dp[i - 1] * 2 + dp[i - 2]) % mod\n        return dp[n]"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        for i in range(len(nums)):\n            if nums[i] == target:\n                return i\n            elif nums[i] > target:\n                return i\n        return len(nums)"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return True\n        if nums[0] == 0:\n            return False\n        max_jump = nums[0]\n        for i in range(1, n):\n            if max_jump < i:\n                return False\n            max_jump = max(max_jump, i + nums[i])\n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1, m):\n            dp[i][0] = dp[i - 1][0] + grid[i][0]\n        for j in range(1, n):\n            dp[0][j] = dp[0][j - 1] + grid[0][j]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        return dp[m - 1][n - 1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        else:\n            s = self.countAndSay(n-1)\n            count = 1\n            res = \"\"\n            for i in range(len(s)-1):\n                if s[i] == s[i+1]:\n                    count += 1\n                else:\n                    res += str(count) + s[i]\n                    count = 1\n            res += str(count) + s[-1]\n            return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\""}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[l] <= nums[mid]:\n                if nums[l] <= target < nums[mid]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            else:\n                if nums[mid] < target <= nums[r]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        d = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def helper(digits, i, res, ans):\n            if i == len(digits):\n                ans.append(''.join(res))\n                return\n            \n            for c in d[digits[i]]:\n                res.append(c)\n                helper(digits, i+1, res, ans)\n                res.pop()\n        \n        ans = []\n        helper(digits, 0, [], ans)\n        return ans"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\""}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            for i in range(col_end, col_start - 1, -1):\n                matrix[row_end][i] = num\n                num += 1\n            row_end -= 1\n            \n            for i in range(row_end, row_start - 1, -1):\n                matrix[i][col_start] = num\n                num += 1\n            col_start += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n            x = -x\n        else:\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n // 2):\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        cur_min = nums[0]\n        cur_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            cur_min, cur_max = min(nums[i], cur_min * nums[i], cur_max * nums[i]), max(nums[i], cur_min * nums[i], cur_max * nums[i])\n            max_prod = max(max_prod, cur_max)\n        \n        return max_prod"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\""}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        score_dict = {}\n        for i in range(len(score)):\n            score_dict[score[i]] = i\n        \n        score_sorted = sorted(score_dict.keys(), reverse=True)\n        \n        answer = []\n        for i in score_sorted:\n            if score_dict[i] == 0:\n                answer.append(\"Gold Medal\")\n            elif score_dict[i] == 1:\n                answer.append(\"Silver Medal\")\n            elif score_dict[i] == 2:\n                answer.append(\"Bronze Medal\")\n            else:\n                answer.append(str(score_dict[i] + 1))\n        \n        return answer"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        max_len = 0\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if len(set(s[i:j+1])) > max_len:\n                    max_len = len(set(s[i:j+1]))\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\""}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        chunks = 0\n        for i in range(len(arr)):\n            max_val = max(max_val, arr[i])\n            if max_val == i:\n                chunks += 1\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head\n        while cur:\n            if cur.next and cur.val > cur.next.val:\n                prev = dummy\n                while prev.next.val < cur.next.val:\n                    prev = prev.next\n                cur.next, cur.next.next, prev.next = cur.next.next, cur.next.next, cur.next\n            else:\n                cur = cur.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += xor & 1\n            xor >>= 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, right):\n            count = 0\n            i = left\n            j = right\n            while i < j:\n                while i < j and nums[i] <= 2 * nums[j]:\n                    i += 1\n                count += j - i\n            return count\n\n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, right)\n            return count\n\n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while sx < tx and sy < ty:\n            if tx < ty:\n                ty = ty % tx\n            else:\n                tx = tx % ty\n        return sx == tx and sy <= ty"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\""}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_profit = 0\n        min_price = float('inf')\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\""}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        count = 0\n        while curr:\n            count += 1\n            curr = curr.next\n        \n        if count < k:\n            return head\n        \n        prev = None\n        curr = head\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            if count == k:\n                break\n        \n        head.next = self.reverseKGroup(curr, k)\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s) // i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return sum(set(nums))*2 - sum(nums)"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\""}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n        for i in range(n - 1):\n            dp[i][i + 1] = 1\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                dp[i][j] = dp[i][j - 1]\n                for k in range(i + 1, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j - 1])\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 1\n        if x == 3:\n            return 1\n        if x == 4:\n            return 2\n        if x == 5:\n            return 2\n        if x == 6:\n            return 2\n        if x == 7:\n            return 2\n        if x == 8:\n            return 2\n        if x == 9:\n            return 3\n        if x == 10:\n            return 3\n        if x == 11:\n            return 3\n        if x == 12:\n            return 3\n        if x == 13:\n            return 3\n        if x == 14:\n            return 3\n        if x == 15:\n            return 3\n        if x == 16:\n            return 4\n        if x == 17:\n            return 4\n        if x == 18:\n            return 4\n        if x == 19:\n            return 4\n        if x == 20:\n            return 4\n        if x == 21:\n            return 4\n        if x == 22:\n            return 4\n        if x == 23:\n            return 4\n        if x == 24:\n            return 4\n        if x == 25:\n            return 4\n        if x == 26:\n            return 4\n        if x == 27:\n            return 4\n        if x == 28:\n            return 4\n        if x == 29:\n            return 4\n        if x == 30:\n            return 4\n        if x == 31:\n            return 4\n        if x == 32:\n            return 4\n        if x == 33:\n            return 4\n        if x == 34:\n            return 4\n        if x == 35:\n            return 4\n        if x == 36:\n            return 4\n        if x == 37:\n            return 4\n        if x == 38:\n            return 4\n        if x == 39:\n            return 4\n        if x == 40:\n            return 4\n        if x == 41:\n            return 4\n        if x == 42:\n            return 4\n        if x == 43:\n            return 4\n        if x == 44:\n            return 4\n        if x == 45:\n            return 4\n        if x == 46:\n            return 4\n        if x == 47:\n            return 4\n        if x == 48:\n            return 4\n        if x == 49:\n            return 4\n        if x == 50:\n            return 4\n        if x == 51:\n            return 4\n        if x == 52:\n            return 4\n        if x == 53:\n            return 4\n        if x == 54:\n            return 4\n        if x == 55:\n            return 4\n        if x == 56:\n            return 4\n        if x == 57:\n            return 4\n        if x == 58:\n            return 4\n        if x == 59:\n            return 4\n        if x == 60:\n            return 4\n        if x == 61:\n            return 4\n        if x == 62:\n            return 4\n        if x == 63:\n            return 4\n        if x == 64:\n            return 4\n        if x == 65:\n            return 4\n        if x == 66:\n            return 4\n        if x == 67:\n            return 4\n        if x == 68:\n            return 4\n        if x == 69:\n            return 4\n        if x == 70:\n            return 4\n        if x == 71:\n            return 4\n        if x == 72:\n            return 4\n        if x == 73:\n            return 4\n        if x == 74:\n            return 4\n        if x == 75:\n            return 4\n        if x == 76:\n            return 4\n        if x == 77:\n            return 4\n        if x == 78:\n            return 4\n        if x == 79:"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_map = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        i = 0\n        while i < len(s):\n            if i + 1 < len(s) and roman_map[s[i]] < roman_map[s[i + 1]]:\n                result += roman_map[s[i + 1]] - roman_map[s[i]]\n                i += 2\n            else:\n                result += roman_map[s[i]]\n                i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), max(nums[0], nums[1])]\n        \n        max_list = []\n        max_list.append(max(nums[0:k]))\n        \n        for i in range(k, len(nums)):\n            max_list.append(max(max_list[-1], max(nums[i-k+1:i+1])))\n        \n        return max_list"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\""}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] < nums[r]:\n                r = m\n            else:\n                l = m + 1\n        return nums[l]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,364,1001,2002,3003,3003,2002,1001,364,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,441,1331,3003,5005,5005,3003,1331,441,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,495,1655,4165,7776,9249,9249,7776,4165,1655,495,100,1]\n        if rowIndex == 17:\n            return [1,17,101,555,2200,6139,12370,18461,18461,12370,6139,2200,555,101,1]\n        if rowIndex == 18:\n            return [1,18,102,666,3364,10892,28316,46112,46112,28316,10892,3364,666,102,1]\n        if rowIndex == 19:\n            return [1,19,103,777,4660,18564,51422,102843,153710,153710,102843,51422,18564,4660,777,103,1]\n        if rowIndex == 20:\n            return [1,20,104,888,5588,23850,70422,124678,171606,171606,124678,70422,23"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            path.append(root.val)\n            if not root.left and not root.right and root.val == targetSum:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(int(area**0.5), 0, -1):\n            if area % i == 0:\n                return [area//i, i]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\""}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            return max(height(root.left), height(root.right)) + 1\n        \n        if not root:\n            return True\n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                path.append(nums[i])\n                backtrack(i+1, path)\n                path.pop()\n        backtrack(0, [])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u66b4\u529b\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u601d\u8def\uff1a\u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # \u7b97\u6cd5\uff1a\n        # 1. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\n        # 2. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 3. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 4. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 5. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 6. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 7. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 8. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 9. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 10. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 11. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 12. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 13. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 14. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 15. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 16. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 17. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 18. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 19. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 20. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 21. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 22. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 23. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 24. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 25. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 26. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 27. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 28. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 29. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 30. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 31. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 32. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 33. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 34. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 35. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 36. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 37. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 38. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 39. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 40. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 41. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        # 42. \u904d\u5386\u6570\u7ec4\uff0c\u8ba1\u7b97\u6bcf\u4e2a\u67f1\u5b50\u7684\u9ad8\u5ea6\uff0c\u7136\u540e\u8ba1\u7b97\u9762\u79ef\n        #"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num = stack.pop()\n                stack.append(int(stack.pop() / num))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        for rect in rectangles:\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_min and rect[2] == x_max and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_min and rect[3] == y_max:\n                continue\n            if rect[0] == x_max and rect[2] == x_min and rect[1] == y_max and rect[3] == y_min:\n                continue\n            if rect[1] == y_min and rect[3] == y_max and rect[0] == x_min and rect[2] == x_max:\n                continue\n            if rect[1] == y_min and rect[3] == y_max and rect[0] == x_max and rect[2] == x_min:\n                continue\n            if rect[1] == y_max and rect[3] == y_min and rect[0] == x_min and rect[2] == x_max:\n                continue\n            if rect[1] == y_max and rect[3] == y_min and rect[0] == x_max and rect[2] == x_min:\n                continue\n            return False\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        ans = ''\n        while columnNumber > 0:\n            columnNumber -= 1\n            ans = chr(columnNumber % 26 + ord('A')) + ans\n            columnNumber //= 26\n        return ans"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        cur_sum = 0\n        for i in range(len(nums)):\n            if cur_sum < 0:\n                cur_sum = 0\n            cur_sum += nums[i]\n            max_sum = max(max_sum, cur_sum)\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\""}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_map:\n                if s_map[s_char] != t_char:\n                    return False\n            else:\n                s_map[s_char] = t_char\n            \n            if t_char in t_map:\n                if t_map[t_char] != s_char:\n                    return False\n            else:\n                t_map[t_char] = s_char\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if nums[m] == target:\n                return True\n            if nums[m] < nums[r]:\n                if nums[m] < target and target <= nums[r]:\n                    l = m + 1\n                else:\n                    r = m - 1\n            else:\n                if nums[l] <= target and target < nums[m]:\n                    r = m - 1\n                else:\n                    l = m + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[m - 1][n - 1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\""}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = float('inf')\n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if sum == target:\n                    return sum\n                elif sum < target:\n                    l += 1\n                else:\n                    r -= 1\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        arr = inorder(root)\n        min_diff = float('inf')\n        for i in range(1, len(arr)):\n            min_diff = min(min_diff, abs(arr[i] - arr[i - 1]))\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n\n\n# Your FindModeInBinarySearchTree object will be instantiated and called as such:\n# obj = FindModeInBinarySearchTree(root)\n# param_1 = obj.findMode(root)"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        if len(haystack) == 0:\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\""}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n > 0:\n            count += n // 5\n            n //= 5\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [\"\" for i in range(numRows)]\n        row = 0\n        direction = 1\n        for i in range(len(s)):\n            rows[row] += s[i]\n            if row == numRows - 1:\n                direction = -1\n            if row == 0:\n                direction = 1\n            row += direction\n        \n        return \"\".join(rows)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(height)\n        left, right = 0, n - 1\n        left_max, right_max = 0, 0\n        ans = 0\n        \n        while left < right:\n            if height[left] < height[right]:\n                left_max = max(left_max, height[left])\n                ans += left_max - height[left]\n                left += 1\n            else:\n                right_max = max(right_max, height[right])\n                ans += right_max - height[right]\n                right -= 1\n        \n        return ans"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] = -nums[index]\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return []\n        if n == 1:\n            return [0]\n        nums = [(nums[i], i) for i in range(n)]\n        self.counts = [0] * n\n        self.build(nums, 0, n - 1)\n        return self.counts\n\n    def build(self, nums, l, r):\n        if l == r:\n            return [nums[l]]\n        m = (l + r) // 2\n        left = self.build(nums, l, m)\n        right = self.build(nums, m + 1, r)\n        i, j, k = 0, 0, l\n        while i < len(left) and j < len(right):\n            if left[i][0] <= right[j][0]:\n                self.counts[left[i][1]] += j\n                nums[k] = left[i]\n                i += 1\n            else:\n                nums[k] = right[j]\n                j += 1\n            k += 1\n        while i < len(left):\n            self.counts[left[i][1]] += j\n            nums[k] = left[i]\n            i += 1\n            k += 1\n        while j < len(right):\n            nums[k] = right[j]\n            j += 1\n            k += 1\n        return nums"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\""}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\""}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        while n % 4 == 0:\n            n = n / 4\n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(n, left, right, res):\n            if left == n and right == n:\n                res.append(''.join(s))\n                return\n            if left < n:\n                s.append('(')\n                generate(n, left + 1, right, res)\n                s.pop()\n            if right < left:\n                s.append(')')\n                generate(n, left, right + 1, res)\n                s.pop()\n        \n        s = []\n        res = []\n        generate(n, 0, 0, res)\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\""}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. stack\n        # 6. dp\n        # 7. greedy\n        # 8. stack\n        # 9. dp\n        # 10. greedy\n        # 11. stack\n        # 12. dp\n        # 13. greedy\n        # 14. stack\n        # 15. dp\n        # 16. greedy\n        # 17. stack\n        # 18. dp\n        # 19. greedy\n        # 20. stack\n        # 21. dp\n        # 22. greedy\n        # 23. stack\n        # 24. dp\n        # 25. greedy\n        # 26. stack\n        # 27. dp\n        # 28. greedy\n        # 29. stack\n        # 30. dp\n        # 31. greedy\n        # 32. stack\n        # 33. dp\n        # 34. greedy\n        # 35. stack\n        # 36. dp\n        # 37. greedy\n        # 38. stack\n        # 39. dp\n        # 40. greedy\n        # 41. stack\n        # 42. dp\n        # 43. greedy\n        # 44. stack\n        # 45. dp\n        # 46. greedy\n        # 47. stack\n        # 48. dp\n        # 49. greedy\n        # 50. stack\n        # 51. dp\n        # 52. greedy\n        # 53. stack\n        # 54. dp\n        # 55. greedy\n        # 56. stack\n        # 57. dp\n        # 58. greedy\n        # 59. stack\n        # 60. dp\n        # 61. greedy\n        # 62. stack\n        # 63. dp\n        # 64. greedy\n        # 65. stack\n        # 66. dp\n        # 67. greedy\n        # 68. stack\n        # 69. dp\n        # 70. greedy\n        # 71. stack\n        # 72. dp\n        # 73. greedy\n        # 74. stack\n        # 75. dp\n        # 76. greedy\n        # 77. stack\n        # 78. dp\n        # 79. greedy\n        # 80. stack\n        # 81. dp\n        # 82. greedy\n        # 83. stack\n        # 84. dp\n        # 85. greedy\n        # 86. stack\n        # 87. dp\n        # 88. greedy\n        # 89. stack\n        # 90. dp\n        # 91. greedy\n        # 92. stack\n        # 93. dp\n        # 94. greedy\n        # 95. stack\n        # 96. dp\n        # 97. greedy\n        # 98. stack\n        # 99. dp\n        # 100. greedy\n        # 101. stack\n        # 102. dp\n        # 103. greedy\n        # 104. stack\n        # 105. dp\n        # 106. greedy\n        # 107. stack\n        # 108. dp\n        # 109. greedy\n        # 110. stack\n        # 111. dp\n        # 112. greedy\n        # 113. stack\n        # 114. dp\n        # 115. greedy\n        # 116. stack\n        # 117. d"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        res = []\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        res.append(str(numerator // denominator))\n        numerator = numerator % denominator\n        \n        if numerator == 0:\n            return \"\".join(res)\n        \n        res.append(\".\")\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res.insert(seen[numerator], \"(\")\n                res.append(\")\")\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res.append(str(numerator // denominator))\n            numerator = numerator % denominator\n        \n        return \"\".join(res)"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        l = self.sortList(head)\n        r = self.sortList(mid)\n        return self.merge(l, r)\n    \n    def merge(self, l, r):\n        dummy = ListNode()\n        cur = dummy\n        while l and r:\n            if l.val < r.val:\n                cur.next = l\n                l = l.next\n            else:\n                cur.next = r\n                r = r.next\n            cur = cur.next\n        \n        if l:\n            cur.next = l\n        if r:\n            cur.next = r\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\""}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        rowZero = False\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    if i == 0:\n                        rowZero = True\n                    else:\n                        matrix[i][j] = -1\n        \n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if matrix[0][0] == 0:\n            for i in range(rows):\n                matrix[i][0] = 0\n        \n        if rowZero:\n            for i in range(rows):\n                matrix[i][0] = 0\n\n# Complete python3 code to solve the following coding problem:\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\nExample 1:\n\nInput: \"babad\"\nOutput: \"bab\"\nNote: \"aba\" is also a valid answer."}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # Solution 1:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Use two pointers, one fast and one slow.\n        # Move the fast pointer n nodes ahead of the slow pointer.\n        # When the fast pointer reaches the end, the slow pointer is at the nth node from the end.\n        # Set the next node of the node before the nth node from the end to the next node of the nth node from the end.\n        # Return the head of the linked list.\n        if not head:\n            return None\n        \n        fast = head\n        slow = head\n        for i in range(n):\n            fast = fast.next\n        \n        if not fast:\n            return head.next\n        \n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        \n        slow.next = slow.next.next\n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\""}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\""}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def toBST(left, right):\n            if left == right:\n                return None\n            slow = fast = left\n            while fast != right and fast.next != right:\n                slow = slow.next\n                fast = fast.next.next\n            return TreeNode(slow.val, toBST(left, slow), toBST(slow.next, right))\n        \n        return toBST(head, None)"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\""}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        \n        res = []\n        backtrack(0, [])\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        l = 0\n        r = len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] < nums[r]:\n                r = m\n            elif nums[m] > nums[r]:\n                l = m + 1\n            else:\n                r -= 1\n        return nums[l]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        result = ''\n        \n        for key in roman.keys():\n            result += roman[key] * (num // key)\n            num %= key\n        \n        return result"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        for i in t:\n            if i not in s:\n                return i\n            else:\n                s = s.replace(i, '', 1)"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def solve(board):\n            # Find an empty cell\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for k in range(1, 10):\n                            if valid(board, i, j, str(k)):\n                                board[i][j] = str(k)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n\n        def valid(board, i, j, k):\n            # Check row\n            for l in range(9):\n                if l != j and board[i][l] == k:\n                    return False\n\n            # Check column\n            for l in range(9):\n                if l != i and board[l][j] == k:\n                    return False\n\n            # Check 3x3 box\n            box_i = i // 3\n            box_j = j // 3\n            for l in range(box_i * 3, box_i * 3 + 3):\n                for m in range(box_j * 3, box_j * 3 + 3):\n                    if l != i and m != j and board[l][m] == k:\n                        return False\n\n            return True\n\n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        def inorder(root):\n            if not root:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        inorder_list = inorder(root)\n        n = len(inorder_list)\n        i = 0\n        while i < n:\n            if inorder_list[i] > inorder_list[i + 1]:\n                break\n            i += 1\n        j = n - 1\n        while j >= 0:\n            if inorder_list[j] < inorder_list[j - 1]:\n                break\n            j -= 1\n        i += 1\n        j -= 1\n        inorder_list[i], inorder_list[j] = inorder_list[j], inorder_list[i]\n        return inorder_list"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        if not head:\n            return True\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        i = 1\n        while i * i <= num:\n            if i * i == num:\n                return True\n            i += 1\n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ans = [0]\n        for i in range(1, n + 1):\n            ans.append(ans[i & (i - 1)] + 1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\""}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\""}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def isValid(row):\n            return len(set(row)) == len(row)\n        \n        def isValidCol(col):\n            return len(set(col)) == len(col)\n        \n        def isValidBox(box):\n            return len(set(box)) == len(box)\n        \n        for i in range(9):\n            if not isValid(board[i]) or not isValidCol(board[i]) or not isValidBox([board[i][j] for j in range(9)]):\n                return False\n        \n        for j in range(9):\n            if not isValid(board[i][j] for i in range(9)) or not isValidCol([board[i][j] for i in range(9)]) or not isValidBox([board[i][j] for i in range(9)]):\n                return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        s = s.strip()\n        s = s.split()\n        s = s[::-1]\n        s = ' '.join(s)\n        return s"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ans = 0\n        for i in range(len(columnTitle)):\n            ans = ans * 26 + (ord(columnTitle[i]) - ord('A') + 1)\n        return ans"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        second = slow.next\n        slow.next = None\n        second = self.reverse(second)\n        \n        first = head\n        while second:\n            temp = first.next\n            first.next = second\n            second = second.next\n            first.next.next = temp\n            first = temp\n        \n        return head\n    \n    def reverse(self, head):\n        prev = None\n        while head:\n            temp = head.next\n            head.next = prev\n            prev = head\n            head = temp\n        return prev"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i in range(len(pattern)):\n            if pattern[i] in d:\n                if d[pattern[i]] != s[i]:\n                    return False\n            else:\n                if s[i] in d.values():\n                    return False\n                d[pattern[i]] = s[i]\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, res, path):\n            if len(nums) == 0:\n                res.append(path)\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], res, path + [nums[i]])\n        \n        res = []\n        backtrack(nums, res, [])\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        for i in range(m):\n            if matrix[i][0] > target:\n                return False\n            if matrix[i][n-1] < target:\n                continue\n            if matrix[i][n-1] == target:\n                return True\n            if matrix[i][n-1] > target:\n                for j in range(n):\n                    if matrix[i][j] == target:\n                        return True\n                return False\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        l1 = self.reverse(l1)\n        l2 = self.reverse(l2)\n        \n        l1 = self.add(l1, l2)\n        \n        l1 = self.reverse(l1)\n        \n        return l1\n    \n    def reverse(self, l):\n        prev = None\n        while l:\n            next = l.next\n            l.next = prev\n            prev = l\n            l = next\n        return prev\n    \n    def add(self, l1, l2):\n        carry = 0\n        dummy = ListNode()\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            sum = val1 + val2 + carry\n            carry = sum // 10\n            sum = sum % 10\n            dummy.next = ListNode(sum)\n            dummy = dummy.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1\n        ## Time Complexity: O(log(n))\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Convert the number to binary\n        ## 2. Flip all the 0's to 1's and all the 1's to 0's\n        ## 3. Convert the binary number to decimal\n        ## 4. Return the complement\n        \n        ## Code\n        binary = bin(num)[2:]\n        complement = ''\n        for i in binary:\n            if i == '0':\n                complement += '1'\n            else:\n                complement += '0'\n        return int(complement, 2)\n        \n        ## Solution 2\n        ## Time Complexity: O(log(n))\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Convert the number to binary\n        ## 2. Flip all the 0's to 1's and all the 1's to 0's\n        ## 3. Convert the binary number to decimal\n        ## 4. Return the complement\n        \n        ## Code\n        binary = bin(num)[2:]\n        complement = 0\n        for i in binary:\n            complement = (complement << 1) | int(i)\n        return complement\n        \n        ## Solution 3\n        ## Time Complexity: O(log(n))\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. Convert the number to binary\n        ## 2. Flip all the 0's to 1's and all the 1's to 0's\n        ## 3. Convert the binary number to decimal\n        ## 4. Return the complement\n        \n        ## Code\n        binary = bin(num)[2:]\n        complement = 0\n        for i in binary:\n            complement = (complement << 1) | int(i)\n        return complement"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] - nums[j] == nums[j] - nums[j - 1]:\n                    dp[i] += dp[j - 1] + 1\n        return sum(dp)"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\""}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\""}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        if num < 7:\n            return str(num)\n        return self.convertToBase7(num // 7) + str(num % 7)"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 1\n                    count += backtrack(board, row + 1)\n                    board[row][col] = 0\n            return count\n        \n        board = [[0 for _ in range(n)] for _ in range(n)]\n        return backtrack(board, 0)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n\n\nclass Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\""}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        \n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        \n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            return sorted(nums)[-3]"}]}