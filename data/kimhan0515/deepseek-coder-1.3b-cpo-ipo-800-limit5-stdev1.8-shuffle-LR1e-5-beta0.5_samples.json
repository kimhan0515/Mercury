{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        res = []\n        \n        left = 0\n        right = n - 1\n        top = 0\n        bottom = m - 1\n        \n        while left <= right and top <= bottom:\n            \n            # left to right\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            \n            top += 1\n            \n            # top to bottom\n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            \n            right -= 1\n            \n            # right to left\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                \n                bottom -= 1\n            \n            # bottom to top\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                \n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Sort the array\n        ## 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        ## 3. If the current number is positive and less than the length of the array, then swap the current number with the index of the current number\n        ## 4. Iterate through the array again and check if the current number is positive and less than the length of the array\n        ## 5. If the current number is positive and less than the length of the array, then return the current number\n        ## 6. If the current number is positive and greater than the length of the array, then return the length of the array + 1\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Sort the array\n        nums.sort()\n        \n        ## 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] < len(nums):\n                ## 3. If the current number is positive and less than the length of the array, then swap the current number with the index of the current number\n                temp = nums[i]\n                nums[i] = nums[temp - 1]\n                nums[temp - 1] = temp\n                \n        ## 4. Iterate through the array again and check if the current number is positive and less than the length of the array\n        for i in range(len(nums)):\n            if nums[i] > 0 and nums[i] < len(nums):\n                ## 5. If the current number is positive and less than the length of the array, then return the current number\n                return nums[i]\n            \n        ## 6. If the current number is positive and greater than the length of the array, then return the length of the array + 1\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. Generate the list of numbers from 1 to n\n        nums = [str(i) for i in range(1, n+1)]\n        \n        # 2. Calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 3. Calculate the kth permutation\n        k -= 1\n        res = \"\"\n        for i in range(n-1, -1, -1):\n            # 3.1 Calculate the index of the current digit\n            idx = k // fact\n            # 3.2 Calculate the digit\n            res += nums[idx]\n            # 3.3 Remove the digit from the list\n            nums.remove(nums[idx])\n            # 3.4 Update k\n            k = k % fact\n            # 3.5 Update the factorial\n            fact = fact // i\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Brute force approach\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # Hashmap approach\n        hashmap = {}\n        for i in range(len(numbers)):\n            if target - numbers[i] in hashmap:\n                return [hashmap[target - numbers[i]] + 1, i + 1]\n            hashmap[numbers[i]] = i\n        \n        return [-1, -1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(num, target, op, res, curr, prev):\n            if not num:\n                if curr == target:\n                    res.append(op)\n                return\n            for i in range(1, len(num) + 1):\n                if i == 1 or (num[0] != '0' and i != 1):\n                    curr = int(num[:i])\n                    if not op:\n                        backtrack(num[i:], target, num[:i], res, curr, curr)\n                    else:\n                        backtrack(num[i:], target, op + '+' + num[:i], res, curr + prev, curr)\n                        backtrack(num[i:], target, op + '-' + num[:i], res, curr - prev, -curr)\n                        backtrack(num[i:], target, op + '*' + num[:i], res, curr * prev, curr)\n        \n        res = []\n        backtrack(num, target, '', res, 0, 0)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr*10 + root.val\n            return dfs(root.left, curr*10 + root.val) + dfs(root.right, curr*10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '-', k)\n        return s"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Calculate the total gas and cost\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        ## 2. If total gas is less than total cost, return -1\n        if total_gas < total_cost:\n            return -1\n        \n        ## 3. Calculate the total gas and cost\n        total_gas = 0\n        total_cost = 0\n        start_index = 0\n        \n        for i in range(len(gas)):\n            total_gas += gas[i]\n            total_cost += cost[i]\n            \n            if total_gas < total_cost:\n                start_index = i + 1\n                total_gas = 0\n                total_cost = 0\n                \n        return start_index"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '.')\n        \n        if p[1] != '*':\n            if len(s) < 1:\n                return False\n            return (s[0] == p[0] or p[0] == '.') and self.isMatch(s[1:], p[1:])\n        \n        while len(s) > 0 and (s[0] == p[0] or p[0] == '.'):\n            if self.isMatch(s, p[2:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[2:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2):\n                if nums1[i] > nums2[j]:\n                    out.append(nums1[i])\n                    i += 1\n                else:\n                    out.append(nums2[j])\n                    j += 1\n            out += nums1[i:]\n            out += nums2[j:]\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums\n            return merge(merge_k(nums[:len(nums)//2]), merge_k(nums[len(nums)//2:]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge(nums1, nums2)\n            return merge(nums2, nums1)\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper_2(nums2, nums1)\n            if nums1[-1] > nums2[-1]:\n                return merge_k_helper_2(nums1, nums2[:-1])\n            return merge_k_helper_2(nums1[:-1], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper_3(nums2, nums1)\n            if nums1[-1] > nums2[-1]:\n                return merge_k_helper_3(nums1, nums2[:-1])\n            return merge_k_helper_3(nums1[:-1], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper_4(nums2, nums1)\n            if nums1[-1] > nums2[-1]:\n                return merge_k_helper_4(nums1, nums2[:-1])\n            return merge_k_helper_4(nums1[:-1], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            if len(nums2) == 0:\n                return nums1\n            if len(nums1) > len(nums2):\n                return merge_k_helper_5(nums2, nums1)\n            if nums1[-1] > nums2[-1]:\n                return merge_k_helper_5(nums1, nums2[:-1])\n            return merge_k_helper_5(nums1[:-1], nums2)\n        \n        def merge_k_helper_6(nums1, nums2):\n            if len(num"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i\n                if i ** 2 != num:\n                    sum += num // i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1 - dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1] - dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j] - dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n                    \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        \n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while j < len(nums) and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n                while i < len(s) and s[i] != ' ':\n                    i += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a','e','i','o','u','A','E','I','O','U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        vowel_indices.reverse()\n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. We can use the property of XOR to find the missing number.\n        ## 2. We can use the property of XOR to find the missing number.\n        ## 3. We can use the property of XOR to find the missing number.\n        ## 4. We can use the property of XOR to find the missing number.\n        ## 5. We can use the property of XOR to find the missing number.\n        ## 6. We can use the property of XOR to find the missing number.\n        ## 7. We can use the property of XOR to find the missing number.\n        ## 8. We can use the property of XOR to find the missing number.\n        ## 9. We can use the property of XOR to find the missing number.\n        ## 10. We can use the property of XOR to find the missing number.\n        ## 11. We can use the property of XOR to find the missing number.\n        ## 12. We can use the property of XOR to find the missing number.\n        ## 13. We can use the property of XOR to find the missing number.\n        ## 14. We can use the property of XOR to find the missing number.\n        ## 15. We can use the property of XOR to find the missing number.\n        ## 16. We can use the property of XOR to find the missing number.\n        ## 17. We can use the property of XOR to find the missing number.\n        ## 18. We can use the property of XOR to find the missing number.\n        ## 19. We can use the property of XOR to find the missing number.\n        ## 20. We can use the property of XOR to find the missing number.\n        ## 21. We can use the property of XOR to find the missing number.\n        ## 22. We can use the property of XOR to find the missing number.\n        ## 23. We can use the property of XOR to find the missing number.\n        ## 24. We can use the property of XOR to find the missing number.\n        ## 25. We can use the property of XOR to find the missing number.\n        ## 26. We can use the property of XOR to find the missing number.\n        ## 27. We can use the property of XOR to find the missing number.\n        ## 28. We can use the property of XOR to find the missing number.\n        ## 29. We can use the property of XOR to find the missing number.\n        ## 30. We can use the property of XOR to find the missing number.\n        ## 31. We can use the property of XOR to find the missing number.\n        ## 32. We can use the property of XOR to find the missing number.\n        ## 33. We can use the property of XOR to find the missing number.\n        ## 34. We can use the property of XOR to find the missing number.\n        ## 35. We can use the property of XOR to find the missing number.\n        ## 36. We can use the property of XOR to find the missing number.\n        ## 37. We can use the property of XOR to find the missing number.\n        ## 38. We can use the property of XOR to find the missing number.\n        ## 39. We can use the property of XOR to find the missing number.\n        ## 40. We can use the property of XOR to find the missing number.\n        ## 41. We can use the property of XOR to find the missing number.\n        ## 42. We can use the property of XOR to find the missing number.\n        ## 43. We can use the property of XOR to find the missing number.\n        ## 44. We can use the property of XOR to find the missing number.\n        ## 45. We can use the property of XOR to find the missing number."}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n * m)\n        # Space Complexity: O(n * m)\n        \n        # Create a graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + \"*\" + word[i+1:]\n                graph[pattern].append(word)\n        \n        # BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        level = 1\n        \n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                if curr == endWord:\n                    return level\n                \n                for i in range(len(curr)):\n                    pattern = curr[:i] + \"*\" + curr[i+1:]\n                    for neighbor in graph[pattern]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append(neighbor)\n            level += 1\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == '1' and b[i] == '1':\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n                        carry = 1\n                elif a[i] == '1' or b[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n            else:\n                if a[i] == '1':\n                    if carry == 1:\n                        res.append('0')\n                    else:\n                        res.append('1')\n                else:\n                    if carry == 1:\n                        res.append('1')\n                    else:\n                        res.append('0')\n        \n        if carry == 1:\n            res.append('1')\n        \n        return ''.join(res[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, left):\n            low = 0\n            high = len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] == target:\n                    if left:\n                        if mid == 0 or nums[mid - 1] < target:\n                            return mid\n                        high = mid - 1\n                    else:\n                        if mid == len(nums) - 1 or nums[mid + 1] > target:\n                            return mid\n                        low = mid + 1\n                elif nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return -1\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n                \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022.05.28\n        ## 2022.05.29\n        ## 2022.05.30\n        ## 2022.05.31\n        ## 2022.06.01\n        ## 2022.06.02\n        ## 2022.06.03\n        ## 2022.06.04\n        ## 2022.06.05\n        ## 2022.06.06\n        ## 2022.06.07\n        ## 2022.06.08\n        ## 2022.06.09\n        ## 2022.06.10\n        ## 2022.06.11\n        ## 2022.06.12\n        ## 2022.06.13\n        ## 2022.06.14\n        ## 2022.06.15\n        ## 2022.06.16\n        ## 2022.06.17\n        ## 2022.06.18\n        ## 2022.06.19\n        ## 2022.06.20\n        ## 2022.06.21\n        ## 2022.06.22\n        ## 2022.06.23\n        ## 2022.06.24\n        ## 2022.06.25\n        ## 2022.06.26\n        ## 2022.06.27\n        ## 2022.06.28\n        ## 2022.06.29\n        ## 2022.06.30\n        ## 2022.06.31\n        ## 2022.07.01\n        ## 2022.07.02\n        ## 2022.07.03\n        ## 2022.07.04\n        ## 2022.07.05\n        ## 2022.07.06\n        ## 2022.07.07\n        ## 2022.07.08\n        ## 2022.07.09\n        ## 2022.07.10\n        ## 2022.07.11\n        ## 2022.07.12\n        ## 2022.07.13\n        ## 2022.07.14\n        ## 2022.07.15\n        ## 2022.07.16\n        ## 2022.07.17\n        ## 2022.07.18\n        ## 2022.07.19\n        ## 2022.07.20\n        ## 2022.07.21\n        ## 2022.07.22\n        ## 2022.07.23\n        ## 2022.07.24\n        ## 2022.07.25\n        ## 2022.07.26\n        ## 2022.07.27\n        ## 2022.07.28\n        ## 2022.07.29\n        ## 2022.07.30\n        ## 2022.07."}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for i in range(len(prices)-1))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)-1):\n            for j in range(1,k+1):\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j][0]-prices[i])\n        \n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 128 ms, faster than 99.75% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.1 MB, less than 99.75% of Python online submissions for First Unique Character in a String.\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2022-08-25\n        ## 2"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(nlogk)\n        # Space Complexity: O(k)\n        \n        # Approach:\n        # 1. Sort the array\n        # 2. Iterate through the array and check if the difference between the current element and the next element is less than or equal to valueDiff\n        # 3. If the difference is less than or equal to valueDiff, return True\n        # 4. If the difference is greater than valueDiff, return False\n        \n        # Edge Cases:\n        # 1. If the array is empty, return False\n        # 2. If the valueDiff is negative, return False\n        \n        if len(nums) == 0:\n            return False\n        \n        if valueDiff < 0:\n            return False\n        \n        nums.sort()\n        \n        for i in range(len(nums)-1):\n            if nums[i+1] - nums[i] <= valueDiff:\n                return True\n        \n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        \n        left = 0\n        right = len(nums) - 1\n        i = 0\n        \n        while i <= right:\n            if nums[i] == 0:\n                nums[left], nums[i] = nums[i], nums[left]\n                left += 1\n                i += 1\n            elif nums[i] == 2:\n                nums[right], nums[i] = nums[i], nums[right]\n                right -= 1\n            else:\n                i += 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                temp = int(num1[i]) + int(num2[i]) + carry\n                carry = temp // 10\n                temp = temp % 10\n                res.append(str(temp))\n            else:\n                temp = int(num1[i]) + carry\n                carry = temp // 10\n                temp = temp % 10\n                res.append(str(temp))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack[-1] = stack[-1]*num\n                elif sign == '/':\n                    stack[-1] = int(stack[-1]/num)\n                sign = s[i]\n                num = 0\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        \n        # sort profits\n        sorted_profits = sorted(profits)\n        \n        # iterate over sorted capital\n        for i in range(len(sorted_capital)):\n            # if we can afford the next project\n            if sorted_capital[i][0] <= w:\n                # add to capital\n                w += sorted_capital[i][1]\n            # if we have enough projects\n            else:\n                # if we have enough projects\n                if k > 0:\n                    # add to capital\n                    w += sorted_profits[k-1]\n                    # decrement projects\n                    k -= 1\n                # if we don'\n                else:\n                    # return capital\n                    return w\n        # return capital\n        return w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number that is bigger than the number to its right\n        # Swap the two numbers\n        # Reverse the numbers to the right of the number that was swapped\n        \n        # Find the first number that is smaller than the number to its right\n        # Find the number"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Hashmap\n        # Store the index of the number in the hashmap\n        # If the number is already in the hashmap, check if the index is within the range of k\n        # If it is, return True\n        # If it is not, add the number to the hashmap\n        \n        hashmap = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in hashmap:\n                if abs(hashmap[nums[i]] - i) <= k:\n                    return True\n            hashmap[nums[i]] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        couples = [(row[i], row[i+1]) for i in range(0, len(row), 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        couples = [couple for couple"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            \n            for letter in word:\n                if letter not in row:\n                    break\n            else:\n                res.append(word)\n                \n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        prev.next = None\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = temp\n            count += 1\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # reverse the string\n        # find the longest palindrome that is a prefix of the string\n        # add the reverse string to the end of the string\n        # return the string\n        \n        # reverse the string\n        s = s[::-1]\n        \n        # find the longest palindrome that is a prefix of the string\n        for i in range(len(s)):\n            if s[:i+1] == s[i::-1]:\n                return s[i::-1] + s\n        \n        # add the reverse string to the end of the string\n        return s + s[::-1]"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        t_count = {}\n        for c in t:\n            t_count[c] = t_count.get(c, 0) + 1\n        \n        s_count = {}\n        for c in s:\n            s_count[c] = s_count.get(c, 0) + 1\n        \n        if t_count == s_count:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        \n        while right < len(s):\n            if s[right] in t_count:\n                s_count[s[right]] = s_count.get(s[right], 0) + 1\n                if s_count[s[right]] <= t_count[s[right]]:\n                    if right - left + 1 < min_len:\n                        min_len = right - left + 1\n                        min_left = left\n                        min_right = right\n                    s_count[s[left]] -= 1\n                    if s_count[s[left]] < t_count[s[left]]:\n                        left += 1\n                else:\n                    left += 1\n            right += 1\n        \n        return s[min_left:min_right + 1]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i+4] >= distance[i+2] and distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i+4] <= distance[i+2] and distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i+4] >= distance[i+2] and distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i+4] <= distance[i+2] and distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i+4] >= distance[i+2] and distance[i+5] <= distance[i+3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Count the frequency of each character in the string\n        # 2. If the frequency is odd, add 1 to the count\n        # 3. If the frequency is even, add it to the count\n        # 4. If the count is greater than 1, add 1 to the count\n        # 5. Return the count\n        \n        count = 0\n        for i in set(s):\n            if s.count(i) % 2 == 0:\n                count += s.count(i)\n            else:\n                count += s.count(i) - 1\n        if count < len(s):\n            count += 1\n        return count"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        root_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:root_index], postorder[:root_index])\n        root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    x, y = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] and (nx, ny) not in visited:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = []\n        for i in range(m):\n            for j in range(n):\n                if forest[i][j]:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        start = (0, 0)\n        steps = 0\n        for tree, x, y in trees:\n            steps += bfs(start, (x, y))\n            if steps < 0:\n                return -1\n            start = (x, y)\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Find the prefix sum array\n        # 3. Find the number of range sum\n        # 4. Find the number of range sum\n        \n        # 1. Sort the array\n        nums.sort()\n        \n        # 2. Find the prefix sum array\n        prefix_sum = [0]\n        for i in range(len(nums)):\n            prefix_sum.append(prefix_sum[-1] + nums[i])\n        \n        # 3. Find the number of range sum\n        # 4. Find the number of range sum\n        # 5. Find the number of range sum\n        # 6. Find the number of range sum\n        # 7. Find the number of range sum\n        # 8. Find the number of range sum\n        # 9. Find the number of range sum\n        # 10. Find the number of range sum\n        # 11. Find the number of range sum\n        # 12. Find the number of range sum\n        # 13. Find the number of range sum\n        # 14. Find the number of range sum\n        # 15. Find the number of range sum\n        # 16. Find the number of range sum\n        # 17. Find the number of range sum\n        # 18. Find the number of range sum\n        # 19. Find the number of range sum\n        # 20. Find the number of range sum\n        # 21. Find the number of range sum\n        # 22. Find the number of range sum\n        # 23. Find the number of range sum\n        # 24. Find the number of range sum\n        # 25. Find the number of range sum\n        # 26. Find the number of range sum\n        # 27. Find the number of range sum\n        # 28. Find the number of range sum\n        # 29. Find the number of range sum\n        # 30. Find the number of range sum\n        # 31. Find the number of range sum\n        # 32. Find the number of range sum\n        # 33. Find the number of range sum\n        # 34. Find the number of range sum\n        # 35. Find the number of range sum\n        # 36. Find the number of range sum\n        # 37. Find the number of range sum\n        # 38. Find the number of range sum\n        # 39. Find the number of range sum\n        # 40. Find the number of range sum\n        # 41. Find the number of range sum\n        # 42. Find the number of range sum\n        # 43. Find the number of range sum\n        # 44. Find the number of range sum\n        # 45. Find the number of range sum\n        # 46. Find the number of range sum\n        # 47. Find the number of range sum\n        # 48. Find the number of range sum\n        # 49. Find the number of range sum\n        # 50. Find the number of range sum\n        # 51. Find the number of range sum\n        # 52. Find the number of range sum\n        # 53. Find the number of range sum\n        # 54. Find the number of range sum\n        # 55. Find the number of range sum\n        # 56. Find the number of range sum\n        # 57. Find the number of range sum\n        # 58. Find the number of range sum\n        # 59. Find the number of range sum\n        # 60. Find the number of range sum\n        # 61. Find the number of range sum\n        # 62. Find the number of range sum\n        # 63. Find the number of range sum\n        # 64. Find the number of range sum\n        # 65. Find the number of range sum\n        # 66. Find the number of range sum\n        # 67. Find the number of range sum\n        # 68. Find the number of range sum\n        # 69. Find the number of range sum\n        # 70. Find the number of range sum\n        # 71. Find the number of range sum\n        # 72. Find the number of range sum\n        #"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 2:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 3:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 4:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 5:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 6:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 7:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 8:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 9:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 10:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 11:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 12:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 13:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 14:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 15:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 16:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 17:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 18:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 19:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 20:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 21:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 22:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 23:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 24:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 25:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 26:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 27:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 28:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 29:\n        # Time Complexity: O(1)\n        # Space Complexity: O(1)\n        \n        # Approach 30:\n        # Time Complexity: O("}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            queue = []\n            res.append(temp)\n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        res.append(0)\n        res.append(1)\n        \n        for i in range(1,n):\n            res.append(res[i]+2**i)\n            res.append(res[i]+2**(i-1))\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # DP solution\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[0] = True\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = True if s[:i] can be segmented into a space-separ"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root,min_val,max_val):\n            if root is None:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return inorder(root.left,min_val,root.val) and inorder(root.right,root.val,max_val)\n        \n        return inorder(root,float('-inf'),float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # edge case\n        if len(intervals) == 0:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval]\n        \n        # edge case\n        if newInterval"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, start, path, res):\n            if start == len(s):\n                res.append(path[:])\n                return\n            \n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i+1]):\n                    path.append(s[start:i+1])\n                    backtrack(s, i+1, path, res)\n                    path.pop()\n        \n        res = []\n        backtrack(s, 0, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Find the min and max of all the numbers in the list\n        # 2. Create a min heap with the min number in each list\n        # 3. Create a max heap with the max number in each list\n        # 4. Keep popping the min number from the min heap and push the max number from the max heap\n        # 5. Keep popping the min number from the min heap and push the max number from the max heap\n        # 6. Keep popping the min number from the min heap and push the max number from the max heap\n        # 7. Keep popping the min number from the min heap and push the max number from the max heap\n        # 8. Keep popping the min number from the min heap and push the max number from the max heap\n        # 9. Keep popping the min number from the min heap and push the max number from the max heap\n        # 10. Keep popping the min number from the min heap and push the max number from the max heap\n        # 11. Keep popping the min number from the min heap and push the max number from the max heap\n        # 12. Keep popping the min number from the min heap and push the max number from the max heap\n        # 13. Keep popping the min number from the min heap and push the max number from the max heap\n        # 14. Keep popping the min number from the min heap and push the max number from the max heap\n        # 15. Keep popping the min number from the min heap and push the max number from the max heap\n        # 16. Keep popping the min number from the min heap and push the max number from the max heap\n        # 17. Keep popping the min number from the min heap and push the max number from the max heap\n        # 18. Keep popping the min number from the min heap and push the max number from the max heap\n        # 19. Keep popping the min number from the min heap and push the max number from the max heap\n        # 20. Keep popping the min number from the min heap and push the max number from the max heap\n        # 21. Keep popping the min number from the min heap and push the max number from the max heap\n        # 22. Keep popping the min number from the min heap and push the max number from the max heap\n        # 23. Keep popping the min number from the min heap and push the max number from the max heap\n        # 24. Keep popping the min number from the min heap and push the max number from the max heap\n        # 25. Keep popping the min number from the min heap and push the max number from the max heap\n        # 26. Keep popping the min number from the min heap and push the max number from the max heap\n        # 27. Keep popping the min number from the min heap and push the max number from the max heap\n        # 28. Keep popping the min number from the min heap and push the max number from the max heap\n        # 29. Keep popping the min number from the min heap and push the max number from the max heap\n        # 30. Keep popping the min number from the min heap and push the max number from the max heap\n        # 31. Keep popping the min number from the min heap and push the max number from the max heap\n        # 32. Keep popping the min number from the min heap and push the max number from the max heap\n        # 33. Keep popping the min number from the min heap and push the max number from the max heap\n        # 34. Keep popping the min number from the min heap and push the max number from the max heap\n        # 35. Keep popping the min number from the min heap and push the max number from the max heap\n        # 36. Keep popping the min number from the min heap and push the max number from the max heap\n        # 37. Keep popping the min number from the min heap and push the max number from the max heap\n        # 38. Keep popping the min number from the min heap and push the max number from the max heap\n        # 39. Keep popping the min number from the min heap and push the max number from the max heap\n        # 40. Keep popping the min number from the min heap and push the max number from the max heap\n        # 41. Keep popping the min number from the min heap"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        heap = []\n        visited = set()\n        heapq.heappush(heap, (grid[0][0], 0, 0))\n        visited.add((0, 0))\n        res = 0\n        \n        while heap:\n            curr_time, x, y = heapq.heappop(heap)\n            res = max(res, curr_time)\n            if x == n - 1 and y == n - 1:\n                return res\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                if new_x < 0 or new_x >= n or new_y < 0 or new_y >= n:\n                    continue\n                if (new_x, new_y) in visited:\n                    continue\n                visited.add((new_x, new_y))\n                heapq.heappush(heap, (grid[new_x][new_y], new_x, new_y))\n                \n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        ## DP\n        ## Time Complexity: O(m*n)\n        ## Space Complexity: O(m*n)\n        \n        ## Approach:\n        ## 1. Create a 2D array of size m*n with all values as 1\n        ## 2. Iterate over the array and for each element, if the element is 1, then the number of unique paths to reach the element is equal to the sum of the number of unique paths to reach the element above and the element to the left\n        ## 3. Return the value at the last element of the array\n        \n        ## Create a 2D array of size m*n with all values as 1\n        dp = [[1 for _ in range(n)] for _ in range(m)]\n        \n        ## Iterate over the array and for each element, if the element is 1, then the number of unique paths to reach the element is equal to the sum of the number of unique paths to reach the element above and the element to the left\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        ## Return the value at the last element of the array\n        return dp[m-1][n-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        if len(prices) <= 1:\n            return 0\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j]-prices[i])\n        return max_profit\n        \n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        if len(prices) <= 1:\n            return 0\n        \n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        min_price = prices[0]\n        max_profit = 0\n        for i in range(1, len(prices)):\n            min_price = min(min_price, prices[i])\n            max_profit = max(max_profit, prices[i]-min_price)\n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target - candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper() and word[0].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n                \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            result.append(root.val)\n            root = root.right\n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        queue = collections.deque([s])\n        visited = set([s])\n        while queue:\n            s = queue.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] in '()':\n                    new_s = s[:i] + s[i+1:]\n                    if new_s not in visited:\n                        queue.append(new_s)\n                        visited.add(new_s)\n        return []"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        if l1 is None:\n            return l2\n        if l2 is None:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min(dp[j] + 1) for all j < i\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:i] is palindrome\n        # dp[i] = min(dp[j] + 1) + 1 for all j < i and s[j:"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count_zeros(n):\n            count = 0\n            while n:\n                n //= 5\n                count += n\n            return count\n        \n        low = 0\n        high = 5 * k\n        \n        while low < high:\n            mid = (low + high) // 2\n            if count_zeros(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        def getPairs(word):\n            pairs = []\n            for i in range(len(word)):\n                if isPalindrome(word[i:]):\n                    pairs.append(len(word)-i-1)\n                if i and isPalindrome(word[:i]):\n                    pairs.append(i-1)\n            return pairs\n        \n        pairs = []\n        for i in range(len(words)):\n            for j in getPairs(words[i]):\n                if i != j:\n                    pairs.append([i,j])\n        return pairs"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, row, col):\n            if isInfected[row][col] == 1:\n                return\n            isInfected[row][col] = 1\n            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                if 0 <= r < len(isInfected) and 0 <= c < len(isInfected[0]):\n                    spread(isInfected, r, c)\n        \n        def build_walls(isInfected, row, col):\n            if isInfected[row][col] == 1:\n                return\n            isInfected[row][col] = 1\n            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                if 0 <= r < len(isInfected) and 0 <= c < len(isInfected[0]):\n                    build_walls(isInfected, r, c)\n        \n        def build_walls_dfs(isInfected, row, col):\n            if isInfected[row][col] == 1:\n                return\n            isInfected[row][col] = 1\n            for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:\n                if 0 <= r < len(isInfected) and 0 <= c < len(isInfected[0]):\n                    build_walls_dfs(isInfected, r, c)\n        \n        def build_walls_bfs(isInfected, row, col):\n            if isInfected[row][col] == 1:\n                return\n            isInfected[row][col] = 1\n            q = [(row, col)]\n            while q:\n                r, c = q.pop(0)\n                for r1, c1 in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= r1 < len(isInfected) and 0 <= c1 < len(isInfected[0]):\n                        if isInfected[r1][c1] == 0:\n                            isInfected[r1][c1] = 1\n                            q.append((r1, c1))\n        \n        def build_walls_bfs_dfs(isInfected, row, col):\n            if isInfected[row][col] == 1:\n                return\n            isInfected[row][col] = 1\n            q = [(row, col)]\n            while q:\n                r, c = q.pop(0)\n                for r1, c1 in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= r1 < len(isInfected) and 0 <= c1 < len(isInfected[0]):\n                        if isInfected[r1][c1] == 0:\n                            isInfected[r1][c1] = 1\n                            q.append((r1, c1))\n                        elif isInfected[r1][c1] == 1:\n                            build_walls_bfs_dfs(isInfected, r1, c1)\n        \n        def build_walls_bfs_dfs_bfs(isInfected, row, col):\n            if isInfected[row][col] == 1:\n                return\n            isInfected[row][col] = 1\n            q = [(row, col)]\n            while q:\n                r, c = q.pop(0)\n                for r1, c1 in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= r1 < len(isInfected) and 0 <= c1 < len(isInfected[0]):\n                        if isInfected[r1][c1] == 0:\n                            isInfected[r1][c1] ="}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            max_len = 1\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    max_len = max(max_len, 1 + dfs(x, y))\n            \n            dp[i][j] = max_len\n            return max_len\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = True if s[:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # d"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level += 1\n            level_list = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_list[::-1])\n            else:\n                result.append(level_list)\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_hour(h):\n            if h < 12:\n                return str(h)\n            else:\n                return str(h - 12)\n        \n        def get_minute(m):\n            if m < 10:\n                return \"0\" + str(m)\n            else:\n                return str(m)\n        \n        def get_time_list(h, m):\n            return [get_hour(h), get_minute(m)]\n        \n        def get_time_list_from_binary(binary):\n            h = int(binary[:4], 2)\n            m = int(binary[4:], 2)\n            return get_time_list(h, m)\n        \n        def get_time_list_from_binary_string(binary_string):\n            return get_time_list_from_binary(int(binary_string, 2))\n        \n        def get_binary_string(h, m):\n            return str(bin(h))[2:] + str(bin(m))[2:]\n        \n        def get_binary_string_from_time_list(time_list):\n            h = int(time_list[0], 2)\n            m = int(time_list[1], 2)\n            return get_binary_string(h, m)\n        \n        def get_binary_string_from_binary_string(binary_string):\n            return get_binary_string_from_time_list(get_time_list_from_binary_string(binary_string))\n        \n        def get_binary_string_from_time_list_string(time_list_string):\n            return get_binary_string_from_binary_string(get_binary_string_from_time_list(time_list_string))\n        \n        def get_binary_string_from_binary_string_string(binary_string_string):\n            return get_binary_string_from_binary_string(get_binary_string_from_binary_string(binary_string_string))\n        \n        def get_binary_string_from_binary_string_string_string(binary_string_string_string):\n            return get_binary_string_from_binary_string_string(get_binary_string_from_binary_string_string(binary_string_string_string))\n        \n        def get_binary_string_from_binary_string_string_string_string(binary_string_string_string_string):\n            return get_binary_string_from_binary_string_string_string(get_binary_string_from_binary_string_string_string(binary_string_string_string_string))\n        \n        def get_binary_string_from_binary_string_string_string_string_string(binary_string_string_string_string_string):\n            return get_binary_string_from_binary_string_string_string_string(get_binary_string_from_binary_string_string_string_string(binary_string_string_string_string_string))\n        \n        def get_binary_string_from_binary_string_string_string_string_string_string(binary_string_string_string_string_string_string):\n            return get_binary_string_from_binary_string_string_string_string_string(get_binary_string_from_binary_string_string_string_string_string(binary_string_string_string_string_string_string))\n        \n        def get_binary_string_from_binary_string_string_string_string_string_string_string(binary_string_string_string_string_string_string_string):\n            return get_binary_string_from_binary_string_string_string_string_string_string(get_binary_string_from_binary_string_string_string_string_string_string(binary_string_string_string_string_string_string_string))\n        \n        def get_binary_string_from_binary_string_string_string_string_string_string_string_string(binary_string_string_string_string_string_string_string_string):\n            return get_binary_"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n            \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for d in directions:\n                new_i, new_j = i + d[0], j + d[1]\n                if new_i < 0 or new_i >= m or new_j < 0 or new_j >= n or (new_i, new_j) in visited:\n                    continue\n                visited.add((new_i, new_j))\n                if heightMap[new_i][new_j] < curr_height:\n                    ans += curr_height - heightMap[new_i][new_j]\n                heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = ''.join(filter(str.isalnum, s))\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # sliding window\n        # 1. sort the array\n        # 2. find the median\n        # 3. return the median\n        \n        # sort the array\n        nums.sort()\n        \n        # find the median\n        if len(nums) % 2 == 0:\n            median = (nums[k//2] + nums[k//2 - 1]) / 2\n        else:\n            median = nums[k//2]\n        \n        # return the median\n        return median"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr.next = head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n // 2\n        \n        while n % 3 == 0:\n            n = n // 3\n        \n        while n % 5 == 0:\n            n = n // 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n        return max_sum\n    \n    def max_subarray_sum(self, sums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for s in sums:\n            prefix_sum += s\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    if board[i][j] == 'O':\n                        dfs(i,j)\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i, j]\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        hashmap = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap:\n                return [hashmap[complement], i]\n            hashmap[nums[i]] = i\n        \n        return []"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, then return false if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, then check if there is a star in p\n        if '*' not in p:\n            # if s is empty, then return false\n            if not s:\n                return False\n            # if s is not empty, then check if the first character of s matches the first character of p\n            elif s[0] == p[0] or p[0] == '?':\n                # if the first character of s matches the first character of p, then recursively call isMatch with the remaining part of s and p\n                return self.isMatch(s[1:], p[1:])\n            else:\n                # if the first character of s does not match the first character of p, then return false\n                return False\n        else:\n            # if p contains a star, then check if the first character of p is a '?' or a character\n            if p[0] == '?':\n                # if the first character of p is a '?' or a character, then recursively call isMatch with the remaining part of s and p\n                return self.isMatch(s, p[1:])\n            else:\n                # if the first character of p is not a '?' or a character, then check if the first character of s matches the first character of p\n                if s[0] == p[0] or p[0] == '*':\n                    # if the first character of s matches the first character of p, then recursively call isMatch with the remaining part of s and p\n                    return self.isMatch(s, p[1:])\n                else:\n                    # if the first character of s does not match the first character of p, then recursively call isMatch with the remaining part of s and p\n                    return self.isMatch(s[1:], p[1:])\n        \n        # if p contains a star, then check if the first character of p is a '?' or a character\n        if p[0] == '?':\n            # if the first character of p is a '?' or a character, then recursively call isMatch with the remaining part of s and p\n            return self.isMatch(s, p[1:])\n        else:\n            # if the first character of p is not a '?' or a character, then check if the first character of s matches the first character of p\n            if s[0] == p[0] or p[0] == '*':\n                # if the first character of s matches the first character of p, then recursively call isMatch with the remaining part of s and p\n                return self.isMatch(s, p[1:])\n            else:\n                # if the first character of s does not match the first character of p, then recursively call isMatch with the remaining part of s and p\n                return self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize result\n        result = [[0,0]]\n        \n        # initialize max height\n        max_height = 0\n        \n        # initialize current building\n        current_building = None\n        \n        # loop through buildings\n        for building in buildings:\n            # if current building is None, set current building to building\n            if current_building is None:\n                current_building = building\n            # if current building is not None and current building[0] is less than or equal to building[1], update current building\n            elif current_building[0] <= building[1]:\n                current_building = building\n            # if current building is not None and current building[0] is greater than building[1], set current building to None\n            else:\n                current_building = None\n            # if current building is not None, add current building to result\n            if current_building is not None:\n                result.append(current_building)\n            # if current building is not None, update max height\n            if current_building is not None:\n                max_height = max(max_height, current_building[2])\n        \n        # initialize result\n        result = []\n        \n        # initialize current height\n        current_height = 0\n        \n        # loop through result\n        for i in range(len(result)):\n            # if result[i][1] is greater than current height, add result[i][1] to result\n            if result[i][1] > current_height:\n                result.append([result[i][0], result[i][1]])\n                current_height = result[i][1]\n            # if result[i][1] is less than current height, add result[i][1] to result\n            elif result[i][1] < current_height:\n                result.append([result[i][0], current_height])\n                current_height = result[i][1]\n            # if result[i][1] is equal to current height, add result[i][0] to result\n            else:\n                result.append([result[i][0], current_height])\n        \n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        \n        # Approach: Dynamic Programming\n        # Base Case:\n        # If the triangle is empty, return 0\n        # If the triangle has only one row, return the first element of the row\n        # If the triangle has more than one row,\n        # Iterate through the triangle from the bottom row to the top row\n        # For each element in the current row,\n        # Find the minimum sum of the two elements in the previous row\n        # Add the minimum sum to the current element\n        # Return the minimum sum\n        \n        if not triangle:\n            return 0\n        \n        if len(triangle) == 1:\n            return triangle[0][0]\n        \n        for i in range(len(triangle)-2, -1, -1):\n            for j in range(len(triangle[i])):\n                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n        \n        return triangle[0][0]"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0] * (k+1) for _ in range(n+1)]\n        \n        for i in range(1, n+1):\n            for j in range(0, k+1):\n                if j == 0:\n                    dp[i][j] = 1\n                else:\n                    if i == 1:\n                        dp[i][j] = 1\n                    else:\n                        if j >= i:\n                            dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % mod\n                        else:\n                            dp[i][j] = (dp[i][j-1] - dp[i-1][j-i] + mod) % mod\n        return dp[n][k]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        left = ListNode(0)\n        right = ListNode(0)\n        left_tail = left\n        right_tail = right\n        \n        while head:\n            if head.val < x:\n                left_tail.next = head\n                left_tail = left_tail.next\n            else:\n                right_tail.next = head\n                right_tail = right_tail.next\n            head = head.next\n        \n        left_tail.next = right.next\n        right_tail.next = None\n        \n        return left.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # edge 1: (1,2)\n        # edge 2: (2,3)\n        # edge 3: (3,4)\n        # edge 4: (4,1)\n        # edge 5: (1,5)\n        \n        # edge 1: (1,2)\n        # edge 2: (2,3)\n        # edge 3: (3,4)\n        # edge 4: (4,1)\n        # edge 5: (1,5)\n        # edge 6: (5,6)\n        # edge 7: (6,7)\n        # edge 8: (7,8)\n        # edge 9: (8,9)\n        # edge 10: (9,10)\n        # edge 11: (10,11)\n        # edge 12: (11,12)\n        # edge 13: (12,13)\n        # edge 14: (13,14)\n        # edge 15: (14,15)\n        # edge 16: (15,16)\n        # edge 17: (16,17)\n        # edge 18: (17,18)\n        # edge 19: (18,19)\n        # edge 20: (19,20)\n        # edge 21: (20,21)\n        # edge 22: (21,22)\n        # edge 23: (22,23)\n        # edge 24: (23,24)\n        # edge 25: (24,25)\n        # edge 26: (25,26)\n        # edge 27: (26,27)\n        # edge 28: (27,28)\n        # edge 29: (28,29)\n        # edge 30: (29,30)\n        # edge 31: (30,31)\n        # edge 32: (31,32)\n        # edge 33: (32,33)\n        # edge 34: (33,34)\n        # edge 35: (34,35)\n        # edge 36: (35,36)\n        # edge 37: (36,37)\n        # edge 38: (37,38)\n        # edge 39: (38,39)\n        # edge 40: (39,40)\n        # edge 41: (40,41)\n        # edge 42: (41,42)\n        # edge 43: (42,43)\n        # edge 44: (43,44)\n        # edge 45: (44,45)\n        # edge 46: (45,46)\n        # edge 47: (46,47)\n        # edge 48: (47,48)\n        # edge 49: (48,49)\n        # edge 50: (49,50)\n        # edge 51: (50,51)\n        # edge 52: (51,52)\n        # edge 53: (52,53)\n        # edge 54: (53,54)\n        # edge 55: (54,55)\n        # edge 56: (55,56)\n        # edge 57: (56,57)\n        # edge 58: (57,58)\n        # edge 59: (58,59)\n        # edge 60: (59,60)\n        # edge 61: (60,61)\n        # edge 62: (61,62)\n        # edge 63: (62,63)\n        # edge 64: (63,64)\n        # edge 65: (64,65)\n        # edge 66: (65,66)"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            \n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n                \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## XOR:\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with a number is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with a number is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is 0\n        ## XOR of a number with 0 is the number itself\n        ## XOR of a number with itself is"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    if grid[i][j1] == -1 or grid[i][j2] == -1:\n                        dp[i][j1][j2] = -1\n                    else:\n                        dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1] + (j1 != j2) * grid[i][j2]\n        res = float('-inf')\n        for j1 in range(n):\n            for j2 in range(n):\n                res = max(res, dp[n - 1][j1][j2])\n        return res if res >= 0 else 0"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        mod = 10**9 + 7\n        dp = [[0]*3 for _ in range(2)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n        dp[0][2] = 1\n        \n        for i in range(1,n):\n            dp[1][0] = (dp[0][0] + dp[0][1] + dp[0][2]) % mod\n            dp[1][1] = (dp[0][0] + dp[0][2]) % mod\n            dp[1][2] = dp[0][1] % mod\n            dp[0][0] = dp[1][0] % mod\n            dp[0][1] = dp[1][1] % mod\n            dp[0][2] = dp[1][2] % mod\n            \n        return (dp[0][0] + dp[0][1] + dp[0][2]) % mod"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        max_reach = 0\n        for i, num in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + num)\n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n            \n        for j in range(1,n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n            \n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n                \n        return dp[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211211131221\"\n        \n        if n == 13:\n            return \"13211321321123113122112131211131221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211213213211231131221\"\n        \n        if n == 15:\n            return \"311311222123113213211231131221121312111322211213213211231131221\"\n        \n        if n == 16:\n            return \"132113213211231132221121312111312212321322211213311213211231131221\"\n        \n        if n == 17:\n            return \"1113122113121321123113222112131211131221232132221121331121321123113222112133213211231131221\"\n        \n        if n == 18:\n            return \"31131122212311321321123113222112131211131221232132221121331121321123113222112133213211231131221\"\n        \n        if n == 19:\n            return \"13211321321123113222112131211131221232132221121331121321123113222112133213211231131221\"\n        \n        if n == 20:\n            return \"1113122113121321123113222112131211131221232132221121331121321123113222112133213211231131221\"\n        \n        if n == 21:\n            return \"311311222123113213211231"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isPossible(nums, k, mid):\n            count = 1\n            currSum = 0\n            for num in nums:\n                if currSum + num > mid:\n                    count += 1\n                    currSum = num\n                else:\n                    currSum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isPossible(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        \n        # edge cases\n        if len(nums) == 0:\n            return -1\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(i, curr):\n            if len(curr) == len(digits):\n                res.append(curr)\n                return\n            \n            for c in phone[digits[i]]:\n                backtrack(i+1, curr+c)\n        \n        backtrack(0, \"\")\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if target - candidates[i] < 0:\n                    break\n                curr.append(candidates[i])\n                backtrack(i, curr, target - candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # edge case\n        if n == '11':\n            return '9'\n        \n        # edge case\n        if n == '0':\n            return '0'\n        \n        # edge case\n        if n == '9':\n            return '8'\n        \n        # edge case\n        if n == '10':\n            return '9'\n        \n        # edge case\n        if n == '11':\n            return '9'\n        \n        # edge case\n        if n == '12':\n            return '11'\n        \n        # edge case\n        if n == '13':\n            return '11'\n        \n        # edge case\n        if n == '14':\n            return '11'\n        \n        # edge case\n        if n == '15':\n            return '11'\n        \n        # edge case\n        if n == '16':\n            return '11'\n        \n        # edge case\n        if n == '17':\n            return '11'\n        \n        # edge case\n        if n == '18':\n            return '11'\n        \n        # edge case\n        if n == '19':\n            return '11'\n        \n        # edge case\n        if n == '20':\n            return '11'\n        \n        # edge case\n        if n == '21':\n            return '11'\n        \n        # edge case\n        if n == '22':\n            return '11'\n        \n        # edge case\n        if n == '23':\n            return '11'\n        \n        # edge case\n        if n == '24':\n            return '11'\n        \n        # edge case\n        if n == '25':\n            return '11'\n        \n        # edge case\n        if n == '26':\n            return '11'\n        \n        # edge case\n        if n == '27':\n            return '11'\n        \n        # edge case\n        if n == '28':\n            return '11'\n        \n        # edge case\n        if n == '29':\n            return '11'\n        \n        # edge case\n        if n == '30':\n            return '11'\n        \n        # edge case\n        if n == '31':\n            return '11'\n        \n        # edge case\n        if n == '32':\n            return '11'\n        \n        # edge case\n        if n == '33':\n            return '11'\n        \n        # edge case\n        if n == '34':\n            return '11'\n        \n        # edge case\n        if n == '35':\n            return '11'\n        \n        # edge case\n        if n == '36':\n            return '11'\n        \n        # edge case\n        if n == '37':\n            return '11'\n        \n        # edge case\n        if n == '38':\n            return '11'\n        \n        # edge case\n        if n == '39':\n            return '11'\n        \n        # edge case\n        if n == '40':\n            return '11'\n        \n        # edge case\n        if n == '41':\n            return '11'\n        \n        # edge case\n        if n == '42':\n            return '11'\n        \n        # edge case\n        if n == '43':\n            return '11'\n        \n        # edge case\n        if n == '44':\n            return '11'\n        \n        # edge case\n        if n == '45':\n            return '11'\n        \n        # edge case\n        if n == '46':\n            return '11'\n        \n        # edge case\n        if n == '47':\n            return '11'\n        \n        # edge case\n        if n == '48':\n            return '11'\n        \n        # edge case\n        if n == '49':\n            return '11'\n        \n        # edge case\n        if n == '50':\n            return '11'\n        \n        # edge case\n        if n == '51':\n            return '11"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0]*n for _ in range(n)]\n        top, bottom, left, right = 0, n-1, 0, n-1\n        num = 1\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        else:\n            return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        # transpose\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(n):\n            matrix[i].reverse()"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        max_prod_so_far = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max_prod\n            max_prod = max(nums[i], nums[i] * max_prod, nums[i] * min_prod)\n            min_prod = min(nums[i], nums[i] * curr_max, nums[i] * min_prod)\n            max_prod_so_far = max(max_prod_so_far, max_prod)\n            \n        return max_prod_so_far"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        stone_set.add(stones[-1])\n        \n        stone_map = {}\n        for stone in stones:\n            stone_map[stone] = stone_set\n        \n        stone_map[0] = stone_set\n        \n        queue = deque([(0,0)])\n        while queue:\n            stone, jump = queue.popleft()\n            if stone == stones[-1]:\n                return True\n            for next_stone in stone_map[stone]:\n                if next_stone == stones[-1]:\n                    return True\n                if next_stone - stone in stone_map:\n                    queue.append((next_stone, jump + 1))\n                elif next_stone - jump - 1 in stone_map:\n                    queue.append((next_stone, jump))\n                elif next_stone - jump in stone_map:\n                    queue.append((next_stone, jump))\n                elif next_stone - jump + 1 in stone_map:\n                    queue.append((next_stone, jump))\n        return False"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in enumerate(score_sorted):\n            score_rank[s] = i + 1\n        \n        # create a list of the ranks\n        rank = []\n        for s in score:\n            rank.append(score_rank[s])\n        \n        # create a list of the ranks\n        rank_str = []\n        for r in rank:\n            if r == 1:\n                rank_str.append(\"Gold Medal\")\n            elif r == 2:\n                rank_str.append(\"Silver Medal\")\n            elif r == 3:\n                rank_str.append(\"Bronze Medal\")\n            else:\n                rank_str.append(str(r))\n        \n        return rank_str"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # time complexity: O(n)\n        # space complexity: O(n)\n        \n        # edge case\n        if len(s) == 0:\n            return 0\n        \n        # initialize\n        max_len = 0\n        curr_len = 0\n        curr_str = \"\"\n        i = 0\n        \n        # loop\n        while i < len(s):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n                i += 1\n            else:\n                max_len = max(max_len, curr_len)\n                curr_str = curr_str[curr_str.index(s[i]) + 1:] + s[i]\n                curr_len = len(curr_str)\n                i += 1\n        \n        return max(max_len, curr_len)"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                temp_word = s[j:j+word_len]\n                if temp_word in word_dict:\n                    if temp_word in temp_dict:\n                        temp_dict[temp_word] += 1\n                    else:\n                        temp_dict[temp_word] = 1\n            if temp_dict == word_dict:\n                res.append(i)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = max(arr)\n        max_idx = arr.index(max_val)\n        max_val_count = 1\n        max_val_count_idx = max_idx\n        for i in range(max_idx + 1, len(arr)):\n            if arr[i] == max_val:\n                max_val_count += 1\n                max_val_count_idx = i\n            elif arr[i] < max_val:\n                max_val_count += 1\n                max_val_count_idx = i\n            else:\n                break\n        return max_val_count"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + i for i in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            nums[left:right + 1] = temp\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(len(v1)):\n            if len(v2) > i:\n                if int(v1[i]) > int(v2[i]):\n                    return 1\n                elif int(v1[i]) < int(v2[i]):\n                    return -1\n            else:\n                if int(v1[i]) > 0:\n                    return 1\n                else:\n                    return 0\n        \n        if len(v2) > len(v1):\n            return -1\n        else:\n            return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_profit = 0\n        min_price = float('inf')\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # loop through courses\n        for duration, lastDay in courses:\n            # add to priority queue\n            heapq.heappush(pq, (-duration, lastDay))\n            \n            # add to total time\n            total += duration\n            \n            # if total time is greater than last day\n            if total > lastDay:\n                # pop from priority queue\n                total += heapq.heappop(pq)[0]\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = nxt\n        return tail"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Use a hashmap to store the frequency of each element in the array\n        ## 2. Iterate through the hashmap and return the element with frequency 1\n        \n        ## Hashmap Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Hashmap Approach\n        hashmap = {}\n        for num in nums:\n            if num not in hashmap:\n                hashmap[num] = 1\n            else:\n                hashmap[num] += 1\n        \n        for key, value in hashmap.items():\n            if value == 1:\n                return key\n        \n        return -1\n        \n        ## Bitwise XOR Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Bitwise XOR Approach\n        ## XOR all the elements in the array\n        ## XOR all the elements in the array with the result of XOR\n        ## The result will be the single element\n        \n        result = 0\n        for num in nums:\n            result = result ^ num\n        \n        return result"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if target.startswith(sticker):\n                    res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res if res != float('inf') else -1\n            return memo[target]\n        \n        memo = {}\n        return dfs(target)"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = min(dp[i][j-1],dp[i+1][j]) + 1\n                    \n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        i = 0\n        while i < len(s):\n            if i+1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n            i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iterate through the array\n        ## 3. If the element is already in the set, return True\n        ## 4. Otherwise, add the element to the set\n        ## 5. Return False\n        \n        ## Set Approach\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Approach:\n        ## 1. Create a set\n        ## 2. Iter"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # sliding window\n        # use deque\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monotonic queue\n        # maintain a monot"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        \n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        \n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n            \n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if root is None:\n                return []\n            \n            path.append(root.val)\n            \n            if root.left is None and root.right is None and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 <= area <= 10^9\n        # 2. area is a perfect square\n        # 3. area is a perfect square\n        # 4. area is a perfect square\n        # 5. area is a perfect square\n        # 6. area is a perfect square\n        # 7. area is a perfect square\n        # 8. area is a perfect square\n        # 9. area is a perfect square\n        # 10. area is a perfect square\n        # 11. area is a perfect square\n        # 12. area is a perfect square\n        # 13. area is a perfect square\n        # 14. area is a perfect square\n        # 15. area is a perfect square\n        # 16. area is a perfect square\n        # 17. area is a perfect square\n        # 18. area is a perfect square\n        # 19. area is a perfect square\n        # 20. area is a perfect square\n        # 21. area is a perfect square\n        # 22. area is a perfect square\n        # 23. area is a perfect square\n        # 24. area is a perfect square\n        # 25. area is a perfect square\n        # 26. area is a perfect square\n        # 27. area is a perfect square\n        # 28. area is a perfect square\n        # 29. area is a perfect square\n        # 30. area is a perfect square\n        # 31. area is a perfect square\n        # 32. area is a perfect square\n        # 33. area is a perfect square\n        # 34. area is a perfect square\n        # 35. area is a perfect square\n        # 36. area is a perfect square\n        # 37. area is a perfect square\n        # 38. area is a perfect square\n        # 39. area is a perfect square\n        # 40. area is a perfect square\n        # 41. area is a perfect square\n        # 42. area is a perfect square\n        # 43. area is a perfect square\n        # 44. area is a perfect square\n        # 45. area is a perfect square\n        # 46. area is a perfect square\n        # 47. area is a perfect square\n        # 48. area is a perfect square\n        # 49. area is a perfect square\n        # 50. area is a perfect square\n        # 51. area is a perfect square\n        # 52. area is a perfect square\n        # 53. area is a perfect square\n        # 54. area is a perfect square\n        # 55. area is a perfect square\n        # 56. area is a perfect square\n        # 57. area is a perfect square\n        # 58. area is a perfect square\n        # 59. area is a perfect square\n        # 60. area is a perfect square\n        # 61. area is a perfect square\n        # 62. area is a perfect square\n        # 63. area is a perfect square\n        # 64. area is a perfect square\n        # 65. area is a perfect square\n        # 66. area is a perfect square\n        # 67. area is a perfect square\n        # 68. area is a perfect square\n        # 69. area is a perfect square\n        # 70. area is a perfect square\n        # 71. area is a perfect square\n        # 72. area is a perfect square\n        # 73. area is a perfect square\n        # 74. area is a perfect square\n        # 75. area is a perfect square\n        # 76. area is a perfect square\n        # 77. area is a perfect square\n        # 78. area is a perfect square\n        # 79. area is a perfect square\n        # 80. area is a perfect square\n        # 81. area is a perfect square\n        # 82. area is a perfect square\n        # 83. area is a perfect square\n        # 84. area is a perfect square\n        # 85. area is a perfect square\n        # 86. area is a"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # Build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # BFS\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for j in range(26):\n                    neighbor = word[:i] + chr(ord(\"a\") + j) + word[i+1:]\n                    if neighbor in visited:\n                        continue\n                    if neighbor in graph:\n                        queue.append(neighbor)\n                        visited[neighbor] = word\n                    else:\n                        visited[neighbor] = None\n        \n        # Backtrack\n        res = []\n        if endWord not in visited:\n            return res\n        while endWord:\n            res.append(endWord)\n            endWord = visited[endWord]\n        return res[::-1]"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if root is None:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]]\n            else:\n                res += [nums[i]]\n                for j in range(len(res)-1, -1, -1):\n                    res.append(res[j] + [nums[i]])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n        area = 0\n        for rect in rectangles:\n            x_min = min(x_min, rect[0])\n            x_max = max(x_max, rect[2])\n            y_min = min(y_min, rect[1])\n            y_max = max(y_max, rect[3])\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if x_min < rectangles[0][0] or x_max > rectangles[-1][2] or y_min < rectangles[0][1] or y_max > rectangles[-1][3]:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the empty square\n        empty_square = None\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 0:\n                    empty_square = (i,j)\n                    break\n        \n        ## 2. Find the goal state\n        goal_state = [1,2,3,4,5,0]\n        \n        ## 3. BFS\n        queue = [(board,0)]\n        visited = set()\n        while queue:\n            board, moves = queue.pop(0)\n            if board == goal_state:\n                return moves\n            if board not in visited:\n                visited.add(board)\n                for i in range(len(board)):\n                    for j in range(len(board[0])):\n                        if board[i][j] == 0:\n                            temp = board[i][:]\n                            temp[i], temp[j] = temp[j], temp[i]\n                            if temp not in visited:\n                                queue.append((temp,moves+1))\n        return -1"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n                \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left = 0\n            right = len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        if len(nums) == 0:\n            return False\n        \n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1,m):\n            if obstacleGrid[i][0] == 1:\n                obstacleGrid[i][0] = 0\n            else:\n                obstacleGrid[i][0] = obstacleGrid[i-1][0]\n        \n        for i in range(1,n):\n            if obstacleGrid[0][i] == 1:\n                obstacleGrid[0][i] = 0\n            else:\n                obstacleGrid[0][i] = obstacleGrid[0][i-1]\n        \n        for i in range(1,m):\n            for j in range(1,n):\n                if obstacleGrid[i][j] == 1:\n                    obstacleGrid[i][j] = 0\n                else:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n        \n        return obstacleGrid[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root == None:\n            return 0\n        \n        left = self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        \n        return max(left, right) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        if root is None:\n            return []\n        \n        inorder_list = inorder(root)\n        max_count = 0\n        max_val = None\n        curr_count = 0\n        prev_val = None\n        for val in inorder_list:\n            if prev_val is None:\n                prev_val = val\n                curr_count = 1\n            elif val == prev_val:\n                curr_count += 1\n            else:\n                if curr_count > max_count:\n                    max_count = curr_count\n                    max_val = prev_val\n                curr_count = 1\n            prev_val = val\n        if curr_count > max_count:\n            max_count = curr_count\n            max_val = prev_val\n        return [max_val] if max_count == 1 else [max_val] if max_count == 2 else [max_val, max_val]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Check if password is at least 6 characters long\n        if len(password) < 6:\n            return max(6 - len(password), 3)\n        \n        # 2. Check if password is at most 20 characters long\n        if len(password) > 20:\n            return max(20 - len(password), 0)\n        \n        # 3. Check if password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        if not any(c.islower() for c in password) or not any(c.isupper() for c in password) or not any(c.isdigit() for c in password):\n            return 3\n        \n        # 4. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 5. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 6. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 7. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 8. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 9. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 10. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 11. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 12. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 13. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 14. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 15. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 16. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 17. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i+2] for i in range(len(password)-2)):\n            return 2\n        \n        # 18. Check if password contains three repeating characters in a row\n        if any(password[i] == password[i+1] == password[i"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        row = 0\n        down = False\n        \n        for i in range(len(s)):\n            res[row] += s[i]\n            if row == 0:\n                down = True\n            elif row == numRows - 1:\n                down = False\n            if down:\n                row += 1\n            else:\n                row -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Brute Force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # TLE\n        # if len(height) < 3:\n        #     return 0\n        # res = 0\n        # for i in range(1, len(height)-1):\n        #     left_max = max(height[0:i])\n        #     right_max = max(height[i+1:])\n        #     res += min(left_max, right_max) - height[i]\n        # return res\n        \n        # Approach 2: Two Pointers\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # Accepted\n        # Use two pointers, left and right, to keep track of the maximum height on the left and right\n        # Keep track of the maximum height on the left and right\n        # If the height of the left pointer is less than the height of the right pointer, move the left pointer\n        # If the height of the left pointer is greater than the height of the right pointer, move the right pointer\n        # If the height of the left pointer is equal to the height of the right pointer, move the left pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the left is less than the maximum height on the right, move the right pointer\n        # Keep track of the maximum height on the left and right\n        # If the maximum height on the left is greater than the maximum height on the right, move the left pointer\n        # If the maximum height on the"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. Create a list of size n with all zeros\n        ## 2. Iterate through the list and mark the index of the number as negative\n        ## 3. Iterate through the list again and add the index to the list\n        ## 4. Iterate through the list again and add the index to the list\n        ## 5. Iterate through the list again and add the index to the list\n        ## 6. Iterate through the list again and add the index to the list\n        ## 7. Iterate through the list again and add the index to the list\n        ## 8. Iterate through the list again and add the index to the list\n        ## 9. Iterate through the list again and add the index to the list\n        ## 10. Iterate through the list again and add the index to the list\n        ## 11. Iterate through the list again and add the index to the list\n        ## 12. Iterate through the list again and add the index to the list\n        ## 13. Iterate through the list again and add the index to the list\n        ## 14. Iterate through the list again and add the index to the list\n        ## 15. Iterate through the list again and add the index to the list\n        ## 16. Iterate through the list again and add the index to the list\n        ## 17. Iterate through the list again and add the index to the list\n        ## 18. Iterate through the list again and add the index to the list\n        ## 19. Iterate through the list again and add the index to the list\n        ## 20. Iterate through the list again and add the index to the list\n        ## 21. Iterate through the list again and add the index to the list\n        ## 22. Iterate through the list again and add the index to the list\n        ## 23. Iterate through the list again and add the index to the list\n        ## 24. Iterate through the list again and add the index to the list\n        ## 25. Iterate through the list again and add the index to the list\n        ## 26. Iterate through the list again and add the index to the list\n        ## 27. Iterate through the list again and add the index to the list\n        ## 28. Iterate through the list again and add the index to the list\n        ## 29. Iterate through the list again and add the index to the list\n        ## 30. Iterate through the list again and add the index to the list\n        ## 31. Iterate through the list again and add the index to the list\n        ## 32. Iterate through the list again and add the index to the list\n        ## 33. Iterate through the list again and add the index to the list\n        ## 34. Iterate through the list again and add the index to the list\n        ## 35. Iterate through the list again and add the index to the list\n        ## 36. Iterate through the list again and add the index to the list\n        ## 37. Iterate through the list again and add the index to the list\n        ## 38. Iterate through the list again and add the index to the list\n        ## 39. Iterate through the list again and add the index to the list\n        ## 40. Iterate through the list again and add the index to the list\n        ## 41. Iterate through the list again and add the index to the list\n        ## 42. Iterate through the list again and add the index to the list\n        ## 43. Iterate through the list again and add the index to the list\n        ## 44. Iterate through the list again and add the index to the list\n        ## 45. Iterate through the list again and add the index to the list\n        ## 46. Iterate through the list again and add the index to the list\n        ## 47. Iterate through the list again and add the index to the list\n        ## 48. Iterate through the list again and add the index to the list\n        ## 49. Iterate through the list"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            i, j, k = 0, 0, 0\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    nums[k] = left[i]\n                    i += 1\n                else:\n                    nums[k] = right[j]\n                    j += 1\n                    self.count += len(left) - i\n                k += 1\n            \n            while i < len(left):\n                nums[k] = left[i]\n                i += 1\n                k += 1\n            \n            while j < len(right):\n                nums[k] = right[j]\n                j += 1\n                k += 1\n            \n            return nums\n        \n        nums = [[nums[i], i] for i in range(len(nums))]\n        nums = mergeSort(nums)\n        return [nums[i][1] for i in range(len(nums))]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        ans = 0\n        prev = -1\n        for i in intervals:\n            if i[0] > prev:\n                ans += 2\n                prev = i[1] - 1\n            else:\n                if i[1] > prev:\n                    ans += 1\n                    prev = i[1] - 1\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(root1, root2):\n            if root1 is None and root2 is None:\n                return True\n            if root1 is None or root2 is None:\n                return False\n            if root1.val != root2.val:\n                return False\n            return isMirror(root1.left, root2.right) and isMirror(root1.right, root2.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(i)\n            elif formula[i] == ')':\n                i = self.count(formula, i, stack)\n            else:\n                i += 1\n        return ''.join(sorted(stack))\n        \n    def count(self, formula, i, stack):\n        count = 0\n        while i < len(formula) and formula[i].isdigit():\n            count = count * 10 + int(formula[i])\n            i += 1\n        if stack:\n            i = stack.pop()\n            count = count * (i - stack[-1] - 1)\n        return i"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n // 4\n            \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(open_count, close_count, curr_str, res):\n            if open_count == close_count == n:\n                res.append(curr_str)\n                return\n            if open_count < n:\n                backtrack(open_count + 1, close_count, curr_str + \"(\", res)\n            if close_count < open_count:\n                backtrack(open_count, close_count + 1, curr_str + \")\", res)\n        \n        res = []\n        backtrack(0, 0, \"\", res)\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] >= n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # Time: O(n)\n        # Space: O(n)\n        # 2. \n        # Time: O(n)\n        # Space: O(1)\n        # 3. \n        # Time: O(n)\n        # Space: O(1)\n        # 4. \n        # Time: O(n)\n        # Space: O(1)\n        # 5. \n        # Time: O(n)\n        # Space: O(1)\n        # 6. \n        # Time: O(n)\n        # Space: O(1)\n        # 7. \n        # Time: O(n)\n        # Space: O(1)\n        # 8. \n        # Time: O(n)\n        # Space: O(1)\n        # 9. \n        # Time: O(n)\n        # Space: O(1)\n        # 10. \n        # Time: O(n)\n        # Space: O(1)\n        # 11. \n        # Time: O(n)\n        # Space: O(1)\n        # 12. \n        # Time: O(n)\n        # Space: O(1)\n        # 13. \n        # Time: O(n)\n        # Space: O(1)\n        # 14. \n        # Time: O(n)\n        # Space: O(1)\n        # 15. \n        # Time: O(n)\n        # Space: O(1)\n        # 16. \n        # Time: O(n)\n        # Space: O(1)\n        # 17. \n        # Time: O(n)\n        # Space: O(1)\n        # 18. \n        # Time: O(n)\n        # Space: O(1)\n        # 19. \n        # Time: O(n)\n        # Space: O(1)\n        # 20. \n        # Time: O(n)\n        # Space: O(1)\n        # 21. \n        # Time: O(n)\n        # Space: O(1)\n        # 22. \n        # Time: O(n)\n        # Space: O(1)\n        # 23. \n        # Time: O(n)\n        # Space: O(1)\n        # 24. \n        # Time: O(n)\n        # Space: O(1)\n        # 25. \n        # Time: O(n)\n        # Space: O(1)\n        # 26. \n        # Time: O(n)\n        # Space: O(1)\n        # 27. \n        # Time: O(n)\n        # Space: O(1)\n        # 28. \n        # Time: O(n)\n        # Space: O(1)\n        # 29. \n        # Time: O(n)\n        # Space: O(1)\n        # 30. \n        # Time: O(n)\n        # Space: O(1)\n        # 31. \n        # Time: O(n)\n        # Space: O(1)\n        # 32. \n        # Time: O(n)\n        # Space: O(1)\n        # 33. \n        # Time: O(n)\n        # Space: O(1)\n        # 34. \n        # Time: O(n)\n        # Space: O(1)\n        # 35. \n        # Time: O(n)\n        # Space: O(1)\n        # 36. \n        # Time: O(n)\n        # Space: O(1)\n        # 37. \n        # Time: O(n)\n        # Space: O(1)\n        # 38. \n        # Time: O(n)\n        # Space: O(1)\n        # 39. \n        # Time: O(n)\n        # Space: O(1)\n        # 40. \n        # Time: O(n)\n        #"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder = remainder * 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str = str(quotient) + remainder_str\n        if remainder == 0:\n            remainder_str = \"\"\n        return sign + str(quotient) + remainder_str"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        elif right:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        # print(envelopes)\n        dp = [1] * len(envelopes)\n        max_val = 1\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            max_val = max(max_val, dp[i])\n        return max_val"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## row = [0]*len(matrix)\n        ## col = [0]*len(matrix[0])\n        ## for i in range(len(matrix)):\n        ##     for j in range(len(matrix[0])):\n        ##         if matrix[i][j] == 0:\n        ##             row[i] = 1\n        ##             col[j] = 1\n        ## for i in range(len(matrix)):\n        ##     for j in range(len(matrix[0])):\n        ##         if row[i] == 1 or col[j] == 1:\n        ##             matrix[i][j] = 0\n        ## return matrix\n        \n        ## O(1) space\n        row = False\n        col = False\n        for i in range(len(matrix)):\n            if matrix[i][0] == 0:\n                col = True\n            for j in range(1,len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        for i in range(len(matrix)):\n            for j in range(1,len(matrix[0])):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        if col:\n            for i in range(len(matrix)):\n                matrix[i][0] = 0\n        if row:\n            for j in range(len(matrix[0])):\n                matrix[0][j] = 0\n        return matrix"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Find the length of the linked list\n        ## 2. Find the node to be removed\n        ## 3. Remove the node\n        \n        ## Edge Cases:\n        ## 1. If the linked list is empty\n        ## 2. If the linked list has only one node\n        ## 3. If the node to be removed is the head node\n        \n        ## Variables:\n        ## 1. length: The length of the linked list\n        ## 2. node_to_remove: The node to be removed\n        ## 3. prev_node: The previous node\n        ## 4. curr_node: The current node\n        \n        ## Edge Cases:\n        ## 1. If the linked list is empty\n        ## 2. If the linked list has only one node\n        ## 3. If the node to be removed is the head node\n        \n        ## Initialization:\n        ## 1. length: The length of the linked list\n        ## 2. node_to_remove: The node to be removed\n        ## 3. prev_node: The previous node\n        ## 4. curr_node: The current node\n        \n        ## Edge Cases:\n        ## 1. If the linked list is empty\n        ## 2. If the linked list has only one node\n        ## 3. If the node to be removed is the head node\n        \n        ## Initialization:\n        ## 1. length: The length of the linked list\n        ## 2. node_to_remove: The node to be removed\n        ## 3. prev_node: The previous node\n        ## 4. curr_node: The current node\n        \n        ## Edge Cases:\n        ## 1. If the linked list is empty\n        ## 2. If the linked list has only one node\n        ## 3. If the node to be removed is the head node\n        \n        ## Initialization:\n        ## 1. length: The length of the linked list\n        ## 2. node_to_remove: The node to be removed\n        ## 3. prev_node: The previous node\n        ## 4. curr_node: The current node\n        \n        ## Edge Cases:\n        ## 1. If the linked list is empty\n        ## 2. If the linked list has only one node\n        ## 3. If the node to be removed is the head node\n        \n        ## Initialization:\n        ## 1. length: The length of the linked list\n        ## 2. node_to_remove: The node to be removed\n        ## 3. prev_node: The previous node\n        ## 4. curr_node: The current node\n        \n        ## Edge Cases:\n        ## 1. If the linked list is empty\n        ## 2. If the linked list has only one node\n        ## 3. If the node to be removed is the head node\n        \n        ## Initialization:\n        ## 1. length: The length of the linked list\n        ## 2. node_to_remove: The node to be removed\n        ## 3. prev_node: The previous node\n        ## 4. curr_node: The current node\n        \n        ## Edge Cases:\n        ## 1. If the linked list is empty\n        ## 2. If the linked list has only one node\n        ## 3. If the node to be removed is the head node\n        \n        ## Initialization:\n        ## 1. length: The length of the linked list\n        ## 2. node_to_remove: The node to be removed\n        ## 3. prev_node: The previous node\n        ## 4. curr_node: The current node\n        \n        ## Edge Cases:\n        ## 1. If the linked list is empty\n        ## 2. If the linked list has only one node\n        ## 3. If the node to be removed is the head node\n        \n        ## Initial"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 11:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 12:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 13:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 14:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 15:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 16:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 17:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 18:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 19:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 20:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 21:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 22:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 23:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 24:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 25:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 26:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 27:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## Solution 2"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 1:\n            return 0\n        \n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        \n        avg = total // n\n        \n        left = 0\n        right = 0\n        curr = 0\n        ans = 0\n        \n        for i in range(n):\n            curr += machines[i]\n            right = max(right, abs(curr - avg * (i + 1)))\n            ans = max(ans, abs(curr - avg * (i + 1)))\n        \n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        low = 1\n        high = m * n\n        \n        while low < high:\n            mid = (low + high) // 2\n            if count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            temp = list1\n            list1 = list1.next\n            temp.next = self.mergeTwoLists(list1, list2)\n            return temp\n        else:\n            temp = list2\n            list2 = list2.next\n            temp.next = self.mergeTwoLists(list1, list2)\n            return temp"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # dp[i][j] = max(dp[i][j], dp[i-1][j] + 1)\n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[i][j] = dp[i][j-1] + 1 if j > 0 else 1\n        \n        max_area = 0\n        for i in range(m):\n            stack = []\n            for j in range(n):\n                if not stack or dp[i][j] >= dp[i][stack[-1]]:\n                    stack.append(j)\n                else:\n                    while stack and dp[i][j] < dp[i][stack[-1]]:\n                        h = dp[i][stack.pop()]\n                        w = j if not stack else j - stack[-1] - 1\n                        max_area = max(max_area, h * w)\n                    stack.append(j)\n            while stack:\n                h = dp[i][stack.pop()]\n                w = n if not stack else n - stack[-1] - 1\n                max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        \n        res = []\n        backtrack(0, [])\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        try:\n            float(s)\n            return True\n        except ValueError:\n            return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}\n        roman_num = ''\n        for key in roman_dict.keys():\n            while num >= key:\n                roman_num += roman_dict[key]\n                num -= key\n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## Approach:\n        ## 1. Create a hashmap to store the frequency of each character in string s\n        ## 2. Iterate through string t and decrement the frequency of each character in hashmap\n        ## 3. Return the character with frequency of 1\n        \n        ## Code:\n        \n        hashmap = {}\n        \n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n                \n        for char in t:\n            if char not in hashmap:\n                return char\n            else:\n                hashmap[char] -= 1\n                \n        for key, value in hashmap.items():\n            if value == 1:\n                return key"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_space(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        return (i,j)\n            return None\n        \n        def is_valid(board, num, pos):\n            # Check row\n            for i in range(9):\n                if board[pos[0]][i] == num and pos[1] != i:\n                    return False\n            \n            # Check column\n            for i in range(9):\n                if board[i][pos[1]] == num and pos[0] != i:\n                    return False\n            \n            # Check 3x3 box\n            box_x = pos[1] // 3\n            box_y = pos[0] // 3\n            \n            for i in range(box_y*3, box_y*3 + 3):\n                for j in range(box_x*3, box_x*3 + 3):\n                    if board[i][j] == num and (i,j) != pos:\n                        return False\n            \n            return True\n        \n        def solve(board):\n            empty = find_empty_space(board)\n            if empty is None:\n                return True\n            \n            for i in range(1,10):\n                if is_valid(board, str(i), empty):\n                    board[empty[0]][empty[1]] = str(i)\n                    \n                    if solve(board):\n                        return True\n                    \n                    board[empty[0]][empty[1]] = '.'\n            \n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # inorder traversal\n        # find the"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        if n == 2:\n            return [0,1,1]\n        \n        if n == 3:\n            return [0,1,1,2]\n        \n        if n == 4:\n            return [0,1,1,2,2]\n        \n        if n == 5:\n            return [0,1,1,2,2,3]\n        \n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        \n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        \n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        \n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        \n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        \n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        \n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        \n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        \n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        \n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        \n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        \n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        \n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10]\n        \n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10]\n        \n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11]\n        \n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,12]\n        \n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,12,13]\n        \n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,12,13,14]\n        \n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,10,10,11,12,13,14,15]\n        \n        if n == 25"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j] or board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1,j,word[1:],visited) or dfs(i-1,j,word[1:],visited) or dfs(i,j+1,word[1:],visited) or dfs(i,j-1,word[1:],visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        visited = [[False for i in range(len(board[0]))] for j in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i,j,word,visited):\n                        res.append(word)\n                        break\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. check rows\n        for row in board:\n            if len(set(row)) != 9:\n                return False\n        \n        # 2. check columns\n        for col in range(9):\n            if len(set([board[row][col] for row in range(9)])) != 9:\n                return False\n        \n        # 3. check 3x3 sub-boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                if len(set([board[i+k][j+l] for k in range(3) for l in range(3)])) != 9:\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern is not equal to the length of the words, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between pattern and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern and word are not in the mapping, add them to the mapping\n            if pattern[i] not in mapping:\n                if words[i] not in mapping.values():\n                    mapping[pattern[i]] = words[i]\n                else:\n                    return False\n            # if the pattern and word are in the mapping, check if they match\n            else:\n                if mapping[pattern[i]] != words[i]:\n                    return False\n        \n        # if all the words are mapped correctly, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m*n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            \n            if matrix[mid//n][mid%n] == target:\n                return True\n            elif matrix[mid//n][mid%n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a new linked list\n        head = ListNode()\n        # Initialize a pointer to the new linked list\n        curr = head\n        # Initialize a variable to keep track of the carry\n        carry = 0\n        \n        # Loop until both linked lists are empty\n        while l1 or l2:\n            # If the first linked list is empty, set the value of the current node to 0\n            if not l1:\n                l1 = ListNode(0)\n            # If the second linked list is empty, set the value of the current node to 0\n            if not l2:\n                l2 = ListNode(0)\n            # Add the values of the current nodes of the two linked lists\n            sum = l1.val + l2.val + carry\n            # Set the value of the current node to the sum modulo 10\n            curr.val = sum % 10\n            # Set the carry to the sum divided by 10\n            carry = sum // 10\n            # If the sum is greater than 9, set the value of the current node to 1\n            if sum > 9:\n                curr.val = 1\n            # If the sum is less than 9, set the value of the current node to 0\n            else:\n                curr.val = 0\n            # If the sum is greater than 9, set the value of the next node to None\n            if sum > 9:\n                curr.next = None\n            # If the sum is less than 9, set the value of the next node to a new node\n            else:\n                curr.next = ListNode()\n            # Set the current node to the next node\n            curr = curr.next\n            # Move the pointers to the next nodes\n            l1 = l1.next\n            l2 = l2.next\n        \n        # If the carry is greater than 0, set the value of the current node to the carry\n        if carry > 0:\n            curr.val = carry\n            curr.next = None\n        # If the carry is less than 0, set the value of the current node to 0\n        else:\n            curr.val = 0\n            curr.next = None\n        \n        # Return the new linked list\n        return head"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Convert the number to binary\n        ## 2. Reverse the binary\n        ## 3. Convert the binary to decimal\n        ## 4. Convert the decimal to binary\n        ## 5. Convert the binary to decimal\n        ## 6. Convert the decimal to binary\n        ## 7. Convert the binary to decimal\n        ## 8. Convert the decimal to binary\n        ## 9. Convert the binary to decimal\n        ## 10. Convert the decimal to binary\n        ## 11. Convert the binary to decimal\n        ## 12. Convert the decimal to binary\n        ## 13. Convert the binary to decimal\n        ## 14. Convert the decimal to binary\n        ## 15. Convert the binary to decimal\n        ## 16. Convert the decimal to binary\n        ## 17. Convert the binary to decimal\n        ## 18. Convert the decimal to binary\n        ## 19. Convert the binary to decimal\n        ## 20. Convert the decimal to binary\n        ## 21. Convert the binary to decimal\n        ## 22. Convert the decimal to binary\n        ## 23. Convert the binary to decimal\n        ## 24. Convert the decimal to binary\n        ## 25. Convert the binary to decimal\n        ## 26. Convert the decimal to binary\n        ## 27. Convert the binary to decimal\n        ## 28. Convert the decimal to binary\n        ## 29. Convert the binary to decimal\n        ## 30. Convert the decimal to binary\n        ## 31. Convert the binary to decimal\n        ## 32. Convert the decimal to binary\n        ## 33. Convert the binary to decimal\n        ## 34. Convert the decimal to binary\n        ## 35. Convert the binary to decimal\n        ## 36. Convert the decimal to binary\n        ## 37. Convert the binary to decimal\n        ## 38. Convert the decimal to binary\n        ## 39. Convert the binary to decimal\n        ## 40. Convert the decimal to binary\n        ## 41. Convert the binary to decimal\n        ## 42. Convert the decimal to binary\n        ## 43. Convert the binary to decimal\n        ## 44. Convert the decimal to binary\n        ## 45. Convert the binary to decimal\n        ## 46. Convert the decimal to binary\n        ## 47. Convert the binary to decimal\n        ## 48. Convert the decimal to binary\n        ## 49. Convert the binary to decimal\n        ## 50. Convert the decimal to binary\n        ## 51. Convert the binary to decimal\n        ## 52. Convert the decimal to binary\n        ## 53. Convert the binary to decimal\n        ## 54. Convert the decimal to binary\n        ## 55. Convert the binary to decimal\n        ## 56. Convert the decimal to binary\n        ## 57. Convert the binary to decimal\n        ## 58. Convert the decimal to binary\n        ## 59. Convert the binary to decimal\n        ## 60. Convert the decimal to binary\n        ## 61. Convert the binary to decimal\n        ## 62. Convert the decimal to binary\n        ## 63. Convert the binary to decimal\n        ## 64. Convert the decimal to binary\n        ## 65. Convert the binary to decimal\n        ## 66. Convert the decimal to binary\n        ## 67. Convert the binary to decimal\n        ## 68. Convert the decimal to binary\n        ## 69. Convert the binary to decimal\n        ## 70. Convert the decimal to binary\n        ## 71. Convert the binary to decimal\n        ## 72. Convert the decimal to binary\n        ## 73. Convert the binary to decimal\n        ## 74. Convert the decimal to binary\n        ## 75. Convert the binary to decimal\n        ## 76. Convert the decimal to binary\n        ## 77. Convert the binary to decimal\n        ## 78. Convert the decimal to binary\n        ## 79. Convert the binary to decimal\n        ## 80"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums)-2:\n            if nums[i+1] - nums[i] == nums[i+2] - nums[i+1]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        curr = []\n        curr_len = 0\n        for word in words:\n            if curr_len + len(word) + len(curr) > maxWidth:\n                if len(curr) == 1:\n                    res.append(curr[0] + ' ' * (maxWidth - curr_len))\n                else:\n                    spaces = (maxWidth - curr_len) // (len(curr) - 1)\n                    extra = (maxWidth - curr_len) % (len(curr) - 1)\n                    res.append(''.join([word] + [spaces + ' '] * extra + [curr[i] + ' ' for i in range(1, len(curr))]))\n                curr = []\n                curr_len = 0\n            curr.append(word)\n            curr_len += len(word)\n        if curr:\n            if len(curr) == 1:\n                res.append(curr[0] + ' ' * (maxWidth - curr_len))\n            else:\n                spaces = (maxWidth - curr_len) // (len(curr) - 1)\n                extra = (maxWidth - curr_len) % (len(curr) - 1)\n                res.append(''.join([word] + [spaces + ' '] * extra + [curr[i] + ' ' for i in range(1, len(curr))]))\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    count += backtrack(board, row + 1)\n                    board[row][col] = '.'\n            return count\n        \n        board = [['.' for _ in range(n)] for _ in range(n)]\n        return backtrack(board, 0)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isValid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if isValid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max1 = max2 = max3 = float('-inf')\n        \n        for num in nums:\n            if num > max1:\n                max3 = max2\n                max2 = max1\n                max1 = num\n            elif num > max2:\n                max3 = max2\n                max2 = num\n            elif num > max3:\n                max3 = num\n                \n        return max3 if max3 != float('-inf') else max1"}]}