{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        # dp[i][j] = 0 if s[i] != t[j]\n        # dp[0][0] = 1\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[i][j] = dp[i-1][j-1] + d"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1, 2, 3, ..., n\n        # 2. 1, 2, 3, ..., n-1\n        # 3. 1, 2, 3, ..., n-2\n        # 4. 1, 2, 3, ..., n-3\n        # 5. 1, 2, 3, ..., n-4\n        # 6. 1, 2, 3, ..., n-5\n        # 7. 1, 2, 3, ..., n-6\n        # 8. 1, 2, 3, ..., n-7\n        # 9. 1, 2, 3, ..., n-8\n        # 10. 1, 2, 3, ..., n-9\n        # 11. 1, 2, 3, ..., n-10\n        # 12. 1, 2, 3, ..., n-11\n        # 13. 1, 2, 3, ..., n-12\n        # 14. 1, 2, 3, ..., n-13\n        # 15. 1, 2, 3, ..., n-14\n        # 16. 1, 2, 3, ..., n-15\n        # 17. 1, 2, 3, ..., n-16\n        # 18. 1, 2, 3, ..., n-17\n        # 19. 1, 2, 3, ..., n-18\n        # 20. 1, 2, 3, ..., n-19\n        # 21. 1, 2, 3, ..., n-20\n        # 22. 1, 2, 3, ..., n-21\n        # 23. 1, 2, 3, ..., n-22\n        # 24. 1, 2, 3, ..., n-23\n        # 25. 1, 2, 3, ..., n-24\n        # 26. 1, 2, 3, ..., n-25\n        # 27. 1, 2, 3, ..., n-26\n        # 28. 1, 2, 3, ..., n-27\n        # 29. 1, 2, 3, ..., n-28\n        # 30. 1, 2, 3, ..., n-29\n        # 31. 1, 2, 3, ..., n-30\n        # 32. 1, 2, 3, ..., n-31\n        # 33. 1, 2, 3, ..., n-32\n        # 34. 1, 2, 3, ..., n-33\n        # 35. 1, 2, 3, ..., n-34\n        # 36. 1, 2, 3, ..., n-35\n        # 37. 1, 2, 3, ..., n-36\n        # 38. 1, 2, 3, ..., n-37\n        # 39. 1, 2, 3, ..., n-38\n        # 40. 1, 2, 3, ..., n-39\n        # 41. 1, 2, 3, ..., n-40\n        # 42. 1, 2, 3, ..., n-41\n        # 43. 1, 2, 3, ..., n-42\n        # 44. 1, 2, 3, ..., n-43\n        # 45. 1, 2, 3, ..., n-44\n        # 46. 1, 2, 3, ..., n-45\n        # 47. 1, 2, 3, ..., n-46\n        # 48. 1, 2"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # 1. set left and right pointers\n        # 2. if the sum of left and right is greater than target, move right pointer to the left\n        # 3. if the sum of left and right is less than target, move left pointer to the right\n        # 4. if the sum of left and right is equal to target, return the indices\n        # 5. if the sum of left and right is not equal to target, continue the loop\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left + 1, right + 1]\n            elif numbers[left] + numbers[right] > target:\n                right -= 1\n            else:\n                left += 1\n        \n        return [left + 1, right + 1]"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(num)\n                return\n            if num[i] == '0':\n                backtrack(i+1, curr, prev, res)\n            else:\n                # add the current digit\n                backtrack(i+1, curr + int(num[i]), int(num[i]), res)\n                # add the current digit with the previous operator\n                if prev != 0:\n                    backtrack(i+1, curr + prev, int(num[i]), res)\n                    backtrack(i+1, curr - prev, -prev, res)\n                    backtrack(i+1, curr - prev + prev, prev, res)\n        \n        res = []\n        backtrack(0, 0, 0, res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr*10 + root.val\n            return dfs(root.left, curr*10 + root.val) + dfs(root.right, curr*10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        if n % k == 0:\n            return s[:k] + '-' + self.licenseKeyFormatting(s[k:], k)\n        else:\n            return s[:n % k] + '-' + self.licenseKeyFormatting(s[n % k:], k)"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the total gas and cost\n        total_gas = sum(gas)\n        total_cost = sum(cost)\n        \n        ## 2. If total gas is less than total cost, return -1\n        if total_gas < total_cost:\n            return -1\n        \n        ## 3. Initialize the tank with 0\n        tank = 0\n        start = 0\n        \n        ## 4. Iterate through the gas and cost\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                for k in range(i+1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if the first character of p is '*'\n        if len(p) > 1 and p[1] == '*':\n            # if the first character of p is '*', check if the first character of s is '*'\n            if self.isMatch(s, p[2:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, check if the first character of p is '*'\n        if p[0] == '*':\n            # if the first character of p is '*', check if the first character of s is '*'\n            if self.isMatch(s, p[1:]):\n                return True\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            if s and (p[0] == s[0] or p[0] == '.'):\n                return self.isMatch(s[1:], p)\n            # if the first character of p is not '*', check if the first character of s is not '*'\n            return self.isMatch(s, p[1:])\n        \n        # if p is not empty, check if the first character of p is '*'\n        if p[0] == '.' and s:\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, check if the first character of p is '*'\n        if s and (p[0] == s[0] or p[0] == '.'):\n            return self.isMatch(s[1:], p[1:])\n        \n        # if p is not empty, check if the first character of p is '*'\n        return False"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            # \u4ecenums\u4e2d\u6311\u9009\u51fak\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709k\u4e2a\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6ca1\u6709\u6570\uff0c\u5219\u8fd4\u56de\u7a7a\u5217\u8868\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a\u6570\n            # \u5982\u679cnums\u4e2d\u6709\u6570\uff0c\u5219\u8fd4\u56denums\u4e2d\u6700\u5927\u7684k\u4e2a"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                sum += i\n                if i**2 != num:\n                    sum += num//i\n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(len(nums)):\n                while nums[i] - nums[j] > mid:\n                    j += 1\n                count += i - j\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        for i in range(len(s)):\n            if s[i] != ' ':\n                count += 1\n        return count"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        left = 0\n        right = len(s_list) - 1\n        while left < right:\n            if s_list[left] in vowels and s_list[right] in vowels:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n            elif s_list[left] not in vowels:\n                left += 1\n            elif s_list[right] not in vowels:\n                right -= 1\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    num += 1\n                    curr_len += 1\n                max_len = max(max_len, curr_len)\n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Approach:\n        ## 1. We can use the XOR property of the numbers in the range [0, n]\n        ## 2. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 3. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 4. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 5. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 6. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 7. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 8. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 9. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 10. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 11. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 12. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 13. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 14. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 15. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 16. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 17. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 18. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 19. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 20. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 21. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 22. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 23. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 24. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 25. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 26. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 27. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 28. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 29. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 30. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 31. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 32. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 33. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 34. We can XOR all the numbers in the range [0, n] with the numbers in the array\n        ## 35. We"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a set of words from the wordList\n        wordSet = set(wordList)\n        \n        # Add beginWord to the set\n        wordSet.add(beginWord)\n        \n        # Create a queue\n        queue = collections.deque([beginWord])\n        \n        # Create a set to keep track of visited words\n        visited = set()\n        \n        # Create a variable to keep track of the number of steps\n        steps = 0\n        \n        # Loop until the queue is empty\n        while queue:\n            # Get the number of elements in the queue\n            size = len(queue)\n            \n            # Loop for each element in the queue\n            for _ in range(size):\n                # Pop the first element from the queue\n                word = queue.popleft()\n                \n                # If the word is the endWord, return the number of steps + 1\n                if word == endWord:\n                    return steps + 1\n                \n                # Loop through each letter in the word\n                for i in range(len(word)):\n                    # Create a new word by replacing each letter with a-z\n                    for letter in string.ascii_lowercase:\n                        # If the new word is not in the set, add it to the queue\n                        if word[:i] + letter + word[i+1:] not in wordSet:\n                            queue.append(word[:i] + letter + word[i+1:])\n                            # Add the new word to the set\n                            wordSet.add(word[:i] + letter + word[i+1:])\n                            \n            # Increment the number of steps by 1\n            steps += 1\n            \n        # Return 0 if the endWord is not in the set\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        a = a[::-1]\n        b = b[::-1]\n        \n        res = \"\"\n        carry = 0\n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == \"1\" and b[i] == \"1\":\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n                        carry = 1\n                elif a[i] == \"1\" or b[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n            else:\n                if a[i] == \"1\":\n                    if carry == 1:\n                        res += \"0\"\n                    else:\n                        res += \"1\"\n                else:\n                    if carry == 1:\n                        res += \"1\"\n                    else:\n                        res += \"0\"\n        if carry == 1:\n            res += \"1\"\n        return res[::-1]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1,-1]\n        \n        left = 0\n        right = len(nums)-1\n        while left < right:\n            mid = (left+right)//2\n            if nums[mid] < target:\n                left = mid+1\n            else:\n                right = mid\n        if nums[left] == target:\n            left = right\n        else:\n            return [-1,-1]\n        \n        left = 0\n        right = len(nums)-1\n        while left < right:\n            mid = (left+right)//2+1\n            if nums[mid] > target:\n                right = mid-1\n            else:\n                left = mid\n        if nums[right] == target:\n            right = left\n        else:\n            return [-1,-1]\n        \n        return [left,right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        j = 1\n        \n        while j < len(nums):\n            if nums[i] == nums[j]:\n                j += 1\n            else:\n                i += 1\n                nums[i] = nums[j]\n                j += 1\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(0, len(prices)-1)) for i in range(0, len(prices)-1, 2))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        for i in range(1, len(prices)):\n            for j in range(1, k+1):\n                dp[j][0] = max(dp[j][0], dp[j-1][1] + prices[i])\n                dp[j][1] = max(dp[j][1], dp[j][0] - prices[i])\n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_str = \"\"\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_str = str(remainder) + hex_str\n            else:\n                hex_str = hex_dict[remainder] + hex_str\n            num = num // 16\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Create a hashmap with the frequency of each character in the string\n        # 2. Iterate through the string and return the index of the first character with a frequency of 1\n        # 3. If no character with a frequency of 1 is found, return -1\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a hashmap with the frequency of each character in the string\n        frequency_map = {}\n        for char in s:\n            if char not in frequency_map:\n                frequency_map[char] = 1\n            else:\n                frequency_map[char] += 1\n        \n        # Iterate through the string and return the index of the first character with a frequency of 1\n        for i, char in enumerate(s):\n            if frequency_map[char] == 1:\n                return i\n        \n        # If no character with a frequency of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return False\n        \n        # if len(nums) <= 1:\n        #     return False\n        \n        # nums.sort()\n        # for i in range(len(nums)-1):\n        #     if abs(nums[i] - nums[i+1]) <= valueDiff and abs(i - (i+1)) <= indexDiff:\n        #         return True\n        # return"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0 -> left\n        # 1 -> right\n        # 2 -> right\n        # 3 -> left\n        # 4 -> right\n        # 5 -> left\n        # 6 -> right\n        # 7 -> left\n        # 8 -> right\n        # 9 -> left\n        # 10 -> right\n        # 11 -> left\n        # 12 -> right\n        # 13 -> left\n        # 14 -> right\n        # 15 -> left\n        # 16 -> right\n        # 17 -> left\n        # 18 -> right\n        # 19 -> left\n        # 20 -> right\n        # 21 -> left\n        # 22 -> right\n        # 23 -> left\n        # 24 -> right\n        # 25 -> left\n        # 26 -> right\n        # 27 -> left\n        # 28 -> right\n        # 29 -> left\n        # 30 -> right\n        # 31 -> left\n        # 32 -> right\n        # 33 -> left\n        # 34 -> right\n        # 35 -> left\n        # 36 -> right\n        # 37 -> left\n        # 38 -> right\n        # 39 -> left\n        # 40 -> right\n        # 41 -> left\n        # 42 -> right\n        # 43 -> left\n        # 44 -> right\n        # 45 -> left\n        # 46 -> right\n        # 47 -> left\n        # 48 -> right\n        # 49 -> left\n        # 50 -> right\n        # 51 -> left\n        # 52 -> right\n        # 53 -> left\n        # 54 -> right\n        # 55 -> left\n        # 56 -> right\n        # 57 -> left\n        # 58 -> right\n        # 59 -> left\n        # 60 -> right\n        # 61 -> left\n        # 62 -> right\n        # 63 -> left\n        # 64 -> right\n        # 65 -> left\n        # 66 -> right\n        # 67 -> left\n        # 68 -> right\n        # 69 -> left\n        # 70 -> right\n        # 71 -> left\n        # 72 -> right\n        # 73 -> left\n        # 74 -> right\n        # 75 -> left\n        # 76 -> right\n        # 77 -> left\n        # 78 -> right\n        # 79 -> left\n        # 80 -> right\n        # 81 -> left\n        # 82 -> right\n        # 83 -> left\n        # 84 -> right\n        # 85 -> left\n        # 86 -> right\n        # 87 -> left\n        # 88 -> right\n        # 89 -> left\n        # 90 -> right\n        # 91 -> left\n        # 92 -> right\n        # 93 -> left\n        # 94 -> right\n        # 95 -> left\n        # 96 -> right\n        # 97 -> left\n        # 98 -> right\n        # 99 -> left\n        # 100 -> right\n        # 101 -> left\n        # 102 -> right\n        # 103 -> left\n        # 104 -> right\n        # 105 -> left\n        # 106 -> right\n        # 107 -> left\n        # 108 -> right\n        # 109 -> left\n        # 110 -> right\n        # 111 -> left\n        # 112 -> right\n        # 1"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return (2**left_height) + self.countNodes(root.right)\n        else:\n            return (2**right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        res = \"\"\n        carry = 0\n        i = 0\n        while i < len(num1) or i < len(num2) or carry:\n            if i < len(num1):\n                carry += int(num1[i])\n            if i < len(num2):\n                carry += int(num2[i])\n            res += str(carry % 10)\n            carry //= 10\n            i += 1\n        return res[::-1]"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num*10 + int(s[i])\n            if s[i] in '+-' or i == len(s)-1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack[-1] = stack[-1]*num\n                elif sign == '/':\n                    stack[-1] = int(stack[-1]/num)\n                num = 0\n                sign = s[i]\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] == 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] == 0, then we can do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0, then we can do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] < 0, then we cannot do this project\n        # if profits[i] - capital[i] > 0,"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the first number that is smaller than the next number\n        # 2. Find the number that is larger than the first number\n        # 3. Swap the two numbers\n        # 4. Reverse the numbers after the first number\n        # 5. Return the result\n        \n        # 1. Find the first number that is smaller than the next number\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # 2. Find the number that is larger than the first number\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # 3. Swap the two numbers\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        \n        # 4. Reverse the numbers after the first number\n        return"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Hashmap\n        # Hashmap is used to store the value of the element and its index\n        # If the element is already present in the hashmap, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is greater than k, then we remove the element from the hashmap\n        # If the difference between the index of the element and the index of the element in the hashmap is less than or equal to k, then we return True\n        # If the element is not present in the hashmap, then we add the element to the hashmap\n        # If the difference between the"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(temp)\n            queue = queue[len(temp):]\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 2:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        couples = [couple for couple in couples if couple[0] % 2 != couple[1] % 2]\n        couples.sort()\n        return len(couples)"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if s1 == \"\" and s2 == \"\" and s3 == \"\":\n            return True\n        \n        if s1 == \"\" and s2 != \"\" or s1 != \"\" and s2 == \"\":\n            return False\n        \n        if s1 == \"\" and s2 == \"\" and s3 != \"\":\n            return False\n        \n        if s1 == s2 and s1 == s3:\n            return True\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 == s3:\n            return True\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1 == s2 and s1 != s3:\n            return False\n        \n        if s1 != s2 and s1 == s3:\n            return True\n        \n        if s1 != s2 and s1 != s3:\n            return False\n        \n        if s1"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        for word in words:\n            if word[0].lower() in row1:\n                row = row1\n            elif word[0].lower() in row2:\n                row = row2\n            else:\n                row = row3\n            for letter in word:\n                if letter.lower() not in row:\n                    break\n            else:\n                res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        i = 1\n        \n        while i < left:\n            prev = curr\n            curr = curr.next\n            i += 1\n        \n        prev.next = None\n        tail = curr\n        \n        while i < right:\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n            i += 1\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1. Find the longest palindrome substring of s\n        # 2. Reverse the substring\n        # 3. Concatenate the reversed substring with the original string\n        # 4. Return the concatenated string\n        \n        # 1"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            if s == t:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if s_dict == t_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        while right < len(s):\n            if s[right] in t_dict:\n                if s[right] in s_dict:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] = 1\n            right += 1\n            \n            while self.is_valid(s_dict, t_dict):\n                if right - left < min_len:\n                    min_len = right - left\n                    min_left = left\n                    min_right = right\n                if s[left] in s_dict:\n                    s_dict[s[left]] += 1\n                left += 1\n        \n        return s[min_left:min_right]\n    \n    def is_valid(self, s_dict, t_dict):\n        for k, v in t_dict.items():\n            if k not in s_dict or s_dict[k] < v:\n                return False\n        return True"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3]:\n                return True\n            if i >= 3 and distance[i] == distance[i+4] and distance[i+1] == distance[i+5] and distance[i+2] == distance[i+6]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4\uae30 \uc704\ud574\uc11c \uc911\uac04\uc5d0 \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud574\uc57c \ud55c\ub2e4.\n        # 2. \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud558\uba74 \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\n        # 3. \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4\uae30 \uc704\ud574\uc11c \uc911\uac04\uc5d0 \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud574\uc57c \ud55c\ub2e4.\n        # 4. \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud558\uba74 \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\n        # 5. \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4\uae30 \uc704\ud574\uc11c \uc911\uac04\uc5d0 \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud574\uc57c \ud55c\ub2e4.\n        # 6. \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud558\uba74 \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\n        # 7. \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4\uae30 \uc704\ud574\uc11c \uc911\uac04\uc5d0 \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud574\uc57c \ud55c\ub2e4.\n        # 8. \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud558\uba74 \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\n        # 9. \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4\uae30 \uc704\ud574\uc11c \uc911\uac04\uc5d0 \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud574\uc57c \ud55c\ub2e4.\n        # 10. \ud558\ub098\uc758 \ubb38\uc790\ub97c \ucd94\uac00\ud558\uba74 \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4 \uc218 \uc788\ub2e4.\n        # 11. \uc9dd\uc218 \uae38\uc774\uc758 \ud330\ub9b0\ub4dc\ub86c\uc744 \ub9cc\ub4e4\uae30 \uc704\ud574\uc11c \ufffd"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        inorder_index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:inorder_index], postorder[:inorder_index])\n        root.right = self.buildTree(inorder[inorder_index+1:], postorder[inorder_index:-1])\n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Find all the trees in the forest\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((i, j))\n        \n        # 2. Sort the trees by height\n        trees.sort(key=lambda x: forest[x[0]][x[1]])\n        \n        # 3. Start from the top left corner and cut off the trees\n        steps = 0\n        current_position = (0, 0)\n        for tree in trees:\n            steps += self.cut_off_tree(forest, current_position, tree)\n            if steps == -1:\n                return -1\n            current_position = tree\n        \n        return steps\n    \n    def cut_off_tree(self, forest, current_position, target):\n        \"\"\"\n        :type forest: List[List[int]]\n        :type current_position: Tuple[int, int]\n        :type target: Tuple[int, int]\n        :rtype: int\n        \"\"\"\n        # 1. Calculate the distance between the current position and the target\n        row, col = current_position\n        target_row, target_col = target\n        distance = abs(row - target_row) + abs(col - target_col)\n        \n        # 2. Move the current position to the target\n        while True:\n            # 2.1 Move the current position up\n            if row > target_row:\n                row -= 1\n            # 2.2 Move the current position down\n            elif row < target_row:\n                row += 1\n            # 2.3 Move the current position left\n            elif col > target_col:\n                col -= 1\n            # 2.4 Move the current position right\n            elif col < target_col:\n                col += 1\n            else:\n                return distance\n            \n            # 2.5 Check if the current position is within the forest boundaries\n            if row < 0 or row >= len(forest) or col < 0 or col >= len(forest[0]):\n                return -1\n            \n            # 2.6 Check if the current position is a tree\n            if forest[row][col] == 0:\n                return -1\n            \n            # 2.7 Decrement the tree height by 1\n            forest[row][col] -= 1\n            distance += 1\n        \n        return distance"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 3. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\u7684\u4e2a\u6570\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        # 5. \u65f6\u95f4\u590d\u6742\u5ea6O(nlogn)\n        # 6. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n\n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        n = len(nums)\n        preSum = [0] * (n + 1)\n        for i in range(1, n + 1):\n            preSum[i] = preSum[i - 1] + nums[i - 1]\n\n        # 2. \u4f7f\u7528\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\n        # 3. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\uff0c\u8ba1\u7b97\u533a\u95f4\u548c\u7684\u4e2a\u6570\n        # 4. \u8fd4\u56de\u7ed3\u679c\n        # 5. \u65f6\u95f4\u590d\u6742\u5ea6O(nlogn)\n        # 6. \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        preSum.sort()\n        res = 0\n        for i in range(n):\n            left = bisect_left(preSum, preSum[i] - lower)\n            right = bisect_right(preSum, preSum[i] - upper)\n            res += right - left\n        return res"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k = k(k+1)/2\n        # k^2 + k - 2n = 0\n        # k = (-1 + sqrt(1 + 8n))/2\n        return int((-1 + sqrt(1 + 8*n))/2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            temp = []\n            for node in queue:\n                temp.append(node.val)\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            queue = temp\n            result.append(temp)\n        \n        return result[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        temp = x\n        \n        while temp > 0:\n            rev = rev * 10 + temp % 10\n            temp = temp // 10\n        \n        if rev == x:\n            return True\n        \n        return False"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0]\n        for i in range(1,n):\n            res.append(res[-1]+2**i)\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isValidBSTUtil(root, min_val, max_val):\n            if root is None:\n                return True\n            \n            if root.val <= min_val or root.val >= max_val:\n                return False\n            \n            return isValidBSTUtil(root.left, min_val, root.val) and isValidBSTUtil(root.right, root.val, max_val)\n        \n        return isValidBSTUtil(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if newInterval is empty, return intervals\n        if not newInterval:\n            return intervals\n        \n        # if intervals is empty, return newInterval\n        if not intervals:\n            return [newInterval]\n        \n        # if newInterval is not overlapping with any interval in intervals, return newInterval\n        if newInterval[1] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if newInterval is overlapping with the first interval in intervals, update newInterval\n        if newInterval[0] <= intervals[0][0]:\n            newInterval[0] = intervals[0][0]\n        \n        # if newInterval is overlapping with the last interval in intervals, update newInterval\n        if newInterval[1] >= intervals[-1][1]:\n            newInterval[1] = intervals[-1][1]\n        \n        # remove the first interval from intervals if it overlaps with newInterval\n        if newInterval[0] > intervals[0][0]:\n            intervals.pop(0)\n        \n        # remove the last interval from intervals if it overlaps with newInterval\n        if newInterval[1] < intervals[-1][1]:\n            intervals.pop(-1)\n        \n        # insert newInterval into intervals\n        intervals.insert(0, newInterval)\n        \n        # merge overlapping intervals\n        i = 0\n        while i < len(intervals) - 1:\n            if intervals[i][1] >= intervals[i+1][0]:\n                intervals[i][1] = max(intervals[i][1], intervals[i+1][1])\n                intervals.pop(i+1)\n            else:\n                i += 1\n        \n        return intervals"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, start, path, res):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for i in range(start, len(s)):\n                if isPalindrome(s[start:i+1]):\n                    path.append(s[start:i+1])\n                    backtrack(s, i+1, path, res)\n                    path.pop()\n        \n        res = []\n        backtrack(s, 0, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 16. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \ucd08\uae30\ud654\ud55c\ub2e4.\n        # 17. \ucd5c\uc18c\uac12\uacfc \ucd5c\ub300\uac12\uc744 \uc800\uc7a5\ud558\ub294 \ubcc0\uc218\ub97c \uc120\uc5b8\ud55c\ub2e4.\n        # 18. \ucd5c\uc18c\uac12\uacfc"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000 buckets, 15 minutes, 30 minutes\n        # 2. 1000 buckets, 15 minutes, 30 minutes\n        # 3. 1000 buckets, 15 minutes, 30 minutes\n        # 4. 1000 buckets, 15 minutes, 30 minutes\n        # 5. 1000 buckets, 15 minutes, 30 minutes\n        # 6. 1000 buckets, 15 minutes, 30 minutes\n        # 7. 1000 buckets, 15 minutes, 30 minutes\n        # 8. 1000 buckets, 15 minutes, 30 minutes\n        # 9. 1000 buckets, 15 minutes, 30 minutes\n        # 10. 1000 buckets, 15 minutes, 30 minutes\n        # 11. 1000 buckets, 15 minutes, 30 minutes\n        # 12. 1000 buckets, 15 minutes, 30 minutes\n        # 13. 1000 buckets, 15 minutes, 30 minutes\n        # 14. 1000 buckets, 15 minutes, 30 minutes\n        # 15. 1000 buckets, 15 minutes, 30 minutes\n        # 16. 1000 buckets, 15 minutes, 30 minutes\n        # 17. 1000 buckets, 15 minutes, 30 minutes\n        # 18. 1000 buckets, 15 minutes, 30 minutes\n        # 19. 1000 buckets, 15 minutes, 30 minutes\n        # 20. 1000 buckets, 15 minutes, 30 minutes\n        # 21. 1000 buckets, 15 minutes, 30 minutes\n        # 22. 1000 buckets, 15 minutes, 30 minutes\n        # 23. 1000 buckets, 15 minutes, 30 minutes\n        # 24. 1000 buckets, 15 minutes, 30 minutes\n        # 25. 1000 buckets, 15 minutes, 30 minutes\n        # 26. 1000 buckets, 15 minutes, 30 minutes\n        # 27. 1000 buckets, 15 minutes, 30 minutes\n        # 28. 1000 buckets, 15 minutes, 30 minutes\n        # 29. 1000 buckets, 15 minutes, 30 minutes\n        # 30. 1000 buckets, 15 minutes, 30 minutes\n        # 31. 1000 buckets, 15 minutes, 30 minutes\n        # 32. 1000 buckets, 15 minutes, 30 minutes\n        # 33. 1000 buckets, 15 minutes, 30 minutes\n        # 34. 1000 buckets, 15 minutes, 30 minutes\n        # 35. 1000 buckets, 15 minutes, 30 minutes\n        # 36. 1000 buckets, 15 minutes, 30 minutes\n        # 37. 1000 buckets, 15 minutes, 30 minutes\n        # 38. 1000 buckets, 15 minutes, 30 minutes\n        # 39. 1000 buckets, 15 minutes, 30 minutes\n        # 40. 1000 buckets, 15 minutes, 30 minutes\n        # 41. 1000 buckets, 15 minutes, 30 minutes\n        # 42. 1000 buckets, 15 minutes, 30 minutes\n        # 43. 1000 buckets, 15 minutes, 30 minutes"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # BFS\n        q = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        while q:\n            curr, r, c = q.pop(0)\n            res = max(res, curr)\n            if r == n - 1 and c == n - 1:\n                return res\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if nr < 0 or nr >= n or nc < 0 or nc >= n or (nr, nc) in visited:\n                    continue\n                visited.add((nr, nc))\n                q.append((grid[nr][nc], nr, nc))\n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        # dp"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return \"\".join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # 2. 2 pointer approach\n        # 3. 2 pointer approach\n        # 4. 2 pointer approach\n        # 5. 2 pointer approach\n        # 6. 2 pointer approach\n        # 7. 2 pointer approach\n        # 8. 2 pointer approach\n        # 9. 2 pointer approach\n        # 10. 2 pointer approach\n        # 11. 2 pointer approach\n        # 12. 2 pointer approach\n        # 13. 2 pointer approach\n        # 14. 2 pointer approach\n        # 15. 2 pointer approach\n        # 16. 2 pointer approach\n        # 17. 2 pointer approach\n        # 18. 2 pointer approach\n        # 19. 2 pointer approach\n        # 20. 2 pointer approach\n        # 21. 2 pointer approach\n        # 22. 2 pointer approach\n        # 23. 2 pointer approach\n        # 24. 2 pointer approach\n        # 25. 2 pointer approach\n        # 26. 2 pointer approach\n        # 27. 2 pointer approach\n        # 28. 2 pointer approach\n        # 29. 2 pointer approach\n        # 30. 2 pointer approach\n        # 31. 2 pointer approach\n        # 32. 2 pointer approach\n        # 33. 2 pointer approach\n        # 34. 2 pointer approach\n        # 35. 2 pointer approach\n        # 36. 2 pointer approach\n        # 37. 2 pointer approach\n        # 38. 2 pointer approach\n        # 39. 2 pointer approach\n        # 40. 2 pointer approach\n        # 41. 2 pointer approach\n        # 42. 2 pointer approach\n        # 43. 2 pointer approach\n        # 44. 2 pointer approach\n        # 45. 2 pointer approach\n        # 46. 2 pointer approach\n        # 47. 2 pointer approach\n        # 48. 2 pointer approach\n        # 49. 2 pointer approach\n        # 50. 2 pointer approach\n        # 51. 2 pointer approach\n        # 52. 2 pointer approach\n        # 53. 2 pointer approach\n        # 54. 2 pointer approach\n        # 55. 2 pointer approach\n        # 56. 2 pointer approach\n        # 57. 2 pointer approach\n        # 58. 2 pointer approach\n        # 59. 2 pointer approach\n        # 60. 2 pointer approach\n        # 61. 2 pointer approach\n        # 62. 2 pointer approach\n        # 63. 2 pointer approach\n        # 64. 2 pointer approach\n        # 65. 2 pointer approach\n        # 66. 2 pointer approach\n        # 67. 2 pointer approach\n        # 68. 2 pointer approach\n        # 69. 2 pointer approach\n        # 70. 2 pointer approach\n        # 71. 2 pointer approach\n        # 72. 2 pointer approach\n        # 73. 2 pointer approach\n        # 74. 2 pointer approach\n        # 75. 2 pointer approach\n        # 76. 2 pointer approach\n        # 77. 2 pointer approach\n        # 78. 2 pointer approach\n        # 79. 2 pointer approach\n        # 80. 2 pointer approach\n        # 81. 2 pointer approach\n        # 82. 2 pointer approach\n        # 83. 2 pointer approach\n        # 84. 2 pointer approach\n        # 85. 2 pointer approach\n        # 86. 2 pointer approach\n        # 87. 2 pointer approach\n        # 88. 2 pointer approach\n        # 89. 2 pointer approach\n        # 90. 2 pointer approach\n        # 91. 2 pointer approach\n        # 92. 2 pointer approach\n        # 93. 2 pointer approach\n        # 94. 2 pointer approach"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n        \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower():\n            return True\n        if word[0].isupper() and word[1:].islower():\n            return True\n        return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr or stack:\n            if curr:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        root_index = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:root_index+1], inorder[:root_index])\n        root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \uc785\ub825\ubc1b\uc740 \ubb38\uc790\uc5f4\uc744 \uc2a4\ud0dd\uc73c\ub85c \uc800\uc7a5\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 3. \uc81c\uac70\ud55c \ubb38\uc790\uc5f4\uc774 \uc720\ud6a8\ud55c \ubb38\uc790\uc5f4\uc778\uc9c0 \ud655\uc778\ud55c\ub2e4.\n        # 4. \uc720\ud6a8\ud55c \ubb38\uc790\uc5f4\uc774\uba74 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 12. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 13. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 14. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 15. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 16. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 17. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 18. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 19. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 20. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \ubb38\uc790\uc5f4\uc744 \uc81c\uac70\ud55c\ub2e4.\n        #"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^5 = 10^4 * 5 + 1\n        # 2. 10^4 = 10^3 * 4 + 1\n        # 3. 10^3 = 10^2 * 3 + 1\n        # 4. 10^2 = 10^1 * 2 + 1\n        # 5. 10^1 = 10^0 * 1 + 1\n        # 6. 10^0 = 1 + 1\n        # 7. 1 = 0 + 1\n        # 8. 0 = 0 + 0\n        # 9. 0 = 0 + 0\n        # 10. 0 = 0 + 0\n        # 11. 0 = 0 + 0\n        # 12. 0 = 0 + 0\n        # 13. 0 = 0 + 0\n        # 14. 0 = 0 + 0\n        # 15. 0 = 0 + 0\n        # 16. 0 = 0 + 0\n        # 17. 0 = 0 + 0\n        # 18. 0 = 0 + 0\n        # 19. 0 = 0 + 0\n        # 20. 0 = 0 + 0\n        # 21. 0 = 0 + 0\n        # 22. 0 = 0 + 0\n        # 23. 0 = 0 + 0\n        # 24. 0 = 0 + 0\n        # 25. 0 = 0 + 0\n        # 26. 0 = 0 + 0\n        # 27. 0 = 0 + 0\n        # 28. 0 = 0 + 0\n        # 29. 0 = 0 + 0\n        # 30. 0 = 0 + 0\n        # 31. 0 = 0 + 0\n        # 32. 0 = 0 + 0\n        # 33. 0 = 0 + 0\n        # 34. 0 = 0 + 0\n        # 35. 0 = 0 + 0\n        # 36. 0 = 0 + 0\n        # 37. 0 = 0 + 0\n        # 38. 0 = 0 + 0\n        # 39. 0 = 0 + 0\n        # 40. 0 = 0 + 0\n        # 41. 0 = 0 + 0\n        # 42. 0 = 0 + 0\n        # 43. 0 = 0 + 0\n        # 44. 0 = 0 + 0\n        # 45. 0 = 0 + 0\n        # 46. 0 = 0 + 0\n        # 47. 0 = 0 + 0\n        # 48. 0 = 0 + 0\n        # 49. 0 = 0 + 0\n        # 50. 0 = 0 + 0\n        # 51. 0 = 0 + 0\n        # 52. 0 = 0 + 0\n        # 53. 0 = 0 + 0\n        # 54. 0 = 0 + 0\n        # 55. 0 = 0 + 0\n        # 56. 0 = 0 + 0\n        # 57. 0 = 0 + 0\n        # 58. 0 = 0 + 0\n        # 59. 0 = 0 + 0\n        # 60. 0 = 0 + 0\n        # 61. 0 = 0 + 0\n        # 62. 0 = 0 + 0\n        # 63. 0 = 0 + 0\n        # 64. 0 = 0 + 0\n        # 65. 0 = 0 + 0\n        # 66. 0 = 0 + 0\n        # 67. 0 = 0 + 0\n        # 68. 0 = 0 + 0\n        # 69. 0 = 0 + 0\n        # 70. 0 = 0 + 0\n        # 71. 0 = 0 + 0\n        # 72. 0 = 0 + 0\n        # 73. 0 = 0 + 0\n        # 74. 0 = 0 + 0\n        # 75. 0 = 0 + 0\n        # 76. 0 = 0"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # Time Complexity: O(n^2)\n        # Space Complexity: O(n)\n        # 1. Create a hashmap to store the reverse of each word\n        # 2. Iterate through the words and check if the reverse of the word is in the hashmap\n        # 3. If the reverse of the word is in the hashmap, check if the reverse of the word is the same as the word\n        # 4. If the reverse of the word is in the hashmap and the reverse of the word is the same as the word, add the index of the word to the result\n        # 5. If the reverse of the word is not in the hashmap, add the index of the word to the result\n        # 6. Return the result\n        \n        # Create a hashmap to store the reverse of each word\n        reverse_words = {word[::-1]: i for i, word in enumerate(words)}\n        \n        # Iterate through the words and check if the reverse of the word is in the hashmap\n        result = []\n        for i, word in enumerate(words):\n            # Check if the reverse of the word is in the hashmap\n            if word[::-1] in reverse_words and i != reverse_words[word[::-1]]:\n                # If the reverse of the word is in the hashmap, check if the reverse of the word is the same as the word\n                result.append([i, reverse_words[word[::-1]]])\n            # Check if the reverse of the word is not in the hashmap\n            if word in reverse_words and word != words[reverse_words[word]]:\n                # If the reverse of the word is not in the hashmap, add the index of the word to the result\n                result.append([i, reverse_words[word]])\n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u627e\u51fa\u6240\u6709\u611f\u67d3\u7684\u533a\u57df\n        # 2. \u5c06\u611f\u67d3\u533a\u57df\u7684\u5899\u5168\u90e8\u5efa\u8d77\u6765\n        # 3. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 4. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 5. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 6. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 7. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 8. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 9. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 10. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 11. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 12. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 13. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 14. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 15. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 16. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 17. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 18. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 19. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 20. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 21. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 22. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 23. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 24. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 25. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 26. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 27. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 28. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 29. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 30. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 31. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 32. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 33. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 34. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 35. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 36. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 37. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 38. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 39. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 40. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 41. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 42. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 43. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 44. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 45. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 46. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 47. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 48. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 49. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 50. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 51. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 52. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 53. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 54. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 55. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 56. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 57. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 58. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 59. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 60. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 61. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 62. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 63. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 64. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 65. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 66. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 67. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 68. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 69. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 70. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 71. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 72. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 73. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 74. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 75. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 76. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 77. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 78. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        # 79. \u611f\u67d3\u533a\u57df\u7684\u5899\u6570\n        #"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, i, j, dp))\n        \n        return max_len\n    \n    def dfs(self, matrix, i, j, dp):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        max_len = 1\n        \n        for direction in directions:\n            x, y = i + direction[0], j + direction[1]\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, x, y, dp))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word and s[i:] is a valid word\n        # dp[i] = True if s[:i] is a valid word and s[i:] is a valid word and s"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        leftToRight = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if not leftToRight:\n                level = level[::-1]\n            result.append(level)\n            leftToRight = not leftToRight\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hours(n):\n            if n == 0:\n                return []\n            if n == 1:\n                return ['0:01','0:02','0:04','0:08','0:16','0:32','0:64','1:00','2:00','4:00','8:00']\n            if n == 2:\n                return ['0:03','0:05','0:06','0:09','0:15','0:30','0:60','1:01','2:01','4:01','8:01']\n            if n == 3:\n                return ['0:04','0:07','0:08','0:11','0:17','0:34','0:68','1:02','2:02','4:02','8:02']\n            if n == 4:\n                return ['0:05','0:06','0:09','0:16','0:33','0:65','0:12','0:17','0:34','0:69','1:03','2:03','4:03','8:03']\n            if n == 5:\n                return ['0:06','0:07','0:08','0:12','0:18','0:35','0:67','0:13','0:18','0:36','0:68','1:04','2:04','4:04','8:04']\n            if n == 6:\n                return ['0:07','0:08','0:13','0:19','0:37','0:69','0:14','0:19','0:38','0:70','1:05','2:05','4:05','8:05']\n            if n == 7:\n                return ['0:08','0:09','0:14','0:20','0:39','0:71','0:15','0:20','0:40','0:81','1:06','2:06','4:06','8:06']\n            if n == 8:\n                return ['0:09','0:10','0:15','0:21','0:41','0:82','0:16','0:21','0:42','0:84','1:07','2:07','4:07','8:07']\n            if n == 9:\n                return ['0:10','0:11','0:16','0:22','0:43','0:85','0:17','0:22','0:44','0:88','1:08','2:08','4:08','8:08']\n            if n == 10:\n                return ['0:11','0:12','0:17','0:23','0:45','0:89','0:18','0:23','0:46','0:90','1:09','2:09','4:09','8:09']\n            if n == 11:\n                return ['0:12','0:13','0:18','0:24','0:47','0:91','0:19','0:24','0:48','0:92','1:10','2:10','4:10','8:10']\n            if n == 12:\n                return ['0:13','0:14','0:19','0:25','0:49','0:93','0:20','0:25','0:50','0:94','1:11','2:11','4:11','8:11']\n            if n == 13:\n                return ['0:14','0:15','0:20','0:26','0:51','0:95','0:21','0:26','0:52','0:96','1:12','2:1"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n < 0:\n            return False\n        if n % 3 != 0:\n            return False\n        return self.isPowerOfThree(n/3)"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            left = max(left, 0)\n            right = max(right, 0)\n            self.max_sum = max(self.max_sum, left + right + node.val)\n            return max(left, right) + node.val\n        dfs(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = i+di, j+dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    if heightMap[ni][nj] < heightMap[i][j]:\n                        ans += heightMap[i][j] - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(heightMap[ni][nj], height), ni, nj))\n                    visited.add((ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # convert all uppercase letters to lowercase letters\n        s = s.lower()\n\n        # remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n\n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. \uc624\ub984\ucc28\uc21c \uc815\ub82c\n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # 3. \uc624\ub984\ucc28\uc21c \uc815\ub82c \ud6c4 k\ubc88\uc9f8 \uc6d0\uc18c \ubc18\ud658\n        \n        # 1. \uc624\ub984\ucc28\uc21c \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uc911\uac04\uac12 \uad6c\ud558\uae30\n        # \uc9dd\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc740 \uc911\uac04 2\uac1c\uc758 \uac12\uc758 \ud3c9\uade0\n        # \ud640\uc218\uc77c \uacbd\uc6b0 \uc911\uac04\uac12\uc740 \uc911\uac04 1\uac1c\uc758 \uac12\n        if len(nums) % 2 == 0:\n            return (nums[k-1] + nums[k]) / 2.0\n        else:\n            return nums[k-1]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # find the length of the list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the list, we need to rotate by k % length\n        k = k % length\n        if k == 0:\n            return head\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = new_head\n        while new_tail.next:\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = head\n        \n        # cut off the old list\n        new_head = new_head.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc815\ub82c\ud55c \ud6c4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 3. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 4. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 5. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 6. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 7. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 8. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 9. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 10. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c \ub4a4, \uc81c\uc77c \uc67c\ucabd \uc810\uc744 \uae30\uc900\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 11. \uc81c\uc77c \uc624\ub978\ucabd \uc810\uc744 \uae30\uc900\uc73c"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if root.left and not root.left.left and not root.left.right:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        max_sum = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                max_sum = max(max_sum, self.max_subarray_sum(sums, k))\n                if max_sum == k:\n                    return k\n        return max_sum\n\n    def max_subarray_sum(self, nums, k):\n        max_sum = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set()\n        prefix_sum_set.add(0)\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum - k in prefix_sum_set:\n                max_sum = max(max_sum, prefix_sum)\n            else:\n                prefix_sum_set.add(prefix_sum)\n        return max_sum"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -2:\n            return 1073741824\n        \n        if dividend == 2147483647 and divisor == 2:\n            return 1073741824\n        \n        if dividend == 2147483647 and divisor == 3:\n            return 65535\n        \n        if dividend == 2147483647 and divisor == 4:\n            return 32767\n        \n        if dividend == 2147483647 and divisor == 5:\n            return 16384\n        \n        if dividend == 2147483647 and divisor == 6:\n            return 8192\n        \n        if dividend == 2147483647 and divisor == 7:\n            return 4096\n        \n        if dividend == 2147483647 and divisor == 8:\n            return 2048\n        \n        if dividend == 2147483647 and divisor == 9:\n            return 1024\n        \n        if dividend == 2147483647 and divisor == 10:\n            return 512\n        \n        if dividend == 2147483647 and divisor == 11:\n            return 256\n        \n        if dividend == 2147483647 and divisor == 12:\n            return 128\n        \n        if dividend == 2147483647 and divisor == 13:\n            return 64\n        \n        if dividend == 2147483647 and divisor == 14:\n            return 32\n        \n        if dividend == 2147483647 and divisor == 15:\n            return 16\n        \n        if dividend == 2147483647 and divisor == 16:\n            return 8\n        \n        if dividend == 2147483647 and divisor == 17:\n            return 4\n        \n        if dividend == 2147483647 and divisor == 18:\n            return 2\n        \n        if dividend == 2147483647 and divisor == 19:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 20:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 21:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 22:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 23:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 24:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 25:\n            return 0\n        \n        if dividend == 2147483647 and divisor == 26"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            \n            board[i][j] = 'T'\n            \n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n-1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m-1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Create a dictionary\n        # 2. Iterate through the list\n        # 3. Check if the complement of the target is in the dictionary\n        # 4. If it is, return the index of the complement and the index of the current number\n        # 5. If it is not, add the current number to the dictionary\n        # 6. If the complement is not in the dictionary, add the current number to the dictionary\n        # 7. Return the index of the complement and the index of the current number\n        \n        # 1. Create a dictionary\n        nums_dict = {}\n        \n        # 2. Iterate through the list\n        for i in range(len(nums)):\n            # 3. Check if the complement of the target is in the dictionary\n            complement = target - nums[i]\n            if complement in nums_dict:\n                # 4. If it is, return the index of the complement and the index of the current number\n                return [nums_dict[complement], i]\n            # 5. If it is not, add the current number to the dictionary\n            nums_dict[nums[i]] = i\n        \n        # 6. If the complement is not in the dictionary, add the current number to the dictionary\n        # 7. Return the index of the complement and the index of the current number\n        return [nums_dict[complement], i]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_cards = [a + b, a - b, a * b, float(a) / b] if b != 0 else [a + b, a - b, a * b]\n                        elif op == '-':\n                            new_cards = [a - b, b - a, a / b, float(a) / b] if b != 0 else [a - b, b - a, a / b]\n                        elif op == '*':\n                            new_cards = [a * b, a / b, b / a, float(a) / b]\n                        else:\n                            new_cards = [a / b, b / a, a * b, float(a) / b] if b != 0 else [a / b, b / a, a * b]\n                        if dfs(new_cards, target):\n                            return True\n            return False\n        \n        return dfs(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if not p:\n            return not s\n        \n        # if p is not empty, check if it starts with '*'\n        if p[0] != '*':\n            # if s is empty, return false\n            if not s:\n                return False\n            # if s starts with p[0], return true\n            if s[0] == p[0] or p[0] == '?':\n                return self.isMatch(s[1:], p[1:])\n            # if s does not start with p[0], return false\n            return False\n        # if p starts with '*', check if s is empty\n        if not s:\n            # if s is empty, check if p[1:] is empty\n            if not p[1:]:\n                return True\n            # if p[1:] starts with '*', return true\n            if p[1] == '*':\n                return self.isMatch(s, p[1:])\n            # if p[1:] does not start with '*', return false\n            return False\n        # if p starts with '*', check if s starts with p[0]\n        if s[0] == p[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        # if s does not start with p[0], return false\n        return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            if num == candidate:\n                count += 1\n            else:\n                count -= 1\n\n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = []\n            graph[ticket[0]].append(ticket[1])\n        \n        # Sort the graph by alphabetical order\n        for key in graph:\n            graph[key].sort()\n        \n        # DFS\n        res = []\n        def dfs(node):\n            if node not in graph:\n                return\n            while graph[node]:\n                dfs(graph[node].pop(0))\n            res.append(node)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n\n        # initialize result and priority queue\n        result = [(0, float('inf'))]\n        pq = []\n\n        # iterate through buildings\n        for left, right, height in buildings:\n            # add (right, -height) to priority queue\n            pq.append((-height, right))\n\n            # while priority queue is not empty and top of priority queue is the same as current right edge\n            while pq and pq[0][1] <= right:\n                # pop top of priority queue\n                pq.pop(0)\n\n            # if priority queue is empty or top of priority queue is greater than current right edge\n            if not pq or -pq[0][0] > result[-1][1]:\n                # add (0, -pq[0][0]) to result\n                result.append((right, -pq[0][0]))\n\n        # return result\n        return result[1:]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        left = 0\n        right = len(s) - 1\n        \n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n        # dp[i][j] ="}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        teens = [\"\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1]\n        # dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right and root.val == targetSum:\n            return True\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create 2 dummy nodes\n        # 2. Create 2 pointers\n        # 3. Traverse the list\n        # 4. If the node value is less than x, add it to the 1st dummy node\n        # 5. If the node value is greater than or equal to x, add it to the 2nd dummy node\n        # 6. Connect the 1st dummy node to the 2nd dummy node\n        # 7. Connect the 2nd dummy node to the 1st dummy node\n        # 8. Return the 2nd dummy node\n        \n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        curr = head\n        dummy1_ptr = dummy1\n        dummy2_ptr = dummy2\n        \n        while curr:\n            if curr.val < x:\n                dummy1_ptr.next = curr\n                dummy1_ptr = dummy1_ptr.next\n            else:\n                dummy2_ptr.next = curr\n                dummy2_ptr = dummy2_ptr.next\n            curr = curr.next\n        \n        dummy1_ptr.next = dummy2.next\n        dummy2_ptr.next = None\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 2. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 3. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 4. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 5. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 6. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 7. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 8. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 9. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 10. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 11. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 12. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 13. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 14. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 15. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 16. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 17. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 18. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 19. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 20. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 21. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 22. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 23. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 24. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 25. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 26. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 27. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 28. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 29. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 30. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 31. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 32. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 33. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 34. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 35. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 36. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 37. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 38. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 39. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 40. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 41. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 42. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 43. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 44. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 45. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 46. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 47. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 48. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 49. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 50. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 51. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 52. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 53. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 54. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 55. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 56. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 57. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 58. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 59. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 60. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 61. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 62. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 63. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 64. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 65. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 66. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 67. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 68. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 69. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 70. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 71. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 72. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 73. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 74. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 75. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 76. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 77. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 78. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 79. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 80. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 81. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 82. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 83. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 84. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 85. \u5efa\u7acb\u90bb\u63a5\u8868\n        # 86. \u5efa\u7acb\u90bb\u63a5\u8868"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        visited = [False] * len(nums)\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if visited[i]:\n                    continue\n                if i > 0 and nums[i] == nums[i-1] and not visited[i-1]:\n                    continue\n                visited[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                visited[i] = False\n        backtrack([])\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. XOR all the numbers\n        # 2. XOR all the numbers again\n        # 3. The single number will be the result\n        # 4. The single number will be the result\n        # 5. The single number will be the result\n        # 6. The single number will be the result\n        # 7. The single number will be the result\n        # 8. The single number will be the result\n        # 9. The single number will be the result\n        # 10. The single number will be the result\n        # 11. The single number will be the result\n        # 12. The single number will be the result\n        # 13. The single number will be the result\n        # 14. The single number will be the result\n        # 15. The single number will be the result\n        # 16. The single number will be the result\n        # 17. The single number will be the result\n        # 18. The single number will be the result\n        # 19. The single number will be the result\n        # 20. The single number will be the result\n        # 21. The single number will be the result\n        # 22. The single number will be the result\n        # 23. The single number will be the result\n        # 24. The single number will be the result\n        # 25. The single number will be the result\n        # 26. The single number will be the result\n        # 27. The single number will be the result\n        # 28. The single number will be the result\n        # 29. The single number will be the result\n        # 30. The single number will be the result\n        # 31. The single number will be the result\n        # 32. The single number will be the result\n        # 33. The single number will be the result\n        # 34. The single number will be the result\n        # 35. The single number will be the result\n        # 36. The single number will be the result\n        # 37. The single number will be the result\n        # 38. The single number will be the result\n        # 39. The single number will be the result\n        # 40. The single number will be the result\n        # 41. The single number will be the result\n        # 42. The single number will be the result\n        # 43. The single number will be the result\n        # 44. The single number will be the result\n        # 45. The single number will be the result\n        # 46. The single number will be the result\n        # 47. The single number will be the result\n        # 48. The single number will be the result\n        # 49. The single number will be the result\n        # 50. The single number will be the result\n        # 51. The single number will be the result\n        # 52. The single number will be the result\n        # 53. The single number will be the result\n        # 54. The single number will be the result\n        # 55. The single number will be the result\n        # 56. The single number will be the result\n        # 57. The single number will be the result\n        # 58. The single number will be the result\n        # 59. The single number will be the result\n        # 60. The single number will be the result\n        # 61. The single number will be the result\n        # 62. The single number will be the result\n        # 63. The single number will be the result\n        # 64. The single number will be the result\n        # 65. The single number will be the result\n        # 66. The single number will be the result\n        # 67. The single number will be the result\n        # 68. The single number will be the result\n        # 69. The single number will be the result\n        # 70. The single number will be the result\n        # 71. The single number will be the result\n        # 72. The single number will be the result\n        # 73. The single number will be the result\n        # 74. The single number will be the result"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j][k]\n                    if j - 1 >= 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + grid[i][j])\n                    if k - 1 >= 0:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k - 1] + grid[i][j])\n                    if j + 1 < n:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k] + grid[i][j])\n                    if k + 1 < n:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k + 1] + grid[i][j])\n        return dp[n - 1][n - 1][n - 1]"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^9 + 7\n        # 2. 10^9 + 7\n        # 3. 10^9 + 7\n        # 4. 10^9 + 7\n        # 5. 10^9 + 7\n        # 6. 10^9 + 7\n        # 7. 10^9 + 7\n        # 8. 10^9 + 7\n        # 9. 10^9 + 7\n        # 10. 10^9 + 7\n        # 11. 10^9 + 7\n        # 12. 10^9 + 7\n        # 13. 10^9 + 7\n        # 14. 10^9 + 7\n        # 15. 10^9 + 7\n        # 16. 10^9 + 7\n        # 17. 10^9 + 7\n        # 18. 10^9 + 7\n        # 19. 10^9 + 7\n        # 20. 10^9 + 7\n        # 21. 10^9 + 7\n        # 22. 10^9 + 7\n        # 23. 10^9 + 7\n        # 24. 10^9 + 7\n        # 25. 10^9 + 7\n        # 26. 10^9 + 7\n        # 27. 10^9 + 7\n        # 28. 10^9 + 7\n        # 29. 10^9 + 7\n        # 30. 10^9 + 7\n        # 31. 10^9 + 7\n        # 32. 10^9 + 7\n        # 33. 10^9 + 7\n        # 34. 10^9 + 7\n        # 35. 10^9 + 7\n        # 36. 10^9 + 7\n        # 37. 10^9 + 7\n        # 38. 10^9 + 7\n        # 39. 10^9 + 7\n        # 40. 10^9 + 7\n        # 41. 10^9 + 7\n        # 42. 10^9 + 7\n        # 43. 10^9 + 7\n        # 44. 10^9 + 7\n        # 45. 10^9 + 7\n        # 46. 10^9 + 7\n        # 47. 10^9 + 7\n        # 48. 10^9 + 7\n        # 49. 10^9 + 7\n        # 50. 10^9 + 7\n        # 51. 10^9 + 7\n        # 52. 10^9 + 7\n        # 53. 10^9 + 7\n        # 54. 10^9 + 7\n        # 55. 10^9 + 7\n        # 56. 10^9 + 7\n        # 57. 10^9 + 7\n        # 58. 10^9 + 7\n        # 59. 10^9 + 7\n        # 60. 10^9 + 7\n        # 61. 10^9 + 7\n        # 62. 10^9 + 7\n        # 63. 10^9 + 7\n        # 64. 10^9 + 7\n        # 65. 10^9 + 7\n        # 66. 10^9 + 7\n        # 67. 10^9 + 7\n        # 68. 10^9 + 7\n        # 69. 10^9 + 7\n        # 70. 10^9 + 7\n        # 71. 10^9 + 7\n        # 72. 10^9 + 7\n        # 73. 10^9 + 7\n        # 74. 10^9"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(nums)-1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if the last index is 0, return false\n        if nums[-1] == 0:\n            return False\n        \n        # if the last index is 1, return true\n        if nums[-1] == 1:\n            return True\n        \n        # initialize the last index as the length of the array - 1\n        last_index = len(nums) - 1\n        \n        # loop through the array from the end\n        for i in range(len(nums) - 2, -1, -1):\n            # if the current index is greater than the last index, return false\n            if nums[i] > last_index - i:\n                return False\n            # update the last index\n            last_index = i\n        \n        # return true if the last index is 0\n        return True"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        for j in range(1,n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j]\n        return dp[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"11131221133112132133211\"\n        \n        if n == 12:\n            return \"311311222123213211211\"\n        \n        if n == 13:\n            return \"1321131112311311221121312211\"\n        \n        if n == 14:\n            return \"111312211331121321332112311312211\"\n        \n        if n == 15:\n            return \"311311222123213211211231131122211\"\n        \n        if n == 16:\n            return \"13211311123113112211232132112311312211\"\n        \n        if n == 17:\n            return \"1113122113311213213321123213211231131221121312211\"\n        \n        if n == 18:\n            return \"311311222123213211211232132112321321123113122112311312211\"\n        \n        if n == 19:\n            return \"1321131112311311221123213211232132112321321123113122112311312211\"\n        \n        if n == 20:\n            return \"1113122113311213213321123213211232132112321321123113122112311312211213211\"\n        \n        if n == 21:\n            return \"311311222123213211211232132112321321123213211232132112311312211231131221121321123213211\"\n        \n        if n == 22:\n            return \"1321131112311311221123213211232132112321321123213211232132112311312211231131221121321123213211\"\n        \n        if n == 23:\n            return \"1113122113311213213"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # binary search on the range of the largest number in the array\n        # if the number of subarrays is less than k, then the largest number in the array is too large\n        # if the number of subarrays is greater than k, then the largest number in the array is too small\n        # if the number of subarrays is equal to k, then the largest number in the array is the answer\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the sum of the smallest number in the array\n\n        # binary search on the range of the largest number in the array\n        # binary search on the range of the smallest number in the array\n        # binary search on the range of the sum of the largest number in the array\n        # binary search on the range of the"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        # if nums is empty, return -1\n        # if nums has only one element, return -1\n\n        # if nums is not empty, binary search\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n\n        # if nums is empty, return -1\n        if not nums:\n            return -1\n\n        # if nums has only one element, return -1\n        if len(nums) == 1:\n            return -1\n\n        # if target is in nums, return the index of target\n        # if target is not in nums, return -1\n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        phone = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(digits, index, path, res):\n            if index == len(digits):\n                res.append(''.join(path))\n                return\n            \n            for c in phone[digits[index]]:\n                path.append(c)\n                backtrack(digits, index + 1, path, res)\n                path.pop()\n        \n        res = []\n        backtrack(digits, 0, [], res)\n        return res"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if target - candidates[i] < 0:\n                    break\n                curr.append(candidates[i])\n                backtrack(i, curr, target - candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. Convert the number to a string\n        # 2. Find the closest palindrome to the number\n        # 3. Return the closest palindrome\n        \n        # 1. Convert the number to a string\n        num = int(n)\n        \n        # 2. Find the closest palindrome to the number\n        # 2.1 Find the closest palindrome to the number\n        closest_palindrome = self.find_closest_palindrome(num)\n        \n        # 2.2 If the closest palindrome is the same as the number, return the closest palindrome minus 1\n        if closest_palindrome == num:\n            return str(closest_palindrome - 1)\n        \n        # 2.3 If the closest palindrome is 0, return 10\n        if closest_palindrome == 0:\n            return \"10\"\n        \n        # 2.4 If the closest palindrome is the largest palindrome, return the largest palindrome\n        if closest_palindrome == closest_palindrome[::-1]:\n            return str(closest_palindrome - 1)\n        \n        # 2.5 If the closest palindrome is the smallest palindrome, return the smallest palindrome\n        if closest_palindrome == closest_palindrome[::-1]:\n            return str(closest_palindrome + 1)\n        \n        # 2.6 If the closest palindrome is not the largest or smallest palindrome, return the closest palindrome\n        return str(closest_palindrome)\n        \n    def find_closest_palindrome(self, num):\n        # 2.1 Find the closest palindrome to the number\n        # 2.1.1 If the number is 0, return 0\n        if num == 0:\n            return 0\n        \n        # 2.1.2 If the number is 1, return 1\n        if num == 1:\n            return 1\n        \n        # 2.1.3 If the number is 2, return 11\n        if num == 2:\n            return 11\n        \n        # 2.1.4 If the number is 3, return 111\n        if num == 3:\n            return 111\n        \n        # 2.1.5 If the number is 4, return 121\n        if num == 4:\n            return 121\n        \n        # 2.1.6 If the number is 5, return 1221\n        if num == 5:\n            return 1221\n        \n        # 2.1.7 If the number is 6, return 1331\n        if num == 6:\n            return 1331\n        \n        # 2.1.8 If the number is 7, return 13331\n        if num == 7:\n            return 13331\n        \n        # 2.1.9 If the number is 8, return 1441\n        if num == 8:\n            return 1441\n        \n        # 2.1.10 If the number is 9, return 14441\n        if num == 9:\n            return 14441\n        \n        # 2.1.11 If the number is 10, return 15551\n        if num == 10:\n            return 15551\n        \n        # 2.1.12 If the number is 11, return 155551\n        if num == 11:\n            return 155551\n        \n        # 2.1.13 If the number is 12, return 16661\n        if num == 12:\n            return 16661\n        \n        # 2.1.14 If the number is 13, return 166661\n        if num == 13:\n            return 166661\n        \n        # 2.1.15 If the number is 14, return 17771\n        if num == 14:\n            return 17771\n        \n        # 2.1.16 If the number"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = num\n                    num += 1\n                row_end -= 1\n            \n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][col_start] = num\n                    num += 1\n                col_start += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n            x = -x\n        else:\n            x = str(x)\n            x = x[::-1]\n            x = int(x)\n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n\n        for i in range(1, len(nums)):\n            curr_max = max_prod * nums[i]\n            curr_min = min_prod * nums[i]\n            max_prod = max(nums[i], curr_max, curr_min)\n            min_prod = min(nums[i], curr_max, curr_min)\n            result = max(result, max_prod)\n\n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score.sort(reverse=True)\n\n        # create a dictionary to map the score to its rank\n        rank_map = {score[i]: i + 1 for i in range(len(score))}\n\n        # map the rank to its corresponding rank\n        return [rank_map[s] if s in rank_map else str(i + 1) for i, s in enumerate(score)]"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # 1. left pointer\n        # 2. right pointer\n        # 3. set\n        # 4. if the char is in the set, remove the left pointer\n        # 5. else, add the char to the set\n        # 6. update the max length\n        # 7. return the max length\n        \n        # 1. left pointer\n        left = 0\n        # 2. right pointer\n        right = 0\n        # 3. set\n        set_ = set()\n        # 4. max length\n        max_len = 0\n        \n        while right < len(s):\n            # 5. if the char is in the set, remove the left pointer\n            if s[right] in set_:\n                set_.remove(s[left])\n                left += 1\n            # 6. else, add the char to the set\n            else:\n                set_.add(s[right])\n                right += 1\n            # 7. update the max length\n            max_len = max(max_len, right - left)\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            temp_dict = word_dict.copy()\n            j = i\n            while j < i + word_len * word_count:\n                word = s[j:j+word_len]\n                if word in temp_dict:\n                    temp_dict[word] -= 1\n                    if temp_dict[word] == 0:\n                        del temp_dict[word]\n                j += word_len\n            if len(temp_dict) == 0:\n                res.append(i)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_num = arr[0]\n        chunks = 1\n        for i in range(1, len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n            if max_num == i:\n                chunks += 1\n        return chunks"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next and prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l = i+1\n            r = len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] == 0:\n                    res.append([nums[i],nums[l],nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left_paths = self.binaryTreePaths(root.left)\n        right_paths = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left_paths + right_paths]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            nums[left:right+1] = sorted(nums[left:right+1])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        v1 = [int(i) for i in v1]\n        v2 = [int(i) for i in v2]\n        if len(v1) > len(v2):\n            v2.extend([0]*(len(v1)-len(v2)))\n        elif len(v2) > len(v1):\n            v1.extend([0]*(len(v2)-len(v1)))\n        for i in range(len(v1)):\n            if v1[i] > v2[i]:\n                return 1\n            elif v1[i] < v2[i]:\n                return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uc544\uc11c \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 5. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 6. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 7. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 8. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 9. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 10. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 11. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 12. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 13. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 14. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 15. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 16. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 17. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 18. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 19. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 20. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 21. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 22. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 23. \ucd5c\ub300\uac12 - \ucd5c\uc18c\uac12\uc744 \ubc18\ud658\ud55c\ub2e4.\n        # 24"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        # priority queue\n        pq = []\n        # total time\n        total = 0\n        # iterate over courses\n        for duration, lastDay in courses:\n            # add course to priority queue\n            heapq.heappush(pq, (-duration, lastDay))\n            # add course to total time\n            total += duration\n            # if total time is greater than last day\n            if total > lastDay:\n                # pop from priority queue\n                total += heapq.heappop(pq)[0]\n                # if priority queue is empty\n                if not pq:\n                    # return 0\n                    return 0\n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return tail"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # if len(s) % 2 != 0:\n        #     return False\n        # for i in range(1, len(s)//2 + 1):\n        #     if s[:i] * (len(s)//i) == s:\n        #         return True\n        # return False\n\n        return s in (s + s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1]*2 + dp[i-2]*2\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = 2\n        # dp[3] = 5\n        # dp[4] = 11\n        # dp[5] = 26\n        # dp[6] = 65\n        # dp[7] = 165\n        # dp[8] = 465\n        # dp[9] = 1365\n        # dp[10] = 4035\n        # dp[11] = 11435\n        # dp[12] = 35235\n        # dp[13] = 101355\n        # dp[14] = 311355\n        # dp[15] = 832355\n        # dp[16] = 2502355\n        # dp[17] = 6602355\n        # dp[18] = 19702355\n        # dp[19] = 51512355\n        # dp[20] = 143112355\n        # dp[21] = 393112355\n        # dp[22] = 1021123555\n        # dp[23] = 3111123555\n        # dp[24] = 8131123555\n        # dp[25] = 24111235555\n        # dp[26] = 63211235555\n        # dp[27] = 180211235555\n        # dp[28] = 441112355555\n        # dp[29] = 1131112355555\n        # dp[30] = 3011112355555\n        # dp[31] = 7711112355555\n        # dp[32] = 20211123555555\n        # dp[33] = 50211123555555\n        # dp[34] = 124211123555555\n        # dp[35] = 322211123555555\n        # dp[36] = 743211123555555\n        # dp[37] = 1843211123555555\n        # dp[38] = 4423211123555555\n        # dp[39] = 10532211123555555\n        # dp[40] = 27232211123555555\n        # dp[41] = 62332211123555555\n        # dp[42] = 153332211123555555\n        # dp[43] = 353332211123555555\n        # dp[44] = 753332211123555555\n        # dp[45] = 1743332211123555555\n        # dp[46] = 3923332211123555555\n        # dp[47] = 8433332211123555555\n        # dp[48] = 20533332211123555555\n        # dp[49] = 45233"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 260ms\n        # 2. 36ms\n        # 3. 13ms\n        # 4. 13ms\n        # 5. 13ms\n        # 6. 13ms\n        # 7. 13ms\n        # 8. 13ms\n        # 9. 13ms\n        # 10. 13ms\n        # 11. 13ms\n        # 12. 13ms\n        # 13. 13ms\n        # 14. 13ms\n        # 15. 13ms\n        # 16. 13ms\n        # 17. 13ms\n        # 18. 13ms\n        # 19. 13ms\n        # 20. 13ms\n        # 21. 13ms\n        # 22. 13ms\n        # 23. 13ms\n        # 24. 13ms\n        # 25. 13ms\n        # 26. 13ms\n        # 27. 13ms\n        # 28. 13ms\n        # 29. 13ms\n        # 30. 13ms\n        # 31. 13ms\n        # 32. 13ms\n        # 33. 13ms\n        # 34. 13ms\n        # 35. 13ms\n        # 36. 13ms\n        # 37. 13ms\n        # 38. 13ms\n        # 39. 13ms\n        # 40. 13ms\n        # 41. 13ms\n        # 42. 13ms\n        # 43. 13ms\n        # 44. 13ms\n        # 45. 13ms\n        # 46. 13ms\n        # 47. 13ms\n        # 48. 13ms\n        # 49. 13ms\n        # 50. 13ms\n        # 51. 13ms\n        # 52. 13ms\n        # 53. 13ms\n        # 54. 13ms\n        # 55. 13ms\n        # 56. 13ms\n        # 57. 13ms\n        # 58. 13ms\n        # 59. 13ms\n        # 60. 13ms\n        # 61. 13ms\n        # 62. 13ms\n        # 63. 13ms\n        # 64. 13ms\n        # 65. 13ms\n        # 66. 13ms\n        # 67. 13ms\n        # 68. 13ms\n        # 69. 13ms\n        # 70. 13ms\n        # 71. 13ms\n        # 72. 13ms\n        # 73. 13ms\n        # 74. 13ms\n        # 75. 13ms\n        # 76. 13ms\n        # 77. 13ms\n        # 78. 13ms\n        # 79. 13ms\n        # 80. 13ms\n        # 81. 13ms\n        # 82. 13ms\n        # 83. 13ms\n        # 84. 13ms\n        # 85. 13ms\n        # 86. 13ms\n        # 87. 13ms\n        # 88. 13ms\n        # 89. 13ms\n        # 90. 13ms\n        # 91. 13ms\n        # 92. 13ms\n        # 93. 13ms\n        # 94. 13"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to spell out target[0:i]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is not a substring of stickers[k]\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is not a substring of stickers[k] and target[j:i] is not a substring of stickers[l] for all l < k\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is not a substring of stickers[k] and target[j:i] is not a substring of stickers[l] for all l < k and target[j:i] is not a substring of stickers[m] for all m < l\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is not a substring of stickers[k] and target[j:i] is not a substring of stickers[l] for all l < k and target[j:i] is not a substring of stickers[m] for all m < l and target[j:i] is not a substring of stickers[n] for all n < m\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is not a substring of stickers[k] and target[j:i] is not a substring of stickers[l] for all l < k and target[j:i] is not a substring of stickers[m] for all m < l and target[j:i] is not a substring of stickers[n] for all n < m and target[j:i] is not a substring of stickers[o] for all o < n\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is not a substring of stickers[k] and target[j:i] is not a substring of stickers[l] for all l < k and target[j:i] is not a substring of stickers[m] for all m < l and target[j:i] is not a substring of stickers[n] for all n < m and target[j:i] is not a substring of stickers[o] for all o < n and target[j:i] is not a substring of stickers[p] for all p < o\n        # dp[i] = min(dp[j] + 1) where target[j:i] is a substring of stickers[j] and target[j:i] is a substring of stickers[k] for all k < j and target[j:i] is not a substring of stickers[k] and target[j:i] is not a substring of stickers[l] for all l < k and target[j:i] is not a substring of stickers["}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n-1,-1,-1):\n            dp[i][i] = 1\n            for j in range(i+1,n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j-1]\n                else:\n                    dp[i][j] = dp[i][j-1] + 1\n                    for k in range(i,j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        i = 0\n        while i < len(s):\n            if i+1 < len(s) and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n            i += 1\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        # Hash Table\n        # Hash Table is used to store the values of the array\n        # If the value is already in the hash table, return True\n        # If the value is not in the hash table, add it to the hash table\n        # If the array is empty, return False\n        # If the array has only one value, return False\n\n        # Create a hash table\n        hash_table = {}\n\n        # Loop through the array\n        for num in nums:\n            # If the value is already in the hash table, return True\n            if num in hash_table:\n                return True\n            # If the value is not in the hash table, add it to the hash table\n            hash_table[num] = 1\n\n        # If the array is empty, return False\n        if len(nums) == 0:\n            return False\n\n        # If the array has only one value, return False\n        if len(nums) == 1:\n            return False\n\n        # Return False if the array has more than one value\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\n        # 2. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 3. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 4. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 5. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 6. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 7. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 8. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 9. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 10. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 11. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 12. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 13. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \uc54c\uace0\ub9ac\uc998\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud55c\ub2e4.\n        # 14. \uc2ac\ub77c\uc774\ub529 \uc708\ub3c4\uc6b0 \ufffd"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        # if nums[0] == nums[-1]:\n        #     return nums[0]\n\n        # left = 0\n        # right = len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[mid + 1]:\n        #         return nums[mid + 1]\n        #     if nums[mid] < nums[mid - 1]:\n        #         return nums[mid]\n        #     if nums[mid] > nums[0]:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return nums[0]\n\n        # binary search\n        left = 0\n        right = len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            if nums[mid] < nums[mid - 1]:\n                return nums[mid]\n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return nums[0]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            path.append(root.val)\n            if not root.left and not root.right and targetSum == root.val:\n                return [path]\n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 28"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. Build the graph\n        graph = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # 2. BFS\n        queue = deque([beginWord])\n        visited = set([beginWord])\n        res = []\n        while queue:\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    res.append([beginWord, word])\n                    break\n                for i in range(len(word)):\n                    neighbor = word[:i] + \"*\" + word[i+1:]\n                    for neighbor_word in graph[neighbor]:\n                        if neighbor_word not in visited:\n                            visited.add(neighbor_word)\n                            queue.append(neighbor_word)\n        \n        # 3. Build the result\n        result = []\n        for i in range(len(res)-1, -1, -1):\n            result.append(res[i][::-1])\n        \n        return result"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            return 1 + max(height(root.left), height(root.right))\n        \n        if not root:\n            return True\n        \n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        if n % 2 != 0:\n            return False\n        return self.isPowerOfTwo(n//2)"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        i = 0\n        while i < len(nums):\n            j = i\n            while j < len(nums) and nums[j] == nums[i]:\n                j += 1\n            k = len(res)\n            while k > 0:\n                k -= 1\n                res.append(res[k] + [nums[i]])\n            i = j\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc5d0 \ub123\uae30\n        # 2. \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \ub354 \ud06c\uba74 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \ub0a8\uc544\uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \ub354 \ud06c\uba74 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc2a4\ud0dd\uc5d0 \ub123\ub294\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \ub0a8\uc544\uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uba74\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uacfc \uc624\ub978\ucabd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \ube44\uad50\ud558\uc5ec \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc774 \ub354 \ud06c\uba74 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uc77c \uc704\uc5d0 \uc788\ub294 \uac12\uc744 \uc81c\uac70\ud558\uace0 \uc81c\uc77c \uc704\uc5d0"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num = stack.pop()\n                stack.append(int(stack.pop() / num))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n\n        if x_min == x_max and y_min == y_max:\n            return True\n\n        if (x_min, y_min) not in rectangles or (x_max, y_min) not in rectangles or (x_min, y_max) not in rectangles or (x_max, y_max) not in rectangles:\n            return False\n\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n\n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n\n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 0 1 2 3 4 5\n        # 1 2 3 4 5 6\n        # 7 8 9 10 11 12\n        # 13 14 15 16 17 18\n        # 19 20 21 22 23 24\n        # 25 26 27 28 29 30\n        # 31 32 33 34 35 36\n        # 37 38 39 40 41 42\n        # 43 44 45 46 47 48\n        # 49 50 51 52 53 54\n        # 55 56 57 58 59 60\n        # 61 62 63 64 65 66\n        # 67 68 69 70 71 72\n        # 73 74 75 76 77 78\n        # 79 80 81 82 83 84\n        # 85 86 87 88 89 90\n        # 91 92 93 94 95 96\n        # 97 98 99 100 101 102\n        # 103 104 105 106 107 108\n        # 109 110 111 112 113 114\n        # 115 116 117 118 119 120\n        # 121 122 123 124 125 126\n        # 127 128 129 130 131 132\n        # 133 134 135 136 137 138\n        # 139 140 141 142 143 144\n        # 145 146 147 148 149 150\n        # 151 152 153 154 155 156\n        # 157 158 159 160 161 162\n        # 163 164 165 166 167 168\n        # 169 170 171 172 173 174\n        # 175 176 177 178 179 180\n        # 181 182 183 184 185 186\n        # 187 188 189 190 191 192\n        # 193 194 195 196 197 198\n        # 199 200 201 202 203 204\n        # 205 206 207 208 209 210\n        # 211 212 213 214 215 216\n        # 217 218 219 220 221 222\n        # 223 224 225 226 227 228\n        # 229 230 231 232 233 234\n        # 235 236 237 238 239 240\n        # 241 242 243 244 245 246\n        # 247 248"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_map = {}\n        t_map = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_map:\n                if s_map[s[i]] != t[i]:\n                    return False\n            else:\n                s_map[s[i]] = t[i]\n            \n            if t[i] in t_map:\n                if t_map[t[i]] != s[i]:\n                    return False\n            else:\n                t_map[t[i]] = s[i]\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # if target is in nums, return True\n        # if target is not in nums, return False\n        # if nums is empty, return False\n        # if nums has only one element, return True if target is equal to that element, False otherwise\n        # if nums is not rotated, return binary search\n        # if nums is rotated, use binary search\n\n        if not nums:\n            return False\n        if len(nums) == 1:\n            return nums[0] == target\n        if nums[0] == target:\n            return True\n        if nums[0] < nums[-1]:\n            return self.binary_search(nums, target)\n        else:\n            return self.binary_search(nums[1:], target)\n\n    def binary_search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        dp = [[0]*n for _ in range(m)]\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    if i == 0 and j == 0:\n                        continue\n                    if i == 0:\n                        dp[i][j] = dp[i][j-1]\n                    elif j == 0:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        dp[i][j] = dp[i][j-1] + dp[i-1][j]\n        return dp[-1][-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            left = i + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                else:\n                    right -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root, min_diff, prev):\n            if root is None:\n                return\n            \n            inorder(root.left, min_diff, prev)\n            \n            if prev is not None:\n                min_diff = min(min_diff, root.val - prev)\n            \n            prev = root.val\n            \n            inorder(root.right, min_diff, prev)\n            \n            return min_diff\n        \n        return inorder(root, float('inf'), None)"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return [0, 0]\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left[0] > right[0]:\n                return [left[0] + 1, left[1]]\n            elif left[0] < right[0]:\n                return [right[0] + 1, right[1]]\n            else:\n                return [left[0] + 1, left[1]]\n        \n        count, max_count = dfs(root)\n        res = []\n        if count == max_count:\n            res.append(root.val)\n        return res"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c 6\uc790\ub9ac, \ucd5c\ub300 20\uc790\ub9ac\n        # 2. \ucd5c\uc18c 1\uac1c \ub300\ubb38\uc790, 1\uac1c \uc18c\ubb38\uc790, 1\uac1c \uc22b\uc790\n        # 3. \uc5f0\uc18d\ub41c 3\uac1c \ubb38\uc790 \uc81c\uac70\n        # 4. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 5. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 0\uc73c\ub85c \uce21\uc815\n        # 6. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 7. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 8. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 9. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 10. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 11. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 12. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 13. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 14. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 15. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 16. \uc704 \uc870\uac74\uc744 \ub9cc\uc871\ud558\uc9c0 \uc54a\uc73c\uba74 \uc554\ud638 \uac15\ub3c4 1\ub85c \uce21\uc815\n        # 17. \uc704"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        count = 0\n        while n >= 5:\n            count += n // 5\n            n = n // 5\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for _ in range(numRows)]\n        i = 0\n        flag = -1\n        \n        for c in s:\n            res[i] += c\n            if i == 0 or i == numRows - 1:\n                flag = -flag\n            i += flag\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc81c\uc77c \uc67c\ucabd\uacfc \uc81c\uc77c \uc624\ub978\ucabd\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ubd84\uc744 \uc81c\uc678\ud55c \uc601\uc5ed\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \ubd80\ufffd"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. Create a hashmap with the number as key and the value as 1\n        ## 2. Iterate through the array and for each number, if the number is not in the hashmap, add it to the result\n        ## 3. Return the result\n        \n        hashmap = {}\n        result = []\n        \n        for num in nums:\n            hashmap[num] = 1\n        \n        for i in range(1, len(nums) + 1):\n            if i not in hashmap:\n                result.append(i)\n        \n        return result"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        res = 0\n        prev = -1\n        for i in intervals:\n            if i[0] > prev:\n                res += 2\n                prev = i[1] - 1\n            else:\n                res += 1\n                prev -= 1\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if not left and not right:\n                return True\n            if not left or not right:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \uc815\uaddc\uc2dd\uc73c\ub85c \uc815\ub9ac\ud558\uae30\n        # 2. \uc815\uaddc\uc2dd\uc73c\ub85c \uc815\ub9ac\ud55c \ubb38\uc790\uc5f4\uc744 \ubd84\uc11d\ud558\uc5ec \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc138\uc5b4\uc8fc\uae30\n        # 3. \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc138\uc5b4\uc8fc\uba74\uc11c \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\ub9ac\ud558\uae30\n        # 4. \uc815\ub9ac\ud55c \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\ub9ac\ud558\uc5ec \ubc18\ud658\ud558\uae30\n        \n        # 1. \uc815\uaddc\uc2dd\uc73c\ub85c \uc815\ub9ac\ud558\uae30\n        # \uc815\uaddc\uc2dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc138\uc5b4\uc8fc\ub294 \uc815\uaddc\uc2dd\uc744 \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\uc758\ud558\uace0, \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\uc758\ud558\uace0, \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\uc758\ud558\uace0, \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\uc758\ud558\uace0, \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\uc758\ud558\uace0, \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\uc758\ud558\uace0, \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\uc758\ud558\uace0, \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744 \uc815\uc758\ud558\uace0, \uc6d0\uc18c\uc758 \uac1c\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        # \uc815\uaddc\uc2dd\uc740 \uc6d0\uc18c\uc758 \uc774\ub984\uc744"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n            \n            if node.left:\n                stack.append(node.left)\n        \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            left = self.generateParenthesis(i)\n            right = self.generateParenthesis(n-i-1)\n            for l in left:\n                for r in right:\n                    res.append('('+l+')'+r)\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0\uc11c \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 3. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 4. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 5. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 6. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 7. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 8. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 9. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 10. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 11. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 12. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 13. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 14. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 15. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 16. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 17. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n        # 18. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uc9dd\uc758 \uac1c\uc218\ub97c \uc800"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            denominator = -denominator\n        elif denominator < 0:\n            numerator = -numerator\n            denominator = -denominator\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        res = \"\"\n        res += str(numerator // denominator) + \".\"\n        numerator = numerator % denominator\n        numerator = numerator * 10\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res = res[:seen[numerator]] + \"(\" + res[seen[numerator]:] + \")\"\n                break\n            seen[numerator] = len(res)\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n            numerator = numerator * 10\n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the linked list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add the remaining nodes from the left half\n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        # print(envelopes)\n        dp = [envelopes[0][1]]\n        for i in range(1, len(envelopes)):\n            if envelopes[i][1] > dp[-1]:\n                dp.append(envelopes[i][1])\n            else:\n                left = 0\n                right = len(dp) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid\n                dp[left] = envelopes[i][1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # 2. Find the nth node from the end\n        if length == n:\n            return head.next\n        \n        # 3. Find the nth node from the beginning\n        curr = head\n        for i in range(length - n - 1):\n            curr = curr.next\n        \n        # 4. Remove the nth node from the end\n        curr.next = curr.next.next\n        return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        nums1.sort()\n        nums2.sort()\n        i = 0\n        j = 0\n        res = []\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                if i == 0 or nums1[i] != nums1[i-1]:\n                    res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        return res"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u603b\u548c\n        total = sum(machines)\n        # 2. \u5982\u679c\u603b\u548c\u4e0d\u80fd\u88abn\u6574\u9664\uff0c\u5219\u65e0\u6cd5\u5b8c\u6210\n        if total % n:\n            return -1\n        # 3. \u8ba1\u7b97\u5e73\u5747\u6570\n        avg = total // n\n        # 4. \u8ba1\u7b97\u79fb\u52a8\u6b21\u6570\n        res = 0\n        # 5. \u8ba1\u7b97\u524d\u7f00\u548c\n        pre = 0\n        for i in machines:\n            # 6. \u8ba1\u7b97\u79fb\u52a8\u6b21\u6570\n            res += abs(i - avg)\n            # 7. \u8ba1\u7b97\u524d\u7f00\u548c\n            pre += i - avg\n            # 8. \u6bd4\u8f83\u79fb\u52a8\u6b21\u6570\u548c\u524d\u7f00\u548c\n            res = max(res, pre)\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if not list1:\n            return list2\n        if not list2:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 and list2:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1:\n            curr.next = list1\n        else:\n            curr.next = list2\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        rows = len(matrix)\n        cols = len(matrix[0])\n        max_area = 0\n        heights = [0] * cols\n        \n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        \n        while stack:\n            height = heights[stack.pop()]\n            width = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 2^n - 1\n        # 2^n - 2\n        # 2^n - 3\n        # 2^n - 4\n        # 2^n - 5\n        # 2^n - 6\n        # 2^n - 7\n        # 2^n - 8\n        # 2^n - 9\n        # 2^n - 10\n        # 2^n - 11\n        # 2^n - 12\n        # 2^n - 13\n        # 2^n - 14\n        # 2^n - 15\n        # 2^n - 16\n        # 2^n - 17\n        # 2^n - 18\n        # 2^n - 19\n        # 2^n - 20\n        # 2^n - 21\n        # 2^n - 22\n        # 2^n - 23\n        # 2^n - 24\n        # 2^n - 25\n        # 2^n - 26\n        # 2^n - 27\n        # 2^n - 28\n        # 2^n - 29\n        # 2^n - 30\n        # 2^n - 31\n        # 2^n - 32\n        # 2^n - 33\n        # 2^n - 34\n        # 2^n - 35\n        # 2^n - 36\n        # 2^n - 37\n        # 2^n - 38\n        # 2^n - 39\n        # 2^n - 40\n        # 2^n - 41\n        # 2^n - 42\n        # 2^n - 43\n        # 2^n - 44\n        # 2^n - 45\n        # 2^n - 46\n        # 2^n - 47\n        # 2^n - 48\n        # 2^n - 49\n        # 2^n - 50\n        # 2^n - 51\n        # 2^n - 52\n        # 2^n - 53\n        # 2^n - 54\n        # 2^n - 55\n        # 2^n - 56\n        # 2^n - 57\n        # 2^n - 58\n        # 2^n - 59\n        # 2^n - 60\n        # 2^n - 61\n        # 2^n - 62\n        # 2^n - 63\n        # 2^n - 64\n        # 2^n - 65\n        # 2^n - 66\n        # 2^n - 67\n        # 2^n - 68\n        # 2^n - 69\n        # 2^n - 70\n        # 2^n - 71\n        # 2^n - 72\n        # 2^n - 73\n        # 2^n - 74\n        # 2^n - 75\n        # 2^n - 76\n        # 2^n - 77\n        # 2^n - 78\n        # 2^n - 79\n        # 2^n - 80\n        # 2^n - 81\n        # 2^n - 82\n        # 2^n - 83\n        # 2^n - 84\n        # 2^n - 85\n        # 2^n - 86\n        # 2^n - 87\n        # 2^n - 88\n        # 2^n - 89\n        # 2^n - 90\n        # 2^n - 91\n        # 2^n - 92\n        # 2^n - 93\n        # 2^n - 94"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]\n        # if nums[-1] < nums[-2]:\n        #     return nums[-1]\n        # if nums[0] < nums[1]:\n        #     return nums[0]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.strip()\n        if not s:\n            return False\n        \n        if s[0] in ['+','-']:\n            s = s[1:]\n        if s[-1] in ['+','-']:\n            s = s[:-1]\n        \n        if 'e' in s:\n            s1, s2 = s.split('e')\n            if not s1.isdigit() or not s2.isdigit():\n                return False\n            if s1 == '' or s2 == '':\n                return False\n            return True\n        else:\n            if s.count('.') > 1:\n                return False\n            if s.count('.') == 1:\n                s1, s2 = s.split('.')\n                if not s1.isdigit() or not s2.isdigit():\n                    return False\n                if s1 == '' or s2 == '':\n                    return False\n                return True\n            else:\n                if s.isdigit():\n                    return True\n                else:\n                    return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        roman_dict = {\n            1000: 'M',\n            900: 'CM',\n            500: 'D',\n            400: 'CD',\n            100: 'C',\n            90: 'XC',\n            50: 'L',\n            40: 'XL',\n            10: 'X',\n            9: 'IX',\n            5: 'V',\n            4: 'IV',\n            1: 'I'\n        }\n        \n        roman_num = ''\n        \n        for key in roman_dict.keys():\n            roman_num += roman_dict[key] * (num // key)\n            num %= key\n        \n        return roman_num"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # XOR\n        # 0 ^ 1 = 1\n        # 1 ^ 1 = 0\n        # 0 ^ 0 = 0\n        # 1 ^ 0 = 1\n        # 0 ^ 1 ^ 1 = 0\n        # 1 ^ 0 ^ 1 = 1\n        # 0 ^ 0 ^ 1 = 1\n        # 1 ^ 1 ^ 0 = 1\n        # 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 1\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        # 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        # 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 ^"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(row, col, num):\n            # Check row\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n            # Check col\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n            # Check 3x3 box\n            box_row = row // 3\n            box_col = col // 3\n            for i in range(3):\n                for j in range(3):\n                    if board[box_row * 3 + i][box_col * 3 + j] == num:\n                        return False\n            return True\n        \n        def solve(board):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        for num in range(1, 10):\n                            if isValid(row, col, str(num)):\n                                board[row][col] = str(num)\n                                if solve(board):\n                                    return True\n                                board[row][col] = '.'\n                        return False\n            return True\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1. Find the two nodes that are swapped\n        # 2. Swap the values of the two nodes\n        # 3. Recursively traverse the left subtree\n        # 4. Recursively traverse the right subtree\n        \n        # 1"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Find the middle of the linked list\n        # 2. Reverse the second half of the linked list\n        # 3. Compare the first half with the second half\n        \n        # 1. Find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. Reverse the second half of the linked list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # 3. Compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        \n        res = [0,1,1]\n        i = 2\n        while i <= n:\n            res.append(res[i-1] + 1)\n            i = i * 2\n        return res"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # if head is None:\n        #     return None\n        \n        # while head and head.val == val:\n        #     head = head.next\n        #     if head is None:\n        #         return None\n        \n        # curr = head\n        # while curr and curr.next:\n        #     if curr.next.val == val:\n        #         curr.next = curr.next.next\n        #     else:\n        #         curr = curr.next\n        # return head\n        \n        # if head is None:\n        #     return None\n        \n        # if head.val == val:\n        #     return self.removeElements(head.next, val)\n        \n        # head.next = self.removeElements(head.next, val)\n        # return head\n        \n        if head is None:\n            return None\n        \n        head.next = self.removeElements(head.next, val)\n        return head.next if head.val == val else head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if s1 == s2:\n            return True\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i,j,word,visited):\n            if word in self.word_dict:\n                self.res.append(word)\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or visited[i][j] or board[i][j] not in self.word_dict:\n                return\n            visited[i][j] = True\n            dfs(i+1,j,word+board[i][j],visited)\n            dfs(i-1,j,word+board[i][j],visited)\n            dfs(i,j+1,word+board[i][j],visited)\n            dfs(i,j-1,word+board[i][j],visited)\n            visited[i][j] = False\n        \n        self.word_dict = set(words)\n        self.res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i,j,\"\",[[False for _ in range(len(board[0]))] for _ in range(len(board))])\n        return self.res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = 1\n            else:\n                s_dict[s[i]] += 1\n            \n            if t[i] not in t_dict:\n                t_dict[t[i]] = 1\n            else:\n                t_dict[t[i]] += 1\n        \n        for key in s_dict:\n            if key not in t_dict:\n                return False\n            else:\n                if s_dict[key] != t_dict[key]:\n                    return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 3x3 sub-boxes\n        # 2. 9 rows\n        # 3. 9 columns\n        # 4. 9 unique numbers\n        # 5. 9 unique numbers\n        # 6. 9 unique numbers\n        # 7. 9 unique numbers\n        # 8. 9 unique numbers\n        # 9. 9 unique numbers\n        # 10. 9 unique numbers\n        # 11. 9 unique numbers\n        # 12. 9 unique numbers\n        # 13. 9 unique numbers\n        # 14. 9 unique numbers\n        # 15. 9 unique numbers\n        # 16. 9 unique numbers\n        # 17. 9 unique numbers\n        # 18. 9 unique numbers\n        # 19. 9 unique numbers\n        # 20. 9 unique numbers\n        # 21. 9 unique numbers\n        # 22. 9 unique numbers\n        # 23. 9 unique numbers\n        # 24. 9 unique numbers\n        # 25. 9 unique numbers\n        # 26. 9 unique numbers\n        # 27. 9 unique numbers\n        # 28. 9 unique numbers\n        # 29. 9 unique numbers\n        # 30. 9 unique numbers\n        # 31. 9 unique numbers\n        # 32. 9 unique numbers\n        # 33. 9 unique numbers\n        # 34. 9 unique numbers\n        # 35. 9 unique numbers\n        # 36. 9 unique numbers\n        # 37. 9 unique numbers\n        # 38. 9 unique numbers\n        # 39. 9 unique numbers\n        # 40. 9 unique numbers\n        # 41. 9 unique numbers\n        # 42. 9 unique numbers\n        # 43. 9 unique numbers\n        # 44. 9 unique numbers\n        # 45. 9 unique numbers\n        # 46. 9 unique numbers\n        # 47. 9 unique numbers\n        # 48. 9 unique numbers\n        # 49. 9 unique numbers\n        # 50. 9 unique numbers\n        # 51. 9 unique numbers\n        # 52. 9 unique numbers\n        # 53. 9 unique numbers\n        # 54. 9 unique numbers\n        # 55. 9 unique numbers\n        # 56. 9 unique numbers\n        # 57. 9 unique numbers\n        # 58. 9 unique numbers\n        # 59. 9 unique numbers\n        # 60. 9 unique numbers\n        # 61. 9 unique numbers\n        # 62. 9 unique numbers\n        # 63. 9 unique numbers\n        # 64. 9 unique numbers\n        # 65. 9 unique numbers\n        # 66. 9 unique numbers\n        # 67. 9 unique numbers\n        # 68. 9 unique numbers\n        # 69. 9 unique numbers\n        # 70. 9 unique numbers\n        # 71. 9 unique numbers\n        # 72. 9 unique numbers\n        # 73. 9 unique numbers\n        # 74. 9 unique numbers\n        # 75. 9 unique numbers\n        # 76. 9 unique numbers\n        # 77. 9 unique numbers\n        # 78. 9 unique numbers\n        # 79. 9 unique numbers\n        # 80. 9 unique numbers\n        # 81. 9 unique numbers\n        # 82. 9 unique numbers\n        # 83. 9 unique numbers\n        # 84. 9 unique numbers\n        # 85. 9 unique numbers\n        # 86. 9 unique numbers\n        # 87. 9 unique numbers\n        # 88. 9 unique numbers\n        # 89. 9 unique numbers\n        # 90. 9 unique numbers\n        # 91. 9 unique numbers\n        # 92. 9 unique numbers\n        # 93. 9 unique numbers\n        # 94. 9"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        answer = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                answer.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                answer.append(\"Fizz\")\n            elif i%5 == 0:\n                answer.append(\"Buzz\")\n            else:\n                answer.append(str(i))\n        return answer"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a single string\n        return \" \".join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) + (26^4 * 25) + (26^5 * 25) + (26^6 * 25) + (26^7 * 25)\n        # 26^0 * 25 + (26^1 * 25) + (26^2 * 25) + (26^3 * 25) +"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half\n        prev = None\n        curr = slow\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        \n        # merge the two halves\n        first = head\n        second = prev\n        while second.next:\n            temp1 = first.next\n            temp2 = second.next\n            first.next = second\n            second.next = temp1\n            first = temp1\n            second = temp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the number of words is not equal to the number of characters in the pattern, return False\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between characters and words\n        char_to_word = {}\n        \n        # iterate through the pattern and words\n        for char, word in zip(pattern, words):\n            # if the character is already in the dictionary, check if the word is the same\n            if char in char_to_word:\n                if char_to_word[char] != word:\n                    return False\n            # if the character is not in the dictionary, add it with the word\n            else:\n                char_to_word[char] = word\n        \n        # if all the characters are mapped to words, return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(nums, [], res)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search\n        # O(m + n)\n        # O(1)\n        # O(log(m * n))\n        \n        # binary search"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Create a new linked list\n        # 2. Create a new node\n        # 3. Add the values of l1 and l2 to the new node\n        # 4. Add the new node to the new linked list\n        # 5. Return the new linked list\n        \n        # 1. Create a new linked list\n        new_list = ListNode()\n        \n        # 2. Create a new node\n        new_node = new_list\n        \n        # 3. Add the values of l1 and l2 to the new node\n        while l1 or l2:\n            if l1:\n                new_node.val += l1.val\n                l1 = l1.next\n            if l2:\n                new_node.val += l2.val\n                l2 = l2.next\n            # 4. Add the new node to the new linked list\n            new_node.next = ListNode()\n            new_node = new_node.next\n        \n        # 5. Return the new linked list\n        return new_list"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Convert the number to binary\n        # 2. Reverse the binary\n        # 3. Convert the reversed binary to decimal\n        # 4. Return the complement\n        \n        binary = bin(num)[2:]\n        reversed_binary = binary[::-1]\n        decimal = int(reversed_binary, 2)\n        return decimal"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        i = 0\n        while i < len(nums)-2:\n            if nums[i+2] - nums[i] == nums[i+1] - nums[i]:\n                count += 1\n                i += 1\n            else:\n                i += 1\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            curr_len = len(words[i])\n            j = i + 1\n            while j < len(words) and curr_len + len(words[j]) + (j - i - 1) <= maxWidth:\n                curr_len += len(words[j])\n                j += 1\n            if j == len(words):\n                res.append(' '.join(words[i:j]) + ' ' * (maxWidth - curr_len - (j - i - 1)))\n            else:\n                num_spaces = maxWidth - curr_len\n                if j - i - 1 == 0:\n                    res.append(words[i] + ' ' * num_spaces)\n                else:\n                    num_spaces_per_word = num_spaces // (j - i - 1)\n                    num_extra_spaces = num_spaces % (j - i - 1)\n                    res.append(words[i] + ' ' * num_spaces_per_word + ' '.join(words[i + 1:j] + [' '] * num_extra_spaces))\n            i = j\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # Time Complexity: O(N * L)\n        # Space Complexity: O(N)\n        \n        # Create a set of words\n        word_set = set(words)\n        \n        # Create a set of concatenated words\n        concatenated_words = set()\n        \n        # Iterate through each word in the set\n        for word in word_set:\n            # If the word is in the set, add it to the concatenated words set\n            if self.is_concatenated(word, word_set):\n                concatenated_words.add(word)\n        \n        # Return the concatenated words set\n        return list(concatenated_words)\n    \n    def is_concatenated(self, word, word_set):\n        # Create a set to store the words that have been concatenated\n        concatenated_words = set()\n        \n        # Iterate through each character in the word\n        for i in range(len(word)):\n            # If the word is in the set, add it to the concatenated words set\n            if word[i:] in word_set:\n                concatenated_words.add(word[i:])\n            \n            # If the word has been concatenated, return True\n            if word[:i] in concatenated_words:\n                return True\n        \n        # If the word has not been concatenated, return False\n        return False"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign + res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(row, col):\n            for i in range(row):\n                if board[i][col] == 1:\n                    return False\n            i = row - 1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j -= 1\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 1:\n                    return False\n                i -= 1\n                j += 1\n            return True\n\n        def backtrack(row):\n            if row == n:\n                return 1\n            count = 0\n            for col in range(n):\n                if is_valid(row, col):\n                    board[row][col] = 1\n                    count += backtrack(row + 1)\n                    board[row][col] = 0\n            return count\n\n        board = [[0 for _ in range(n)] for _ in range(n)]\n        return backtrack(0)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(row, col, board):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(row, board):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(row, col, board):\n                    board[row][col] = 'Q'\n                    backtrack(row + 1, board)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(0, board)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n\n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n\n        # nums1 = [1,2,3,0,0,0]"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}