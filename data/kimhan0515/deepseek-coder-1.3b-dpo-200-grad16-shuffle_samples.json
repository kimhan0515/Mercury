{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n - 1\n        top, bottom = 0, m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) < len(t):\n            return 0\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the first missing positive integer\n        ## 2. Find the first missing positive integer\n        ## 3. Find the first missing positive integer\n        ## 4. Find the first missing positive integer\n        ## 5. Find the first missing positive integer\n        ## 6. Find the first missing positive integer\n        ## 7. Find the first missing positive integer\n        ## 8. Find the first missing positive integer\n        ## 9. Find the first missing positive integer\n        ## 10. Find the first missing positive integer\n        ## 11. Find the first missing positive integer\n        ## 12. Find the first missing positive integer\n        ## 13. Find the first missing positive integer\n        ## 14. Find the first missing positive integer\n        ## 15. Find the first missing positive integer\n        ## 16. Find the first missing positive integer\n        ## 17. Find the first missing positive integer\n        ## 18. Find the first missing positive integer\n        ## 19. Find the first missing positive integer\n        ## 20. Find the first missing positive integer\n        ## 21. Find the first missing positive integer\n        ## 22. Find the first missing positive integer\n        ## 23. Find the first missing positive integer\n        ## 24. Find the first missing positive integer\n        ## 25. Find the first missing positive integer\n        ## 26. Find the first missing positive integer\n        ## 27. Find the first missing positive integer\n        ## 28. Find the first missing positive integer\n        ## 29. Find the first missing positive integer\n        ## 30. Find the first missing positive integer\n        ## 31. Find the first missing positive integer\n        ## 32. Find the first missing positive integer\n        ## 33. Find the first missing positive integer\n        ## 34. Find the first missing positive integer\n        ## 35. Find the first missing positive integer\n        ## 36. Find the first missing positive integer\n        ## 37. Find the first missing positive integer\n        ## 38. Find the first missing positive integer\n        ## 39. Find the first missing positive integer\n        ## 40. Find the first missing positive integer\n        ## 41. Find the first missing positive integer\n        ## 42. Find the first missing positive integer\n        ## 43. Find the first missing positive integer\n        ## 44. Find the first missing positive integer\n        ## 45. Find the first missing positive integer\n        ## 46. Find the first missing positive integer\n        ## 47. Find the first missing positive integer\n        ## 48. Find the first missing positive integer\n        ## 49. Find the first missing positive integer\n        ## 50. Find the first missing positive integer\n        ## 51. Find the first missing positive integer\n        ## 52. Find the first missing positive integer\n        ## 53. Find the first missing positive integer\n        ## 54. Find the first missing positive integer\n        ## 55. Find the first missing positive integer\n        ## 56. Find the first missing positive integer\n        ## 57. Find the first missing positive integer\n        ## 58. Find the first missing positive integer\n        ## 59. Find the first missing positive integer\n        ## 60. Find the first missing positive integer\n        ## 61. Find the first missing positive integer\n        ## 62. Find the first missing positive integer\n        ## 63. Find the first missing positive integer\n        ## 64. Find the first missing positive integer\n        ## 65. Find the first missing positive integer\n        ## 66. Find the first missing positive integer\n        ## 67. Find the first missing positive integer\n        ## 68. Find the first missing positive integer\n        ## 69. Find the first missing positive integer\n        ## 70. Find the first missing positive integer\n        ## 71. Find the first missing positive integer\n        ## 72. Find the first missing positive integer\n        ## 73. Find the first missing positive integer\n        ## 74. Find the first missing"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        ans = \"\"\n        nums = [i for i in range(1, n+1)]\n        for i in range(n-1, -1, -1):\n            fact //= i\n            idx = k // fact\n            ans += str(nums[idx])\n            nums.pop(idx)\n            k %= fact\n        \n        return ans"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the numbers and their indices\n        num_dict = {}\n        \n        # iterate through the numbers list\n        for i, num in enumerate(numbers):\n            \n            # if the difference between the target and the current number is in the dictionary, return the indices\n            if target - num in num_dict:\n                return [num_dict[target - num], i]\n            \n            # otherwise, add the number to the dictionary with its index as the value\n            num_dict[num] = i"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target and op == \"+\":\n                    res.append(curr)\n                return\n            if op == \"+\":\n                backtrack(i + 1, curr + int(num[i]), int(num[i]), res, \"+\")\n                backtrack(i + 1, curr, prev, res, \"-\")\n            elif op == \"-\":\n                backtrack(i + 1, curr + int(num[i]), -int(num[i]), res, \"+\")\n                backtrack(i + 1, -curr, -prev, res, \"-\")\n            else:\n                backtrack(i + 1, curr + prev, int(num[i]), res, \"*\")\n                backtrack(i + 1, curr - prev, -int(num[i]), res, \"-\")\n                backtrack(i + 1, curr * prev, int(num[i]), res, \"*\")\n        \n        if not num:\n            return []\n        res = []\n        backtrack(0, 0, 0, res, \"+\")\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr * 10 + root.val\n            return dfs(root.left, curr * 10 + root.val) + dfs(root.right, curr * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        if n % k == 0:\n            return s[:k] + '-' + self.licenseKeyFormatting(s[k:], k)\n        else:\n            return s[:n % k] + '-' + self.licenseKeyFormatting(s[n % k:], k)"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                dp[i][j] = max(nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j] for k in range(i+1, j))\n        \n        return dp[0][n-1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if digits[-1] < 9:\n            digits[-1] += 1\n            return digits\n        else:\n            digits[-1] = 0\n            for i in range(len(digits)-2,-1,-1):\n                if digits[i] < 9:\n                    digits[i] += 1\n                    return digits\n                else:\n                    digits[i] = 0\n            digits.insert(0,1)\n            return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p.replace('*', ''):\n            return not s\n        \n        star = p.find('*')\n        if star == -1:\n            return False\n        \n        if p[star - 1] != s[0] and p[star - 1] != '.':\n            return False\n        \n        if star + 1 < len(p) and p[star + 1] == '*':\n            return self.isMatch(s[1:], p)\n        \n        if star + 1 < len(p) and p[star + 1] == s[0]:\n            return self.isMatch(s[1:], p[star + 1:])\n        \n        return self.isMatch(s[1:], p[star + 1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the length of the longest common prefix\n        # of nums1 and nums2\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            return self.maxNumber(nums2, nums1, k)\n        if m == 0:\n            return [nums2[i] for i in range(k)]\n        if k == 0:\n            return []\n        if k == m:\n            return nums1\n        if k == n:\n            return nums2\n        \n        # find the length of the longest common suffix\n        # of nums1 and nums2\n        k1, k2 = k, k\n        if m > k1:\n            k1 = m - k1\n        if n > k2:\n            k2 = n - k2\n        if k1 > k2:\n            k1, k2 = k2, k1\n        if k1 == 0:\n            return []\n        if k2 == 0:\n            return nums1[:k1]\n        \n        # find the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix of nums1 and nums2\n        # and the longest common suffix of nums1 and nums2\n        # and the longest common prefix of nums2 and nums1\n        # and the longest common suffix of nums2 and nums1\n        # and the longest common prefix"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if num // i != i:\n                    divisors.append(num // i)\n        \n        return num == sum(divisors)"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        dp[-1][-1] = 1\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            m = (l + r) // 2\n            cnt, j = 0, 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= m:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = m\n            else:\n                l = m + 1\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        l, r = 0, len(s) - 1\n        while l < r:\n            if s[l] in vowels and s[r] in vowels:\n                s[l], s[r] = s[r], s[l]\n                l += 1\n                r -= 1\n            elif s[l] not in vowels:\n                l += 1\n            elif s[r] not in vowels:\n                r -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums_set:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 ^ 0 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 = 1\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(beginWord)\n            graph[beginWord].append(word)\n        \n        # build a queue\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        level = 1\n        \n        # BFS\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                for neighbor in graph[curr]:\n                    if neighbor == endWord:\n                        return level\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n        \n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        a, b = a[::-1], b[::-1]\n        carry = 0\n        ans = []\n        for i in range(len(a)):\n            if i < len(b):\n                if a[i] == '1' and b[i] == '1':\n                    ans.append('1')\n                    carry = 1\n                elif a[i] == '0' and b[i] == '0':\n                    ans.append('0')\n                    carry = 0\n                else:\n                    ans.append('1')\n                    carry = 1\n            else:\n                if a[i] == '1':\n                    ans.append('1')\n                    carry = 1\n                else:\n                    ans.append('0')\n                    carry = 0\n        if carry == 1:\n            ans.append('1')\n        return ''.join(ans[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if not nums:\n            return [-1, -1]\n        \n        if target < nums[0] or target > nums[-1]:\n            return [-1, -1]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        if nums[left] != target:\n            return [-1, -1]\n        \n        left = right\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        \n        return [left, right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy\n        ## 2. DP\n        ## 3. BFS\n        ## 4. Binary Search\n        \n        ## 1. Greedy"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k == 0:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(0, len(prices) - 1)) - (prices[-1] - prices[-2]) for prices in zip(prices, prices[1:]))\n        \n        if k >= len(prices) // 2:\n            return sum(max(prices"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_list = [hex_dict[i] if i in hex_dict else i for i in hex_list]\n        return ''.join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first occurence of each character\n        # iterate through the string and update the hashmap and the list\n        # iterate through the list and return the first non-repeating character\n        \n        # create a hashmap to store the frequency of each character\n        freq = {}\n        # create a list to store the indices of the first occurence of each character\n        idx = []\n        # iterate through the string and update the hashmap and the list\n        for i, c in enumerate(s):\n            if c not in freq:\n                freq[c] = [i]\n                idx.append(i)\n            else:\n                freq[c].append(i)\n        # iterate through the list and return the first non-repeating character\n        for i in idx:\n            if freq[s[i]] == [i]:\n                return i\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if valueDiff < 0:\n            return False\n        \n        if indexDiff < 0:\n            return False\n        \n        if indexDiff >= len(nums):\n            return False\n        \n        if valueDiff >= len(nums):\n            return False\n        \n        if valueDiff == 0:\n            return False\n        \n        if indexDiff == 0:\n            return False\n        \n        if valueDiff == 1:\n            return False\n        \n        if valueDiff == len(nums) - 1:\n            return False\n        \n        if valueDiff == len(nums) - 2:\n            return False\n        \n        if valueDiff == len(nums) - 3:\n            return False\n        \n        if valueDiff == len(nums) - 4:\n            return False\n        \n        if valueDiff == len(nums) - 5:\n            return False\n        \n        if valueDiff == len(nums) - 6:\n            return False\n        \n        if valueDiff == len(nums) - 7:\n            return False\n        \n        if valueDiff == len(nums) - 8:\n            return False\n        \n        if valueDiff == len(nums) - 9:\n            return False\n        \n        if valueDiff == len(nums) - 10:\n            return False\n        \n        if valueDiff == len(nums) - 11:\n            return False\n        \n        if valueDiff == len(nums) - 12:\n            return False\n        \n        if valueDiff == len(nums) - 13:\n            return False\n        \n        if valueDiff == len(nums) - 14:\n            return False\n        \n        if valueDiff == len(nums) - 15:\n            return False\n        \n        if valueDiff == len(nums) - 16:\n            return False\n        \n        if valueDiff == len(nums) - 17:\n            return False\n        \n        if valueDiff == len(nums) - 18:\n            return False\n        \n        if valueDiff == len(nums) - 19:\n            return False\n        \n        if valueDiff == len(nums) - 20:\n            return False\n        \n        if valueDiff == len(nums) - 21:\n            return False\n        \n        if valueDiff == len(nums) - 22:\n            return False\n        \n        if valueDiff == len(nums) - 23:\n            return False\n        \n        if valueDiff == len(nums) - 24:\n            return False\n        \n        if valueDiff == len(nums) - 25:\n            return False\n        \n        if valueDiff == len(nums) - 26:\n            return False\n        \n        if valueDiff == len(nums) - 27:\n            return False\n        \n        if valueDiff == len(nums) - 28:\n            return False\n        \n        if valueDiff == len(nums) - 29:\n            return False\n        \n        if valueDiff == len(nums) - 30:\n            return False\n        \n        if valueDiff == len(nums) - 31:\n            return False\n        \n        if valueDiff == len(nums) - 32:\n            return False\n        \n        if valueDiff == len(nums) - 33:\n            return False\n        \n        if valueDiff == len(nums) - 34:\n            return False\n        \n        if valueDiff == len(nums) - 35:\n            return False\n        \n        if valueDiff == len(nums) - 36:\n            return False\n        \n        if valueDiff == len(nums) - 37:\n            return False\n        \n        if valueDiff == len(nums) - 38:\n            return False\n        \n        if valueDiff == len(nums) - 39:\n            return False\n        \n        if valueDiff == len(nums) - 40:\n            return False\n        \n        if valueDiff == len(nums) - 41:\n            return False\n        \n        if valueDiff == len(nums)"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        curr_count = 0\n        \n        for num in nums:\n            if num == 1:\n                curr_count += 1\n            else:\n                max_count = max(max_count, curr_count)\n                curr_count = 0\n        \n        return max(max_count, curr_count)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1, num2 = num1[::-1], num2[::-1]\n        \n        carry = 0\n        ans = []\n        for i in range(len(num1)):\n            if i < len(num2):\n                ans.append(str((int(num1[i]) + int(num2[i]) + carry) % 10))\n                carry = (int(num1[i]) + int(num2[i]) + carry) // 10\n            else:\n                ans.append(str((int(num1[i]) + carry) % 10))\n                carry = (int(num1[i]) + carry) // 10\n        \n        if carry:\n            ans.append(str(carry))\n        \n        return ''.join(ans[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize the stack and the result\n        stack = []\n        result = 0\n        \n        # 2. Initialize the sign to be positive\n        sign = 1\n        \n        # 3. Initialize the number to be 0\n        num = 0\n        \n        # 4. Iterate over the string\n        for c in s:\n            \n            # 5. If the character is a digit, add it to the number\n            if c.isdigit():\n                num = num * 10 + int(c)\n                \n            # 6. If the character is a non-digit character, or the end of the string,\n            #    then we need to do some processing\n            elif c in '+-':\n                \n                # 7. If the sign is positive, then we need to add the number to the result\n                #    and set the number to 0\n                if sign == 1:\n                    result += num\n                    num = 0\n                \n                # 8. If the sign is negative, then we need to subtract the number from the result\n                #    and set the number to 0\n                else:\n                    result -= num\n                    num = 0\n                \n                # 9. If the character is a +, then we need to set the sign to be positive\n                if c == '+':\n                    sign = 1\n                \n                # 10. If the character is a -, then we need to set the sign to be negative\n                elif c == '-':\n                    sign = -1\n                \n            # 11. If the character is a (, then we need to push the result and sign onto the stack\n            elif c == '(':\n                stack.append(result)\n                stack.append(sign)\n                \n                # 12. Reset the result and sign to be 1\n                result = 0\n                sign = 1\n                \n            # 13. If the character is a ), then we need to pop the sign and result from the stack\n            elif c == ')':\n                result = stack.pop() * result + stack.pop()\n                \n        # 14. If the string is not empty, then we need to add the number to the result\n        if num != 0:\n            result += num\n            \n        # 15. Return the result\n        return result"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital[i]\n        # profits[i] - capital["}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) % 2 != 0:\n            return False\n        \n        stack = []\n        mapping = {')':'(', ']':'[', '}':'{'}\n        \n        for char in s:\n            if char not in mapping:\n                stack.append(char)\n            elif not stack or mapping[char] != stack.pop():\n                return False\n        \n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next number\n        # find the number that is larger than the first number\n        # swap the two numbers\n        # reverse the second half of the array\n        \n        # find the first number that is smaller than the next"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k <= 0:\n            return False\n        \n        if k >= len(nums):\n            k = len(nums) - 1\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len(nums) > len(set(nums)):\n            return True\n        \n        if len(nums) == len(set(nums)):\n            return False\n        \n        if len("}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q if node for child in (node.left, node.right)]\n        \n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        ans = 0\n        for couple in couples:\n            if couple[0] % 2 == 1:\n                ans += 1\n            if couple[1] % 2 == 0:\n                ans += 1\n        \n        return ans // 2"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if s1 == s2:\n            return s3 == s1\n        \n        if s1 == s3[:len(s1)] and s2 == s3[len(s1):]:\n            return True\n        \n        if s2 == s3[:len(s2)]:\n            return self.isInterleave(s2, s1, s3)\n        \n        if s1[0] == s3[0]:\n            return self.isInterleave(s1[1:], s2, s3[1:])\n        \n        if s2[0] == s3[0]:\n            return self.isInterleave(s1, s2[1:], s3[1:])\n        \n        return False"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        count = 0\n        \n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        \n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a dictionary of the first row\n        first_row = {'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'}\n        # create a dictionary of the second row\n        second_row = {'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'}\n        # create a dictionary of the third row\n        third_row = {'z', 'x', 'c', 'v', 'b', 'n', 'm'}\n        \n        # create a list of the words that can be typed using letters of the alphabet on only one row of American keyboard\n        words_on_one_row = []\n        \n        # loop through the words\n        for word in words:\n            # create a set of the letters in the word\n            word_letters = set(word.lower())\n            # if the word is in the first row\n            if word_letters <= first_row:\n                # add the word to the list of words that can be typed using letters of the alphabet on only one row of American keyboard\n                words_on_one_row.append(word)\n            # if the word is in the second row\n            elif word_letters <= second_row:\n                # add the word to the list of words that can be typed using letters of the alphabet on only one row of American keyboard\n                words_on_one_row.append(word)\n            # if the word is in the third row\n            elif word_letters <= third_row:\n                # add the word to the list of words that can be typed using letters of the alphabet on only one row of American keyboard\n                words_on_one_row.append(word)\n        \n        # return the list of words that can be typed using letters of the alphabet on only one row of American keyboard\n        return words_on_one_row"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        prev.next = None\n        curr = curr.next\n        for i in range(right - left):\n            curr = curr.next\n        \n        curr.next, curr = self.reverse(curr)\n        prev.next = curr\n        return dummy.next\n    \n    def reverse(self, head):\n        prev = None\n        curr = head\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        return prev, head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome is itself\n        # if s is not a palindrome, then the longest palindrome is the reverse of the longest palindrome that can be centered at the end of s\n        # if s is a palindrome, then the longest palindrome"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        if len(s) == 1:\n            return s if s == t else \"\"\n        \n        if len(s) == 2:\n            return s if s[0] == t[0] and s[1] == t[1] else \"\"\n        \n        if len(s) == 3:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] else \"\"\n        \n        if len(s) == 4:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] else \"\"\n        \n        if len(s) == 5:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] else \"\"\n        \n        if len(s) == 6:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] else \"\"\n        \n        if len(s) == 7:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] else \"\"\n        \n        if len(s) == 8:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] else \"\"\n        \n        if len(s) == 9:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] else \"\"\n        \n        if len(s) == 10:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] else \"\"\n        \n        if len(s) == 11:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] and s[10] == t[10] else \"\"\n        \n        if len(s) == 12:\n            return s if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] and s[10] == t[10]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(distance) < 4:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] <= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return True\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return True\n        \n        if distance[0] >= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] >= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] >= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] >= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] >= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] >= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] >= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] >= distance[2] and distance[1] >= distance[3]:\n            return True\n        \n        if distance[0] <= distance[2] and distance[1] <= distance[3]:\n            return False\n        \n        if distance[0] <= distance[2] and distance[1] >= distance[3]:\n            return True"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a variable to store the length of the longest palindrome\n        # create a variable to store the number of odd characters\n        # create a variable to store the number of even characters\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the number of characters with odd frequency\n        # create a variable to store the number of characters with even frequency\n        # create a variable to store the"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root_val = postorder[-1]\n        root_idx = inorder.index(root_val)\n        \n        left_inorder = inorder[:root_idx]\n        right_inorder = inorder[root_idx + 1:]\n        \n        left_postorder = postorder[:len(left_inorder)]\n        right_postorder = postorder[len(left_inorder):-1]\n        \n        root = TreeNode(root_val)\n        root.left = self.buildTree(left_inorder, left_postorder)\n        root.right = self.buildTree(right_inorder, right_postorder)\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # get all the trees in the forest\n        trees = []\n        for row in forest:\n            for tree in row:\n                if tree > 1:\n                    trees.append(tree)\n        \n        # sort the trees in ascending order\n        trees.sort()\n        \n        # get the starting point\n        start = (0, 0)\n        for i, tree in enumerate(trees):\n            if forest[start[0]][start[1]] >= tree:\n                start = (start[0], i)\n                break\n        \n        # get the ending point\n        end = (len(forest) - 1, len(forest[0]) - 1)\n        for i, tree in en.reversed(list(enumerate(trees))):\n            if forest[end[0]][end[1]] >= tree:\n                end = (end[0], i)\n                break\n        \n        # get the distance between the starting and ending points\n        return self.bfs(forest, start, end)\n    \n    def bfs(self, forest, start, end):\n        # get the distance between the starting and ending points\n        q = [(start, 0)]\n        visited = set()\n        visited.add(start)\n        while q:\n            node, dist = q.pop(0)\n            if node == end:\n                return dist\n            for neighbor in self.get_neighbors(forest, node):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append((neighbor, dist + 1))\n        return -1\n    \n    def get_neighbors(self, forest, node):\n        # get the neighbors of the node\n        neighbors = []\n        if node[0] > 0:\n            neighbors.append((node[0] - 1, node[1]))\n        if node[0] < len(forest) - 1:\n            neighbors.append((node[0] + 1, node[1]))\n        if node[1] > 0:\n            neighbors.append((node[0], node[1] - 1))\n        if node[1] < len(forest[0]) - 1:\n            neighbors.append((node[0], node[1] + 1))\n        return neighbors"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. preprocess the nums array\n        # 2. use the prefix sum to find the range sum\n        # 3. use the binary search to find the range sum\n        # 4. use the binary search to find the range sum\n        # 5. use the binary search to find the range sum\n        # 6. use the binary search to find the range sum\n        # 7. use the binary search to find the range sum\n        # 8. use the binary search to find the range sum\n        # 9. use the binary search to find the range sum\n        # 10. use the binary search to find the range sum\n        # 11. use the binary search to find the range sum\n        # 12. use the binary search to find the range sum\n        # 13. use the binary search to find the range sum\n        # 14. use the binary search to find the range sum\n        # 15. use the binary search to find the range sum\n        # 16. use the binary search to find the range sum\n        # 17. use the binary search to find the range sum\n        # 18. use the binary search to find the range sum\n        # 19. use the binary search to find the range sum\n        # 20. use the binary search to find the range sum\n        # 21. use the binary search to find the range sum\n        # 22. use the binary search to find the range sum\n        # 23. use the binary search to find the range sum\n        # 24. use the binary search to find the range sum\n        # 25. use the binary search to find the range sum\n        # 26. use the binary search to find the range sum\n        # 27. use the binary search to find the range sum\n        # 28. use the binary search to find the range sum\n        # 29. use the binary search to find the range sum\n        # 30. use the binary search to find the range sum\n        # 31. use the binary search to find the range sum\n        # 32. use the binary search to find the range sum\n        # 33. use the binary search to find the range sum\n        # 34. use the binary search to find the range sum\n        # 35. use the binary search to find the range sum\n        # 36. use the binary search to find the range sum\n        # 37. use the binary search to find the range sum\n        # 38. use the binary search to find the range sum\n        # 39. use the binary search to find the range sum\n        # 40. use the binary search to find the range sum\n        # 41. use the binary search to find the range sum\n        # 42. use the binary search to find the range sum\n        # 43. use the binary search to find the range sum\n        # 44. use the binary search to find the range sum\n        # 45. use the binary search to find the range sum\n        # 46. use the binary search to find the range sum\n        # 47. use the binary search to find the range sum\n        # 48. use the binary search to find the range sum\n        # 49. use the binary search to find the range sum\n        # 50. use the binary search to find the range sum\n        # 51. use the binary search to find the range sum\n        # 52. use the binary search to find the range sum\n        # 53. use the binary search to find the range sum\n        # 54. use the binary search to find the range sum\n        # 55. use the binary search to find the range sum\n        # 56. use the binary search to find the range sum\n        # 57. use the binary search to find the range sum\n        # 58. use the binary search to find the range sum\n        # 59. use the binary search to find the range sum\n        # 60. use the binary search to find the range sum\n        # 61. use the binary search to find the range sum\n        # 62. use the binary search to find the range sum\n        # 63. use the binary search to find the range sum\n        # 64. use the binary search to find the range sum\n        # 65. use the binary search to find"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)\n        \n        # n = n - 1\n        # return int(n**2/2/n)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        if x < 100:\n            return True\n        \n        if x < 1000:\n            return x % 11 == x // 11\n        \n        if x < 10000:\n            return x % 101 == x // 101\n        \n        if x < 100000:\n            return x % 1001 == x // 1001\n        \n        if x < 1000000:\n            return x % 10001 == x // 10001\n        \n        if x < 10000000:\n            return x % 100001 == x // 100001\n        \n        if x < 100000000:\n            return x % 1000001 == x // 1000001\n        \n        if x < 1000000000:\n            return x % 10000001 == x // 10000001\n        \n        if x < 10000000000:\n            return x % 100000001 == x // 100000001\n        \n        if x < 100000000000:\n            return x % 1000000001 == x // 1000000001\n        \n        if x < 1000000000000:\n            return x % 10000000001 == x // 10000000001\n        \n        if x < 10000000000000:\n            return x % 100000000001 == x // 100000000001\n        \n        if x < 100000000000000:\n            return x % 1000000000001 == x // 1000000000001\n        \n        if x < 1000000000000000:\n            return x % 10000000000001 == x // 10000000000001\n        \n        if x < 10000000000000000:\n            return x % 100000000000001 == x // 100000000000001\n        \n        if x < 100000000000000000:\n            return x % 1000000000000001 == x // 1000000000000001\n        \n        if x < 1000000000000000000:\n            return x % 10000000000000001 == x // 10000000000000001\n        \n        if x < 10000000000000000000:\n            return x % 100000000000000001 == x // 100000000000000001\n        \n        if x < 100000000000000000000:\n            return x % 1000000000000000001 == x // 1000000000000000001\n        \n        if x < 1000000000000000000000:\n            return x % 10000"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        if len(s) == 2:\n            if s[1] == '0':\n                if s[0] == '1':\n                    return 1\n                else:\n                    return 0\n            else:\n                if s[0] == '1':\n                    return 1\n                else:\n                    return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] == '0':\n                if s[i - 2] == '1' or s[i - 2] == '2':\n                    dp[i] = dp[i - 2]\n                else:\n                    return 0\n            else:\n                if s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] in '12'):\n                    dp[i] = dp[i - 1] + dp[i - 2]\n                else:\n                    dp[i] = dp[i - 1]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) > len(t):\n            return False\n        \n        if len(s) == 0:\n            return True\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2^n - 1\n        # 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # create a set of words\n        word_set = set(wordDict)\n        \n        # create a list of words\n        words = []\n        for word in word_set:\n            words.append(word)\n        \n        # create a list of words\n        words = set(words)\n        \n        # create a list of words\n        words = list(words)\n        \n        # create a list of words\n        words = list(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word_set)\n        \n        # create a list of words\n        words = set(word"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            if (node.val <= left[0] or node.val >= right[0]):\n                return False\n            return valid(node.left, left, [node.val, right[0]]) and valid(node.right, [left[0], node.val], right)\n        \n        return valid(root, [-float('inf'), float('inf')], [])"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the original list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first interval in the list,\n        # insert the new interval at the beginning of the list\n        if newInterval[1] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last interval in the list,\n        # insert the new interval at the end of the list\n        if newInterval[0] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first interval in the list,\n        # merge the new interval with the first interval\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last interval in the list,\n        # merge the new interval with the last interval\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with an interval in the middle of the list,\n        # merge the new interval with the interval in the middle\n        if newInterval[0] >="}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # if len(s) == 1:\n        #     return [[s]]\n        \n        # if len(s) == 2:\n        #     if s[0] == s[1]:\n        #         return [[s[0], s[1]]]\n        #     else:\n        #         return [[s[0], s[1]], [s[1], s[0]]]\n        \n        # if len(s) == 3:\n        #     if s[0] == s[1] and s[1] == s[2]:\n        #         return [[s[0], s[1], s[2]]]\n        #     elif s[0] == s[1] and s[1] != s[2]:\n        #         return [[s[0], s[2]], [s[1], s[2]]]\n        #     elif s[0] != s[1] and s[1] == s[2]:\n        #         return [[s[0], s[1]], [s[2]]]\n        #     else:\n        #         return [[s[0], s[1], s[2]], [s[1], s[0], s[2]], [s[2], s[0], s[1]]]\n        \n        # if len(s) == 4:\n        #     if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:\n        #         return [[s[0], s[1], s[2], s[3]]]\n        #     elif s[0] == s[1] and s[1] == s[2] and s[2] != s[3]:\n        #         return [[s[0], s[2], s[3]], [s[1], s[2], s[3]]]\n        #     elif s[0] == s[1] and s[1] != s[2] and s[2] == s[3]:\n        #         return [[s[0], s[1], s[3]], [s[2], s[3]]]\n        #     elif s[0] == s[1] and s[1] != s[2] and s[2] != s[3]:\n        #         return [[s[0], s[1], s[2], s[3]], [s[0], s[1], s[3], s[2]], [s[0], s[2], s[1], s[3]], [s[0], s[2], s[3], s[1]], [s[1], s[0], s[2], s[3]], [s[1], s[0], s[3], s[2]], [s[2], s[0], s[1], s[3]], [s[2], s[0], s[3], s[1]], [s[3], s[0], s[1], s[2]], [s[3], s[0], s[2], s[1]], [s[0], s[1], s[2], s[3], s[4]], [s[0], s[1], s[3], s[2], s[4]], [s[0], s[1], s[4], s[2], s[3]], [s[0], s[1], s[4], s[3], s[2]], [s[0], s[2], s[1], s[3], s[4]], [s[0], s[2], s[3], s[1], s[4]], [s[0], s[2], s[4], s[1], s[3]], [s[0], s[2], s[4], s[3], s[1]], [s[0], s[3], s[1], s[2], s[4]], [s[0], s[3], s[2], s[1], s[4]], [s[0], s[3], s[4], s[1], s[2]], [s[0], s[4], s[1], s[2], s[3]], [s[0], s[4], s[2], s[1], s[3]], [s[1], s[0], s[2], s[3], s["}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the min and max of all the lists\n        min_val = float('inf')\n        max_val = float('-inf')\n        for l in nums:\n            min_val = min(min_val, l[0])\n            max_val = max(max_val, l[-1])\n        \n        # find the min and max of the range\n        min_range = max_val - min_val\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and max of the range\n        min_range_list = [min_val, max_val]\n        \n        # find the min and"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000 buckets, 15 minutes, 15 minutes\n        # 2. 1000 buckets, 15 minutes, 30 minutes\n        # 3. 1000 buckets, 15 minutes, 60 minutes\n        # 4. 1000 buckets, 15 minutes, 120 minutes\n        # 5. 1000 buckets, 15 minutes, 240 minutes\n        # 6. 1000 buckets, 15 minutes, 480 minutes\n        # 7. 1000 buckets, 15 minutes, 960 minutes\n        # 8. 1000 buckets, 15 minutes, 1920 minutes\n        # 9. 1000 buckets, 15 minutes, 3840 minutes\n        # 10. 1000 buckets, 15 minutes, 7680 minutes\n        # 11. 1000 buckets, 15 minutes, 15360 minutes\n        # 12. 1000 buckets, 15 minutes, 30720 minutes\n        # 13. 1000 buckets, 15 minutes, 61440 minutes\n        # 14. 1000 buckets, 15 minutes, 122880 minutes\n        # 15. 1000 buckets, 15 minutes, 245760 minutes\n        # 16. 1000 buckets, 15 minutes, 491520 minutes\n        # 17. 1000 buckets, 15 minutes, 983040 minutes\n        # 18. 1000 buckets, 15 minutes, 1966080 minutes\n        # 19. 1000 buckets, 15 minutes, 3932160 minutes\n        # 20. 1000 buckets, 15 minutes, 7864320 minutes\n        # 21. 1000 buckets, 15 minutes, 15728640 minutes\n        # 22. 1000 buckets, 15 minutes, 31457280 minutes\n        # 23. 1000 buckets, 15 minutes, 62914560 minutes\n        # 24. 1000 buckets, 15 minutes, 125829120 minutes\n        # 25. 1000 buckets, 15 minutes, 251658240 minutes\n        # 26. 1000 buckets, 15 minutes, 503316480 minutes\n        # 27. 1000 buckets, 15 minutes, 1006632960 minutes\n        # 28. 1000 buckets, 15 minutes, 2013265920 minutes\n        # 29. 1000 buckets, 15 minutes, 4026531840 minutes\n        # 30. 1000 buckets, 15 minutes, 8053063680 minutes\n        # 31. 1000 buckets, 15 minutes, 16106127360 minutes\n        # 32. 1000 buckets, 15 minutes, 32212254720 minutes\n        # 33. 1000 buckets, 15 minutes, 64424509440 minutes\n        # 34. 1000 buckets, 15 minutes, 128849018880 minutes\n        # 35. 1000 buckets, 15 minutes, 257698037760 minutes\n        # 36. 1000 buckets, 15 minutes, 51539"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        # BFS\n        q = [(grid[0][0], 0, 0)]\n        seen = set()\n        seen.add((0, 0))\n        ans = 0\n        while q:\n            ans, x, y = heapq.heappop(q)\n            if x == y == n - 1:\n                return ans\n            for nx, ny in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in seen:\n                    seen.add((nx, ny))\n                    heapq.heappush(q, (max(ans, grid[nx][ny]), nx, ny))\n        return ans"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # if m == 1 or n == 1:\n        #     return 1\n        # if m == 2 and n == 2:\n        #     return 2\n        # if m == 2 and n == 3:\n        #     return 3\n        # if m == 3 and n == 2:\n        #     return 3\n        # if m == 3 and n == 3:\n        #     return 6\n        # if m == 4 and n == 3:\n        #     return 10\n        # if m == 5 and n == 3:\n        #     return 15\n        # if m == 6 and n == 3:\n        #     return 21\n        # if m == 7 and n == 3:\n        #     return 28\n        # if m == 8 and n == 3:\n        #     return 36\n        # if m == 9 and n == 3:\n        #     return 45\n        # if m == 10 and n == 3:\n        #     return 55\n        # if m == 11 and n == 3:\n        #     return 66\n        # if m == 12 and n == 3:\n        #     return 78\n        # if m == 13 and n == 3:\n        #     return 91\n        # if m == 14 and n == 3:\n        #     return 105\n        # if m == 15 and n == 3:\n        #     return 120\n        # if m == 16 and n == 3:\n        #     return 136\n        # if m == 17 and n == 3:\n        #     return 153\n        # if m == 18 and n == 3:\n        #     return 171\n        # if m == 19 and n == 3:\n        #     return 190\n        # if m == 20 and n == 3:\n        #     return 210\n        # if m == 21 and n == 3:\n        #     return 231\n        # if m == 22 and n == 3:\n        #     return 253\n        # if m == 23 and n == 3:\n        #     return 276\n        # if m == 24 and n == 3:\n        #     return 300\n        # if m == 25 and n == 3:\n        #     return 325\n        # if m == 26 and n == 3:\n        #     return 351\n        # if m == 27 and n == 3:\n        #     return 378\n        # if m == 28 and n == 3:\n        #     return 406\n        # if m == 29 and n == 3:\n        #     return 435\n        # if m == 30 and n == 3:\n        #     return 465\n        # if m == 31 and n == 3:\n        #     return 496\n        # if m == 32 and n == 3:\n        #     return 528\n        # if m == 33 and n == 3:\n        #     return 561\n        # if m == 34 and n == 3:\n        #     return 595\n        # if m == 35 and n == 3:\n        #     return 630\n        # if m == 36 and n == 3:\n        #     return 666\n        # if m == 37 and n == 3:\n        #     return 703\n        # if m == 38 and n == 3:\n        #     return 741\n        # if m == 39 and n == 3:\n        #     return 780\n        # if m == 40 and n == 3:\n        #     return 820\n        # if m == 41 and n == 3:\n        #     return 861\n        # if m == 42 and n == 3:\n        #     return 903\n        # if m == 43 and n == 3:\n        #     return 946\n        # if m == 44 and n == 3:\n        #     return 990\n        # if m == 45 and n == 3:\n        #     return 1035\n        # if m == 46 and n == 3:\n        #     return 10"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        if num1 == '1':\n            return num2\n        \n        if num2 == '1':\n            return num1\n        \n        if num1 == '2':\n            return num2 + num2\n        \n        if num2 == '2':\n            return num1 + num1\n        \n        if num1 == '3':\n            return num2 + num2 + num2\n        \n        if num2 == '3':\n            return num1 + num1 + num1\n        \n        if num1 == '4':\n            return num2 + num2 + num2 + num2\n        \n        if num2 == '4':\n            return num1 + num1 + num1 + num1\n        \n        if num1 == '5':\n            return num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '5':\n            return num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '6':\n            return num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '6':\n            return num1 + num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '7':\n            return num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '7':\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '8':\n            return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '8':\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '9':\n            return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '9':\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '10':\n            return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '10':\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '11':\n            return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '11':\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '12':\n            return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '12':\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '13':\n            return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '13':\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1\n        \n        if num1 == '14':\n            return num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2 + num2\n        \n        if num2 == '14':\n            return num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num1 + num"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the max profit from left to right\n        ## 2. find the max profit from right to left\n        ## 3. return the max of the two\n        \n        ## 1. find the max profit from left to right\n        max_profit = 0\n        min_price = prices[0]\n        for price in prices:\n            if price < min_price:\n                min_price = price\n            else:\n                max_profit = max(max_profit, price - min_price)\n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper():\n            return True\n        elif word[1:].isupper() and word[0].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the min price\n        min_price = prices[0]\n        ## 2. find the max profit\n        max_profit = 0\n        \n        for price in prices:\n            if price < min_price:\n                min_price = price\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        inorder_idx = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:inorder_idx+1], inorder[:inorder_idx])\n        root.right = self.buildTree(preorder[inorder_idx+1:], inorder[inorder_idx+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        # find the first and last '(' and ')'\n        # if the first '(' is not the last, then we need to remove the last ')'\n        # if the last ')' is not the first, then we need to remove the first '('\n        # if the first '(' is the last, then we need to remove all ')'\n        # if the last ')' is the first, then we need to remove all '('\n        # if the first '(' is not the last and the last ')' is not the first, then we need to remove the first '('\n        # if the first '(' is not the last and the last ')' is the first, then we need to remove the last ')'\n        # if the first '(' is the last and the last ')' is not the first, then we need to remove all '('\n        # if the first '(' is the last and the last ')' is the first, then we need to remove all ')'\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is not the last, then we need to remove the first '('\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last, then we need to remove the last ')'\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last, then we need to remove all '('\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last, then we need to remove all ')'\n        # if the first '(' is the last and the last ')' is not the first and the first '(' is not the last, then we need to remove all '('\n        # if the first '(' is the last and the last ')' is not the first and the first '(' is the last, then we need to remove all ')'\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is not the last and the last ')' is not the first, then we need to remove the first '('\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last and the last ')' is not the first, then we need to remove the last ')'\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last and the last ')' is the first, then we need to remove all '('\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last and the last ')' is the first, then we need to remove all ')'\n        # if the first '(' is the last and the last ')' is not the first and the first '(' is not the last and the last ')' is not the first, then we need to remove all '('\n        # if the first '(' is the last and the last ')' is not the first and the first '(' is the last and the last ')' is the first, then we need to remove all ')'\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is not the last and the last ')' is not the first and the first '(' is not the last, then we need to remove the first '('\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last and the last ')' is the first, then we need to remove the last ')'\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last and the last ')' is the first, then we need to remove all '('\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last and the last ')' is the first, then we need to remove all ')'\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is not the last and the last ')' is not the first and the first '(' is not the last, then we need to remove the first '('\n        # if the first '(' is not the last and the last ')' is not the first and the first '(' is the last and the last ')' is the first, then we need to remove the"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) == 1:\n        #     return 0\n        \n        # if len(s) == 2:\n        #     return 0 if s[0] == s[1] else 1\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut(s[1:-1])\n        \n        # return 1 + self.minCut(s[1:])\n        \n        # if s[0] == s[-1]:\n        #     return self.minCut"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. k = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 22"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a hashmap to store the reverse of each word\n        # and the index of the word\n        word_map = {word[::-1]: i for i, word in enumerate(words)}\n        \n        # create a list to store the result\n        result = []\n        \n        # iterate over the words\n        for i, word in enumerate(words):\n            # if the word is empty, add the index to the result\n            if not word:\n                result.append([i, word_map[\"\"]])\n                continue\n            \n            # if the word is a palindrome, add the index to the result\n            if word in word_map:\n                result.append([i, word_map[word]])\n                continue\n            \n            # if the word is not a palindrome, reverse the word\n            rev_word = word[::-1]\n            \n            # if the reverse word is a palindrome, add the index to the result\n            if rev_word in word_map:\n                result.append([i, word_map[rev_word]])\n                result.append([word_map[rev_word], i])\n                continue\n            \n            # if the reverse word is not a palindrome, add the index to the result\n            result.append([i, word_map[rev_word]])\n        \n        # return the result\n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not nums:\n            return None\n        \n        if len(nums) == 1:\n            return TreeNode(nums[0])\n        \n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(isInfected), len(isInfected[0])\n        infected, infected_count, wall_count = 0, 0, 0\n        for i in range(m):\n            for j in range(n):\n                if isInfected[i][j] == 1:\n                    infected += 1\n                    infected_count += self.get_infected_count(isInfected, i, j)\n        if infected == 0:\n            return wall_count\n        if infected_count == 0:\n            return 0\n        if infected_count > m * n:\n            return m * n\n        if infected_count > m * n / 2:\n            return m * n / 2\n        if infected_count > m * n / 4:\n            return m * n / 4\n        if infected_count > m * n / 8:\n            return m * n / 8\n        if infected_count > m * n / 16:\n            return m * n / 16\n        if infected_count > m * n / 32:\n            return m * n / 32\n        if infected_count > m * n / 64:\n            return m * n / 64\n        if infected_count > m * n / 128:\n            return m * n / 128\n        if infected_count > m * n / 256:\n            return m * n / 256\n        if infected_count > m * n / 512:\n            return m * n / 512\n        if infected_count > m * n / 1024:\n            return m * n / 1024\n        if infected_count > m * n / 2048:\n            return m * n / 2048\n        if infected_count > m * n / 4096:\n            return m * n / 4096\n        if infected_count > m * n / 8192:\n            return m * n / 8192\n        if infected_count > m * n / 16384:\n            return m * n / 16384\n        if infected_count > m * n / 32768:\n            return m * n / 32768\n        if infected_count > m * n / 65536:\n            return m * n / 65536\n        if infected_count > m * n / 131072:\n            return m * n / 131072\n        if infected_count > m * n / 262144:\n            return m * n / 262144\n        if infected_count > m * n / 524288:\n            return m * n / 524288\n        if infected_count > m * n / 1048576:\n            return m * n / 1048576\n        if infected_count > m * n / 2097152:\n            return m * n / 2097152\n        if infected_count > m * n / 4194304:\n            return m * n / 4194304\n        if infected_count > m * n / 8388608:\n            return m * n / 8388608\n        if infected_count > m * n / 16777216:\n            return m * n / 16777216\n        if infected_count > m * n / 33554432:\n            return m * n / 33554432\n        if infected_count > m * n / 67108864:\n            return m * n / 67108864\n        if infected_count > m * n / 134217728:\n            return m * n / 134217728\n        if infected_count > m * n / 268435456:\n            return m * n / 268435456\n        if infected_count > m * n / 536"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        if i > 0 and matrix[i][j] < matrix[i - 1][j]:\n            max_len = max(max_len, 1 + self.dfs(matrix, dp, i - 1, j))\n        if i < m - 1 and matrix[i][j] < matrix[i + 1][j]:\n            max_len = max(max_len, 1 + self.dfs(matrix, dp, i + 1, j))\n        if j > 0 and matrix[i][j] < matrix[i][j - 1]:\n            max_len = max(max_len, 1 + self.dfs(matrix, dp, i, j - 1))\n        if j < n - 1 and matrix[i][j] < matrix[i][j + 1]:\n            max_len = max(max_len, 1 + self.dfs(matrix, dp, i, j + 1))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a set of all the words in the wordDict\n        wordSet = set(wordDict)\n        \n        # create a dictionary to store the results\n        dp = {}\n        \n        # create a list to store the results\n        res = []\n        \n        # create a recursive function to find the words in the string\n        def findWords(s, wordSet, dp):\n            # if the string is empty, return an empty list\n            if not s:\n                return []\n            \n            # if the string is in the dictionary, return an empty list\n            if s in wordSet:\n                return [s]\n            \n            # if the string is not in the dictionary, return an empty list\n            if s not in dp:\n                dp[s] = []\n                for word in wordSet:\n                    if s.startswith(word):\n                        dp[s].extend(findWords(s[len(word):], wordSet, dp))\n                dp[s] = [s] + [word + \" \" + wordBreak for word in dp[s] if word]\n            return dp[s]\n        \n        # find the words in the string\n        res.extend(findWords(s, wordSet, dp))\n        \n        # return the list of words\n        return res"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        left_to_right = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(level)\n            left_to_right = not left_to_right\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if turnedOn > 10:\n            return []\n        \n        if turnedOn == 0:\n            return [\"0:00\"]\n        \n        if turnedOn == 1:\n            return [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"0:64\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n        \n        if turnedOn == 2:\n            return [\"0:03\",\"0:05\",\"0:06\",\"0:09\",\"0:15\",\"0:30\",\"0:60\",\"1:01\",\"1:02\",\"1:04\",\"1:08\",\"1:16\",\"1:32\",\"1:64\",\"2:01\",\"2:02\",\"2:04\",\"2:08\",\"2:16\",\"2:32\",\"2:64\",\"3:01\",\"3:02\",\"3:04\",\"3:08\",\"3:16\",\"3:32\",\"3:64\",\"4:01\",\"4:02\",\"4:04\",\"4:08\",\"4:16\",\"4:32\",\"4:64\",\"5:01\",\"5:02\",\"5:04\",\"5:08\",\"5:16\",\"5:32\",\"5:64\",\"6:01\",\"6:02\",\"6:04\",\"6:08\",\"6:16\",\"6:32\",\"6:64\",\"7:01\",\"7:02\",\"7:04\",\"7:08\",\"7:16\",\"7:32\",\"7:64\",\"8:01\",\"8:02\",\"8:04\",\"8:08\",\"8:16\",\"8:32\",\"8:64\",\"9:01\",\"9:02\",\"9:04\",\"9:08\",\"9:16\",\"9:32\",\"9:64\",\"10:01\",\"10:02\",\"10:04\",\"10:08\",\"10:16\",\"10:32\",\"10:64\",\"11:01\",\"11:02\",\"11:04\",\"11:08\",\"11:16\",\"11:32\",\"11:64\",\"12:01\",\"12:02\",\"12:04\",\"12:08\",\"12:16\",\"12:32\",\"12:64\",\"13:01\",\"13:02\",\"13:04\",\"13:08\",\"13:16\",\"13:32\",\"13:64\",\"14:01\",\"14:02\",\"14:04\",\"14:08\",\"14:16\",\"14:32\",\"14:64\",\"15:01\",\"15:02\",\"15:04\",\"15:08\",\"15:16\",\"15:32\",\"15:64\",\"16:01\",\"16:02\",\"16:04\",\"16:08\",\"16:16\",\"16:32\",\"16:64\",\"17:01\",\"17:02\",\"17:04\",\"17:08\",\"17:16\",\"17:32\",\"17:64\",\"18:01\",\"18:02\",\"18:04\",\"18:08\",\"18:16\",\"18:32\",\"18:64\",\"19:01\",\"19:02\",\"19:04\",\"19:08\",\"19:16\",\"19:32\",\"19:64\",\"20:01\",\"20:02\",\"20:04\",\"20:08\",\"20:16\",\"20:32\",\"20:64\",\"21:01\",\"21:02\",\"21:04\",\"21:08\",\"21:16\",\"21:32\",\"21:64\",\"22:01\",\"22:02\",\"22:04\",\"22:08\",\"22:16\",\"22:32\",\"22:64\",\"23:01\",\"23:02\",\"23"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(res[i-1][j-1] + res[i-1][j])\n            row.append(1)\n            res.append(row)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        self.max_sum = float('-inf')\n        def dfs(node):\n            if not node:\n                return 0\n            left = max(dfs(node.left), 0)\n            right = max(dfs(node.right), 0)\n            self.max_sum = max(self.max_sum, left + right + node.val)\n            return max(left, right) + node.val\n        \n        dfs(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[0][0], 0, 0)]\n        visited = set((0, 0))\n        max_height = heightMap[0][0]\n        for i in range(1, m):\n            heapq.heappush(heap, (heightMap[i][0], i, 0))\n            max_height = max(max_height, heightMap[i][0])\n        for j in range(1, n):\n            heapq.heappush(heap, (heightMap[0][j], 0, j))\n            max_height = max(max_height, heightMap[0][j])\n        \n        ans = 0\n        while heap:\n            height, i, j = heapq.heappop(heap)\n            if i > 0 and (i, j) not in visited:\n                ans += max_height - height\n                visited.add((i, j))\n                heapq.heappush(heap, (heightMap[i][j], i, j))\n            if i < m - 1 and (i + 1, j) not in visited:\n                ans += max_height - height\n                visited.add((i + 1, j))\n                heapq.heappush(heap, (heightMap[i + 1][j], i + 1, j))\n            if j > 0 and (i, j - 1) not in visited:\n                ans += max_height - height\n                visited.add((i, j - 1))\n                heapq.heappush(heap, (heightMap[i][j - 1], i, j - 1))\n            if j < n - 1 and (i, j + 1) not in visited:\n                ans += max_height - height\n                visited.add((i, j + 1))\n                heapq.heappush(heap, (heightMap[i][j + 1], i, j + 1))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is empty\n        if not s:\n            return True\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # if k is odd, then the median is the middle value\n        if k % 2 == 1:\n            return [nums[k//2]]\n        \n        # if k is even, then the median is the mean of the two middle values\n        else:\n            return [(nums[k//2] + nums[k//2 - 1])/2.0]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        # find the length of the list\n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        # find the new head\n        new_head = head\n        for i in range(length - k % length - 1):\n            new_head = new_head.next\n        \n        # find the new tail\n        new_tail = new_head\n        curr = new_head\n        while curr.next:\n            curr = curr.next\n            new_tail = new_tail.next\n        \n        # connect the new tail to the new head\n        new_tail.next = head\n        \n        # cut the list\n        new_head = new_head.next\n        new_tail.next = None\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n == 1:\n            return True\n        \n        if n % 2 == 0:\n            return self.isUgly(n // 2)\n        \n        if n % 3 == 0:\n            return self.isUgly(n // 3)\n        \n        if n % 5 == 0:\n            return self.isUgly(n // 5)\n        \n        return False"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        if not matrix or not matrix[0]:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        max_sum = float('-inf')\n        prefix_sum = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0:\n                    prefix_sum[i][j] = matrix[i][j]\n                else:\n                    prefix_sum[i][j] = prefix_sum[i - 1][j] + matrix[i][j]\n        \n        for i in range(n):\n            for j in range(i, n):\n                prefix_sum_j = [0] * m\n                for l in range(m):\n                    if i == 0:\n                        prefix_sum_j[l] = prefix_sum[l][j]\n                    else:\n                        prefix_sum_j[l] = prefix_sum[l][j] - prefix_sum[l][i - 1]\n                \n                prefix_sum_j = [0] + prefix_sum_j\n                prefix_sum_j = [0] * (m + 1)\n                prefix_sum_j = [0] + prefix_sum_j\n                \n                max_sum_j = float('-inf')\n                prefix_sum_j_sum = 0\n                for k in range(m + 1):\n                    prefix_sum_j_sum += prefix_sum_j[k]\n                    if prefix_sum_j_sum > max_sum_j:\n                        max_sum_j = prefix_sum_j_sum\n                    if prefix_sum_j_sum > k:\n                        prefix_sum_j_sum = prefix_sum_j_sum - k\n                    else:\n                        prefix_sum_j_sum = 0\n                \n                max_sum = max(max_sum, max_sum_j)\n        \n        return max_sum if max_sum <= k else max_sum_j"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == 2147483647:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 2147483647:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483647:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483647:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483647:\n            return -1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -2147483648:\n            return 1\n        \n        if dividend == 2147483647 and divisor == -2147483648:\n            return -1\n        \n        if dividend == -2147483648 and divisor == -214"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                elif board[i][j] == 'O':\n                    board[i][j] = 'X'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # key: number, value: index\n        nums_dict = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            # if the number is in the dictionary, return the index and the index of the number\n            if target - num in nums_dict:\n                return [nums_dict[target - num], i]\n            # if the number is not in the dictionary, add it to the dictionary\n            else:\n                nums_dict[num] = i"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(cards) == 1:\n            return abs(cards[0] - 24) < 1e-6\n        \n        if len(cards) == 2:\n            return abs(cards[0] * 4 - cards[1] * 3) < 1e-6\n        \n        if len(cards) == 3:\n            return abs(cards[0] * 3 - cards[1] * 2) < 1e-6\n        \n        if len(cards) == 4:\n            return abs(cards[0] * 2 - cards[1] * 1) < 1e-6\n        \n        if len(cards) == 5:\n            return abs(cards[0] * 1 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 6:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 7:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 8:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 9:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 10:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 11:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 12:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 13:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 14:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 15:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 16:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 17:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 18:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 19:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 20:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 21:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 22:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 23:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 24:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 25:\n            return abs(cards[0] * 0 - cards[1] * 0) < 1e-6\n        \n        if len(cards) == 26:\n            return abs"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p.replace('*', ''):\n            return not s\n        \n        star = p.find('*')\n        if star == -1:\n            return False\n        \n        if p[star + 1] == '*':\n            return True\n        \n        if p[star - 1] != s[0] and p[star - 1] != '?':\n            return False\n        \n        if p[star + 1] != s[1] and p[star + 1] != '*':\n            return False\n        \n        if p[star - 1] == '*':\n            return self.isMatch(s[1:], p[star + 1:])\n        \n        if p[star - 1] == '?' or p[star - 1] == s[0]:\n            return self.isMatch(s[1:], p[star + 1:])\n        \n        return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-of-size-n-time-less-than-n-2/\n        # https://www.geeksforgeeks.org/majority-element-in-a-sorted-array-"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in sorted(tickets)[::-1]:\n            graph[from_city].append(to_city)\n        \n        # dfs\n        ans = []\n        def dfs(node):\n            # if there is no more edges, add the node to the answer\n            if len(graph[node]) == 0:\n                ans.append(node)\n                return\n            # otherwise, add the next edge to the answer\n            for next_node in graph[node]:\n                dfs(next_node)\n        \n        dfs(\"JFK\")\n        return ans[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = []\n        for i in range(n-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] > target:\n                break\n            if nums[i] + nums[n-1] + nums[n-2] + nums[n-3] < target:\n                continue\n            if nums[i] + nums[n-1] + nums[n-2] + nums[n-3] == target:\n                res.append([nums[i], nums[n-1], nums[n-2], nums[n-3]])\n                break\n            if nums[i] + nums[n-1] + nums[n-2] + nums[n-3] == target:\n                res.append([nums[i], nums[n-1], nums[n-2], nums[n-3]])\n                break\n            l = i + 1\n            r = n - 1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] + nums[r-1] > target:\n                    r -= 1\n                elif nums[i] + nums[l] + nums[r] + nums[r-1] < target:\n                    l += 1\n                else:\n                    if nums[l] + nums[r] + nums[r-1] == target:\n                        res.append([nums[i], nums[l], nums[r], nums[r-1]])\n                        break\n                    r -= 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize heap with first building\n        heap = [(-buildings[0][2], buildings[0][1])]\n        \n        # initialize result\n        result = [[0, 0]]\n        \n        # initialize current height\n        curr_height = -heap[0][0]\n        \n        # initialize current edge\n        curr_edge = buildings[0][0]\n        \n        # iterate over buildings\n        for b in buildings[1:]:\n            # if building is right edge\n            if b[0] > curr_edge:\n                # add current height to result\n                result.append([curr_edge, curr_height])\n                # update current edge\n                curr_edge = b[0]\n                # update current height\n                curr_height = -b[2]\n            # if building is left edge\n            else:\n                # if building is taller than current height\n                if b[2] > curr_height:\n                    # update current height\n                    curr_height = b[2]\n                # if building is shorter than current height\n                else:\n                    # remove current height from heap\n                    heapq.heappop(heap)\n                    # if heap is empty\n                    if not heap:\n                        # add current height to result\n                        result.append([curr_edge, curr_height])\n                        # update current edge\n                        curr_edge = b[0]\n                        # update current height\n                        curr_height = -b[2]\n                    # if heap is not empty\n                    else:\n                        # update current edge\n                        curr_edge = heap[0][1]\n                        # update current height\n                        curr_height = -heap[0][0]\n        \n        # add last building to result\n        result.append([curr_edge, curr_height])\n        \n        # return result\n        return result"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # if len(triangle) == 1:\n        #     return triangle[0][0]\n        \n        # if len(triangle) == 2:\n        #     return triangle[0][0] + triangle[1][0]\n        \n        # if len(triangle) == 3:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1])\n        \n        # if len(triangle) == 4:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1])\n        \n        # if len(triangle) == 5:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1]) + min(triangle[3][0], triangle[3][1])\n        \n        # if len(triangle) == 6:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1]) + min(triangle[3][0], triangle[3][1]) + min(triangle[4][0], triangle[4][1])\n        \n        # if len(triangle) == 7:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1]) + min(triangle[3][0], triangle[3][1]) + min(triangle[4][0], triangle[4][1]) + min(triangle[5][0], triangle[5][1])\n        \n        # if len(triangle) == 8:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1]) + min(triangle[3][0], triangle[3][1]) + min(triangle[4][0], triangle[4][1]) + min(triangle[5][0], triangle[5][1]) + min(triangle[6][0], triangle[6][1])\n        \n        # if len(triangle) == 9:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1]) + min(triangle[3][0], triangle[3][1]) + min(triangle[4][0], triangle[4][1]) + min(triangle[5][0], triangle[5][1]) + min(triangle[6][0], triangle[6][1]) + min(triangle[7][0], triangle[7][1])\n        \n        # if len(triangle) == 10:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1]) + min(triangle[3][0], triangle[3][1]) + min(triangle[4][0], triangle[4][1]) + min(triangle[5][0], triangle[5][1]) + min(triangle[6][0], triangle[6][1]) + min(triangle[7][0], triangle[7][1]) + min(triangle[8][0], triangle[8][1])\n        \n        # if len(triangle) == 11:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1]) + min(triangle[3][0], triangle[3][1]) + min(triangle[4][0], triangle[4][1]) + min(triangle[5][0], triangle[5][1]) + min(triangle[6][0], triangle[6][1]) + min(triangle[7][0], triangle[7][1]) + min(triangle[8][0], triangle[8][1]) + min(triangle[9][0], triangle[9][1])\n        \n        # if len(triangle) == 12:\n        #     return triangle[0][0] + min(triangle[1][0], triangle[1][1]) + min(triangle[2][0], triangle[2][1]) + min(triangle[3][0], triangle[3][1]) + min(triangle[4][0],"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        # 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # if k > n * (n - 1) / 2:\n        #     return 0\n        # if k == 0:\n        #     return 1\n        # if k == 1:\n        #     return n - 1\n        # if k == 2:\n        #     return n * (n - 1) // 2\n        # if k == 3:\n        #     return n * (n - 1) * (n - 2) // 8\n        # if k == 4:\n        #     return n * (n - 1) * (n - 2) * (n - 3) // 24\n        # if k == 5:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) // 120\n        # if k == 6:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) // 720\n        # if k == 7:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) // 5040\n        # if k == 8:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) // 40320\n        # if k == 9:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) // 362880\n        # if k == 10:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) // 3628800\n        # if k == 11:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) // 39916800\n        # if k == 12:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) * (n - 11) // 479001600\n        # if k == 13:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) * (n - 11) * (n - 12) // 6227020800\n        # if k == 14:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) * (n - 11) * (n - 12) * (n - 13) // 87178291200\n        # if k == 15:\n        #     return n * (n - 1) * (n - 2) * (n - 3) * ("}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        \n        while prev.next and prev.next.next:\n            first = prev.next\n            second = first.next\n            \n            prev.next = second\n            first.next = second.next\n            second.next = first\n            \n            prev = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to p1\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to p2\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # set the next node of p1 to the next node of p2\n        p1.next = dummy2.next\n        # set the next node of p2 to None\n        p2.next = None\n        \n        # return the next node of dummy1\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent1 = None\n        parent2 = None\n        for edge in edges:\n            if parent1 is None and edge[1] != 0:\n                parent1 = edge[1]\n            elif parent2 is None and edge[1] != 0:\n                parent2 = edge[1]\n            elif parent1 is not None and edge[1] != 0:\n                parent2 = edge[1]\n        \n        # find the node with only one parent\n        if parent1 is None:\n            parent1 = parent2\n            parent2 = None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            parent2 = parent1\n            parent1 = None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent2 is None:\n            return None\n        \n        # find the node with only one parent\n        if parent1 is None:\n            return None\n        \n        # find the node with only one parent\n        if"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        used = [False] * len(nums)\n        self.dfs(nums, [], res, used)\n        return res\n    \n    def dfs(self, nums, path, res, used):\n        if len(path) == len(nums):\n            res.append(path[:])\n            return\n        \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                continue\n            if not used[i]:\n                used[i] = True\n                path.append(nums[i])\n                self.dfs(nums, path, res, used)\n                path.pop()\n                used[i] = False"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## XOR\n        ## 0 ^ 0 = 0\n        ## 0 ^ 1 = 1\n        ## 1 ^ 0 = 1\n        ## 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 = 0\n        ## 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 = 1\n        ## 1 ^ 0 ^ 0 = 1\n        ## 0 ^ 1 ^ 1 ^ 1 = 0\n        ## 1 ^ 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 = 0\n        ## 1 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 ^ 0 = 0\n        ## 1 ^ 0 ^ 1 ^ 0 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 = 0\n        ## 1 ^ 0 ^ 0 ^ 0 = 0\n        ## 0 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        ## 1 ^ 0 ^ 1 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 = 0\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 ^ 0 ^ 1 = 0\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 1 = 0\n        ## 1 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 ^ 1 ^ 0 = 0\n        ## 1 ^ 0 ^ 1 ^ 1 ^ 0 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 0 = 0\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 = 0\n        ## 0 ^ 1 ^ 1 ^ 0 ^ 0 = 0\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 = 0\n        ## 1 ^ 0 ^ 0 ^ 0 ^ 0 = 0\n        ## 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        ## 1 ^ 0 ^ 1 ^ 1 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 1 = 0\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 ^ 0 ^ 1 ^ 1 = 0\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 1 ^ 1 = 0\n        ## 1 ^ 0 ^ 0 ^ 0 ^ 1 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 ^ 1 ^ 0 ^ 1 = 0\n        ## 1 ^ 0 ^ 1 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 0 ^ 1 = 0\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 ^ 0 ^ 0 ^ 1 = 0\n        ## 1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 0\n        ## 0 ^ 1 ^ 1 ^ 1 ^ 1 ^ 0 = 0\n        ## 1 ^ 0 ^ 1 ^ 1 ^ 1 ^ 0 = 0\n        ## 0 ^ 1 ^ 0 ^ 1 ^ 1 ^ 0 = 0\n        ## 1 ^ 0 ^ 0 ^ 1 ^ 1 ^ 0 = 0\n        #"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 0:\n            return 0\n        \n        if n == 1:\n            return grid[0][0]\n        \n        if n == 2:\n            return max(grid[0][0], grid[1][1]) + max(grid[1][0], grid[0][1])\n        \n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        dp[n - 1][n - 1] = grid[n - 1][n - 1]\n        \n        for i in range(1, n):\n            dp[i][i] = grid[i][i]\n            dp[i][n - 1] = max(dp[i][n - 1], dp[i - 1][n - 1])\n            dp[n - 1][i] = max(dp[n - 1][i], dp[n - 2][i])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][0] = max(dp[i][0], dp[i + 1][0])\n            dp[n - 1][i] = max(dp[n - 1][i], dp[n - 2][i])\n        \n        for i in range(1, n):\n            dp[i][i] = max(dp[i][i], dp[i - 1][i - 1])\n            dp[i][n - 1] = max(dp[i][n - 1], dp[i - 1][n - 1])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][0] = max(dp[i][0], dp[i + 1][0])\n            dp[n - 1][i] = max(dp[n - 1][i], dp[n - 2][i])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][i] = max(dp[i][i], dp[i + 1][i + 1])\n            dp[i][n - 1] = max(dp[i][n - 1], dp[i + 1][n - 1])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][0] = max(dp[i][0], dp[i + 1][0])\n            dp[n - 1][i] = max(dp[n - 1][i], dp[n - 2][i])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][i] = max(dp[i][i], dp[i + 1][i + 1])\n            dp[i][n - 1] = max(dp[i][n - 1], dp[i + 1][n - 1])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][0] = max(dp[i][0], dp[i + 1][0])\n            dp[n - 1][i] = max(dp[n - 1][i], dp[n - 2][i])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][i] = max(dp[i][i], dp[i + 1][i + 1])\n            dp[i][n - 1] = max(dp[i][n - 1], dp[i + 1][n - 1])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][0] = max(dp[i][0], dp[i + 1][0])\n            dp[n - 1][i] = max(dp[n - 1][i], dp[n - 2][i])\n        \n        for i in range(n - 2, -1, -1):\n            dp[i][i] = max(dp[i][i], dp[i"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2^n\n        # 2. 2^n * 2^n\n        # 3. 2^n * 2^n * 2^n\n        # 4. 2^n * 2^n * 2^n * 2^n\n        # 5. 2^n * 2^n * 2^n * 2^n * 2^n\n        # 6. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 7. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 8. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 9. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 10. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 11. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 12. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 13. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 14. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 15. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 16. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 17. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 18. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n\n        # 19. 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n * 2^n"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a set to store the number we have seen before\n        # 2. create a variable to store the number we are checking\n        # 3. create a variable to store the number we are squaring\n        # 4. create a variable to store the number we are adding\n        # 5. create a variable to store the number we are dividing by\n        # 6. create a variable to store the number we are modding by\n        # 7. create a variable to store the number we are dividing by\n        # 8. create a variable to store the number we are modding by\n        # 9. create a variable to store the number we are dividing by\n        # 10. create a variable to store the number we are modding by\n        # 11. create a variable to store the number we are dividing by\n        # 12. create a variable to store the number we are modding by\n        # 13. create a variable to store the number we are dividing by\n        # 14. create a variable to store the number we are modding by\n        # 15. create a variable to store the number we are dividing by\n        # 16. create a variable to store the number we are modding by\n        # 17. create a variable to store the number we are dividing by\n        # 18. create a variable to store the number we are modding by\n        # 19. create a variable to store the number we are dividing by\n        # 20. create a variable to store the number we are modding by\n        # 21. create a variable to store the number we are dividing by\n        # 22. create a variable to store the number we are modding by\n        # 23. create a variable to store the number we are dividing by\n        # 24. create a variable to store the number we are modding by\n        # 25. create a variable to store the number we are dividing by\n        # 26. create a variable to store the number we are modding by\n        # 27. create a variable to store the number we are dividing by\n        # 28. create a variable to store the number we are modding by\n        # 29. create a variable to store the number we are dividing by\n        # 30. create a variable to store the number we are modding by\n        # 31. create a variable to store the number we are dividing by\n        # 32. create a variable to store the number we are modding by\n        # 33. create a variable to store the number we are dividing by\n        # 34. create a variable to store the number we are modding by\n        # 35. create a variable to store the number we are dividing by\n        # 36. create a variable to store the number we are modding by\n        # 37. create a variable to store the number we are dividing by\n        # 38. create a variable to store the number we are modding by\n        # 39. create a variable to store the number we are dividing by\n        # 40. create a variable to store the number we are modding by\n        # 41. create a variable to store the number we are dividing by\n        # 42. create a variable to store the number we are modding by\n        # 43. create a variable to store the number we are dividing by\n        # 44. create a variable to store the number we are modding by\n        # 45. create a variable to store the number we are dividing by\n        # 46. create a variable to store the number we are modding by\n        # 47. create a variable to store the number we are dividing by\n        # 48. create a variable to store the number we are modding by\n        # 49. create a variable to store the number we are dividing by\n        # 50. create a variable to store the number we are modding by\n        # 51. create a variable to store the number we are dividing by\n        # 52. create a variable to store the number we are modding by\n        # 53. create a variable to store the number we are dividing by\n        # 54. create a variable to store the number we are modding by\n        # 55. create a variable to store the number"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # left, right = 0, len(nums) - 1\n        # while left <= right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] < target:\n        #         left = mid + 1\n        #     else:\n        #         right = mid - 1\n        # return left\n        \n        # linear search\n        for i, num in enumerate(nums):\n            if num >= target:\n                return i\n        return len(nums)"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # if nums[0] == 0:\n        #     return False\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_jump = nums[0]\n        # for i in range(1, len(nums)):\n        #     if max_jump == 0:\n        #         return False\n        #     max_jump = max(max_jump - 1, nums[i])\n        # return True\n        \n        # if len(nums) == 1:\n        #     return True\n        \n        # max_"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[-1][-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"1113122113311213212313211\"\n        \n        if n == 12:\n            return \"311311222123213222112114121\"\n        \n        if n == 13:\n            return \"132113213211123122113114121\"\n        \n        if n == 14:\n            return \"111312211312124213222112114121\"\n        \n        if n == 15:\n            return \"311311222123213222112114121\"\n        \n        if n == 16:\n            return \"132113213211123122113114121\"\n        \n        if n == 17:\n            return \"111312211312124213222112114121\"\n        \n        if n == 18:\n            return \"311311222123213222112114121\"\n        \n        if n == 19:\n            return \"132113213211123122113114121\"\n        \n        if n == 20:\n            return \"111312211312124213222112114121\"\n        \n        if n == 21:\n            return \"311311222123213222112114121\"\n        \n        if n == 22:\n            return \"132113213211123122113114121\"\n        \n        if n == 23:\n            return \"111312211312124213222112114121\"\n        \n        if n == 24:\n            return \"311311222123213222112114121\"\n        \n        if n == 25:\n            return \"132113213211123122113114121\"\n        \n        if n == 26:\n            return \"111312211312124213222112114121\"\n        \n        if n == 27:\n            return \"311311222123213222112114121\"\n        \n        if n == 28:\n            return \"132113213211123122113114121\"\n        \n        if n == 29:\n            return \"111312211312124213222112114121"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max sum\n        # find the min sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum\n        # binary search the min sum\n        # find the mid sum\n        # binary search the mid sum\n        # find the max sum\n        # binary search the max sum\n        # find the min sum"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target not in nums:\n            return -1\n        \n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] < nums[right]:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        combinations = ['']\n        \n        for digit in digits:\n            new_combinations = []\n            for letter in digit_to_letters[digit]:\n                for combination in combinations:\n                    new_combinations.append(combination + letter)\n            combinations = new_combinations\n        \n        return combinations"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            self.dfs(candidates, target - candidates[i], i, path + [candidates[i]], res)"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of n\n        length = len(n)\n        \n        # 2. get the mid number\n        mid = int(n[:(length+1)//2])\n        \n        # 3. get the left and right number\n        left = mid - 1 if mid % 10 != 0 else mid - 2\n        right = mid + 1 if mid % 10 != 9 else mid + 2\n        \n        # 4. get the left and right palindrome\n        left_palindrome = str(left)\n        right_palindrome = str(right)\n        \n        # 5. get the left and right palindrome\n        left_palindrome = left_palindrome[:(length-1)//2] + left_palindrome[length-1]\n        right_palindrome = right_palindrome[:(length-1)//2] + right_palindrome[length-1]\n        \n        # 6. get the closest palindrome\n        closest_palindrome = min(left_palindrome, right_palindrome, key=lambda x: abs(int(x) - int(n)))\n        \n        # 7. return the closest palindrome\n        return closest_palindrome"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a matrix of size n x n\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # initialize the values of the matrix\n        val = 1\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        # iterate over the matrix\n        while row_start <= row_end and col_start <= col_end:\n            # move right\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = val\n                val += 1\n            row_start += 1\n            \n            # move down\n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = val\n                val += 1\n            col_end -= 1\n            \n            # move left\n            for i in range(col_end, col_start - 1, -1):\n                matrix[row_end][i] = val\n                val += 1\n            row_end -= 1\n            \n            # move up\n            for i in range(row_end, row_start - 1, -1):\n                matrix[i][col_start] = val\n                val += 1\n            col_start += 1\n        \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        if x > 2**31 - 1:\n            return 0\n        if x < -2**31:\n            return 0\n        return x * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        # reverse the matrix\n        for i in range(n//2):\n            matrix[i], matrix[n-i-1] = matrix[n-i-1], matrix[i]\n        \n        # transpose the matrix\n        for i in range(n):\n            for j in range(i+1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # max_prod = nums[0]\n        # curr_prod = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] == 0:\n        #         curr_prod = 1\n        #         max_prod = 0\n        #     else:\n        #         curr_prod = curr_prod * nums[i]\n        #         max_prod = max(max_prod, curr_prod)\n        # return max_prod\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # max_prod = nums[0]\n        # curr_prod = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] == 0:\n        #         curr_prod = 1\n        #         max_prod = 0\n        #     else:\n        #         curr_prod = curr_prod * nums[i]\n        #         max_prod = max(max_prod, curr_prod)\n        # return max_prod\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # max_prod = nums[0]\n        # curr_prod = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] == 0:\n        #         curr_prod = 1\n        #         max_prod = 0\n        #     else:\n        #         curr_prod = curr_prod * nums[i]\n        #         max_prod = max(max_prod, curr_prod)\n        # return max_prod\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # max_prod = nums[0]\n        # curr_prod = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] == 0:\n        #         curr_prod = 1\n        #         max_prod = 0\n        #     else:\n        #         curr_prod = curr_prod * nums[i]\n        #         max_prod = max(max_prod, curr_prod)\n        # return max_prod\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # max_prod = nums[0]\n        # curr_prod = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] == 0:\n        #         curr_prod = 1\n        #         max_prod = 0\n        #     else:\n        #         curr_prod = curr_prod * nums[i]\n        #         max_prod = max(max_prod, curr_prod)\n        # return max_prod\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # max_prod = nums[0]\n        # curr_prod = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] == 0:\n        #         curr_prod = 1\n        #         max_prod = 0\n        #     else:\n        #         curr_prod = curr_prod * nums[i]\n        #         max_prod = max(max_prod, curr_prod)\n        # return max_prod\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # max_prod = nums[0]\n        # curr_prod = nums[0]\n        \n        # for i in range(1, len(nums)):\n        #     if nums[i] == 0:\n        #         curr_prod = 1\n        #         max_prod = 0\n        #     else:\n        #         curr_prod"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        stone_set = set(stones)\n        stone_set.add(stones[-1])\n        \n        if stones[-1] not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1])\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 1)\n        \n        if stones[-1] + 1 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 1)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 2)\n        \n        if stones[-1] + 2 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 2)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 3)\n        \n        if stones[-1] + 3 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 3)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 4)\n        \n        if stones[-1] + 4 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 4)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 5)\n        \n        if stones[-1] + 5 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 5)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 6)\n        \n        if stones[-1] + 6 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 6)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 7)\n        \n        if stones[-1] + 7 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 7)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 8)\n        \n        if stones[-1] + 8 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 8)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 9)\n        \n        if stones[-1] + 9 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 9)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 10)\n        \n        if stones[-1] + 10 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 10)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 11)\n        \n        if stones[-1] + 11 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 11)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 12)\n        \n        if stones[-1] + 12 not in stone_set:\n            return False\n        \n        stone_set.remove(stones[-1] + 12)\n        \n        if len(stone_set) == 1:\n            return True\n        \n        stone_set.add(stones[-1] + 13)"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score = sorted(score, reverse=True)\n        \n        # create a dictionary to store the index of each score\n        score_dict = {score[i]: i for i in range(len(score))}\n        \n        # create a list to store the rank of each score\n        rank = []\n        \n        # iterate over the score in descending order\n        for i in score:\n            # if the score is the 1st place, add \"Gold Medal\" to the rank list\n            if i == score[0]:\n                rank.append(\"Gold Medal\")\n            # if the score is the 2nd place, add \"Silver Medal\" to the rank list\n            elif i == score[1]:\n                rank.append(\"Silver Medal\")\n            # if the score is the 3rd place, add \"Bronze Medal\" to the rank list\n            elif i == score[2]:\n                rank.append(\"Bronze Medal\")\n            # if the score is the 4th place, add the index of the score to the rank list\n            else:\n                rank.append(str(score_dict[i]))\n        \n        # return the rank list\n        return rank"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if len(s) == 0:\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        \n        # max_len = 0\n        # cur_len = 0\n        # seen = set()\n        # for i in range(len(s)):\n        #     if s[i] not in seen:\n        #         cur_len += 1\n        #         seen.add(s[i])\n        #     else:\n        #         max_len = max(max_len, cur_len)\n        #         cur_len = i - seen.index(s[i])\n        #         seen = seen.difference({s[i]})\n        #         seen.add(s[i])\n        #     max_len = max(max_len, cur_len)\n        # return max_len\n        \n        # if len(s) == 0:\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        \n        # max_len = 0\n        # cur_len = 0\n        # seen = set()\n        # for i in range(len(s)):\n        #     if s[i] not in seen:\n        #         cur_len += 1\n        #         seen.add(s[i])\n        #     else:\n        #         max_len = max(max_len, cur_len)\n        #         cur_len = i - seen.index(s[i])\n        #         seen = seen.difference({s[i]})\n        #         seen.add(s[i])\n        #     max_len = max(max_len, cur_len)\n        # return max_len\n        \n        # if len(s) == 0:\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        \n        # max_len = 0\n        # cur_len = 0\n        # seen = set()\n        # for i in range(len(s)):\n        #     if s[i] not in seen:\n        #         cur_len += 1\n        #         seen.add(s[i])\n        #     else:\n        #         max_len = max(max_len, cur_len)\n        #         cur_len = i - seen.index(s[i])\n        #         seen = seen.difference({s[i]})\n        #         seen.add(s[i])\n        #     max_len = max(max_len, cur_len)\n        # return max_len\n        \n        # if len(s) == 0:\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        \n        # max_len = 0\n        # cur_len = 0\n        # seen = set()\n        # for i in range(len(s)):\n        #     if s[i] not in seen:\n        #         cur_len += 1\n        #         seen.add(s[i])\n        #     else:\n        #         max_len = max(max_len, cur_len)\n        #         cur_len = i - seen.index(s[i])\n        #         seen = seen.difference({s[i]})\n        #         seen.add(s[i])\n        #     max_len = max(max_len, cur_len)\n        # return max_len\n        \n        # if len(s) == 0:\n        #     return 0\n        # if len(s) == 1:\n        #     return 1\n        \n        # max_len = 0\n        # cur_len = 0\n        # seen = set()\n        # for i in range(len(s)):\n        #     if s[i] not in seen:\n        #         cur_len += 1\n        #         seen.add(s[i])\n        #     else:\n        #         max_len = max(max_len, cur_len)\n        #         cur_len = i - seen.index(s[i])\n        #         seen = seen.difference({s[i]})\n        #         seen.add(s[i])\n        #     max_len = max(max_len, cur_len)\n        # return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        s_len = len(s)\n        if s_len < word_len * word_count:\n            return []\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_pow = word_len ** word_count\n        word_dict_len_pow_str = str(word_dict_len_pow)\n        \n        s_len_pow = s_len ** word_count\n        s_len_pow_str = str(s_len_pow)\n        \n        s_len_pow_str_len = len(s_len_pow_str)\n        s_len_pow_str_len_str = str(s_len_pow_str_len)\n        \n        s_len_pow_str_len_str_len = len(s_len_pow_str_len_str)\n        \n        s_len_pow_str_len_str_len_str = str(s_len_pow_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len = len(s_len_pow_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str = str(s_len_pow_str_len_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str_len = len(s_len_pow_str_len_str_len_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str_len_str = str(s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str_len_str_len = len(s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str_len_str_len_str = str(s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len = len(s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str = str(s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str)\n        \n        s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str_len = len(s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str = str(s_len_pow_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len_str_len)\n        \n        s_len_pow_str_len_str_len_str_len_str_len"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        arr.sort()\n        \n        # find the max\n        max_num = arr[0]\n        max_num_idx = 0\n        for i in range(1, len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n                max_num_idx = i\n        \n        # find the min\n        min_num = arr[max_num_idx]\n        min_num_idx = max_num_idx\n        for i in range(max_num_idx, len(arr)):\n            if arr[i] < min_num:\n                min_num = arr[i]\n                min_num_idx = i\n        \n        # find the max\n        max_num = arr[min_num_idx]\n        max_num_idx = min_num_idx\n        for i in range(min_num_idx, len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n                max_num_idx = i\n        \n        # find the min\n        min_num = arr[max_num_idx]\n        min_num_idx = max_num_idx\n        for i in range(max_num_idx, len(arr)):\n            if arr[i] < min_num:\n                min_num = arr[i]\n                min_num_idx = i\n        \n        # find the max\n        max_num = arr[min_num_idx]\n        max_num_idx = min_num_idx\n        for i in range(min_num_idx, len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n                max_num_idx = i\n        \n        # find the min\n        min_num = arr[max_num_idx]\n        min_num_idx = max_num_idx\n        for i in range(max_num_idx, len(arr)):\n            if arr[i] < min_num:\n                min_num = arr[i]\n                min_num_idx = i\n        \n        # find the max\n        max_num = arr[min_num_idx]\n        max_num_idx = min_num_idx\n        for i in range(min_num_idx, len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n                max_num_idx = i\n        \n        # find the min\n        min_num = arr[max_num_idx]\n        min_num_idx = max_num_idx\n        for i in range(max_num_idx, len(arr)):\n            if arr[i] < min_num:\n                min_num = arr[i]\n                min_num_idx = i\n        \n        # find the max\n        max_num = arr[min_num_idx]\n        max_num_idx = min_num_idx\n        for i in range(min_num_idx, len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n                max_num_idx = i\n        \n        # find the min\n        min_num = arr[max_num_idx]\n        min_num_idx = max_num_idx\n        for i in range(max_num_idx, len(arr)):\n            if arr[i] < min_num:\n                min_num = arr[i]\n                min_num_idx = i\n        \n        # find the max\n        max_num = arr[min_num_idx]\n        max_num_idx = min_num_idx\n        for i in range(min_num_idx, len(arr)):\n            if arr[i] > max_num:\n                max_num = arr[i]\n                max_num_idx = i\n        \n        # find the min\n        min_num = arr[max_num_idx]\n        min_num_idx = max_num_idx\n        for i in range(max_num_idx, len(arr)):\n            if arr[i] < min_num:\n                min_num = arr[i]\n                min_num_idx = i\n        \n        # find the max\n        max_num = arr[min"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr:\n            if curr.val < dummy.next.val:\n                dummy.next = curr\n                curr = curr.next\n                dummy.next.next = None\n            else:\n                prev = dummy\n                while prev.next and prev.next.val < curr.val:\n                    prev = prev.next\n                curr.next, prev.next, curr = prev.next, curr, curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0, head)\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                if nums[i] + nums[l] + nums[r] > 0:\n                    r -= 1\n                elif nums[i] + nums[l] + nums[r] < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # if word1 is empty, then we need to insert all the characters of word2\n        if len(word1) == 0:\n            return len(word2)\n        \n        # if word2 is empty, then we need to delete all the characters of word1\n        if len(word2) == 0:\n            return len(word1)\n        \n        # create a 2D array of size (len(word1) + 1) x (len(word2) + 1)\n        dp = [[0 for _ in range(len(word2) + 1)] for _ in range(len(word1) + 1)]\n        \n        # fill the first row with the index of word2\n        for i in range(len(word2) + 1):\n            dp[0][i] = i\n        \n        # fill the first column with the index of word1\n        for i in range(len(word1) + 1):\n            dp[i][0] = i\n        \n        # fill the rest of the array\n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                # if the characters at word1[i - 1] and word2[j - 1] are the same, then we don'\n                #t need to do anything\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    # otherwise, we need to do one of the following:\n                    # 1. insert the character at word1[i - 1]\n                    # 2. delete the character at word2[j - 1]\n                    # 3. replace the character at word1[i - 1] with word2[j - 1]\n                    dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j])\n        \n        # return the last element of the last row\n        return dp[-1][-1]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. merge sort\n        # 3. binary search\n        # 4. binary search\n        # 5. binary search\n        # 6. binary search\n        # 7. binary search\n        # 8. binary search\n        # 9. binary search\n        # 10. binary search\n        # 11. binary search\n        # 12. binary search\n        # 13. binary search\n        # 14. binary search\n        # 15. binary search\n        # 16. binary search\n        # 17. binary search\n        # 18. binary search\n        # 19. binary search\n        # 20. binary search\n        # 21. binary search\n        # 22. binary search\n        # 23. binary search\n        # 24. binary search\n        # 25. binary search\n        # 26. binary search\n        # 27. binary search\n        # 28. binary search\n        # 29. binary search\n        # 30. binary search\n        # 31. binary search\n        # 32. binary search\n        # 33. binary search\n        # 34. binary search\n        # 35. binary search\n        # 36. binary search\n        # 37. binary search\n        # 38. binary search\n        # 39. binary search\n        # 40. binary search\n        # 41. binary search\n        # 42. binary search\n        # 43. binary search\n        # 44. binary search\n        # 45. binary search\n        # 46. binary search\n        # 47. binary search\n        # 48. binary search\n        # 49. binary search\n        # 50. binary search\n        # 51. binary search\n        # 52. binary search\n        # 53. binary search\n        # 54. binary search\n        # 55. binary search\n        # 56. binary search\n        # 57. binary search\n        # 58. binary search\n        # 59. binary search\n        # 60. binary search\n        # 61. binary search\n        # 62. binary search\n        # 63. binary search\n        # 64. binary search\n        # 65. binary search\n        # 66. binary search\n        # 67. binary search\n        # 68. binary search\n        # 69. binary search\n        # 70. binary search\n        # 71. binary search\n        # 72. binary search\n        # 73. binary search\n        # 74. binary search\n        # 75. binary search\n        # 76. binary search\n        # 77. binary search\n        # 78. binary search\n        # 79. binary search\n        # 80. binary search\n        # 81. binary search\n        # 82. binary search\n        # 83. binary search\n        # 84. binary search\n        # 85. binary search\n        # 86. binary search\n        # 87. binary search\n        # 88. binary search\n        # 89. binary search\n        # 90. binary search\n        # 91. binary search\n        # 92. binary search\n        # 93. binary search\n        # 94. binary search\n        # 95. binary search\n        # 96. binary search\n        # 97. binary search\n        # 98. binary search\n        # 99. binary search\n        # 100. binary search\n        # 101. binary search\n        # 102. binary search\n        # 103. binary search\n        # 104. binary search\n        # 105. binary search\n        # 106. binary search\n        # 107. binary search\n        # 108. binary search\n        # 109. binary search\n        # 110. binary search\n        # 111. binary search\n        # 112. binary search\n        # 113. binary search"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        if len(v1) > len(v2):\n            v2.extend(['0'] * (len(v1) - len(v2)))\n        elif len(v1) < len(v2):\n            v1.extend(['0'] * (len(v2) - len(v1)))\n        \n        for i in range(len(v1)):\n            if int(v1[i]) > int(v2[i]):\n                return 1\n            elif int(v1[i]) < int(v2[i]):\n                return -1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the min price\n        min_price = prices[0]\n        ## 2. find the max profit\n        max_profit = 0\n        ## 3. iterate over the prices\n        for price in prices:\n            ## 4. if the price is less than the min price, update the min price\n            if price < min_price:\n                min_price = price\n            ## 5. if the price is greater than the max profit, update the max profit\n            elif price - min_price > max_profit:\n                max_profit = price - min_price\n        ## 6. return the max profit\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # max heap\n        heap = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for duration, end in courses:\n            # add course to heap\n            heapq.heappush(heap, (-duration, end))\n            \n            # if total time + duration > end date\n            if total + duration > end:\n                # pop from heap\n                total -= heapq.heappop(heap)[0]\n                \n            # update total time\n            total += duration\n            \n        # return length of heap\n        return len(heap)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, end):\n        curr = end\n        prev.next = None\n        while curr:\n            next = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = next\n        return end"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] != s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] == s[1] and s[0] * 2 != s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] != s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] == s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] != s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] != s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] != s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] != s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] == s[1] and s[0] * 2 == s:\n            return True\n        \n        if s[0] != s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] == s[1] and s[0] * 2 != s:\n            return False\n        \n        if s[0] != s[1] and s[0] *"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n        # 2. 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35\n        # 3. 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324\n        # 4. 1, 5, 15, 35, 70, 126, 210, 343, 548, 840, 1248, 1782, 2585, 3606, 4900, 6445, 8300, 10526\n        # 5. 1, 6, 21, 56, 123, 252, 476, 828, 1344, 2092, 3140, 4556, 6400, 8736, 11680, 15360, 20000\n        # 6. 1, 7, 28, 84, 216, 504, 1024, 2048, 4096, 65536, 100000, 144000, 200000, 268800, 360000, 480000, 640000, 840000, 1080000\n        # 7. 1, 8, 44, 144, 368, 828, 1872, 4096, 8192, 15360, 28640, 49152, 80000, 122880, 200000, 327680, 491520, 720000, 1048576\n        # 8. 1, 9, 55, 220, 660, 1680, 4032, 8568, 16776, 32760, 58984, 100000, 161000, 252000, 384000, 566000, 800000, 1100000, 1500000\n        # 9. 1, 10, 66, 330, 1000, 2660, 6552, 15360, 32760, 60000, 100000, 161000, 262000, 403200, 589840, 820000, 1100000, 1440000, 1880000\n        # 10. 1, 11, 77, 440, 1680, 5000, 13440, 32760, 65520, 120000, 200000, 330000, 500000,"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. XOR\n        ## 2. XOR of a number with itself is 0\n        ## 3. XOR of a number with 0 is the number\n        ## 4. XOR of a number with itself is itself\n        ## 5. XOR of a number with 0 is the number\n        ## 6. XOR of a number with itself is itself\n        ## 7. XOR of a number with 0 is the number\n        ## 8. XOR of a number with itself is itself\n        ## 9. XOR of a number with 0 is the number\n        ## 10. XOR of a number with itself is itself\n        ## 11. XOR of a number with 0 is the number\n        ## 12. XOR of a number with itself is itself\n        ## 13. XOR of a number with 0 is the number\n        ## 14. XOR of a number with itself is itself\n        ## 15. XOR of a number with 0 is the number\n        ## 16. XOR of a number with itself is itself\n        ## 17. XOR of a number with 0 is the number\n        ## 18. XOR of a number with itself is itself\n        ## 19. XOR of a number with 0 is the number\n        ## 20. XOR of a number with itself is itself\n        ## 21. XOR of a number with 0 is the number\n        ## 22. XOR of a number with itself is itself\n        ## 23. XOR of a number with 0 is the number\n        ## 24. XOR of a number with itself is itself\n        ## 25. XOR of a number with 0 is the number\n        ## 26. XOR of a number with itself is itself\n        ## 27. XOR of a number with 0 is the number\n        ## 28. XOR of a number with itself is itself\n        ## 29. XOR of a number with 0 is the number\n        ## 30. XOR of a number with itself is itself\n        ## 31. XOR of a number with 0 is the number\n        ## 32. XOR of a number with itself is itself\n        ## 33. XOR of a number with 0 is the number\n        ## 34. XOR of a number with itself is itself\n        ## 35. XOR of a number with 0 is the number\n        ## 36. XOR of a number with itself is itself\n        ## 37. XOR of a number with 0 is the number\n        ## 38. XOR of a number with itself is itself\n        ## 39. XOR of a number with 0 is the number\n        ## 40. XOR of a number with itself is itself\n        ## 41. XOR of a number with 0 is the number\n        ## 42. XOR of a number with itself is itself\n        ## 43. XOR of a number with 0 is the number\n        ## 44. XOR of a number with itself is itself\n        ## 45. XOR of a number with 0 is the number\n        ## 46. XOR of a number with itself is itself\n        ## 47. XOR of a number with 0 is the number\n        ## 48. XOR of a number with itself is itself\n        ## 49. XOR of a number with 0 is the number\n        ## 50. XOR of a number with itself is itself\n        ## 51. XOR of a number with 0 is the number\n        ## 52. XOR of a number with itself is itself\n        ## 53. XOR of a number with 0 is the number\n        ## 54. XOR of a number with itself is itself\n        ## 55. XOR of a number with 0 is the number\n        ## 56. XOR of a number with itself is itself\n        ## 57. XOR of a number with 0 is the number\n        ## 58. XOR of a number with itself"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict of target letters\n        # 2. build a dict of stickers letters\n        # 3. build a dict of stickers letters with counts\n        # 4. build a dict of stickers letters with counts\n        # 5. build a dict of stickers letters with counts\n        # 6. build a dict of stickers letters with counts\n        # 7. build a dict of stickers letters with counts\n        # 8. build a dict of stickers letters with counts\n        # 9. build a dict of stickers letters with counts\n        # 10. build a dict of stickers letters with counts\n        # 11. build a dict of stickers letters with counts\n        # 12. build a dict of stickers letters with counts\n        # 13. build a dict of stickers letters with counts\n        # 14. build a dict of stickers letters with counts\n        # 15. build a dict of stickers letters with counts\n        # 16. build a dict of stickers letters with counts\n        # 17. build a dict of stickers letters with counts\n        # 18. build a dict of stickers letters with counts\n        # 19. build a dict of stickers letters with counts\n        # 20. build a dict of stickers letters with counts\n        # 21. build a dict of stickers letters with counts\n        # 22. build a dict of stickers letters with counts\n        # 23. build a dict of stickers letters with counts\n        # 24. build a dict of stickers letters with counts\n        # 25. build a dict of stickers letters with counts\n        # 26. build a dict of stickers letters with counts\n        # 27. build a dict of stickers letters with counts\n        # 28. build a dict of stickers letters with counts\n        # 29. build a dict of stickers letters with counts\n        # 30. build a dict of stickers letters with counts\n        # 31. build a dict of stickers letters with counts\n        # 32. build a dict of stickers letters with counts\n        # 33. build a dict of stickers letters with counts\n        # 34. build a dict of stickers letters with counts\n        # 35. build a dict of stickers letters with counts\n        # 36. build a dict of stickers letters with counts\n        # 37. build a dict of stickers letters with counts\n        # 38. build a dict of stickers letters with counts\n        # 39. build a dict of stickers letters with counts\n        # 40. build a dict of stickers letters with counts\n        # 41. build a dict of stickers letters with counts\n        # 42. build a dict of stickers letters with counts\n        # 43. build a dict of stickers letters with counts\n        # 44. build a dict of stickers letters with counts\n        # 45. build a dict of stickers letters with counts\n        # 46. build a dict of stickers letters with counts\n        # 47. build a dict of stickers letters with counts\n        # 48. build a dict of stickers letters with counts\n        # 49. build a dict of stickers letters with counts\n        # 50. build a dict of stickers letters with counts\n        # 51. build a dict of stickers letters with counts\n        # 52. build a dict of stickers letters with counts\n        # 53. build a dict of stickers letters with counts\n        # 54. build a dict of stickers letters with counts\n        # 55. build a dict of stickers letters with counts\n        # 56. build a dict of stickers letters with counts\n        # 57. build a dict of stickers letters with counts\n        # 58. build a dict of stickers letters with counts\n        # 59. build a dict of stickers letters with counts\n        # 60. build a dict of stickers letters with counts\n        # 61. build a dict of stickers letters with counts\n        # 62. build a dict of stickers letters with counts\n        # 63. build a dict of stickers letters with counts\n        # 64. build a dict of stickers letters with counts\n        # 65. build a dict of stickers letters with"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            c = s[i]\n            for j in range(i + 1, n):\n                if s[j] == c:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = dp[i][j - 1] + 1\n                    for k in range(i, j):\n                        if s[k] == c:\n                            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary of roman numerals and their values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # initialize the result to 0\n        result = 0\n        \n        # iterate over the string in reverse order\n        for i in range(len(s)-1, -1, -1):\n            # if the current character is less than the next character, subtract it\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # otherwise, add it\n            else:\n                result += roman_dict[s[i]]\n        \n        # return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # if k == 1:\n        #     return nums\n        \n        # if len(nums) == 1:\n        #     return nums\n        \n        # if len(nums) == 2:\n        #     return [max(nums[0], nums[1])]\n        \n        # if len(nums) == 3:\n        #     return [max(nums[0], nums[1], nums[2])]\n        \n        # if len(nums) == 4:\n        #     return [max(nums[0], nums[1], nums[2], nums[3])]\n        \n        # if len(nums) == 5:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4])]\n        \n        # if len(nums) == 6:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5])]\n        \n        # if len(nums) == 7:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        # if len(nums) == 8:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7])]\n        \n        # if len(nums) == 9:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8])]\n        \n        # if len(nums) == 10:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9])]\n        \n        # if len(nums) == 11:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10])]\n        \n        # if len(nums) == 12:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11])]\n        \n        # if len(nums) == 13:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12])]\n        \n        # if len(nums) == 14:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13])]\n        \n        # if len(nums) == 15:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13], nums[14])]\n        \n        # if len(nums) == 16:\n        #     return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums["}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # if len(nums1) > len(nums2):\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1\n        #     nums1, nums2 = nums2, nums1"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] > nums[1]:\n        #     return nums[1]\n        \n        # if nums[-1] > nums[-2]:\n        #     return nums[-1]\n        \n        # if nums[0] < nums[-1] and nums[0] < nums[-2]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1] and nums[0] > nums[-2]:\n        #     return nums[-2]\n        \n        # if nums[-1] < nums[-2] and nums[-1] < nums[-3]:\n        #     return nums[-3]\n        \n        # if nums[-1] > nums[-2] and nums[-1] > nums[-3]:\n        #     return nums[-3]\n        \n        # if nums[-2] < nums[-3] and nums[-2] < nums[-4]:\n        #     return nums[-4]\n        \n        # if nums[-2] > nums[-3] and nums[-2] > nums[-4]:\n        #     return nums[-4]\n        \n        # if nums[-3] < nums[-4] and nums[-3] < nums[-5]:\n        #     return nums[-5]\n        \n        # if nums[-3] > nums[-4] and nums[-3] > nums[-5]:\n        #     return nums[-5]\n        \n        # if nums[-4] < nums[-5] and nums[-4] < nums[-6]:\n        #     return nums[-6]\n        \n        # if nums[-4] > nums[-5] and nums[-4] > nums[-6]:\n        #     return nums[-6]\n        \n        # if nums[-5] < nums[-6] and nums[-5] < nums[-7]:\n        #     return nums[-7]\n        \n        # if nums[-5] > nums[-6] and nums[-5] > nums[-7]:\n        #     return nums[-7]\n        \n        # if nums[-6] < nums[-7] and nums[-6] < nums[-8]:\n        #     return nums[-8]\n        \n        # if nums[-6] > nums[-7] and nums[-6] > nums[-8]:\n        #     return nums[-8]\n        \n        # if nums[-7] < nums[-8] and nums[-7] < nums[-9]:\n        #     return nums[-9]\n        \n        # if nums[-7] > nums[-8] and nums[-7] > nums[-9]:\n        #     return nums[-9]\n        \n        # if nums[-8] < nums[-9] and nums[-8] < nums[-10]:\n        #     return nums[-10]\n        \n        # if nums[-8] > nums[-9] and nums[-8] > nums[-10]:\n        #     return nums[-10]\n        \n        # if nums[-9] < nums[-10] and nums[-9] < nums[-11]:\n        #     return nums[-11]\n        \n        # if nums[-9] > nums[-10] and nums[-9] > nums[-11]:\n        #     return nums[-11]\n        \n        # if nums[-10] < nums[-11] and nums[-10] < nums[-12]:\n        #     return nums[-12]\n        \n        # if nums[-10] > nums[-11] and nums[-10] > nums[-12]:\n        #     return nums[-12]\n        \n        # if nums[-11] < nums[-1"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        res = []\n        self.dfs(root, targetSum, [], res)\n        return res\n    \n    def dfs(self, root, targetSum, path, res):\n        if not root:\n            return\n        \n        path.append(root.val)\n        \n        if root.val == targetSum and not root.left and not root.right:\n            res.append(path[:])\n        \n        self.dfs(root.left, targetSum - root.val, path, res)\n        self.dfs(root.right, targetSum - root.val, path, res)\n        \n        path.pop()"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the square root of area\n        # 2. find the largest number that is less than square root of area\n        # 3. return [largest number, square root of area]\n        \n        # 1. find the square root of area\n        sqrt_area = area ** 0.5\n        \n        # 2. find the largest number that is less than square root of area\n        largest_num = int(sqrt_area)\n        \n        # 3. return [largest number, square root of area]\n        return [largest_num, int(sqrt_area)]"}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            graph[word].append(word)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # build the queue\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                new_word = word[:i] + \"*\" + word[i+1:]\n                for neighbor in graph[new_word]:\n                    if neighbor not in visited:\n                        visited[neighbor] = word\n                        queue.append(neighbor)\n        \n        # build the path\n        path = []\n        if endWord not in visited:\n            return path\n        while endWord:\n            path.append(endWord)\n            endWord = visited[endWord]\n        return path[::-1]"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n & (n - 1) == 0:\n            return True\n        \n        return False"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        i = 0\n        for num in nums:\n            if num != nums[i]:\n                res.append([num])\n                i = len(res) - 1\n            else:\n                res.append(res[i] + [num])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        ## 2. \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ub41c \uc2a4\ud0dd\uc5d0\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc704\uce58\ub97c \ucc3e\ub294\ub2e4.\n        ## 3. \uc67c\ucabd \uc624\ub978\ucabd \uc704\uce58\ub97c \ucc3e\uc558\uc73c\uba74 \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 4. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 5. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 6. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 7. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 8. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 9. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 10. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 11. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 12. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 13. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 14. \uc624\ub978\ucabd \uc704\uce58\uc5d0\uc11c \uc67c\ucabd \uc704\uce58\ub97c \ube80 \uac12\uc744 \uacf1\ud55c\ub2e4.\n        ## 15. \uc624\ub978"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        seen = set()\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n            seen.add((x1, y1))\n            seen.add((x2, y1))\n            seen.add((x1, y2))\n            seen.add((x2, y2))\n        \n        if len(seen) != 4:\n            return False\n        \n        if x_min >= x_max or y_min >= y_max:\n            return False\n        \n        if (x_min, y_min) not in seen or (x_max, y_min) not in seen or (x_min, y_max) not in seen or (x_max, y_max) not in seen:\n            return False\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = [board[0][0]*10 + board[0][1]*1 + board[0][2],\n                    board[1][0]*10 + board[1][1]*1 + board[1][2]]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d[0:2], board_1d[2:4]]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0][0]*100 + board_2d[0][1]*10 + board_2d[0][2]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//100, board_1d%100]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]\n        \n        # convert board_2d to a 1D array\n        board_1d = board_2d[0]*10 + board_2d[1]\n        \n        # convert board_1d to a 2D array\n        board_2d = [board_1d//10, board_1d%10]"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for s_char, t_char in zip(s, t):\n            if s_char not in s_to_t:\n                if t_char in t_to_s:\n                    return False\n                s_to_t[s_char] = t_char\n                t_to_s[t_char] = s_char\n            elif s_to_t[s_char] != t_char:\n                return False\n        \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in that half\n        if nums[pivot] == target:\n            return True\n        \n        # if the target is in the second half of the array, search in that half\n        if nums[pivot] < target:\n            return self.search(nums[pivot:], target)\n        \n        # if the target is not in the first half of the array, search in that half\n        return self.search(nums[:pivot], target)\n        \n    def find_pivot(self, nums):\n        # find the pivot\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [0] * n\n        dp[0] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                elif j > 0:\n                    dp[j] += dp[j-1]\n        \n        return dp[-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        if s[-1] == '0':\n            return 0\n        \n        if len(s) == 2:\n            if s[0] == '0':\n                return 0\n            if s[0] == '1' and s[1] in '0123456':\n                return 1\n            if s[0] == '2' and s[1] in '0123456':\n                return 1\n            return 0\n        \n        if s[-2] == '0':\n            return 0\n        \n        if s[-2] == '1' and s[-1] in '0123456':\n            return 1\n        \n        if s[-2] == '2' and s[-1] in '0123456':\n            return 1\n        \n        if s[-3] == '0':\n            return 0\n        \n        if s[-3] == '1' and s[-2] in '0123456':\n            return 1\n        \n        if s[-3] == '2' and s[-2] in '0123456':\n            return 1\n        \n        if s[-4] == '0':\n            return 0\n        \n        if s[-4] == '1' and s[-3] in '0123456':\n            return 1\n        \n        if s[-4] == '2' and s[-3] in '0123456':\n            return 1\n        \n        if s[-5] == '0':\n            return 0\n        \n        if s[-5] == '1' and s[-4] in '0123456':\n            return 1\n        \n        if s[-5] == '2' and s[-4] in '0123456':\n            return 1\n        \n        if s[-6] == '0':\n            return 0\n        \n        if s[-6] == '1' and s[-5] in '0123456':\n            return 1\n        \n        if s[-6] == '2' and s[-5] in '0123456':\n            return 1\n        \n        if s[-7] == '0':\n            return 0\n        \n        if s[-7] == '1' and s[-6] in '0123456':\n            return 1\n        \n        if s[-7] == '2' and s[-6] in '0123456':\n            return 1\n        \n        if s[-8] == '0':\n            return 0\n        \n        if s[-8] == '1' and s[-7] in '0123456':\n            return 1\n        \n        if s[-8] == '2' and s[-7] in '0123456':\n            return 1\n        \n        if s[-9] == '0':\n            return 0\n        \n        if s[-9] == '1' and s[-8] in '0123456':\n            return 1\n        \n        if s[-9] == '2' and s[-8] in '0123456':\n            return 1\n        \n        if s[-10] == '0':\n            return 0\n        \n        if s[-10] == '1' and s[-9] in '0123456':\n            return 1\n        \n        if s[-10] == '2' and s[-9] in '0123456':\n            return 1\n        \n        if s[-11] == '0':\n            return 0\n        \n        if s[-11] == '1' and s[-10] in '0123456':\n            return 1\n        \n        if s[-11] == '2' and s[-10] in '0123456':\n            return 1\n        \n        if s[-12] == '0':\n            return 0\n        \n        if s[-12] == '"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        closest = nums[0] + nums[1] + nums[2]\n        if n < 3:\n            return closest\n        \n        for i in range(n-2):\n            l, r = i+1, n-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(closest - target):\n                    closest = s\n                if s < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max\n        \n        # inorder traversal\n        # find the min and max value\n        # return the min - max"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.max_val = None\n        self.curr_count = 0\n        self.curr_val = None\n        self.prev_val = None\n        self.res = []\n        \n        self.inorder(root)\n        \n        return self.res\n    \n    def inorder(self, root):\n        if not root:\n            return\n        \n        self.inorder(root.left)\n        \n        if self.curr_val == root.val:\n            self.curr_count += 1\n        else:\n            if self.curr_count > self.max_count:\n                self.max_count = self.curr_count\n                self.res = [self.curr_val]\n            elif self.curr_count == self.max_count:\n                self.res.append(self.curr_val)\n            self.curr_val = root.val\n            self.curr_count = 1\n        \n        self.inorder(root.right)\n        \n        if self.curr_val == root.val:\n            self.curr_count += 1\n        else:\n            if self.curr_count > self.max_count:\n                self.max_count = self.curr_count\n                self.res = [self.curr_val]\n            elif self.curr_count == self.max_count:\n                self.res.append(self.curr_val)\n            self.curr_val = root.val\n            self.curr_count = 1\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.max_val = None\n        self.curr_count = 0\n        self.curr_val = None\n        self.prev_val = None\n        self.res = []\n        \n        self.inorder(root)\n        \n        return self.res\n    \n    def inorder(self, root):\n        if not root:\n            return\n        \n        self.inorder(root.left)\n        \n        if self.curr_val == root.val:\n            self.curr_count += 1\n        else:\n            if self.curr_count > self.max_count:\n                self.max_count = self.curr_count\n                self.res = [self.curr_val]\n            elif self.curr_count == self.max_count:\n                self.res.append(self.curr_val)\n            self.curr_val = root.val\n            self.curr_count = 1\n        \n        self.inorder(root.right)\n        \n        if self.curr_val == root.val:\n            self.curr_count += 1\n        else:\n            if self.curr_count > self.max_count:\n                self.max_count = self.curr_count\n                self.res = [self.curr_val]\n            elif self.curr_count == self.max_count:\n                self.res.append(self.curr_val)\n            self.curr_val = root.val\n            self.curr_count = 1\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.max_val = None\n        self.curr_count = 0"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        if len(haystack) == len(needle):\n            return 0 if haystack == needle else -1\n        \n        if len(haystack) > len(needle):\n            if haystack[0:len(needle)] == needle:\n                return 0\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if haystack[len(needle):len(haystack)] == needle:\n                return len(haystack) - len(needle)\n        \n        if len(haystack) > len(needle):\n            if hay"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        return n//5 + self.trailingZeroes(n//5)"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\"] * numRows\n        idx = 0\n        down = True\n        \n        for c in s:\n            res[idx] += c\n            if idx == 0:\n                down = True\n            elif idx == numRows - 1:\n                down = False\n            if down:\n                idx += 1\n            else:\n                idx -= 1\n        \n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the max height\n        max_height = max(height)\n        \n        ## 2. find the index of max height\n        max_height_index = height.index(max_height)\n        \n        ## 3. find the left max height\n        left_max_height = height[0]\n        left_max_height_index = 0\n        for i in range(max_height_index):\n            if height[i] > left_max_height:\n                left_max_height = height[i]\n                left_max_height_index = i\n        \n        ## 4. find the right max height\n        right_max_height = height[-1]\n        right_max_height_index = len(height) - 1\n        for i in range(len(height) - 1, max_height_index, -1):\n            if height[i] > right_max_height:\n                right_max_height = height[i]\n                right_max_height_index = i\n        \n        ## 5. find the water\n        water = 0\n        for i in range(max_height_index):\n            if height[i] < left_max_height:\n                water += left_max_height - height[i]\n            else:\n                left_max_height = height[i]\n        \n        for i in range(len(height) - 1, max_height_index, -1):\n            if height[i] < right_max_height:\n                water += right_max_height - height[i]\n            else:\n                right_max_height = height[i]\n        \n        return water"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n) time\n        ## O(1) space\n        ## O(n)"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. use binary search to find the index of the number in the sorted array\n        # 3. use binary search to find the number of numbers smaller than the number\n        # 4. use binary search to find the number of numbers smaller than the number\n        # 5. use binary search to find the number of numbers smaller than the number\n        # 6. use binary search to find the number of numbers smaller than the number\n        # 7. use binary search to find the number of numbers smaller than the number\n        # 8. use binary search to find the number of numbers smaller than the number\n        # 9. use binary search to find the number of numbers smaller than the number\n        # 10. use binary search to find the number of numbers smaller than the number\n        # 11. use binary search to find the number of numbers smaller than the number\n        # 12. use binary search to find the number of numbers smaller than the number\n        # 13. use binary search to find the number of numbers smaller than the number\n        # 14. use binary search to find the number of numbers smaller than the number\n        # 15. use binary search to find the number of numbers smaller than the number\n        # 16. use binary search to find the number of numbers smaller than the number\n        # 17. use binary search to find the number of numbers smaller than the number\n        # 18. use binary search to find the number of numbers smaller than the number\n        # 19. use binary search to find the number of numbers smaller than the number\n        # 20. use binary search to find the number of numbers smaller than the number\n        # 21. use binary search to find the number of numbers smaller than the number\n        # 22. use binary search to find the number of numbers smaller than the number\n        # 23. use binary search to find the number of numbers smaller than the number\n        # 24. use binary search to find the number of numbers smaller than the number\n        # 25. use binary search to find the number of numbers smaller than the number\n        # 26. use binary search to find the number of numbers smaller than the number\n        # 27. use binary search to find the number of numbers smaller than the number\n        # 28. use binary search to find the number of numbers smaller than the number\n        # 29. use binary search to find the number of numbers smaller than the number\n        # 30. use binary search to find the number of numbers smaller than the number\n        # 31. use binary search to find the number of numbers smaller than the number\n        # 32. use binary search to find the number of numbers smaller than the number\n        # 33. use binary search to find the number of numbers smaller than the number\n        # 34. use binary search to find the number of numbers smaller than the number\n        # 35. use binary search to find the number of numbers smaller than the number\n        # 36. use binary search to find the number of numbers smaller than the number\n        # 37. use binary search to find the number of numbers smaller than the number\n        # 38. use binary search to find the number of numbers smaller than the number\n        # 39. use binary search to find the number of numbers smaller than the number\n        # 40. use binary search to find the number of numbers smaller than the number\n        # 41. use binary search to find the number of numbers smaller than the number\n        # 42. use binary search to find the number of numbers smaller than the number\n        # 43. use binary search to find the number of numbers smaller than the number\n        # 44. use binary search to find the number of numbers smaller than the number\n        # 45. use binary search to find the number of numbers smaller than the number\n        # 46. use binary search to find the number of numbers smaller than the number\n        # 47. use binary search to find the number of numbers smaller than the number\n        # 48. use binary search to find the number of numbers smaller than the number\n        # 49. use binary search to find the number of numbers smaller than the number\n        # 50. use binary search to find the number of numbers smaller than the number\n        # 51. use binary search to find the number of numbers smaller than the number\n        # 52. use binary search to find the number of numbers smaller than the number\n        #"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # sort by end\n        intervals.sort(key=lambda x: x[1])\n        \n        # initialize\n        ans = 0\n        end = -1\n        \n        # iterate over intervals\n        for interval in intervals:\n            # if end is less than interval[0], then we have a new interval\n            if end < interval[0]:\n                # update end\n                end = interval[1]\n                # update ans\n                ans += 2\n            # if end is less than interval[1], then we have a new interval\n            elif end > interval[1]:\n                # update end\n                end = interval[1]\n                # update ans\n                ans += 1\n            # if end is equal to interval[1], then we have a new interval\n            else:\n                # update ans\n                ans += 1\n        \n        # return ans\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return True\n        \n        return self.isMirror(root.left, root.right)\n    \n    def isMirror(self, left, right):\n        if left is None and right is None:\n            return True\n        if left is None or right is None:\n            return False\n        if left.val != right.val:\n            return False\n        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the formula into tokens\n        # 2. build a stack of tokens\n        # 3. build a stack of counts\n        # 4. build a stack of atoms\n        # 5. build a stack of parentheses\n        # 6. build a stack of parentheses\n        # 7. build a stack of parentheses\n        # 8. build a stack of parentheses\n        # 9. build a stack of parentheses\n        # 10. build a stack of parentheses\n        # 11. build a stack of parentheses\n        # 12. build a stack of parentheses\n        # 13. build a stack of parentheses\n        # 14. build a stack of parentheses\n        # 15. build a stack of parentheses\n        # 16. build a stack of parentheses\n        # 17. build a stack of parentheses\n        # 18. build a stack of parentheses\n        # 19. build a stack of parentheses\n        # 20. build a stack of parentheses\n        # 21. build a stack of parentheses\n        # 22. build a stack of parentheses\n        # 23. build a stack of parentheses\n        # 24. build a stack of parentheses\n        # 25. build a stack of parentheses\n        # 26. build a stack of parentheses\n        # 27. build a stack of parentheses\n        # 28. build a stack of parentheses\n        # 29. build a stack of parentheses\n        # 30. build a stack of parentheses\n        # 31. build a stack of parentheses\n        # 32. build a stack of parentheses\n        # 33. build a stack of parentheses\n        # 34. build a stack of parentheses\n        # 35. build a stack of parentheses\n        # 36. build a stack of parentheses\n        # 37. build a stack of parentheses\n        # 38. build a stack of parentheses\n        # 39. build a stack of parentheses\n        # 40. build a stack of parentheses\n        # 41. build a stack of parentheses\n        # 42. build a stack of parentheses\n        # 43. build a stack of parentheses\n        # 44. build a stack of parentheses\n        # 45. build a stack of parentheses\n        # 46. build a stack of parentheses\n        # 47. build a stack of parentheses\n        # 48. build a stack of parentheses\n        # 49. build a stack of parentheses\n        # 50. build a stack of parentheses\n        # 51. build a stack of parentheses\n        # 52. build a stack of parentheses\n        # 53. build a stack of parentheses\n        # 54. build a stack of parentheses\n        # 55. build a stack of parentheses\n        # 56. build a stack of parentheses\n        # 57. build a stack of parentheses\n        # 58. build a stack of parentheses\n        # 59. build a stack of parentheses\n        # 60. build a stack of parentheses\n        # 61. build a stack of parentheses\n        # 62. build a stack of parentheses\n        # 63. build a stack of parentheses\n        # 64. build a stack of parentheses\n        # 65. build a stack of parentheses\n        # 66. build a stack of parentheses\n        # 67. build a stack of parentheses\n        # 68. build a stack of parentheses\n        # 69. build a stack of parentheses\n        # 70. build a stack of parentheses\n        # 71. build a stack of parentheses\n        # 72. build a stack of parentheses\n        # 73. build a stack of parentheses\n        # 74. build a stack of parentheses\n        # 75"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                stack.append(node.left)\n        \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        if n & (n - 1) == 0:\n            return n & 0x55555555 != 0\n        \n        return False"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        self.dfs(n, n, '', res)\n        return res\n    \n    def dfs(self, left, right, cur, res):\n        if left == 0 and right == 0:\n            res.append(cur)\n            return\n        if left > 0:\n            self.dfs(left - 1, right, cur + '(', res)\n        if right > 0 and left < right:\n            self.dfs(left, right - 1, cur + ')', res)"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if nums[0] > n:\n            return 0\n        \n        # edge case\n        if nums[-1] > n:\n            return 1\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case\n        if nums[-1] < n:\n            nums.append(n)\n        \n        # edge case\n        if nums[-1] == n:\n            return 1\n        \n        # edge case"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # if s is empty, return 0\n        if not s:\n            return 0\n        \n        # initialize max_len to 0\n        max_len = 0\n        \n        # initialize stack to keep track of the last index of a valid parentheses\n        stack = [-1]\n        \n        # iterate over the string\n        for i, c in enumerate(s):\n            # if c is '('\n            if c == '(':\n                # append i to stack\n                stack.append(i)\n            # if c is ')'\n            else:\n                # pop stack\n                stack.pop()\n                # if stack is empty\n                if not stack:\n                    # append i to stack\n                    stack.append(i)\n                # else\n                else:\n                    # max_len = max(max_len, i - stack[-1])\n                    max_len = max(max_len, i - stack[-1])\n        \n        # return max_len\n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = \"-\"\n        elif numerator > 0 and denominator < 0:\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        if numerator < 0:\n            numerator = -numerator\n        if denominator < 0:\n            denominator = -denominator\n        \n        if numerator > denominator:\n            numerator, denominator = denominator, numerator\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return sign + str(quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        remainder_str = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str\n                remainder_str += \")\" * (len(remainder_dict) - remainder_dict[remainder])\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        \n        return sign + str(quotient) + \".\" + remainder_str"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by width, then height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # find longest increasing subsequence\n        h = []\n        for w, h in envelopes:\n            if not h or h > h[0]:\n                h[0] = h\n            else:\n                h = self.binary_search(h, h[0])\n                h[0] = h\n        \n        return len(h)\n    \n    def binary_search(self, h, target):\n        lo, hi = 0, len(h) - 1\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if h[mid][1] < target:\n                lo = mid + 1\n            else:\n                hi = mid\n        return h[lo]"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. Find the rows and cols that have 0s\n        ## 2. Set the rows and cols to 0\n        ## 3. Set the 0s to 0\n        \n        ## 1. Find the rows and cols that have 0s\n        rows = set()\n        cols = set()\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        \n        ## 2. Set the rows and cols to 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0\n        \n        ## 3. Set the 0s to 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0, head)\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = head\n        \n        # move fast pointer n steps\n        for i in range(n):\n            fast = fast.next\n        \n        # move both pointers until fast pointer reaches the end\n        while fast:\n            fast = fast.next\n            slow = slow.next\n        \n        # remove the node\n        slow.next = slow.next.next\n        \n        # return the head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        ## 4. use set\n        ## 5. use dict\n        ## 6. use list\n        ## 7. use set\n        ## 8. use dict\n        ## 9. use list\n        ## 10. use set\n        ## 11. use dict\n        ## 12. use list\n        ## 13. use set\n        ## 14. use dict\n        ## 15. use list\n        ## 16. use set\n        ## 17. use dict\n        ## 18. use list\n        ## 19. use set\n        ## 20. use dict\n        ## 21. use list\n        ## 22. use set\n        ## 23. use dict\n        ## 24. use list\n        ## 25. use set\n        ## 26. use dict\n        ## 27. use list\n        ## 28. use set\n        ## 29. use dict\n        ## 30. use list\n        ## 31. use set\n        ## 32. use dict\n        ## 33. use list\n        ## 34. use set\n        ## 35. use dict\n        ## 36. use list\n        ## 37. use set\n        ## 38. use dict\n        ## 39. use list\n        ## 40. use set\n        ## 41. use dict\n        ## 42. use list\n        ## 43. use set\n        ## 44. use dict\n        ## 45. use list\n        ## 46. use set\n        ## 47. use dict\n        ## 48. use list\n        ## 49. use set\n        ## 50. use dict\n        ## 51. use list\n        ## 52. use set\n        ## 53. use dict\n        ## 54. use list\n        ## 55. use set\n        ## 56. use dict\n        ## 57. use list\n        ## 58. use set\n        ## 59. use dict\n        ## 60. use list\n        ## 61. use set\n        ## 62. use dict\n        ## 63. use list\n        ## 64. use set\n        ## 65. use dict\n        ## 66. use list\n        ## 67. use set\n        ## 68. use dict\n        ## 69. use list\n        ## 70. use set\n        ## 71. use dict\n        ## 72. use list\n        ## 73. use set\n        ## 74. use dict\n        ## 75. use list\n        ## 76. use set\n        ## 77. use dict\n        ## 78. use list\n        ## 79. use set\n        ## 80. use dict\n        ## 81. use list\n        ## 82. use set\n        ## 83. use dict\n        ## 84. use list\n        ## 85. use set\n        ## 86. use dict\n        ## 87. use list\n        ## 88. use set\n        ## 89. use dict\n        ## 90. use list\n        ## 91. use set\n        ## 92. use dict\n        ## 93. use list\n        ## 94. use set\n        ## 95. use dict\n        ## 96. use list\n        ## 97. use set\n        ## 98. use dict\n        ## 99. use list\n        ## 100. use set\n        ## 101. use dict\n        ## 102. use list\n        ## 103. use set"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines) % len(machines) != 0:\n            return -1\n        \n        avg = sum(machines) // len(machines)\n        ans = 0\n        cur = 0\n        for m in machines:\n            cur += m - avg\n            ans = max(ans, abs(cur))\n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            cnt = 0\n            for i in range(1, m + 1):\n                cnt += min(n, x // i)\n            return cnt\n        \n        if k == 1:\n            return min(m, n)\n        \n        if m > n:\n            m, n = n, m\n            k = n - k + 1\n        \n        if k > count(n):\n            return n\n        \n        lo, hi = 1, m * n\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if count(mid) < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        \n        return lo"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        \n        prev.next = None\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1, list2 = list2, list1\n        \n        head = list1\n        \n        while list1.next is not None and list2 is not None:\n            if list1.next.val < list2.val:\n                list1 = list1.next\n            else:\n                list1.next, list2 = list2, list1.next\n                list1 = list1.next\n        \n        list1.next = list2\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        max_area = 0\n        heights.append(0)\n        \n        for i, h in enumerate(heights):\n            if not stack or h >= heights[stack[-1]]:\n                stack.append(i)\n            else:\n                while stack and h < heights[stack[-1]]:\n                    ht = heights[stack.pop()]\n                    w = i if not stack else i - stack[-1] - 1\n                    max_area = max(max_area, ht * w)\n                stack.append(i)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [[]]\n        \n        if len(nums) == 1:\n            return [[], nums]\n        \n        if len(nums) == 2:\n            return [[], nums, [nums[1], nums[0]]]\n        \n        if len(nums) == 3:\n            return [[], nums, [nums[1], nums[0]], [nums[2], nums[0], nums[1]]]\n        \n        if len(nums) == 4:\n            return [[], nums, [nums[1], nums[0]], [nums[3], nums[0], nums[1]], [nums[2], nums[0], nums[1], nums[3]]]\n        \n        if len(nums) == 5:\n            return [[], nums, [nums[1], nums[0]], [nums[4], nums[0], nums[1]], [nums[3], nums[0], nums[1], nums[4]], [nums[2], nums[0], nums[1], nums[3], nums[4]]]\n        \n        if len(nums) == 6:\n            return [[], nums, [nums[1], nums[0]], [nums[5], nums[0], nums[1]], [nums[4], nums[0], nums[1], nums[5]], [nums[3], nums[0], nums[1], nums[4], nums[5]], [nums[2], nums[0], nums[1], nums[3], nums[4], nums[5]]]\n        \n        if len(nums) == 7:\n            return [[], nums, [nums[1], nums[0]], [nums[6], nums[0], nums[1]], [nums[5], nums[0], nums[1], nums[6]], [nums[4], nums[0], nums[1], nums[5], nums[6]], [nums[3], nums[0], nums[1], nums[4], nums[5], nums[6]], [nums[2], nums[0], nums[1], nums[3], nums[4], nums[5], nums[6]]]\n        \n        if len(nums) == 8:\n            return [[], nums, [nums[1], nums[0]], [nums[7], nums[0], nums[1]], [nums[6], nums[0], nums[1], nums[7]], [nums[5], nums[0], nums[1], nums[6], nums[7]], [nums[4], nums[0], nums[1], nums[5], nums[6], nums[7]], [nums[3], nums[0], nums[1], nums[4], nums[5], nums[6], nums[7]], [nums[2], nums[0], nums[1], nums[3], nums[4], nums[5], nums[6], nums[7]]]\n        \n        if len(nums) == 9:\n            return [[], nums, [nums[1], nums[0]], [nums[8], nums[0], nums[1]], [nums[7], nums[0], nums[1], nums[8]], [nums[6], nums[0], nums[1], nums[7], nums[8]], [nums[5], nums[0], nums[1], nums[6], nums[7], nums[8]], [nums[4], nums[0], nums[1], nums[5], nums[6], nums[7], nums[8]], [nums[3], nums[0], nums[1], nums[4], nums[5], nums[6], nums[7], nums[8]], [nums[2], nums[0], nums["}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid] < nums[mid - 1]:\n                return nums[mid]\n            \n            if nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-e':\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        if not s or s[0] not in '0123456789':\n            return False\n        if s[0] == '0' and len(s) > 1:\n            return False\n        if s[0] == '0' and len(s) == 1:\n            return True\n        \n        # 4. check if it is a valid decimal\n        if s[0] == '.':\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n            if s[0] == '0' and len(s) > 1:\n                return False\n            if s[0] == '0' and len(s) == 1:\n                return True\n        \n        # 5. check if it is a valid exponential\n        if s[0] == 'e':\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n            if s[0] == '0' and len(s) > 1:\n                return False\n            if s[0] == '0' and len(s) == 1:\n                return True\n        \n        # 6. check if it is a valid integer\n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        if not s or s[0] not in '0123456789':\n            return False\n        if s[0] == '0' and len(s) > 1:\n            return False\n        if s[0] == '0' and len(s) == 1:\n            return True\n        \n        # 7. check if it is a valid decimal\n        if s[0] == '.':\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n            if s[0] == '0' and len(s) > 1:\n                return False\n            if s[0] == '0' and len(s) == 1:\n                return True\n        \n        # 8. check if it is a valid exponential\n        if s[0] == 'e':\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n            if s[0] == '0' and len(s) > 1:\n                return False\n            if s[0] == '0' and len(s) == 1:\n                return True\n        \n        # 9. check if it is a valid integer\n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        if not s or s[0] not in '0123456789':\n            return False\n        if s[0] == '0' and len(s) > 1:\n            return False\n        if s[0] == '0' and len(s) == 1:\n            return True\n        \n        # 10. check if it is a valid decimal\n        if s[0] == '.':\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n            if s[0] == '0' and len(s) > 1:\n                return False\n            if s[0] == '0' and len(s) == 1:\n                return True\n        \n        # 11. check if it is a valid exponential\n        if s[0] == 'e':\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n            if s[0] == '0' and len(s) > 1:\n                return False"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XLV, LX, LXX, LXXX, XC, XXC, XLC, C, XCV, CV, CXV, D, DC, DD, DDC, CM, DCC, DCCC, M, MM, MMM\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XLV, LX, LXX, LXXX, XC, XXC, XLC, C, XCV, CV, CXV, D, DC, DD, DDC, CM, DCC, DCCC, M, MM, MMM\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XLV, LX, LXX, LXXX, XC, XXC, XLC, C, XCV, CV, CXV, D, DC, DD, DDC, CM, DCC, DCCC, M, MM, MMM\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XLV, LX, LXX, LXXX, XC, XXC, XLC, C, XCV, CV, CXV, D, DC, DD, DDC, CM, DCC, DCCC, M, MM, MMM\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XLV, LX, LXX, LXXX, XC, XXC, XLC, C, XCV, CV, CXV, D, DC, DD, DDC, CM, DCC, DCCC, M, MM, MMM\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XLV, LX, LXX, LXXX, XC, XXC, XLC, C, XCV, CV, CXV, D, DC, DD, DDC, CM, DCC, DCCC, M, MM, MMM\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XLV, LX, LXX, LXXX, XC, XXC, XLC, C, XCV, CV, CXV, D, DC, DD, DDC, CM, DCC,"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## XOR\n        ## s = a b c d\n        ## t = a b c d e\n        ## s ^ t = a b c d\n        ## t ^ s = e\n        ## s ^ t ^ s = e\n        ## s ^ t ^ t = 0\n        ## s ^ 0 = s\n        ## t ^ 0 = t\n        ## s ^ t ^ 0 = s ^ t\n        ## s ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ 0 = s ^ t ^ t\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t = 0\n        ## s ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^ t ^"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. Find empty cells\n        empty_cells = []\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    empty_cells.append((i, j))\n        \n        # 2. Solve the puzzle\n        self.solve(board, empty_cells)\n        \n    def solve(self, board, empty_cells):\n        # 3. If there are no empty cells, we are done\n        if not empty_cells:\n            return True\n        \n        # 4. Choose a random empty cell\n        i, j = random.choice(empty_cells)\n        \n        # 5. Try to fill the cell with a number\n        for num in range(1, 10):\n            if self.is_valid(board, i, j, num):\n                board[i][j] = str(num)\n                \n                # 6. If the cell is valid, recursively solve the rest of the puzzle\n                if self.solve(board, empty_cells):\n                    return True\n                \n                # 7. If the cell is not valid, backtrack and try the next number\n                board[i][j] = '.'\n        \n        # 8. If the cell is not valid, return False\n        return False\n    \n    def is_valid(self, board, i, j, num):\n        # 9. Check if the number is already in the row\n        for c in range(9):\n            if board[i][c] == num:\n                return False\n        \n        # 10. Check if the number is already in the column\n        for r in range(9):\n            if board[r][j] == num:\n                return False\n        \n        # 11. Check if the number is already in the 3x3 box\n        box_i = i // 3 * 3\n        box_j = j // 3 * 3\n        for r in range(box_i, box_i + 3):\n            for c in range(box_j, box_j + 3):\n                if board[r][c] == num:\n                    return False\n        \n        # 12. If all checks pass, the number is valid\n        return True"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first, second = None, None\n        prev = None\n        while root:\n            if root.left:\n                prev = root.left\n            else:\n                if prev and prev.val > root.val:\n                    second = root\n                prev = root\n                root = root.right\n        return second, first"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        if not head:\n            return True\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        left, right = head, prev\n        while right:\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        if num < 4:\n            return False\n        \n        left = 1\n        right = num\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if head.val == val:\n            return self.removeElements(head.next, val)\n        \n        head.next = self.removeElements(head.next, val)\n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        return self.isScramble(s1[:len(s1)//2], s2[:len(s1)//2]) and self.isScramble(s1[len(s1)//2:], s2[len(s1)//2:])"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # split the path into a list of directories\n        dirs = path.split('/')\n        \n        # remove empty strings from the list\n        dirs = [d for d in dirs if d]\n        \n        # create a stack to store the directories\n        stack = []\n        \n        # iterate over the list of directories\n        for d in dirs:\n            # if the directory is '..', pop the last directory from the stack\n            if d == '..':\n                if stack:\n                    stack.pop()\n            # if the directory is not '..', add it to the stack\n            elif d != '.':\n                stack.append(d)\n        \n        # join the stack with a '/' to get the simplified path\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['#'] = word\n        \n        def dfs(i, j, node):\n            char = board[i][j]\n            if char not in node:\n                return []\n            word = node.pop(char, '#')\n            if '#' in node:\n                ans.append(word)\n            board[i][j] = '#'\n            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):\n                if 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] != '#':\n                    dfs(x, y, node[board[x][y]])\n            board[i][j] = char\n            return ans\n        \n        ans = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] in trie:\n                    ans.extend(dfs(i, j, trie[board[i][j]]))\n        return ans"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != 9:\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != 9:\n                return False\n        \n        # check 3x3 squares\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(square)) != 9:\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 * 25 + (26^1 * 25 + (26^2 * 25 + (26^3 * 25 + (26^4 * 25 + (26^5 * 25 + (26^6 * 25 + (26^7 * 25 + (26^8 * 25 + (26^9 * 25 + (26^10 * 25 + (26^11 * 25 + (26^12 * 25 + (26^13 * 25 + (26^14 * 25 + (26^15 * 25 + (26^16 * 25 + (26^17 * 25 + (26^18 * 25 + (26^19 * 25 + (26^20 * 25 + (26^21 * 25 + (26^22 * 25 + (26^23 * 25 + (26^24 * 25 + (26^25 * 25 + (26^26 * 25 + (26^27 * 25 + (26^28 * 25 + (26^29 * 25 + (26^30 * 25 + (26^31 * 25 + (26^32 * 25 + (26^33 * 25 + (26^34 * 25 + (26^35 * 25 + (26^36 * 25 + (26^37 * 25 + (26^38 * 25 + (26^39 * 25 + (26^40 * 25 + (26^41 * 25 + (26^42 * 25 + (26^43 * 25 + (26^44 * 25 + (26^45 * 25 + (26^46 * 25 + (26^47 * 25 + (26^48 * 25 + (26^49 * 25 + (26^50 * 25 + (26^51 * 25 + (26^52 * 25 + (26^53 * 25 + (26^54 * 25 + (26^55 * 25 + (26^56 * 25 + (26^57 * 25 + (26^58 * 25 + (26^59 * 25 + (26^60 * 25 + (26^61 * 25 + (26^62 * 25 + (26^63 * 25 + (26^64 * 25 + (26^65 * 25 + (26^66 * 25 + (26^67 * 25 + (26^68 * 25 + (26^69 * 25 + (26^70 * 25 + (26^71 * 25 + (26^72 * 25 + (26^73 * 25 + (26^74 * 25 + (26^75 * 25 + (26^76 * 25 + (26^77 * 25 + (26^78 * 25 + (26^79 * 25 + (26^80 * 25 + (26^81 * 25 + (26^82 * 25 + (26^83 * 25 + (26^84 * 25 + (26^85 * 25 + (26^86 * 25 + (26^87 * 25 + (26^88 * 25 + (26^89 * 25 + (26^90 * 25 + (26^91 * 25 + (26^92 * 25 + (26^93 * 2"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        curr = slow\n        while curr:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        \n        # merge the first and second halves\n        first = head\n        second = prev\n        while second.next:\n            tmp1 = first.next\n            tmp2 = second.next\n            first.next = second\n            second.next = tmp1\n            first = tmp1\n            second = tmp2\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern and the length of the words are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between pattern and words\n        mapping = {}\n        \n        # create a set to store the set of words\n        word_set = set()\n        \n        # iterate over the pattern and words\n        for p, w in zip(pattern, words):\n            # if the pattern is not in the mapping, add it to the mapping\n            if p not in mapping:\n                mapping[p] = w\n            # if the word is not in the set, add it to the set\n            elif mapping[p] != w:\n                return False\n            # if the word is in the set, add it to the set\n            else:\n                word_set.add(w)\n        \n        # if the length of the set is not equal to the length of the pattern, return False\n        if len(word_set) != len(pattern):\n            return False\n        \n        # if the mapping is not empty, return False\n        if mapping:\n            return False\n        \n        # return True if the mapping is empty\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        if len(nums) == 2:\n            return [[nums[0], nums[1]], [nums[1], nums[0]]]\n        \n        if len(nums) == 3:\n            return [[nums[0], nums[1], nums[2]], [nums[0], nums[2], nums[1]], [nums[1], nums[0], nums[2]], [nums[1], nums[2], nums[0]], [nums[2], nums[0], nums[1]], [nums[2], nums[1], nums[0]]]\n        \n        if len(nums) > 3:\n            return [nums[0:1] + nums[2:]] + [nums[0:2] + nums[1:]] + [nums[1:2] + nums[0:]]"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        if target == matrix[0][0] or target == matrix[-1][-1]:\n            return True\n        \n        if target == matrix[m-1][n-1]:\n            return True\n        \n        if target == matrix[m-1][0]:\n            return True\n        \n        if target == matrix[0][n-1]:\n            return True\n        \n        if target == matrix[m-2][n-1]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[m-1][n-2]:\n            return True\n        \n        if target == matrix[m-1][0]:\n            return True\n        \n        if target == matrix[0][n-2]:\n            return True\n        \n        if target == matrix[m-2][n-2]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-3]:\n            return True\n        \n        if target == matrix[m-2][n-3]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-4]:\n            return True\n        \n        if target == matrix[m-2][n-4]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-5]:\n            return True\n        \n        if target == matrix[m-2][n-5]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-6]:\n            return True\n        \n        if target == matrix[m-2][n-6]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-7]:\n            return True\n        \n        if target == matrix[m-2][n-7]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-8]:\n            return True\n        \n        if target == matrix[m-2][n-8]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-9]:\n            return True\n        \n        if target == matrix[m-2][n-9]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-10]:\n            return True\n        \n        if target == matrix[m-2][n-10]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-11]:\n            return True\n        \n        if target == matrix[m-2][n-11]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-12]:\n            return True\n        \n        if target == matrix[m-2][n-12]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-13]:\n            return True\n        \n        if target == matrix[m-2][n-13]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-14]:\n            return True\n        \n        if target == matrix[m-2][n-14]:\n            return True\n        \n        if target == matrix[m-2][0]:\n            return True\n        \n        if target == matrix[0][n-15]:\n            return True\n        \n        if target == matrix[m-2][n-15"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize the result list\n        result = ListNode()\n        # Initialize the current node\n        current = result\n        # Initialize the carry\n        carry = 0\n        \n        # Iterate over the lists\n        while l1 or l2 or carry:\n            # Get the values of the nodes\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            # Calculate the sum\n            sum = val1 + val2 + carry\n            # Get the digit\n            digit = sum % 10\n            # Get the carry\n            carry = sum // 10\n            # Create a new node\n            current.next = ListNode(digit)\n            # Move to the next node\n            current = current.next\n            # Move to the next node\n            if l1: l1 = l1.next\n            if l2: l2 = l2.next\n        \n        # Return the result list\n        return result.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert to binary\n        # 2. flip bits\n        # 3. convert back to decimal\n        \n        # 1. convert to binary\n        binary = bin(num)[2:]\n        \n        # 2. flip bits\n        binary = binary.replace('1', '0')\n        binary = binary.replace('0', '1')\n        \n        # 3. convert back to decimal\n        return int(binary, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        diff = nums[1] - nums[0]\n        count = 0\n        ans = 0\n        \n        for i in range(2, len(nums)):\n            if nums[i] - nums[i-1] == diff:\n                count += 1\n            else:\n                diff = nums[i] - nums[i-1]\n                count = 0\n            ans += count\n        \n        return ans"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # initialize\n        res = []\n        cur_line = []\n        cur_len = 0\n        cur_words = 0\n        cur_space = 0\n        cur_space_left = 0\n        cur_space_right = 0\n        \n        # loop through words\n        for word in words:\n            # if word is longer than maxWidth, add it to the current line\n            if cur_len + len(word) + cur_words > maxWidth:\n                # add the current line to the result\n                res.append(self.justify(cur_line, cur_len, cur_words, cur_space, cur_space_left, cur_space_right, maxWidth))\n                # reset the current line\n                cur_line = []\n                cur_len = 0\n                cur_words = 0\n                cur_space = 0\n                cur_space_left = 0\n                cur_space_right = 0\n            # if word is shorter than maxWidth, add it to the current line\n            else:\n                # add the word to the current line\n                cur_line.append(word)\n                # add the word length to the current length\n                cur_len += len(word)\n                # add 1 to the current words\n                cur_words += 1\n                # add 1 to the current space\n                cur_space += 1\n                # add 1 to the current space left\n                cur_space_left += 1\n                # add 1 to the current space right\n                cur_space_right += 1\n        \n        # if there are words left in the current line, add them to the current line\n        if cur_line:\n            # add the current line to the result\n            res.append(self.justify(cur_line, cur_len, cur_words, cur_space, cur_space_left, cur_space_right, maxWidth))\n        \n        # return the result\n        return res\n    \n    def justify(self, line, line_len, line_words, line_space, line_space_left, line_space_right, maxWidth):\n        # if the number of words is 1, add a space to the end of the line\n        if line_words == 1:\n            # add a space to the end of the line\n            line.append(' ')\n            # add a space to the end of the line\n            line.append(' ')\n            # return the line\n            return ' '.join(line)\n        # if the number of words is 2, add a space to the end of the line\n        elif line_words == 2:\n            # add a space to the end of the line\n            line.append(' ')\n            # return the line\n            return ' '.join(line)\n        # if the number of words is 3 or more, add a space to the end of the line\n        else:\n            # add a space to the end of the line\n            line.append(' ')\n            # add a space to the end of the line\n            line.append(' ')\n            # add a space to the end of the line\n            line.append(' ')\n            # return the line\n            return ' '.join(line)"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.left)\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area ="}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a set of words\n        word_set = set(words)\n        \n        # create a dictionary to store the longest word\n        longest_word = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        longest_word_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len_len_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len_len_len_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len_len_len_len_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len_len_len_len_len_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len_len_len_len_len_len_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        longest_word_len_len_len_len_len_len_len_len_len_len = {}\n        \n        # create a dictionary to store the longest word\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with the number of words in the dictionary\n        # with"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = -num\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 queen\n        # 2. 2 queens\n        # 3. 3 queens\n        # 4. 4 queens\n        # 5. 5 queens\n        # 6. 6 queens\n        # 7. 7 queens\n        # 8. 8 queens\n        # 9. 9 queens\n        # 10. 10 queens\n        # 11. 11 queens\n        # 12. 12 queens\n        # 13. 13 queens\n        # 14. 14 queens\n        # 15. 15 queens\n        # 16. 16 queens\n        # 17. 17 queens\n        # 18. 18 queens\n        # 19. 19 queens\n        # 20. 20 queens\n        # 21. 21 queens\n        # 22. 22 queens\n        # 23. 23 queens\n        # 24. 24 queens\n        # 25. 25 queens\n        # 26. 26 queens\n        # 27. 27 queens\n        # 28. 28 queens\n        # 29. 29 queens\n        # 30. 30 queens\n        # 31. 31 queens\n        # 32. 32 queens\n        # 33. 33 queens\n        # 34. 34 queens\n        # 35. 35 queens\n        # 36. 36 queens\n        # 37. 37 queens\n        # 38. 38 queens\n        # 39. 39 queens\n        # 40. 40 queens\n        # 41. 41 queens\n        # 42. 42 queens\n        # 43. 43 queens\n        # 44. 44 queens\n        # 45. 45 queens\n        # 46. 46 queens\n        # 47. 47 queens\n        # 48. 48 queens\n        # 49. 49 queens\n        # 50. 50 queens\n        # 51. 51 queens\n        # 52. 52 queens\n        # 53. 53 queens\n        # 54. 54 queens\n        # 55. 55 queens\n        # 56. 56 queens\n        # 57. 57 queens\n        # 58. 58 queens\n        # 59. 59 queens\n        # 60. 60 queens\n        # 61. 61 queens\n        # 62. 62 queens\n        # 63. 63 queens\n        # 64. 64 queens\n        # 65. 65 queens\n        # 66. 66 queens\n        # 67. 67 queens\n        # 68. 68 queens\n        # 69. 69 queens\n        # 70. 70 queens\n        # 71. 71 queens\n        # 72. 72 queens\n        # 73. 73 queens\n        # 74. 74 queens\n        # 75. 75 queens\n        # 76. 76 queens\n        # 77. 77 queens\n        # 78. 78 queens\n        # 79. 79 queens\n        # 80. 80 queens\n        # 81. 81 queens\n        # 82. 82 queens\n        # 83. 83 queens\n        # 84. 84 queens\n        # 85. 85 queens\n        # 86. 86 queens\n        # 87. 87 queens"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # 1. create a board\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        \n        # 2. create a list of queens\n        queens = []\n        \n        # 3. create a list of columns\n        columns = [0 for _ in range(n)]\n        \n        # 4. create a list of diagonals\n        diagonals1 = [0 for _ in range(2*n-1)]\n        diagonals2 = [0 for _ in range(2*n-1)]\n        \n        # 5. create a list of anti-diagonals\n        anti_diagonals1 = [0 for _ in range(2*n-1)]\n        anti_diagonals2 = [0 for _ in range(2*n-1)]\n        \n        # 6. create a list of all the diagonals\n        diagonals = [diagonals1, diagonals2]\n        \n        # 7. create a list of all the anti-diagonals\n        anti_diagonals = [anti_diagonals1, anti_diagonals2]\n        \n        # 8. create a list of all the columns\n        columns = [columns, columns]\n        \n        # 9. create a list of all the anti-diagonals\n        anti_diagonals = [anti_diagonals, anti_diagonals]\n        \n        # 10. create a list of all the diagonals\n        diagonals = [diagonals, diagonals]\n        \n        # 11. create a list of all the queens\n        queens = [queens, queens]\n        \n        # 12. create a list of all the columns\n        columns = [columns, columns]\n        \n        # 13. create a list of all the anti-diagonals\n        anti_diagonals = [anti_diagonals, anti_diagonals]\n        \n        # 14. create a list of all the diagonals\n        diagonals = [diagonals, diagonals]\n        \n        # 15. create a list of all the queens\n        queens = [queens, queens]\n        \n        # 16. create a list of all the columns\n        columns = [columns, columns]\n        \n        # 17. create a list of all the anti-diagonals\n        anti_diagonals = [anti_diagonals, anti_diagonals]\n        \n        # 18. create a list of all the diagonals\n        diagonals = [diagonals, diagonals]\n        \n        # 19. create a list of all the queens\n        queens = [queens, queens]\n        \n        # 20. create a list of all the columns\n        columns = [columns, columns]\n        \n        # 21. create a list of all the anti-diagonals\n        anti_diagonals = [anti_diagonals, anti_diagonals]\n        \n        # 22. create a list of all the diagonals\n        diagonals = [diagonals, diagonals]\n        \n        # 23. create a list of all the queens\n        queens = [queens, queens]\n        \n        # 24. create a list of all the columns\n        columns = [columns, columns]\n        \n        # 25. create a list of all the anti-diagonals\n        anti_diagonals = [anti_diagonals, anti_diagonals]\n        \n        # 26. create a list of all the diagonals\n        diagonals = [diagonals, diagonals]\n        \n        # 27. create a list of all the queens\n        queens = [queens, queens]\n        \n        # 28. create a list of all the columns\n        columns = [columns, columns]\n        \n        # 29. create a list of all the anti-diagonals\n        anti_diagonals = [anti_diagonals, anti_diagonals]\n        \n        # 30. create a list of all the diagonals\n        diagonals = [diagonals, diagonals]\n        \n        # 31. create a list of all the queens\n        que"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        if not board[0]:\n            return False\n        \n        if not word[0]:\n            return False\n        \n        if len(word) > len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):\n            return self.exist_helper(board, word)\n        \n        if len(word) < len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):\n            return self.exist_helper(board, word)\n        \n        return False\n    \n    def exist_helper(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        if not board[0]:\n            return False\n        \n        if not word[0]:\n            return False\n        \n        if len(word) > len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):\n            return self.exist_helper_helper(board, word)\n        \n        if len(word) < len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):\n            return self.exist_helper_helper(board, word)\n        \n        return False\n    \n    def exist_helper_helper(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        if not board[0]:\n            return False\n        \n        if not word[0]:\n            return False\n        \n        if len(word) > len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):\n            return self.exist_helper_helper_helper(board, word)\n        \n        if len(word) < len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):\n            return self.exist_helper_helper_helper(board, word)\n        \n        return False\n    \n    def exist_helper_helper_helper(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        if not board[0]:\n            return False\n        \n        if not word[0]:\n            return False\n        \n        if len(word) > len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):\n            return self.exist_helper_helper_helper_helper(board, word)\n        \n        if len(word) < len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):\n            return self.exist_helper_helper_helper_helper(board, word)\n        \n        return False\n    \n    def exist_helper_helper_helper_helper(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if not word:\n            return True\n        \n        if not board:\n            return False\n        \n        if not board[0]:\n            return False\n        \n        if not word[0]:\n            return False\n        \n        if len(word) > len(board)*len(board[0]):\n            return False\n        \n        if len(word) == len(board)*len(board[0]):"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        nums.sort()\n        \n        # 2. if the list is empty, return None\n        if not nums:\n            return None\n        \n        # 3. if the list has only one element, return that element\n        if len(nums) == 1:\n            return nums[0]\n        \n        # 4. if the list has two elements, return the second element\n        if len(nums) == 2:\n            return nums[1]\n        \n        # 5. if the list has three elements, return the third element\n        if len(nums) == 3:\n            return nums[2]\n        \n        # 6. if the list has more than three elements, return the third element\n        return nums[-3]"}]}