{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n-1\n        top, bottom = 0, m-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom+1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left-1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top-1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. mark all negative numbers and all numbers larger than n as 0\n        # 2. iterate through the array and mark the numbers as negative\n        # 3. iterate through the array again and return the first number that is not negative\n        # 4. if all numbers are negative, return n + 1\n        \n        n = len(nums)\n        \n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 2. calculate the kth permutation\n        k -= 1\n        res = \"\"\n        for i in range(n, 0, -1):\n            # 2.1 calculate the number of permutations that can be chosen from the remaining numbers\n            num = k // fact\n            # 2.2 calculate the digit that will be chosen\n            k = k % fact\n            # 2.3 add the digit to the result\n            res += str(i)\n            # 2.4 remove the digit from the remaining numbers\n            if num > 0:\n                res += str(i - 1)\n                num -= 1\n            # 2.5 update the factorial\n            fact = fact // (i - 1)\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the numbers and their indices\n        num_dict = {}\n        \n        # iterate through the numbers list\n        for i, num in enumerate(numbers):\n            # check if the difference between the target and the current number is in the dictionary\n            if target - num in num_dict:\n                # return the indices of the two numbers\n                return [num_dict[target - num] + 1, i + 1]\n            # add the number to the dictionary with its index\n            num_dict[num] = i"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            if curr != 0:\n                backtrack(i + 1, curr * 10 + int(num[i]), prev * 10 + int(num[i]), res, op + '*' + num[i])\n                backtrack(i + 1, curr, prev, res, op + '+' + num[i])\n                backtrack(i + 1, curr, prev, res, op + '-' + num[i])\n            else:\n                backtrack(i + 1, int(num[i]), int(num[i]), res, op + num[i])\n                if i < len(num) - 1:\n                    backtrack(i + 2, int(num[i:i + 2]), int(num[i:i + 2]), res, op + '+' + num[i:i + 2])\n                    backtrack(i + 2, int(num[i:i + 2]), -int(num[i:i + 2]), res, op + '-' + num[i:i + 2])\n                    backtrack(i + 2, int(num[i:i + 2]), int(num[i:i + 2]), res, op + '*' + num[i:i + 2])\n        \n        res = []\n        backtrack(0, 0, 0, res, '')\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in en.umerate(nums):\n                while out and out[-1] < n and len(out) + len(nums) - i > k:\n                    out.pop()\n                if len(out) < k:\n                    out.append(n)\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while nums1 or nums2:\n                if not nums2:\n                    return nums1\n                if not nums1:\n                    return nums2\n                if nums1[0] > nums2[0]:\n                    out.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    out.append(nums2[0])\n                    nums2 = nums2[1:]\n            return out\n        \n        return max(merge(pick(nums1, i), pick(nums2, k - i)) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if num / i == i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if i == m - 1 and j == n - 1:\n                    dp[i][j] = max(1 - dungeon[i][j], 1)\n                elif i == m - 1:\n                    dp[i][j] = max(dp[i][j + 1] - dungeon[i][j], 1)\n                elif j == n - 1:\n                    dp[i][j] = max(dp[i + 1][j] - dungeon[i][j], 1)\n                else:\n                    dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            m = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while nums[i] - nums[j] > m:\n                    j += 1\n                cnt += i - j\n            if cnt >= k:\n                r = m\n            else:\n                l = m + 1\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        left, right = 0, len(s) - 1\n        while left < right:\n            while left < right and s[left] not in vowels:\n                left += 1\n            while left < right and s[right] not in vowels:\n                right -= 1\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_num = num\n                curr_len = 1\n                \n                while curr_num + 1 in nums_set:\n                    curr_num += 1\n                    curr_len += 1\n                    \n                max_len = max(max_len, curr_len)\n                \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 100 ms, faster than 99.88% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.9 MB, less than 99.88% of Python online submissions for Missing Number.\n        \n        ##"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(N * 26^L)\n        # Space: O(N)\n        if endWord not in wordList:\n            return 0\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i+1:]\n                    if next_word == endWord:\n                        return length + 1\n                    if next_word in wordList:\n                        queue.append((next_word, length + 1))\n                        wordList.remove(next_word)\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        res = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1':\n                carry += 1\n            if b[i] == '1':\n                carry += 1\n            if carry % 2 == 1:\n                res = '1' + res\n            else:\n                res = '0' + res\n            carry //= 2\n        if carry == 1:\n            res = '1' + res\n        return res"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return [-1, -1]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        if nums[left] != target:\n            return [-1, -1]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right + 1) // 2\n            if nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid\n        \n        return [left, right]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        cur_reach = 0\n        \n        for i in range(n):\n            if i > cur_reach:\n                jumps += 1\n                cur_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(0, len(prices)-1)) for i in range(0, len(prices)-1, 2))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(1, len(prices)):\n            for j in range(1, k+1):\n                dp[j][0] = max(dp[j][0], dp[j-1][1] + prices[i])\n                dp[j][1] = max(dp[j][1], dp[j][0] - prices[i])\n        \n        return dp[k][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        hex_dict = {10: \"a\", 11: \"b\", 12: \"c\", 13: \"d\", 14: \"e\", 15: \"f\"}\n        hex_list = []\n        if num < 0:\n            num = 2 ** 32 + num\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = \"\"\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a hashmap to store the frequency of each character\n        # create a list to store the indices of the first unique character\n        # iterate through the string and for each character, check if it is in the hashmap\n        # if it is, remove it from the hashmap and add its index to the list\n        # if it is not, add it to the hashmap with a frequency of 1\n        # if the list is empty, return -1\n        # if the list has more than one element, return the first element\n        \n        # create a hashmap to store the frequency of each character\n        hashmap = {}\n        # create a list to store the indices of the first unique character\n        list = []\n        \n        # iterate through the string and for each character, check if it is in the hashmap\n        for i, c in en.umerate(s):\n            if c in hashmap:\n                # if it is, remove it from the hashmap and add its index to the list\n                hashmap.pop(c)\n                list.remove(i)\n            else:\n                # if it is not, add it to the hashmap with a frequency of 1\n                hashmap[c] = 1\n                # add its index to the list\n                list.append(i)\n        \n        # if the list is empty, return -1\n        if len(list) == 0:\n            return -1\n        # if the list has more than one element, return the first element\n        else:\n            return list[0]"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        curr_count = 0\n        \n        for i in nums:\n            if i == 1:\n                curr_count += 1\n            else:\n                curr_count = 0\n            max_count = max(max_count, curr_count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1, num2 = list(num1), list(num2)\n        \n        carry = 0\n        for i in range(len(num1)):\n            num1[i] = int(num1[i])\n            num2[i] = int(num2[i])\n            sum = num1[i] + num2[i] + carry\n            carry = sum // 10\n            num1[i] = sum % 10\n        \n        for i in range(len(num1), len(num2)):\n            num2[i] = int(num2[i])\n            sum = num2[i] + carry\n            carry = sum // 10\n            num2[i] = sum % 10\n        \n        if carry:\n            num2.append(carry)\n        \n        return ''.join(map(str, num2))"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = '+'\n        for i in range(len(s)):\n            if s[i].isdigit():\n                num = num * 10 + int(s[i])\n            if s[i] in '+-' or i == len(s) - 1:\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    stack.append(int(stack.pop() / num))\n                sign = s[i]\n                num = 0\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, add to capital\n        # else, add to profits\n        \n        # sort capital and profits\n        # for"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '{':\n                stack.append('}')\n            elif i == '[':\n                stack.append(']')\n            elif stack and stack[-1] == i:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index exists, then the array is already in descending order\n        if i == -1:\n            return nums.reverse()\n        \n        # find the first index j such that nums[j] > nums[i]\n        j = len(nums) - 1\n        while nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the subarray nums[i+1:]\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k == 0:\n            return False\n        \n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        \n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[0] == nums[2]\n        \n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[0] == nums[3]\n        \n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[0] == nums[4]\n        \n        if len(nums) == 6:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[0] == nums[5]\n        \n        if len(nums) == 7:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[0] == nums[6]\n        \n        if len(nums) == 8:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[0] == nums[7]\n        \n        if len(nums) == 9:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[0] == nums[8]\n        \n        if len(nums) == 10:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[0] == nums[9]\n        \n        if len(nums) == 11:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[9] == nums[10] or nums[0] == nums[10]\n        \n        if len(nums) == 12:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        swaps = 0\n        for i in range(0, n, 2):\n            if couples[i][0] != couples[i+1][0] and couples[i][1] != couples[i+1][1]:\n                couples[i+1] = couples[i]\n                swaps += 1\n        \n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        \n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set('qwertyuiop')\n        row2 = set('asdfghjkl')\n        row3 = set('zxcvbnm')\n        \n        ans = []\n        for word in words:\n            if word[0] in row1:\n                r = row1\n            elif word[0] in row2:\n                r = row2\n            else:\n                r = row3\n            for c in word:\n                if c not in r:\n                    break\n            else:\n                ans.append(word)\n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for i in range(left - 1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right - left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # if the string is a palindrome, then the longest palindrome will be the same as the string\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is not a palindrome, then the longest palindrome will be the reverse of the string\n        # with the first character removed\n        # if the string is a pal"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return t\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        \n        while right < len(s):\n            if s[right] in t_dict:\n                if s_dict[s[right]] > t_dict[s[right]]:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] -= 1\n                    left += 1\n            right += 1\n        \n        while left < len(s):\n            if right - left < min_len:\n                min_len = right - left\n                min_left = left\n                min_right = right\n            if s[left] in t_dict:\n                if s_dict[s[left]] < t_dict[s[left]]:\n                    s_dict[s[left]] += 1\n                else:\n                    s_dict[s[left]] += 1\n                    left += 1\n            else:\n                left += 1\n        \n        return s[min_left:min_right]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] == distance[i - 3] and distance[i - 1] == distance[i - 4]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 6 and distance[i] + distance[i - 5] >= distance[i - 2] and distance[i - 2] == distance[i - 4] and distance[i - 1] == distance[i - 3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a hashmap to store the frequency of each character\n        # 2. iterate through the hashmap and add the max of odd and even to the result\n        # 3. if the hashmap has a value of 1, add 1 to the result\n        # 4. return the result\n        \n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        result = 0\n        for key in hashmap:\n            if hashmap[key] % 2 == 0:\n                result += hashmap[key]\n            else:\n                result += hashmap[key] - 1\n        \n        if result < len(s):\n            result += 1\n        \n        return result"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    x, y = q.pop(0)\n                    if (x, y) == end:\n                        return steps\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and forest[nx][ny] > 0 and (nx, ny) not in visited:\n                            q.append((nx, ny))\n                            visited.add((nx, ny))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = [(forest[i][j], i, j) for i in range(m) for j in range(n) if forest[i][j] > 1]\n        trees.sort(key=lambda x: x[0])\n        steps = 0\n        for i, j in trees:\n            steps += bfs((0, 0), (i, j))\n            if steps < 0:\n                return steps\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u524d\u7f00\u548c\n        # 2. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 3. \u4f7f\u7528\u54c8\u5e0c\u8868\n        # 4. \u4f7f\u7528\u53cc\u6307\u9488\n        # 5. \u4f7f\u7528\u5f52\u5e76\u6392\u5e8f\n        # 6. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 7. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 8. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 9. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 10. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 11. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 12. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 13. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 14. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 15. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 16. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 17. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 18. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 19. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 20. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 21. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 22. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 23. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 24. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 25. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 26. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 27. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 28. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 29. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 30. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 31. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 32. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 33. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 34. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 35. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 36. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 37. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 38. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 39. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 40. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 41. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 42. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 43. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 44. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 45. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 46. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 47. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 48. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 49. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 50. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 51. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 52. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 53. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 54. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 55. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 56. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 57. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 58. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 59. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 60. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 61. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 62. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 63. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 64. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 65. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 66. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 67. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 68. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 69. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 70. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 71. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 72. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 73. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 74. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 75. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 76. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 77. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 78. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 79. \u4f7f\u7528\u4e8c\u5206\u67e5\u627e\n        # 80. \u4f7f\u7528"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2 * n + 0.25) ** 0.5 - 0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0, 1]\n        \n        res = [0, 1]\n        for i in range(1, n):\n            res += [res[i] + (1 << i)]\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (left and node.val <= left.val) or (right and node.val >= right.val):\n                return False\n            \n            return valid(node.left, left, node) and valid(node.right, node, right)\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element in the list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element in the list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element in the list, merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element in the list, merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any elements in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of all the numbers in the list\n        # 2. find the range of the list\n        # 3. find the range of the remaining lists\n        # 4. find the range of the remaining lists\n        # 5. find the range of the remaining lists\n        # 6. find the range of the remaining lists\n        # 7. find the range of the remaining lists\n        # 8. find the range of the remaining lists\n        # 9. find the range of the remaining lists\n        # 10. find the range of the remaining lists\n        # 11. find the range of the remaining lists\n        # 12. find the range of the remaining lists\n        # 13. find the range of the remaining lists\n        # 14. find the range of the remaining lists\n        # 15. find the range of the remaining lists\n        # 16. find the range of the remaining lists\n        # 17. find the range of the remaining lists\n        # 18. find the range of the remaining lists\n        # 19. find the range of the remaining lists\n        # 20. find the range of the remaining lists\n        # 21. find the range of the remaining lists\n        # 22. find the range of the remaining lists\n        # 23. find the range of the remaining lists\n        # 24. find the range of the remaining lists\n        # 25. find the range of the remaining lists\n        # 26. find the range of the remaining lists\n        # 27. find the range of the remaining lists\n        # 28. find the range of the remaining lists\n        # 29. find the range of the remaining lists\n        # 30. find the range of the remaining lists\n        # 31. find the range of the remaining lists\n        # 32. find the range of the remaining lists\n        # 33. find the range of the remaining lists\n        # 34. find the range of the remaining lists\n        # 35. find the range of the remaining lists\n        # 36. find the range of the remaining lists\n        # 37. find the range of the remaining lists\n        # 38. find the range of the remaining lists\n        # 39. find the range of the remaining lists\n        # 40. find the range of the remaining lists\n        # 41. find the range of the remaining lists\n        # 42. find the range of the remaining lists\n        # 43. find the range of the remaining lists\n        # 44. find the range of the remaining lists\n        # 45. find the range of the remaining lists\n        # 46. find the range of the remaining lists\n        # 47. find the range of the remaining lists\n        # 48. find the range of the remaining lists\n        # 49. find the range of the remaining lists\n        # 50. find the range of the remaining lists\n        # 51. find the range of the remaining lists\n        # 52. find the range of the remaining lists\n        # 53. find the range of the remaining lists\n        # 54. find the range of the remaining lists\n        # 55. find the range of the remaining lists\n        # 56. find the range of the remaining lists\n        # 57. find the range of the remaining lists\n        # 58. find the range of the remaining lists\n        # 59. find the range of the remaining lists\n        # 60. find the range of the remaining lists\n        # 61. find the range of the remaining lists\n        # 62. find the range of the remaining lists\n        # 63. find the range of the remaining lists\n        # 64. find the range of the remaining lists\n        # 65. find the range of the remaining lists\n        # 66. find the range of the remaining lists\n        # 67. find the range of the remaining lists\n        # 68. find the range of the remaining lists\n        # 69. find the range of the remaining lists\n        # 70. find the range of the remaining lists\n        # 71. find the range of the remaining lists\n        # 72. find the range of the remaining lists\n        # 73. find the range of the remaining lists\n        # 74. find"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 2. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 3. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 4. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 5. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 6. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 7. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 8. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 9. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 10. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 11. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 12. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 13. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 14. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 15. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 16. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128 pig, 256 pig, 512 pig, 1024 pig\n        # 17. 1 pig, 2 pig, 4 pig, 8 pig, 16 pig, 32 pig, 64 pig, 128"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set()\n        seen.add((0, 0))\n        ans = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            ans = max(ans, t)\n            if i == j == n - 1:\n                return ans\n            for ni, nj in ((i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)):\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    seen.add((ni, nj))\n        return ans"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D array\n        # 2. 1D array\n        # 3. DP\n        # 4. Math\n        # 5. BFS\n        # 6. DFS\n        # 7. Greedy\n        # 8. Backtracking\n        # 9. Bit Manipulation\n        # 10. Math\n        # 11. Math\n        # 12. Math\n        # 13. Math\n        # 14. Math\n        # 15. Math\n        # 16. Math\n        # 17. Math\n        # 18. Math\n        # 19. Math\n        # 20. Math\n        # 21. Math\n        # 22. Math\n        # 23. Math\n        # 24. Math\n        # 25. Math\n        # 26. Math\n        # 27. Math\n        # 28. Math\n        # 29. Math\n        # 30. Math\n        # 31. Math\n        # 32. Math\n        # 33. Math\n        # 34. Math\n        # 35. Math\n        # 36. Math\n        # 37. Math\n        # 38. Math\n        # 39. Math\n        # 40. Math\n        # 41. Math\n        # 42. Math\n        # 43. Math\n        # 44. Math\n        # 45. Math\n        # 46. Math\n        # 47. Math\n        # 48. Math\n        # 49. Math\n        # 50. Math\n        # 51. Math\n        # 52. Math\n        # 53. Math\n        # 54. Math\n        # 55. Math\n        # 56. Math\n        # 57. Math\n        # 58. Math\n        # 59. Math\n        # 60. Math\n        # 61. Math\n        # 62. Math\n        # 63. Math\n        # 64. Math\n        # 65. Math\n        # 66. Math\n        # 67. Math\n        # 68. Math\n        # 69. Math\n        # 70. Math\n        # 71. Math\n        # 72. Math\n        # 73. Math\n        # 74. Math\n        # 75. Math\n        # 76. Math\n        # 77. Math\n        # 78. Math\n        # 79. Math\n        # 80. Math\n        # 81. Math\n        # 82. Math\n        # 83. Math\n        # 84. Math\n        # 85. Math\n        # 86. Math\n        # 87. Math\n        # 88. Math\n        # 89. Math\n        # 90. Math\n        # 91. Math\n        # 92. Math\n        # 93. Math\n        # 94. Math\n        # 95. Math\n        # 96. Math\n        # 97. Math\n        # 98. Math\n        # 99. Math\n        # 100. Math\n        # 101. Math\n        # 102. Math\n        # 103. Math\n        # 104. Math\n        # 105. Math\n        # 106. Math\n        # 107. Math\n        # 108. Math\n        # 109. Math\n        # 110. Math\n        # 111. Math\n        # 112. Math\n        # 113. Math\n        # 114. Math\n        # 115. Math\n        # 116. Math\n        # 117. Math\n        # 118. Math\n        # 119. Math\n        # 120. Math\n        # 121. Math\n        # 122. Math\n        # 123. Math\n        # 124. Math"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                res[i+j+1] += res[i+j] // 10\n                res[i+j] %= 10\n        \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) - 1 and res[i] == 0:\n            i += 1\n        \n        return ''.join(map(str, res[i:]))"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max profit from left to right\n        # 2. find the max profit from right to left\n        # 3. return the max of the two\n        \n        # 1. find the max profit from left to right\n        max_profit = 0\n        min_price = prices[0]\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, nums, target, start, path, res):\n        if target < 0:\n            return\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums, target - nums[i], i + 1, path + [nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        min_price = float('inf')\n        max_profit = 0\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        while root or stack:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                root = stack.pop()\n                result.append(root.val)\n                root = root.right\n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            cnt = 0\n            for c in s:\n                if c == '(':\n                    cnt += 1\n                elif c == ')':\n                    if cnt > 0:\n                        cnt -= 1\n                    else:\n                        return False\n            return cnt == 0\n        \n        q = collections.deque([s])\n        seen = {s}\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\n                mergedLists.append(self.mergeTwoLists(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeTwoLists(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with k zeros\n        # 2. find the last number with k zeros\n        # 3. return the difference\n        \n        # 1. find the first number with"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a dict to store the index of each word\n        word_dict = {word: i for i, word in enumerate(words)}\n        \n        # create a list to store the result\n        result = []\n        \n        # iterate over the words\n        for i, word in enumerate(words):\n            # reverse the word\n            rev_word = word[::-1]\n            \n            # check if the reversed word is a palindrome\n            if rev_word in word_dict:\n                # if it is, check if the index of the reversed word is not the same as the current word\n                if i != word_dict[rev_word]:\n                    # if it is, add the pair to the result\n                    result.append([i, word_dict[rev_word]])\n            \n            # check if the reversed word is a palindrome\n            for j in range(len(word) + 1):\n                # reverse the substring of the word\n                rev_sub_word = word[:len(word) - j]\n                \n                # check if the reversed substring is a palindrome\n                if rev_sub_word in word_dict and word_dict[rev_sub_word] != i:\n                    # if it is, add the pair to the result\n                    result.append([i, word_dict[rev_sub_word]])\n        \n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                res += 1\n                for i, j in infected:\n                    isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n            return res\n        \n        return len(isInfected) * len(isInfected[0]) - spread(isInfected) - spread(list(zip(*isInfected)))"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n <= 0:\n            return 0\n        \n        if n < 10:\n            return 1\n        \n        if n < 100:\n            return 10\n        \n        if n < 1000:\n            return 100\n        \n        if n < 10000:\n            return 1000\n        \n        if n < 100000:\n            return 10000\n        \n        if n < 1000000:\n            return 100000\n        \n        if n < 10000000:\n            return 1000000\n        \n        if n < 100000000:\n            return 10000000\n        \n        if n < 1000000000:\n            return 100000000\n        \n        if n < 10000000000:\n            return 1000000000\n        \n        if n < 100000000000:\n            return 10000000000\n        \n        if n < 1000000000000:\n            return 100000000000\n        \n        if n < 10000000000000:\n            return 1000000000000\n        \n        if n < 100000000000000:\n            return 10000000000000\n        \n        if n < 1000000000000000:\n            return 100000000000000\n        \n        if n < 10000000000000000:\n            return 1000000000000000\n        \n        if n < 100000000000000000:\n            return 10000000000000000\n        \n        if n < 1000000000000000000:\n            return 100000000000000000\n        \n        if n < 10000000000000000000:\n            return 1000000000000000000\n        \n        if n < 100000000000000000000:\n            return 10000000000000000000\n        \n        if n < 1000000000000000000000:\n            return 100000000000000000000\n        \n        if n < 10000000000000000000000:\n            return 1000000000000000000000\n        \n        if n < 100000000000000000000000:\n            return 10000000000000000000000\n        \n        if n < 1000000000000000000000000:\n            return 100000000000000000000000\n        \n        if n < 10000000000000000000000000:\n            return 1000000000000000000000000\n        \n        if n < 100000000000000000000000000:\n            return"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n                    break\n        \n        if dp[-1]:\n            return [s[:i + 1] for i in range(len(s)) if dp[i + 1]]\n        else:\n            return []"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        left_to_right = True\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                if left_to_right:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            result.append(level)\n            left_to_right = not left_to_right\n            \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return \"%d:%02d\" % (h, m)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m - 1), get_time(h + 2, m - 2), get_time(h + 3, m - 3), get_time(h + 4, m - 4), get_time(h + 5, m - 5), get_time(h + 6, m - 6), get_time(h + 7, m - 7), get_time(h + 8, m - 8), get_time(h + 9, m - 9)]\n        \n        if turnedOn == 0:\n            return [get_time(0, 0)]\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h) + bin(m)).count('1') == turnedOn:\n                    res.extend(get_times(h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            if (i, j) not in seen:\n                seen.add((i, j))\n                ans += h\n                for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                        heapq.heappush(heap, (max(h, heightMap[ni][nj]), ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the result list\n        result = []\n        \n        # 2. Initialize the window\n        window = nums[:k]\n        \n        # 3. Calculate the median\n        median = self.calculateMedian(window)\n        \n        # 4. Add the median to the result list\n        result.append(median)\n        \n        # 5. Iterate over the remaining elements\n        for i in range(k, len(nums)):\n            # 6. Remove the leftmost element from the window\n            window.pop(0)\n            \n            # 7. Add the new element to the window\n            window.append(nums[i])\n            \n            # 8. Calculate the median\n            median = self.calculateMedian(window)\n            \n            # 9. Add the median to the result list\n            result.append(median)\n        \n        # 10. Return the result list\n        return result\n    \n    def calculateMedian(self, window):\n        # 1. Sort the window\n        window.sort()\n        \n        # 2. Calculate the median\n        if len(window) % 2 == 0:\n            # 3. If the window is even, return the mean of the two middle elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0\n        else:\n            # 4. If the window is odd, return the middle element\n            return window[len(window) // 2]"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        curr = head\n        for _ in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        while n % 3 == 0:\n            n = n / 3\n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        \n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                sums.sort()\n                res = max(res, self.maxSumSubarray(sums, k))\n                if res == k:\n                    return res\n        return res\n    \n    def maxSumSubarray(self, sums, k):\n        res = float('-inf')\n        s = 0\n        for i in range(len(sums)):\n            s += sums[i]\n            if s == k:\n                return k\n            if s > k:\n                res = max(res, s)\n            if s < 0:\n                s = 0\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend / divisor)\n        \n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend) / abs(divisor))\n        \n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend) / abs(divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend) / abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        nums_dict = {}\n        \n        # iterate through the list\n        for i, num in enumerate(nums):\n            # check if the complement is in the dictionary\n            complement = target - num\n            if complement in nums_dict:\n                # if it is, return the index of the complement and the index of the current number\n                return [nums_dict[complement], i]\n            # if it is not, add the current number to the dictionary\n            nums_dict[num] = i\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        return None"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 1e-6\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_a, new_b = a + b, a - b\n                            elif op == '-':\n                                new_a, new_b = a - b, b - a\n                            elif op == '*':\n                                new_a, new_b = a * b, a / b\n                            else:\n                                new_a, new_b = b / a, a / b\n                            if new_b > 1e-6 and backtrack([new_a] + cards[0:i] + cards[i+1:j] + cards[j+1:], new_b):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:])\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if p[0] == s[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in sorted(tickets):\n            graph[from_city].append(to_city)\n        \n        # dfs\n        route = []\n        def dfs(from_city):\n            # if there is no connection, add to the route\n            if from_city not in graph:\n                return\n            # if there is no connection, add to the route\n            to_city = graph[from_city].pop()\n            dfs(to_city)\n            # add to the route\n            route.append(from_city)\n        \n        dfs(\"JFK\")\n        return route[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. sort the buildings by left edge\n        # 2. use a priority queue to store the heights of the buildings\n        # 3. iterate over the buildings\n        # 4. if the current building is taller than the top of the priority queue, add it to the queue\n        # 5. if the current building is shorter than the top of the priority queue, pop it\n        # 6. if the queue is empty, add 0 to the result\n        # 7. if the queue is not empty, add the top of the queue to the result\n        \n        # 1. sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # 2. use a priority queue to store the heights of the buildings\n        pq = []\n        \n        # 3. iterate over the buildings\n        for l, r, h in buildings:\n            \n            # 4. if the current building is taller than the top of the priority queue, add it to the queue\n            if h > pq[0][0]:\n                heapq.heappush(pq, (h, r))\n                \n            # 5. if the current building is shorter than the top of the priority queue, pop it\n            else:\n                while pq and pq[0][0] <= h:\n                    heapq.heappop(pq)\n                    \n            # 6. if the queue is empty, add 0 to the result\n            if not pq:\n                heapq.heappush(pq, (0, l))\n                \n            # 7. if the queue is not empty, add the top of the queue to the result\n            else:\n                heapq.heappush(pq, (pq[0][0], l))\n                \n        # 8. return the result\n        return [(pq[0][1], pq[0][0])] + [heapq.heappop(pq) for _ in range(len(pq) - 1)]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i] + dp[i-2][j-i+1] - dp[i-3][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i] + dp[i-2][j-i+1] - dp[i-3][j-i] + dp[i-3][j-i+1] - dp[i-3][j-i+2] + ... + dp[i-3][j-i+k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i] + dp[i-2][j-i+1] - dp[i-3][j-i] + dp[i-3][j-i+1] - dp[i-3][j-i+2] + ... + dp[i-3][j-i+k] + dp[i-3][j-i+k+1] - dp[i-4][j-i+k] + dp[i-4][j-i+k+1] - dp[i-4][j-i+k+2] + ... + dp[i-4][j-i+k+k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-1][j-2] + dp[i-2][j-2] - dp[i-2][j-3] + ... + dp[i-2][j-i] + dp[i-2][j-i+1] - dp[i-3][j-i] + dp[i-3][j-i+1] - dp[i-3][j-i+2] + ... + dp[i-3][j-i+k] + dp[i-3][j-i+k+1] - dp[i-4][j-i+k] + dp[i-4][j-i+k+1] - dp[i-4][j-i+k+2] + ... + dp[i-4][j-i+k+k] + dp[i-4][j-i+k+k+1] - dp[i-5][j-i+k+k] + dp[i-5][j-i+k+k+1] - dp[i-5][j-i+k+k+2] + ... + dp[i-5][j-i+k+k+k]\n        # dp[i][j] = dp[i-1][j] + dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the edge that connects the two parents\n        # 3. find the node that has only one parent\n        # 4. return the edge that connects the two parents\n        \n        # 1. find the node with two parents\n        parent_map = {}\n        for edge in edges:\n            if edge[0] in parent_map:\n                parent_map[edge[0]].append(edge[1])\n            else:\n                parent_map[edge[0]] = [edge[1]]\n        \n        # 2. find the edge that connects the two parents\n        for edge in edges:\n            if edge[1] in parent_map and edge[0] in parent_map[edge[1]]:\n                return edge\n        \n        # 3. find the node that has only one parent\n        for edge in edges:\n            if len(parent_map[edge[1]]) == 1:\n                return edge\n        \n        # 4. return the edge that connects the two parents\n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            else:\n                for i in range(first, n):\n                    if nums[i] not in used:\n                        used.add(nums[i])\n                        nums[first], nums[i] = nums[i], nums[first]\n                        backtrack(first + 1)\n                        nums[first], nums[i] = nums[i], nums[first]\n        n = len(nums)\n        res = []\n        used = set()\n        backtrack()\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        return 2*sum(set(nums))-sum(nums)"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j1 in range(n):\n                for j2 in range(n):\n                    p1 = max(j1 - 1, 0)\n                    p2 = min(j1 + 1, n - 1)\n                    p3 = max(j2 - 1, 0)\n                    p4 = min(j2 + 1, n - 1)\n                    if grid[i][j1] == -1 or grid[i][j2] == -1:\n                        dp[i][j1][j2] = dp[i - 1][j1][j2]\n                    elif j1 == j2:\n                        dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1]\n                    else:\n                        dp[i][j1][j2] = dp[i - 1][j1][j2] + grid[i][j1] + grid[i][j2]\n                    if j1 != j2:\n                        dp[i][j1][j2] = max(dp[i][j1][j2], dp[i - 1][p1][p2] + dp[i - 1][p3][p4])\n        return max(dp[n - 1][j1][j2] for j1 in range(n) for j2 in range(n) if grid[n - 1][j1] * grid[n - 1][j2] > 0)"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '11131221133112132132221'\n        \n        if n == 12:\n            return '311311222123213221131112311312211'\n        \n        if n == 13:\n            return '1321131112311311221123123112111312211'\n        \n        if n == 14:\n            return '111312211331121321322212311312211231131122211'\n        \n        if n == 15:\n            return '311311222123213221131112311312211231131122211231131112311312211'\n        \n        if n == 16:\n            return '1321131112311311221123123112111312211231131122211231131112311312211231131112311312211'\n        \n        if n == 17:\n            return '111312211331121321322212311312211231131122211231131112311312211231131122211231131112311312211231131112311312211'\n        \n        if n == 18:\n            return '311311222123213221131112311312211231131122211231131112311312211231131122211231131112311312211231131112311312211231131112311312211'\n        \n        if n == 19:\n            return '1321131112311311221123123112111312211231131122211231131112311312211231131122211231131112311312211231131112311312211231131112311312211'\n        \n        if n == 20:\n            return '11131"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        # else, decrease the max sum\n        # return the max sum\n        \n        # binary search\n        # find the max sum of the subarray\n        # if the sum is less than the max sum, then increase the max sum\n        #"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        # if the pivot point is not found, return -1\n        # if the pivot point is found, use binary search to find the target\n        # if the target is found, return the index\n        # if the target is not found, return -1\n        \n        # find the pivot point\n        pivot = self.find_pivot(nums)\n        \n        # if the pivot point is not found, return -1\n        if pivot == -1:\n            return -1\n        \n        # if the target is found, return the index\n        if nums[pivot] == target:\n            return pivot\n        \n        # if the target is not found, return -1\n        return -1\n        \n    def find_pivot(self, nums):\n        # find the pivot point\n        # if the pivot point is not found, return -1\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index\n        # if the pivot point is found, return the index"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def backtrack(combination, next_digits, mapping):\n            if len(next_digits) == 0:\n                combinations.append(combination)\n            else:\n                for letter in mapping[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:], mapping)\n        \n        combinations = []\n        backtrack(\"\", digits, mapping)\n        return combinations"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur[:])\n                return\n            if i >= len(candidates) or total > target:\n                return\n            cur.append(candidates[i])\n            dfs(i, cur, total + candidates[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n        dfs(0, [], 0)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of n\n        length = len(n)\n        \n        # 2. get the left and right part of n\n        left = n[:length//2]\n        right = n[length//2:]\n        \n        # 3. get the list of all possible palindromes\n        palindromes = [int(left + right), int(left + \"0\" + right[::-1]), int(left + \"1\" + right[1:]), int(left + \"9\" + right[1:])]\n        \n        # 4. get the closest palindrome\n        closest = min(palindromes, key=lambda x: abs(x - int(n)))\n        \n        # 5. return the closest palindrome\n        return str(closest)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        else:\n            return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n // 2):\n                matrix[i][j], matrix[i][n - j - 1] = matrix[i][n - j - 1], matrix[i][j]"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        result = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max_prod * nums[i]\n            curr_min = min_prod * nums[i]\n            \n            max_prod = max(nums[i], curr_max, curr_min)\n            min_prod = min(nums[i], curr_max, curr_min)\n            \n            result = max(result, max_prod)\n            \n        return result"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        dp = {stones[0]:set([1])}\n        \n        for stone in stones[1:]:\n            for prev in dp.get(stone - 1, set()):\n                dp.setdefault(stone + prev, set())\n                dp[stone + prev].add(prev)\n                dp[stone + prev].add(prev + 1)\n                if prev > 1:\n                    dp[stone + prev].add(prev - 1)\n        \n        return len(dp[stones[-1]]) > 0"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary\n        score_dict = {}\n        for i, s in enumerate(score_sorted):\n            score_dict[s] = i + 1\n        \n        # create the output list\n        output = []\n        for s in score:\n            output.append(str(score_dict[s]))\n        \n        # replace the medals\n        for i, s in enumerate(output):\n            if s == '1':\n                output[i] = 'Gold Medal'\n            elif s == '2':\n                output[i] = 'Silver Medal'\n            elif s == '3':\n                output[i] = 'Bronze Medal'\n        \n        return output"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        curr_str = ''\n        \n        for i in range(len(s)):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n            else:\n                max_len = max(max_len, curr_len)\n                curr_str = curr_str[curr_str.index(s[i])+1:] + s[i]\n                curr_len = len(curr_str)\n        \n        return max(max_len, curr_len)"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = collections.Counter(words)\n        res = []\n        \n        for i in range(word_len):\n            left = i\n            word_dict_copy = word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                else:\n                    left = j + word_len\n                    word_dict_copy = word_dict.copy()\n                if not word_dict_copy:\n                    res.append(left)\n        \n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = max(arr)\n        max_idx = arr.index(max_val)\n        max_cnt = 1\n        \n        for i in range(max_idx):\n            if arr[i] > max_val:\n                max_val = arr[i]\n                max_cnt += 1\n        \n        return max_cnt"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        left = self.binaryTreePaths(root.left)\n        right = self.binaryTreePaths(root.right)\n        \n        return [str(root.val) + '->' + path for path in left + right]"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            for k in range(left, right + 1):\n                if i == mid + 1:\n                    nums[k] = nums[j]\n                    j += 1\n                elif j == right + 1:\n                    nums[k] = nums[i]\n                    i += 1\n                elif nums[i] > 2 * nums[j]:\n                    count += mid - i + 1\n                    nums[k] = nums[j]\n                    j += 1\n                else:\n                    nums[k] = nums[i]\n                    i += 1\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left < right:\n                mid = (left + right) // 2\n                count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n                count += merge(nums, left, mid, right)\n                return count\n            return 0\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                if v1[i] > v2[i]:\n                    return 1\n                elif v1[i] < v2[i]:\n                    return -1\n            else:\n                if v2[i] > 0:\n                    return 1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for duration, end in courses:\n            # add course to queue\n            heapq.heappush(pq, duration)\n            \n            # add course to total\n            total += duration\n            \n            # if total exceeds end date, remove course from queue\n            if total > end:\n                total -= heapq.heappop(pq)\n                \n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while True:\n            kth = prev\n            for i in range(k):\n                if not kth:\n                    break\n                kth = kth.next\n            if not kth:\n                break\n            # reverse the nodes in the range\n            prev.next = self.reverse(prev.next, kth)\n            # move the prev pointer to the end of the reversed list\n            for i in range(k):\n                prev = prev.next\n        \n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = tail.next\n        curr = head\n        while True:\n            nxt = curr.next\n            curr.next = prev\n            if nxt == tail:\n                break\n            prev = curr\n            curr = nxt\n        return tail"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) < 2:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use a dictionary to store the count of each number\n        ## 2. iterate through the list and check if the count is 1\n        ## 3. if it is, return the number\n        \n        num_dict = {}\n        for num in nums:\n            if num not in num_dict:\n                num_dict[num] = 1\n            else:\n                num_dict[num] += 1\n        \n        for num in num_dict:\n            if num_dict[num] == 1:\n                return num"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min number of stickers needed to form target[0:i]\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp[j] + 1) for all stickers[j] in stickers\n        # dp[i] = min(dp"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1] + 1, dp[j][j])\n                    for k in range(i, j):\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return nums\n        \n        if k == 1:\n            return nums\n        \n        max_list = []\n        max_num = max(nums[0:k])\n        max_list.append(max_num)\n        \n        for i in range(k, len(nums)):\n            if max_num == nums[i - k]:\n                max_num = max(nums[i - k + 1:i + 1])\n            elif max_num < nums[i]:\n                max_num = nums[i]\n            max_list.append(max_num)\n        \n        return max_list"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2.0\n        else:\n            return nums1[len(nums1) // 2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[mid + 1]:\n        #         return nums[mid + 1]\n        #     if nums[mid - 1] > nums[mid]:\n        #         return nums[mid]\n        #     if nums[mid] < nums[right]:\n        #         right = mid - 1\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            if nums[mid] < nums[right]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,364,1001,2002,3003,3432,3003,2002,1001,364,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,441,1331,3003,5679,9248,12870,15472,16796,16796,15472,12870,9248,5679,3003,1331,441,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,495,1655,4164,8320,13271,20022,28792,38744,48828,58058,66438,66438,58058,48828,38744,28792,13271,4164,8320,1655,495,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,555,2205,6660,15555,31110,53333,80080,113313,142929,170070,194414,215800,234141,249242,261002,270270,276927,280882,282978,283185,281486,277871,272332,264867,255476,244159,230914,215740,198621,180"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59. 60. 61. 62. 63. 64. 65. 66. 67. 68. 69. 70. 71. 72. 73. 74. 75. 76. 77. 78. 79. 80. 81. 82. 83. 84. 85. 86. 87. 88. 89. 90. 91. 92. 93. 94. 95. 96. 97. 98. 99. 100. 101. 102. 103. 104. 105. 106. 107. 108. 109. 110. 111. 112. 113. 114. 115. 116. 117. 118. 119. 120. 121. 122. 123. 124. 125. 126. 127. 128. 129. 130. 131. 132. 133. 134. 135. 136. 137. 138. 139. 140. 141. 142. 143. 144. 145. 146. 147. 148. 149. 150. 151. 152. 153. 154. 155. 156. 157. 158. 159. 160. 161. 162. 163. 164. 165. 166. 167. 168. 169. 170. 171. 172. 173. 174. 175. 176. 177. 178. 179. 180. 181. 182. 183. 184. 185. 186. 187. 188. 189. 190. 191. 192. 193. 194. 195. 196. 197. 198. 199. 200. 201. 202. 203. 204. 205. 206. 207. 208. 209. 210. 211. 212. 213. 214. 215. 216. 217. 218. 219. 220. 221. 222. 223. 224. 225. 226."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"*\" + word[i+1:]].append(word)\n        \n        # build queue and visited\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        \n        # build result\n        result = []\n        while queue:\n            # get current level\n            level = []\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                if word == endWord:\n                    path = [endWord]\n                    while path[0] != beginWord:\n                        path.append(visited[path[0]])\n                    result.append(path[::-1])\n                for i in range(len(word)):\n                    for neighbor in graph[word[:i] + \"*\" + word[i+1:]]:\n                        if neighbor not in visited:\n                            visited[neighbor] = word\n                            queue.append(neighbor)\n                            level.append(neighbor)\n            if not level:\n                return result\n            graph = collections.defaultdict(list)\n            for word in level:\n                for i in range(len(word)):\n                    for neighbor in graph[word[:i] + \"*\" + word[i+1:]]:\n                        graph[word[:i] + \"*\" + word[i+1:]].append(neighbor)\n        return result"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ub41c \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c\ub2e4.\n        # 3. \uc624\ub978\ucabd \uac12\uc774 \uc791\uc744 \ub54c\uae4c\uc9c0 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ud55c \ud6c4 \uc624\ub978\ucabd \uac12\uc744 \uc81c\uac70\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                second = stack.pop()\n                first = stack.pop()\n                if token == \"+\":\n                    stack.append(first + second)\n                elif token == \"-\":\n                    stack.append(first - second)\n                elif token == \"*\":\n                    stack.append(first * second)\n                else:\n                    stack.append(int(float(first) / second))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if (x_min, y_min) not in rectangles or (x_max, y_min) not in rectangles or (x_min, y_max) not in rectangles or (x_max, y_max) not in rectangles:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = [0] * 12\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                board_1d[i * 3 + j] = board[i][j]\n        \n        # convert board_1d to a string\n        board_str = ''.join(str(x) for x in board_1d)\n        \n        # convert board_str to a tuple\n        board_tuple = tuple(board_str)\n        \n        # convert board_tuple to a set\n        board_set = set([board_tuple])\n        \n        # convert board_set to a list\n        board_list = list(board_set)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list\n        board_list = list(board_dict)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list\n        board_list = list(board_dict)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list\n        board_list = list(board_dict)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list\n        board_list = list(board_dict)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list\n        board_list = list(board_dict)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list\n        board_list = list(board_dict)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list\n        board_list = list(board_dict)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list\n        board_list = list(board_dict)\n        \n        # convert board_list to a dictionary\n        board_dict = {board_list[0]: 0}\n        \n        # convert board_dict to a queue\n        queue = collections.deque([board_dict])\n        \n        # convert board_dict to a set\n        visited = set()\n        \n        # convert board_dict to a list"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in the first half\n        if nums[pivot] == target:\n            return True\n        \n        # if the target is in the second half of the array, search in the second half\n        if nums[0] <= target:\n            return self.binary_search(nums, 0, pivot - 1, target)\n        \n        # if the target is not in the first half of the array, search in the second half\n        return self.binary_search(nums, pivot + 1, len(nums) - 1, target)\n    \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left\n    \n    def binary_search(self, nums, left, right, target):\n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                \n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                \n                if sum > target:\n                    r -= 1\n                else:\n                    l += 1\n        \n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        prev = None\n        min_diff = float('inf')\n        for n in inorder(root):\n            if prev:\n                min_diff = min(min_diff, n - prev)\n            prev = n\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return [0, float('-inf')]\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left[0] == right[0]:\n                return [left[0] + 1, root.val]\n            elif left[0] > right[0]:\n                return [left[0] + 1, left[1]]\n            else:\n                return [right[0] + 1, right[1]]\n        \n        return dfs(root)[1:]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if needle == \"\":\n            return 0\n        \n        if needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check length\n        if len(password) < 6:\n            return max(6 - len(password), 3)\n        if len(password) > 20:\n            return max(20 - len(password), 3)\n        \n        # 2. check for repeating characters\n        # 2.1 check for 3 repeating characters in a row\n        # 2.2 check for 2 repeating characters in a row\n        # 2.3 check for 1 repeating character in a row\n        # 2.4 check for 0 repeating characters in a row\n        # 2.5 check for 0 repeating characters in a row\n        # 2.6 check for 0 repeating characters in a row\n        # 2.7 check for 0 repeating characters in a row\n        # 2.8 check for 0 repeating characters in a row\n        # 2.9 check for 0 repeating characters in a row\n        # 2.10 check for 0 repeating characters in a row\n        # 2.11 check for 0 repeating characters in a row\n        # 2.12 check for 0 repeating characters in a row\n        # 2.13 check for 0 repeating characters in a row\n        # 2.14 check for 0 repeating characters in a row\n        # 2.15 check for 0 repeating characters in a row\n        # 2.16 check for 0 repeating characters in a row\n        # 2.17 check for 0 repeating characters in a row\n        # 2.18 check for 0 repeating characters in a row\n        # 2.19 check for 0 repeating characters in a row\n        # 2.20 check for 0 repeating characters in a row\n        # 2.21 check for 0 repeating characters in a row\n        # 2.22 check for 0 repeating characters in a row\n        # 2.23 check for 0 repeating characters in a row\n        # 2.24 check for 0 repeating characters in a row\n        # 2.25 check for 0 repeating characters in a row\n        # 2.26 check for 0 repeating characters in a row\n        # 2.27 check for 0 repeating characters in a row\n        # 2.28 check for 0 repeating characters in a row\n        # 2.29 check for 0 repeating characters in a row\n        # 2.30 check for 0 repeating characters in a row\n        # 2.31 check for 0 repeating characters in a row\n        # 2.32 check for 0 repeating characters in a row\n        # 2.33 check for 0 repeating characters in a row\n        # 2.34 check for 0 repeating characters in a row\n        # 2.35 check for 0 repeating characters in a row\n        # 2.36 check for 0 repeating characters in a row\n        # 2.37 check for 0 repeating characters in a row\n        # 2.38 check for 0 repeating characters in a row\n        # 2.39 check for 0 repeating characters in a row\n        # 2.40 check for 0 repeating characters in a row\n        # 2.41 check for 0 repeating characters in a row\n        # 2.42 check for 0 repeating characters in a row\n        # 2.43 check for 0 repeating characters in a row\n        # 2.44 check for 0 repeating characters in a row\n        # 2.45 check for 0 repeating characters in a row\n        # 2.46 check for 0 repeating characters in a row\n        # 2.47 check for 0 repeating characters in a row\n        # 2.48 check for 0 repeating characters in a row\n        # 2.49 check for 0 repeating characters in a row\n        # 2.50 check for 0 repeating characters in a row\n        # 2.51 check for 0 repeating characters in a row\n        # 2.52 check for 0 repeating characters in a row\n        # 2.53 check for 0 repeating characters in a row\n        # 2.54 check for 0 repeating characters in a row\n        # 2.55 check for 0 repeating characters in a row\n        # 2.56 check for 0 repeating characters in a row\n        # 2.57 check for 0"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        return n//5 + self.trailingZeroes(n//5)"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [''] * numRows\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return ''.join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3,4\n        ## 6. return water\n        \n        ## 2022-03-25\n        ## 1. find the max height of left and right\n        ## 2. find the min height of left and right\n        ## 3. find the water\n        ## 4. update left and right\n        ## 5. repeat 2,3"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            if nums[index] > 0:\n                nums[index] *= -1\n        \n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use binary search to find the number of smaller elements to the right\n        # 5. use binary search to find the number of smaller elements to the left\n        # 6. use binary search to find the number of smaller elements to the right\n        # 7. use binary search to find the number of smaller elements to the left\n        # 8. use binary search to find the number of smaller elements to the right\n        # 9. use binary search to find the number of smaller elements to the left\n        # 10. use binary search to find the number of smaller elements to the right\n        # 11. use binary search to find the number of smaller elements to the left\n        # 12. use binary search to find the number of smaller elements to the right\n        # 13. use binary search to find the number of smaller elements to the left\n        # 14. use binary search to find the number of smaller elements to the right\n        # 15. use binary search to find the number of smaller elements to the left\n        # 16. use binary search to find the number of smaller elements to the right\n        # 17. use binary search to find the number of smaller elements to the left\n        # 18. use binary search to find the number of smaller elements to the right\n        # 19. use binary search to find the number of smaller elements to the left\n        # 20. use binary search to find the number of smaller elements to the right\n        # 21. use binary search to find the number of smaller elements to the left\n        # 22. use binary search to find the number of smaller elements to the right\n        # 23. use binary search to find the number of smaller elements to the left\n        # 24. use binary search to find the number of smaller elements to the right\n        # 25. use binary search to find the number of smaller elements to the left\n        # 26. use binary search to find the number of smaller elements to the right\n        # 27. use binary search to find the number of smaller elements to the left\n        # 28. use binary search to find the number of smaller elements to the right\n        # 29. use binary search to find the number of smaller elements to the left\n        # 30. use binary search to find the number of smaller elements to the right\n        # 31. use binary search to find the number of smaller elements to the left\n        # 32. use binary search to find the number of smaller elements to the right\n        # 33. use binary search to find the number of smaller elements to the left\n        # 34. use binary search to find the number of smaller elements to the right\n        # 35. use binary search to find the number of smaller elements to the left\n        # 36. use binary search to find the number of smaller elements to the right\n        # 37. use binary search to find the number of smaller elements to the left\n        # 38. use binary search to find the number of smaller elements to the right\n        # 39. use binary search to find the number of smaller elements to the left\n        # 40. use binary search to find the number of smaller elements to the right\n        # 41. use binary search to find the number of smaller elements to the left\n        # 42. use binary search to find the number of smaller elements to the right\n        # 43. use binary search to find the number of smaller elements to the left\n        # 44. use binary search to find the number of smaller elements to the right\n        # 45. use binary search to find the number of smaller elements to the left\n        # 46. use binary search to find the number of smaller elements to the right\n        # 47. use binary search to find the number of smaller elements to the left\n        # 48. use binary search to find the number of smaller elements to the right\n        # 49. use binary search to find the number of smaller elements to the left\n        # 50. use binary search to find the number of smaller elements to the right\n        # 51. use binary search to find the number of smaller elements to the left\n        # 52. use binary search to find the number of smaller elements to the right\n        #"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by the end of the interval\n        intervals.sort(key=lambda x: x[1])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the first and second end of the interval\n        first = -1\n        second = -1\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the end of the interval is less than the first end\n            if interval[1] < first:\n                # update the second end\n                second = first\n                # update the first end\n                first = interval[1]\n            # if the end of the interval is less than the second end\n            elif interval[1] < second:\n                # update the second end\n                second = interval[1]\n            # if the end of the interval is greater than the second end\n            else:\n                # update the result\n                res += 1\n                # update the second end\n                second = interval[1]\n                # update the first end\n                first = interval[1]\n        \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            if node:\n                res.append(node.val)\n                stack.append(node.right)\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        if n == 0:\n            return []\n        if n == 1:\n            return ['()']\n        \n        res = []\n        for i in range(n):\n            for left in self.generateParenthesis(i):\n                for right in self.generateParenthesis(n - i - 1):\n                    res.append('({}){}'.format(left, right))\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if not nums:\n            return 0\n        \n        # initialize\n        patches = 0\n        i = 0\n        \n        # loop\n        while i < len(nums):\n            if nums[i] <= n:\n                n += nums[i]\n                i += 1\n            else:\n                patches += 1\n                n += n\n        \n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        # 4. greedy\n        # 5. stack\n        # 6. dp\n        # 7. greedy\n        # 8. stack\n        # 9. dp\n        # 10. greedy\n        # 11. stack\n        # 12. dp\n        # 13. greedy\n        # 14. stack\n        # 15. dp\n        # 16. greedy\n        # 17. stack\n        # 18. dp\n        # 19. greedy\n        # 20. stack\n        # 21. dp\n        # 22. greedy\n        # 23. stack\n        # 24. dp\n        # 25. greedy\n        # 26. stack\n        # 27. dp\n        # 28. greedy\n        # 29. stack\n        # 30. dp\n        # 31. greedy\n        # 32. stack\n        # 33. dp\n        # 34. greedy\n        # 35. stack\n        # 36. dp\n        # 37. greedy\n        # 38. stack\n        # 39. dp\n        # 40. greedy\n        # 41. stack\n        # 42. dp\n        # 43. greedy\n        # 44. stack\n        # 45. dp\n        # 46. greedy\n        # 47. stack\n        # 48. dp\n        # 49. greedy\n        # 50. stack\n        # 51. dp\n        # 52. greedy\n        # 53. stack\n        # 54. dp\n        # 55. greedy\n        # 56. stack\n        # 57. dp\n        # 58. greedy\n        # 59. stack\n        # 60. dp\n        # 61. greedy\n        # 62. stack\n        # 63. dp\n        # 64. greedy\n        # 65. stack\n        # 66. dp\n        # 67. greedy\n        # 68. stack\n        # 69. dp\n        # 70. greedy\n        # 71. stack\n        # 72. dp\n        # 73. greedy\n        # 74. stack\n        # 75. dp\n        # 76. greedy\n        # 77. stack\n        # 78. dp\n        # 79. greedy\n        # 80. stack\n        # 81. dp\n        # 82. greedy\n        # 83. stack\n        # 84. dp\n        # 85. greedy\n        # 86. stack\n        # 87. dp\n        # 88. greedy\n        # 89. stack\n        # 90. dp\n        # 91. greedy\n        # 92. stack\n        # 93. dp\n        # 94. greedy\n        # 95. stack\n        # 96. dp\n        # 97. greedy\n        # 98. stack\n        # 99. dp\n        # 100. greedy\n        # 101. stack\n        # 102. dp\n        # 103. greedy\n        # 104. stack\n        # 105. dp\n        # 106. greedy\n        # 107. stack\n        # 108. dp\n        # 109. greedy\n        # 110. stack\n        # 111. dp\n        # 112. greedy\n        # 113. stack\n        # 114. dp\n        # 115. greedy\n        # 116. stack\n        # 117. d"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 == denominator < 0:\n            sign = \"\"\n        elif numerator < 0:\n            sign = \"-\"\n        else:\n            sign = \"+\"\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        \n        quotient, remainder = divmod(numerator, denominator)\n        if remainder == 0:\n            return sign + str(quotient)\n        \n        seen = {}\n        res = sign + str(quotient) + \".\"\n        \n        while remainder != 0:\n            if remainder in seen:\n                res = res[:seen[remainder]] + \"(\" + res[seen[remainder]:] + \")\"\n                break\n            seen[remainder] = len(res)\n            quotient, remainder = divmod(remainder * 10, denominator)\n            res += str(quotient)\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [envelopes[0][1]]\n        \n        for i in range(1, len(envelopes)):\n            if envelopes[i][1] > dp[-1]:\n                dp.append(envelopes[i][1])\n            else:\n                left, right = 0, len(dp) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid\n                dp[left] = envelopes[i][1]\n        \n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space\n        \n        ## O(1) space\n        ## O(1) space"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create two pointers\n        left = dummy\n        right = dummy\n        \n        # move right pointer n nodes ahead\n        for i in range(n + 1):\n            right = right.next\n        \n        # move both pointers at the same time\n        while right:\n            left = left.next\n            right = right.next\n        \n        # delete the node\n        left.next = left.next.next\n        \n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use collections.Counter\n        ## 4. use set.intersection\n        ## 5. use collections.Counter.intersection\n        ## 6. use collections.Counter.intersection_update\n        ## 7. use collections.Counter.intersection_update\n        ## 8. use collections.Counter.intersection_update\n        ## 9. use collections.Counter.intersection_update\n        ## 10. use collections.Counter.intersection_update\n        ## 11. use collections.Counter.intersection_update\n        ## 12. use collections.Counter.intersection_update\n        ## 13. use collections.Counter.intersection_update\n        ## 14. use collections.Counter.intersection_update\n        ## 15. use collections.Counter.intersection_update\n        ## 16. use collections.Counter.intersection_update\n        ## 17. use collections.Counter.intersection_update\n        ## 18. use collections.Counter.intersection_update\n        ## 19. use collections.Counter.intersection_update\n        ## 20. use collections.Counter.intersection_update\n        ## 21. use collections.Counter.intersection_update\n        ## 22. use collections.Counter.intersection_update\n        ## 23. use collections.Counter.intersection_update\n        ## 24. use collections.Counter.intersection_update\n        ## 25. use collections.Counter.intersection_update\n        ## 26. use collections.Counter.intersection_update\n        ## 27. use collections.Counter.intersection_update\n        ## 28. use collections.Counter.intersection_update\n        ## 29. use collections.Counter.intersection_update\n        ## 30. use collections.Counter.intersection_update\n        ## 31. use collections.Counter.intersection_update\n        ## 32. use collections.Counter.intersection_update\n        ## 33. use collections.Counter.intersection_update\n        ## 34. use collections.Counter.intersection_update\n        ## 35. use collections.Counter.intersection_update\n        ## 36. use collections.Counter.intersection_update\n        ## 37. use collections.Counter.intersection_update\n        ## 38. use collections.Counter.intersection_update\n        ## 39. use collections.Counter.intersection_update\n        ## 40. use collections.Counter.intersection_update\n        ## 41. use collections.Counter.intersection_update\n        ## 42. use collections.Counter.intersection_update\n        ## 43. use collections.Counter.intersection_update\n        ## 44. use collections.Counter.intersection_update\n        ## 45. use collections.Counter.intersection_update\n        ## 46. use collections.Counter.intersection_update\n        ## 47. use collections.Counter.intersection_update\n        ## 48. use collections.Counter.intersection_update\n        ## 49. use collections.Counter.intersection_update\n        ## 50. use collections.Counter.intersection_update\n        ## 51. use collections.Counter.intersection_update\n        ## 52. use collections.Counter.intersection_update\n        ## 53. use collections.Counter.intersection_update\n        ## 54. use collections.Counter.intersection_update\n        ## 55. use collections.Counter.intersection_update\n        ## 56. use collections.Counter.intersection_update\n        ## 57. use collections.Counter.intersection_update\n        ## 58. use collections.Counter.intersection_update\n        ## 59. use collections.Counter.intersection_update\n        ## 60. use collections.Counter.intersection_update\n        ## 61. use collections.Counter.intersection_update\n        ## 62. use collections.Counter.intersection_update\n        ##"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines) % len(machines) != 0:\n            return -1\n        \n        avg = sum(machines) / len(machines)\n        ans = 0\n        curr = 0\n        \n        for i in machines:\n            curr += i - avg\n            ans = max(ans, abs(curr))\n        \n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low, high = 1, m * n\n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.next.val)\n        root.right = self.sortedListToBST(slow.next.next)\n        slow.next = None\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for i in nums:\n            res += [r + [i] for r in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min\n        \n        # 1. find the pivot point\n        # 2. find the min\n        # 3. if pivot is not found, find the min"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and not s[1].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and not s[0].isdigit():\n            return False\n        \n        # 5. check if it is a valid exponent\n        if s[0] in ('+', '-') and s[1] == 'e' and len(s) > 2 and s[2] in ('+', '-') and s[2] != '.' and not s[2].isdigit():\n            return False\n        \n        # 6. check if it is a valid exponent\n        if s[0] not in ('+', '-') and s[1] == 'e' and len(s) > 2 and s[2] in ('+', '-') and s[2] != '.' and not s[2].isdigit():\n            return False\n        \n        # 7. check if it is a valid integer\n        if s[0] not in ('+', '-') and s[1] == 'e' and len(s) > 2 and s[2] not in ('+', '-') and not s[2].isdigit():\n            return False\n        \n        # 8. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[1] not in ('+', '-') and s[1] != '.' and not s[1].isdigit():\n            return False\n        \n        # 9. check if it is a valid integer\n        if s[0] not in ('+', '-') and s[1] not in ('+', '-') and s[1] == '.' and len(s) > 2 and s[2] in ('+', '-') and s[2] != '.' and not s[2].isdigit():\n            return False\n        \n        # 10. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[1] not in ('+', '-') and s[1] == '.' and len(s) > 2 and s[2] not in ('+', '-') and not s[2].isdigit():\n            return False\n        \n        # 11. check if it is a valid integer\n        if s[0] not in ('+', '-') and s[1] not in ('+', '-') and s[1] == '.' and len(s) > 2 and s[2] not in ('+', '-') and s[2] != '.' and not s[2].isdigit():\n            return False\n        \n        # 12. check if it is a valid integer\n        if s[0] not in ('+', '-') and s[1] not in ('+', '-') and s[1] == '.' and len(s) > 2 and s[2] not in ('+', '-') and s[2] != '.' and s[2] != 'e':\n            return False\n        \n        # 13. check if it is a valid integer\n        if s[0] not in ('+', '-') and s[1] not in ('+', '-') and s[1] == '.' and len(s) > 2 and s[2] not in ('+', '-') and s[2] != '.' and s[2] == 'e':\n            return False\n        \n        # 14. check if it is a valid integer\n        if s[0] not in ('+', '-') and s[1] not in ('+', '-') and s[1] == '.' and len(s) > 2 and s[2] not in ('+', '-') and s[2] == 'e':\n            return False\n        \n        # 15. check if it is a valid integer\n        if"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 2nd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 3rd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 4th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 5th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 6th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 7th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 8th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 9th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 10th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 11th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 12th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 13th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 14th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 15th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 16th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 17th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 18th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 19th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 20th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 21th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 22th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 23th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 24th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 25th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## \n        ## 26th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board, l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board, row, num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board, col, num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board, box_start_row, box_start_col, num):\n            for row in range(3):\n                for col in range(3):\n                    if board[row+box_start_row][col+box_start_col] == num:\n                        return True\n            return False\n        \n        def is_valid(board, row, col, num):\n            return not used_in_row(board, row, num) and not used_in_col(board, col, num) and not used_in_box(board, row - row % 3, col - col % 3, num)\n        \n        def solve_sudoku(board):\n            l = [0, 0]\n            if not find_empty_location(board, l):\n                return True\n            \n            row = l[0]\n            col = l[1]\n            \n            for num in range(1, 10):\n                if is_valid(board, row, col, str(num)):\n                    board[row][col] = str(num)\n                    \n                    if solve_sudoku(board):\n                        return True\n                    \n                    board[row][col] = '.'\n            \n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        left = 0\n        right = num\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid == num:\n                return True\n            elif mid * mid < num:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node):\n            if not node:\n                return False\n            if node.isWord:\n                res.append(node.word)\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return False\n            tmp = board[i][j]\n            if tmp not in node.children:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, node.children[tmp]) or dfs(i - 1, j, node.children[tmp]) or dfs(i, j + 1, node.children[tmp]) or dfs(i, j - 1, node.children[tmp])\n            board[i][j] = tmp\n            return res\n        \n        trie = {}\n        for word in words:\n            node = trie\n            for c in word:\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['isWord'] = True\n            node['word'] = word\n        \n        res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] in trie:\n                    dfs(i, j, trie[board[i][j]])\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(box)) != len(box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a single string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 25600\n        # 26^4 = 144000\n        # 26^5 = 7372800\n        # 26^6 = 36896000\n        # 26^7 = 2097152000\n        # 26^8 = 11859760000\n        # 26^9 = 677721600000\n        # 26^10 = 39580960000000\n        # 26^11 = 2388609600000000\n        # 26^12 = 14785536000000000\n        # 26^13 = 85899345000000000\n        # 26^14 = 495973650000000000\n        # 26^15 = 3116701350000000000\n        # 26^16 = 19437181350000000000\n        # 26^17 = 122595736500000000000\n        # 26^18 = 712819135000000000000\n        # 26^19 = 3914577135000000000000\n        # 26^20 = 22819717135000000000000\n        # 26^21 = 144171877135000000000000\n        # 26^22 = 85899345000000000000000\n        # 26^23 = 49597365000000000000000\n        # 26^24 = 311670135000000000000000\n        # 26^25 = 194371813500000000000000\n        # 26^26 = 122595736500000000000000\n        # 26^27 = 71281913500000000000000\n        # 26^28 = 39145771350000000000000\n        # 26^29 = 22819717135000000000000\n        # 26^30 = 1441718771350000000000\n        # 26^31 = 85899345000000000000\n        # 26^32 = 4959736500000000000\n        # 26^33 = 311670135000000000\n        # 26^34 = 19437181350000000\n        # 26^35 = 1225957365000000\n        # 26^36 = 71281913500000\n        # 26^37 = 3914577135000\n        # 26^38 = 2281971713500\n        # 26^39"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.split()\n        if len(pattern) != len(s):\n            return False\n        \n        d = {}\n        for i, j in zip(pattern, s):\n            if i not in d:\n                if j in d.values():\n                    return False\n                d[i] = j\n            elif d[i] != j:\n                return False\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        low = 0\n        high = m * n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid // n][mid % n] == target:\n                return True\n            elif matrix[mid // n][mid % n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a new linked list\n        head = ListNode()\n        # Initialize a pointer to the new linked list\n        curr = head\n        # Initialize a variable to store the carry over\n        carry = 0\n        \n        # Loop through both linked lists\n        while l1 or l2 or carry:\n            # If both linked lists are not empty, add the values of the nodes\n            if l1:\n                val1 = l1.val\n            else:\n                val1 = 0\n            if l2:\n                val2 = l2.val\n            else:\n                val2 = 0\n            # Add the values of the nodes to the carry over\n            carry, val = divmod(val1 + val2 + carry, 10)\n            # Create a new node with the value of the sum\n            curr.next = ListNode(val)\n            # Move to the next node\n            curr = curr.next\n            # Move to the next node\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        # Return the new linked list\n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert to binary\n        ## 2. flip the bits\n        ## 3. convert back to decimal\n        \n        ## 1. convert to binary\n        binary = bin(num)[2:]\n        \n        ## 2. flip the bits\n        binary = binary.replace('1', '0')\n        binary = binary.replace('0', '1')\n        \n        ## 3. convert back to decimal\n        return int(binary, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(1, len(nums)-1):\n            if nums[i+1] - nums[i] == diff:\n                count += 1\n            else:\n                diff = nums[i+1] - nums[i]\n        \n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # 2 pointers\n        # left and right pointers\n        # left = 0\n        # right = len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build a set of words\n        word_set = set(words)\n        \n        # 2. build a dict of words\n        word_dict = {}\n        for word in words:\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in word_dict:\n                    if suffix not in word_dict:\n                        word_dict[suffix] = True\n                    else:\n                        word_dict[suffix] = word_dict[suffix] or word_dict[prefix]\n                else:\n                    word_dict[prefix] = True\n        \n        # 3. find all words in the dict\n        res = []\n        for word in words:\n            if word_dict[word]:\n                res.append(word)\n        \n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    count += backtrack(row + 1, cols | {col}, diag1 | {row + col}, diag2 | {row - col})\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, idx):\n            if idx == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[idx]:\n                return False\n            board[i][j] = '#'\n            res = (dfs(i + 1, j, idx + 1) or dfs(i - 1, j, idx + 1) or dfs(i, j + 1, idx + 1) or dfs(i, j - 1, idx + 1))\n            board[i][j] = word[idx]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max element\n        # 3. else return the third element\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}